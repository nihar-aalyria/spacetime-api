// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/wireless_receiver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fwireless_5freceiver_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fwireless_5freceiver_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/channel.pb.h"
#include "api/common/wireless.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fwireless_5freceiver_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class Filter_LinearFilterDefinition;
struct Filter_LinearFilterDefinitionDefaultTypeInternal;
extern Filter_LinearFilterDefinitionDefaultTypeInternal _Filter_LinearFilterDefinition_default_instance_;
class Filter_RectangularFilterDefinition;
struct Filter_RectangularFilterDefinitionDefaultTypeInternal;
extern Filter_RectangularFilterDefinitionDefaultTypeInternal _Filter_RectangularFilterDefinition_default_instance_;
class PhotodetectorDefinition;
struct PhotodetectorDefinitionDefaultTypeInternal;
extern PhotodetectorDefinitionDefaultTypeInternal _PhotodetectorDefinition_default_instance_;
class PhotodetectorDefinition_AvalanchePhotodiodeDefinition;
struct PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal;
extern PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal _PhotodetectorDefinition_AvalanchePhotodiodeDefinition_default_instance_;
class PhotodetectorDefinition_PinPhotodiodeDefinition;
struct PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal;
extern PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal _PhotodetectorDefinition_PinPhotodiodeDefinition_default_instance_;
class ReceiveSignalProcessor;
struct ReceiveSignalProcessorDefaultTypeInternal;
extern ReceiveSignalProcessorDefaultTypeInternal _ReceiveSignalProcessor_default_instance_;
class ReceiverDefinition;
struct ReceiverDefinitionDefaultTypeInternal;
extern ReceiverDefinitionDefaultTypeInternal _ReceiverDefinition_default_instance_;
class ReceiverDefinition_ChannelSetEntry_DoNotUse;
struct ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal;
extern ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal _ReceiverDefinition_ChannelSetEntry_DoNotUse_default_instance_;
class RxChannels;
struct RxChannelsDefaultTypeInternal;
extern RxChannelsDefaultTypeInternal _RxChannels_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::Filter* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Filter>(Arena*);
template <>
::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Filter_LinearFilterDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::PhotodetectorDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PhotodetectorDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::ReceiveSignalProcessor* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiveSignalProcessor>(Arena*);
template <>
::aalyria::spacetime::api::common::ReceiverDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::RxChannels* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RxChannels>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class RxChannels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RxChannels) */ {
 public:
  inline RxChannels() : RxChannels(nullptr) {}
  ~RxChannels() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RxChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RxChannels(const RxChannels& from);
  RxChannels(RxChannels&& from) noexcept
    : RxChannels() {
    *this = ::std::move(from);
  }

  inline RxChannels& operator=(const RxChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline RxChannels& operator=(RxChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RxChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const RxChannels* internal_default_instance() {
    return reinterpret_cast<const RxChannels*>(
               &_RxChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RxChannels& a, RxChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(RxChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RxChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RxChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RxChannels>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RxChannels& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RxChannels& from) {
    RxChannels::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RxChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RxChannels";
  }
  protected:
  explicit RxChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFrequencyHzFieldNumber = 1,
  };
  // repeated int64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
  int center_frequency_hz_size() const;
  private:
  int _internal_center_frequency_hz_size() const;

  public:
  void clear_center_frequency_hz() ;
  ::int64_t center_frequency_hz(int index) const;
  void set_center_frequency_hz(int index, ::int64_t value);
  void add_center_frequency_hz(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& center_frequency_hz() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_center_frequency_hz();

  private:
  ::int64_t _internal_center_frequency_hz(int index) const;
  void _internal_add_center_frequency_hz(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_center_frequency_hz() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_center_frequency_hz();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RxChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> center_frequency_hz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class ReceiverDefinition_ChannelSetEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiverDefinition_ChannelSetEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::RxChannels,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiverDefinition_ChannelSetEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::RxChannels,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ReceiverDefinition_ChannelSetEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiverDefinition_ChannelSetEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ReceiverDefinition_ChannelSetEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ReceiverDefinition_ChannelSetEntry_DoNotUse& other);
  static const ReceiverDefinition_ChannelSetEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ReceiverDefinition_ChannelSetEntry_DoNotUse*>(&_ReceiverDefinition_ChannelSetEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.ReceiverDefinition.ChannelSetEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};
// -------------------------------------------------------------------

class ReceiverDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ReceiverDefinition) */ {
 public:
  inline ReceiverDefinition() : ReceiverDefinition(nullptr) {}
  ~ReceiverDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiverDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiverDefinition(const ReceiverDefinition& from);
  ReceiverDefinition(ReceiverDefinition&& from) noexcept
    : ReceiverDefinition() {
    *this = ::std::move(from);
  }

  inline ReceiverDefinition& operator=(const ReceiverDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiverDefinition& operator=(ReceiverDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiverDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiverDefinition* internal_default_instance() {
    return reinterpret_cast<const ReceiverDefinition*>(
               &_ReceiverDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReceiverDefinition& a, ReceiverDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiverDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiverDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiverDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiverDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiverDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiverDefinition& from) {
    ReceiverDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiverDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ReceiverDefinition";
  }
  protected:
  explicit ReceiverDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kChannelSetFieldNumber = 10,
    kSignalProcessingStepFieldNumber = 11,
    kNameFieldNumber = 2,
    kChannelSelectionMethodFieldNumber = 9,
  };
  // map<string, .aalyria.spacetime.api.common.RxChannels> channel_set = 10 [json_name = "channelSet"];
  int channel_set_size() const;
  private:
  int _internal_channel_set_size() const;

  public:
  void clear_channel_set() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >&
      _internal_channel_set() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >*
      _internal_mutable_channel_set();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >&
      channel_set() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >*
      mutable_channel_set();
  // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor signal_processing_step = 11 [json_name = "signalProcessingStep"];
  int signal_processing_step_size() const;
  private:
  int _internal_signal_processing_step_size() const;

  public:
  void clear_signal_processing_step() ;
  ::aalyria::spacetime::api::common::ReceiveSignalProcessor* mutable_signal_processing_step(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >*
      mutable_signal_processing_step();
  private:
  const ::aalyria::spacetime::api::common::ReceiveSignalProcessor& _internal_signal_processing_step(int index) const;
  ::aalyria::spacetime::api::common::ReceiveSignalProcessor* _internal_add_signal_processing_step();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiveSignalProcessor>& _internal_signal_processing_step() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiveSignalProcessor>* _internal_mutable_signal_processing_step();
  public:
  const ::aalyria::spacetime::api::common::ReceiveSignalProcessor& signal_processing_step(int index) const;
  ::aalyria::spacetime::api::common::ReceiveSignalProcessor* add_signal_processing_step();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >&
      signal_processing_step() const;
  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .aalyria.spacetime.api.common.ChannelSelectionMethod channel_selection_method = 9 [json_name = "channelSelectionMethod"];
  bool has_channel_selection_method() const;
  void clear_channel_selection_method() ;
  ::aalyria::spacetime::api::common::ChannelSelectionMethod channel_selection_method() const;
  void set_channel_selection_method(::aalyria::spacetime::api::common::ChannelSelectionMethod value);

  private:
  ::aalyria::spacetime::api::common::ChannelSelectionMethod _internal_channel_selection_method() const;
  void _internal_set_channel_selection_method(::aalyria::spacetime::api::common::ChannelSelectionMethod value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ReceiverDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ReceiverDefinition_ChannelSetEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::RxChannels,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> channel_set_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiveSignalProcessor > signal_processing_step_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int channel_selection_method_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class ReceiveSignalProcessor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ReceiveSignalProcessor) */ {
 public:
  inline ReceiveSignalProcessor() : ReceiveSignalProcessor(nullptr) {}
  ~ReceiveSignalProcessor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiveSignalProcessor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveSignalProcessor(const ReceiveSignalProcessor& from);
  ReceiveSignalProcessor(ReceiveSignalProcessor&& from) noexcept
    : ReceiveSignalProcessor() {
    *this = ::std::move(from);
  }

  inline ReceiveSignalProcessor& operator=(const ReceiveSignalProcessor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveSignalProcessor& operator=(ReceiveSignalProcessor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveSignalProcessor& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kFilter = 1,
    kPhotodetector = 2,
    kAmplifier = 3,
    kGainOrLoss = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const ReceiveSignalProcessor* internal_default_instance() {
    return reinterpret_cast<const ReceiveSignalProcessor*>(
               &_ReceiveSignalProcessor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReceiveSignalProcessor& a, ReceiveSignalProcessor& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveSignalProcessor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveSignalProcessor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveSignalProcessor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveSignalProcessor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveSignalProcessor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveSignalProcessor& from) {
    ReceiveSignalProcessor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveSignalProcessor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ReceiveSignalProcessor";
  }
  protected:
  explicit ReceiveSignalProcessor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kPhotodetectorFieldNumber = 2,
    kAmplifierFieldNumber = 3,
    kGainOrLossFieldNumber = 4,
  };
  // .aalyria.spacetime.api.common.Filter filter = 1 [json_name = "filter"];
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::aalyria::spacetime::api::common::Filter& filter() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Filter* release_filter();
  ::aalyria::spacetime::api::common::Filter* mutable_filter();
  void set_allocated_filter(::aalyria::spacetime::api::common::Filter* filter);
  private:
  const ::aalyria::spacetime::api::common::Filter& _internal_filter() const;
  ::aalyria::spacetime::api::common::Filter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::aalyria::spacetime::api::common::Filter* filter);
  ::aalyria::spacetime::api::common::Filter* unsafe_arena_release_filter();
  // .aalyria.spacetime.api.common.PhotodetectorDefinition photodetector = 2 [json_name = "photodetector"];
  bool has_photodetector() const;
  private:
  bool _internal_has_photodetector() const;

  public:
  void clear_photodetector() ;
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition& photodetector() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PhotodetectorDefinition* release_photodetector();
  ::aalyria::spacetime::api::common::PhotodetectorDefinition* mutable_photodetector();
  void set_allocated_photodetector(::aalyria::spacetime::api::common::PhotodetectorDefinition* photodetector);
  private:
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition& _internal_photodetector() const;
  ::aalyria::spacetime::api::common::PhotodetectorDefinition* _internal_mutable_photodetector();
  public:
  void unsafe_arena_set_allocated_photodetector(
      ::aalyria::spacetime::api::common::PhotodetectorDefinition* photodetector);
  ::aalyria::spacetime::api::common::PhotodetectorDefinition* unsafe_arena_release_photodetector();
  // .aalyria.spacetime.api.common.AmplifierDefinition amplifier = 3 [json_name = "amplifier"];
  bool has_amplifier() const;
  private:
  bool _internal_has_amplifier() const;

  public:
  void clear_amplifier() ;
  const ::aalyria::spacetime::api::common::AmplifierDefinition& amplifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AmplifierDefinition* release_amplifier();
  ::aalyria::spacetime::api::common::AmplifierDefinition* mutable_amplifier();
  void set_allocated_amplifier(::aalyria::spacetime::api::common::AmplifierDefinition* amplifier);
  private:
  const ::aalyria::spacetime::api::common::AmplifierDefinition& _internal_amplifier() const;
  ::aalyria::spacetime::api::common::AmplifierDefinition* _internal_mutable_amplifier();
  public:
  void unsafe_arena_set_allocated_amplifier(
      ::aalyria::spacetime::api::common::AmplifierDefinition* amplifier);
  ::aalyria::spacetime::api::common::AmplifierDefinition* unsafe_arena_release_amplifier();
  // .aalyria.spacetime.api.common.MiscGainOrLoss gain_or_loss = 4 [json_name = "gainOrLoss"];
  bool has_gain_or_loss() const;
  private:
  bool _internal_has_gain_or_loss() const;

  public:
  void clear_gain_or_loss() ;
  const ::aalyria::spacetime::api::common::MiscGainOrLoss& gain_or_loss() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::MiscGainOrLoss* release_gain_or_loss();
  ::aalyria::spacetime::api::common::MiscGainOrLoss* mutable_gain_or_loss();
  void set_allocated_gain_or_loss(::aalyria::spacetime::api::common::MiscGainOrLoss* gain_or_loss);
  private:
  const ::aalyria::spacetime::api::common::MiscGainOrLoss& _internal_gain_or_loss() const;
  ::aalyria::spacetime::api::common::MiscGainOrLoss* _internal_mutable_gain_or_loss();
  public:
  void unsafe_arena_set_allocated_gain_or_loss(
      ::aalyria::spacetime::api::common::MiscGainOrLoss* gain_or_loss);
  ::aalyria::spacetime::api::common::MiscGainOrLoss* unsafe_arena_release_gain_or_loss();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ReceiveSignalProcessor)
 private:
  class _Internal;
  void set_has_filter();
  void set_has_photodetector();
  void set_has_amplifier();
  void set_has_gain_or_loss();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::Filter* filter_;
      ::aalyria::spacetime::api::common::PhotodetectorDefinition* photodetector_;
      ::aalyria::spacetime::api::common::AmplifierDefinition* amplifier_;
      ::aalyria::spacetime::api::common::MiscGainOrLoss* gain_or_loss_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class Filter_RectangularFilterDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Filter.RectangularFilterDefinition) */ {
 public:
  inline Filter_RectangularFilterDefinition() : Filter_RectangularFilterDefinition(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Filter_RectangularFilterDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter_RectangularFilterDefinition(const Filter_RectangularFilterDefinition& from);
  Filter_RectangularFilterDefinition(Filter_RectangularFilterDefinition&& from) noexcept
    : Filter_RectangularFilterDefinition() {
    *this = ::std::move(from);
  }

  inline Filter_RectangularFilterDefinition& operator=(const Filter_RectangularFilterDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter_RectangularFilterDefinition& operator=(Filter_RectangularFilterDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter_RectangularFilterDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter_RectangularFilterDefinition* internal_default_instance() {
    return reinterpret_cast<const Filter_RectangularFilterDefinition*>(
               &_Filter_RectangularFilterDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Filter_RectangularFilterDefinition& a, Filter_RectangularFilterDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter_RectangularFilterDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter_RectangularFilterDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter_RectangularFilterDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter_RectangularFilterDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Filter_RectangularFilterDefinition& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Filter_RectangularFilterDefinition& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Filter.RectangularFilterDefinition";
  }
  protected:
  explicit Filter_RectangularFilterDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Filter.RectangularFilterDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class Filter_LinearFilterDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Filter.LinearFilterDefinition) */ {
 public:
  inline Filter_LinearFilterDefinition() : Filter_LinearFilterDefinition(nullptr) {}
  ~Filter_LinearFilterDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Filter_LinearFilterDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter_LinearFilterDefinition(const Filter_LinearFilterDefinition& from);
  Filter_LinearFilterDefinition(Filter_LinearFilterDefinition&& from) noexcept
    : Filter_LinearFilterDefinition() {
    *this = ::std::move(from);
  }

  inline Filter_LinearFilterDefinition& operator=(const Filter_LinearFilterDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter_LinearFilterDefinition& operator=(Filter_LinearFilterDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter_LinearFilterDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter_LinearFilterDefinition* internal_default_instance() {
    return reinterpret_cast<const Filter_LinearFilterDefinition*>(
               &_Filter_LinearFilterDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Filter_LinearFilterDefinition& a, Filter_LinearFilterDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter_LinearFilterDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter_LinearFilterDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter_LinearFilterDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter_LinearFilterDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter_LinearFilterDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Filter_LinearFilterDefinition& from) {
    Filter_LinearFilterDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter_LinearFilterDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Filter.LinearFilterDefinition";
  }
  protected:
  explicit Filter_LinearFilterDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRejectionDbPerHzFieldNumber = 1,
  };
  // optional double rejection_db_per_hz = 1 [json_name = "rejectionDbPerHz"];
  bool has_rejection_db_per_hz() const;
  void clear_rejection_db_per_hz() ;
  double rejection_db_per_hz() const;
  void set_rejection_db_per_hz(double value);

  private:
  double _internal_rejection_db_per_hz() const;
  void _internal_set_rejection_db_per_hz(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double rejection_db_per_hz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  enum FilterTypeCase {
    kRectangular = 5,
    kLinear = 6,
    FILTER_TYPE_NOT_SET = 0,
  };

  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Filter& from) {
    Filter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Filter_RectangularFilterDefinition RectangularFilterDefinition;
  typedef Filter_LinearFilterDefinition LinearFilterDefinition;

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyHzFieldNumber = 1,
    kLowerBandwidthLimitHzFieldNumber = 2,
    kUpperBandwidthLimitHzFieldNumber = 3,
    kNoiseTemperatureKFieldNumber = 4,
    kRectangularFieldNumber = 5,
    kLinearFieldNumber = 6,
  };
  // optional double frequency_hz = 1 [json_name = "frequencyHz"];
  bool has_frequency_hz() const;
  void clear_frequency_hz() ;
  double frequency_hz() const;
  void set_frequency_hz(double value);

  private:
  double _internal_frequency_hz() const;
  void _internal_set_frequency_hz(double value);

  public:
  // optional double lower_bandwidth_limit_hz = 2 [json_name = "lowerBandwidthLimitHz"];
  bool has_lower_bandwidth_limit_hz() const;
  void clear_lower_bandwidth_limit_hz() ;
  double lower_bandwidth_limit_hz() const;
  void set_lower_bandwidth_limit_hz(double value);

  private:
  double _internal_lower_bandwidth_limit_hz() const;
  void _internal_set_lower_bandwidth_limit_hz(double value);

  public:
  // optional double upper_bandwidth_limit_hz = 3 [json_name = "upperBandwidthLimitHz"];
  bool has_upper_bandwidth_limit_hz() const;
  void clear_upper_bandwidth_limit_hz() ;
  double upper_bandwidth_limit_hz() const;
  void set_upper_bandwidth_limit_hz(double value);

  private:
  double _internal_upper_bandwidth_limit_hz() const;
  void _internal_set_upper_bandwidth_limit_hz(double value);

  public:
  // optional double noise_temperature_k = 4 [json_name = "noiseTemperatureK"];
  bool has_noise_temperature_k() const;
  void clear_noise_temperature_k() ;
  double noise_temperature_k() const;
  void set_noise_temperature_k(double value);

  private:
  double _internal_noise_temperature_k() const;
  void _internal_set_noise_temperature_k(double value);

  public:
  // .aalyria.spacetime.api.common.Filter.RectangularFilterDefinition rectangular = 5 [json_name = "rectangular"];
  bool has_rectangular() const;
  private:
  bool _internal_has_rectangular() const;

  public:
  void clear_rectangular() ;
  const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition& rectangular() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* release_rectangular();
  ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* mutable_rectangular();
  void set_allocated_rectangular(::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* rectangular);
  private:
  const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition& _internal_rectangular() const;
  ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* _internal_mutable_rectangular();
  public:
  void unsafe_arena_set_allocated_rectangular(
      ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* rectangular);
  ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* unsafe_arena_release_rectangular();
  // .aalyria.spacetime.api.common.Filter.LinearFilterDefinition linear = 6 [json_name = "linear"];
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;

  public:
  void clear_linear() ;
  const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition& linear() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* release_linear();
  ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* mutable_linear();
  void set_allocated_linear(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* linear);
  private:
  const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition& _internal_linear() const;
  ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* linear);
  ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* unsafe_arena_release_linear();
  void clear_filter_type();
  FilterTypeCase filter_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Filter)
 private:
  class _Internal;
  void set_has_rectangular();
  void set_has_linear();

  inline bool has_filter_type() const;
  inline void clear_has_filter_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double frequency_hz_;
    double lower_bandwidth_limit_hz_;
    double upper_bandwidth_limit_hz_;
    double noise_temperature_k_;
    union FilterTypeUnion {
      constexpr FilterTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* rectangular_;
      ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* linear_;
    } filter_type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class PhotodetectorDefinition_AvalanchePhotodiodeDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition) */ {
 public:
  inline PhotodetectorDefinition_AvalanchePhotodiodeDefinition() : PhotodetectorDefinition_AvalanchePhotodiodeDefinition(nullptr) {}
  ~PhotodetectorDefinition_AvalanchePhotodiodeDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhotodetectorDefinition_AvalanchePhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhotodetectorDefinition_AvalanchePhotodiodeDefinition(const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from);
  PhotodetectorDefinition_AvalanchePhotodiodeDefinition(PhotodetectorDefinition_AvalanchePhotodiodeDefinition&& from) noexcept
    : PhotodetectorDefinition_AvalanchePhotodiodeDefinition() {
    *this = ::std::move(from);
  }

  inline PhotodetectorDefinition_AvalanchePhotodiodeDefinition& operator=(const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhotodetectorDefinition_AvalanchePhotodiodeDefinition& operator=(PhotodetectorDefinition_AvalanchePhotodiodeDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhotodetectorDefinition_AvalanchePhotodiodeDefinition* internal_default_instance() {
    return reinterpret_cast<const PhotodetectorDefinition_AvalanchePhotodiodeDefinition*>(
               &_PhotodetectorDefinition_AvalanchePhotodiodeDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PhotodetectorDefinition_AvalanchePhotodiodeDefinition& a, PhotodetectorDefinition_AvalanchePhotodiodeDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(PhotodetectorDefinition_AvalanchePhotodiodeDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhotodetectorDefinition_AvalanchePhotodiodeDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhotodetectorDefinition_AvalanchePhotodiodeDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhotodetectorDefinition_AvalanchePhotodiodeDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from) {
    PhotodetectorDefinition_AvalanchePhotodiodeDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhotodetectorDefinition_AvalanchePhotodiodeDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition";
  }
  protected:
  explicit PhotodetectorDefinition_AvalanchePhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOfViewRadFieldNumber = 1,
    kBandwidthHzFieldNumber = 2,
    kNoiseTemperatureKFieldNumber = 3,
    kEfficiencyPercentFieldNumber = 4,
    kDarkCurrentAmpFieldNumber = 5,
    kLoadImpedanceOhmFieldNumber = 6,
    kNoiseFactorFieldNumber = 7,
    kGainDbFieldNumber = 8,
    kOpticalBandpassFilterBandwidthHzFieldNumber = 9,
    kSkySpectralRadianceFieldNumber = 10,
    kSunSpectralRadiantEmittanceFieldNumber = 11,
    kWavelengthMFieldNumber = 12,
  };
  // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
  bool has_field_of_view_rad() const;
  void clear_field_of_view_rad() ;
  double field_of_view_rad() const;
  void set_field_of_view_rad(double value);

  private:
  double _internal_field_of_view_rad() const;
  void _internal_set_field_of_view_rad(double value);

  public:
  // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
  bool has_bandwidth_hz() const;
  void clear_bandwidth_hz() ;
  double bandwidth_hz() const;
  void set_bandwidth_hz(double value);

  private:
  double _internal_bandwidth_hz() const;
  void _internal_set_bandwidth_hz(double value);

  public:
  // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
  bool has_noise_temperature_k() const;
  void clear_noise_temperature_k() ;
  double noise_temperature_k() const;
  void set_noise_temperature_k(double value);

  private:
  double _internal_noise_temperature_k() const;
  void _internal_set_noise_temperature_k(double value);

  public:
  // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
  bool has_efficiency_percent() const;
  void clear_efficiency_percent() ;
  double efficiency_percent() const;
  void set_efficiency_percent(double value);

  private:
  double _internal_efficiency_percent() const;
  void _internal_set_efficiency_percent(double value);

  public:
  // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
  bool has_dark_current_amp() const;
  void clear_dark_current_amp() ;
  double dark_current_amp() const;
  void set_dark_current_amp(double value);

  private:
  double _internal_dark_current_amp() const;
  void _internal_set_dark_current_amp(double value);

  public:
  // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
  bool has_load_impedance_ohm() const;
  void clear_load_impedance_ohm() ;
  double load_impedance_ohm() const;
  void set_load_impedance_ohm(double value);

  private:
  double _internal_load_impedance_ohm() const;
  void _internal_set_load_impedance_ohm(double value);

  public:
  // optional double noise_factor = 7 [json_name = "noiseFactor"];
  bool has_noise_factor() const;
  void clear_noise_factor() ;
  double noise_factor() const;
  void set_noise_factor(double value);

  private:
  double _internal_noise_factor() const;
  void _internal_set_noise_factor(double value);

  public:
  // optional double gain_db = 8 [json_name = "gainDb"];
  bool has_gain_db() const;
  void clear_gain_db() ;
  double gain_db() const;
  void set_gain_db(double value);

  private:
  double _internal_gain_db() const;
  void _internal_set_gain_db(double value);

  public:
  // optional double optical_bandpass_filter_bandwidth_hz = 9 [json_name = "opticalBandpassFilterBandwidthHz"];
  bool has_optical_bandpass_filter_bandwidth_hz() const;
  void clear_optical_bandpass_filter_bandwidth_hz() ;
  double optical_bandpass_filter_bandwidth_hz() const;
  void set_optical_bandpass_filter_bandwidth_hz(double value);

  private:
  double _internal_optical_bandpass_filter_bandwidth_hz() const;
  void _internal_set_optical_bandpass_filter_bandwidth_hz(double value);

  public:
  // optional double sky_spectral_radiance = 10 [json_name = "skySpectralRadiance"];
  bool has_sky_spectral_radiance() const;
  void clear_sky_spectral_radiance() ;
  double sky_spectral_radiance() const;
  void set_sky_spectral_radiance(double value);

  private:
  double _internal_sky_spectral_radiance() const;
  void _internal_set_sky_spectral_radiance(double value);

  public:
  // optional double sun_spectral_radiant_emittance = 11 [json_name = "sunSpectralRadiantEmittance"];
  bool has_sun_spectral_radiant_emittance() const;
  void clear_sun_spectral_radiant_emittance() ;
  double sun_spectral_radiant_emittance() const;
  void set_sun_spectral_radiant_emittance(double value);

  private:
  double _internal_sun_spectral_radiant_emittance() const;
  void _internal_set_sun_spectral_radiant_emittance(double value);

  public:
  // optional double wavelength_m = 12 [json_name = "wavelengthM"];
  bool has_wavelength_m() const;
  void clear_wavelength_m() ;
  double wavelength_m() const;
  void set_wavelength_m(double value);

  private:
  double _internal_wavelength_m() const;
  void _internal_set_wavelength_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double field_of_view_rad_;
    double bandwidth_hz_;
    double noise_temperature_k_;
    double efficiency_percent_;
    double dark_current_amp_;
    double load_impedance_ohm_;
    double noise_factor_;
    double gain_db_;
    double optical_bandpass_filter_bandwidth_hz_;
    double sky_spectral_radiance_;
    double sun_spectral_radiant_emittance_;
    double wavelength_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class PhotodetectorDefinition_PinPhotodiodeDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition) */ {
 public:
  inline PhotodetectorDefinition_PinPhotodiodeDefinition() : PhotodetectorDefinition_PinPhotodiodeDefinition(nullptr) {}
  ~PhotodetectorDefinition_PinPhotodiodeDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhotodetectorDefinition_PinPhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhotodetectorDefinition_PinPhotodiodeDefinition(const PhotodetectorDefinition_PinPhotodiodeDefinition& from);
  PhotodetectorDefinition_PinPhotodiodeDefinition(PhotodetectorDefinition_PinPhotodiodeDefinition&& from) noexcept
    : PhotodetectorDefinition_PinPhotodiodeDefinition() {
    *this = ::std::move(from);
  }

  inline PhotodetectorDefinition_PinPhotodiodeDefinition& operator=(const PhotodetectorDefinition_PinPhotodiodeDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhotodetectorDefinition_PinPhotodiodeDefinition& operator=(PhotodetectorDefinition_PinPhotodiodeDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhotodetectorDefinition_PinPhotodiodeDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhotodetectorDefinition_PinPhotodiodeDefinition* internal_default_instance() {
    return reinterpret_cast<const PhotodetectorDefinition_PinPhotodiodeDefinition*>(
               &_PhotodetectorDefinition_PinPhotodiodeDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PhotodetectorDefinition_PinPhotodiodeDefinition& a, PhotodetectorDefinition_PinPhotodiodeDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(PhotodetectorDefinition_PinPhotodiodeDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhotodetectorDefinition_PinPhotodiodeDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhotodetectorDefinition_PinPhotodiodeDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhotodetectorDefinition_PinPhotodiodeDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhotodetectorDefinition_PinPhotodiodeDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhotodetectorDefinition_PinPhotodiodeDefinition& from) {
    PhotodetectorDefinition_PinPhotodiodeDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhotodetectorDefinition_PinPhotodiodeDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition";
  }
  protected:
  explicit PhotodetectorDefinition_PinPhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOfViewRadFieldNumber = 1,
    kBandwidthHzFieldNumber = 2,
    kNoiseTemperatureKFieldNumber = 3,
    kEfficiencyPercentFieldNumber = 4,
    kDarkCurrentAmpFieldNumber = 5,
    kLoadImpedanceOhmFieldNumber = 6,
    kOpticalBandpassFilterBandwidthHzFieldNumber = 7,
    kSkySpectralRadianceFieldNumber = 8,
    kSunSpectralRadiantEmittanceFieldNumber = 9,
    kWavelengthMFieldNumber = 10,
  };
  // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
  bool has_field_of_view_rad() const;
  void clear_field_of_view_rad() ;
  double field_of_view_rad() const;
  void set_field_of_view_rad(double value);

  private:
  double _internal_field_of_view_rad() const;
  void _internal_set_field_of_view_rad(double value);

  public:
  // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
  bool has_bandwidth_hz() const;
  void clear_bandwidth_hz() ;
  double bandwidth_hz() const;
  void set_bandwidth_hz(double value);

  private:
  double _internal_bandwidth_hz() const;
  void _internal_set_bandwidth_hz(double value);

  public:
  // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
  bool has_noise_temperature_k() const;
  void clear_noise_temperature_k() ;
  double noise_temperature_k() const;
  void set_noise_temperature_k(double value);

  private:
  double _internal_noise_temperature_k() const;
  void _internal_set_noise_temperature_k(double value);

  public:
  // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
  bool has_efficiency_percent() const;
  void clear_efficiency_percent() ;
  double efficiency_percent() const;
  void set_efficiency_percent(double value);

  private:
  double _internal_efficiency_percent() const;
  void _internal_set_efficiency_percent(double value);

  public:
  // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
  bool has_dark_current_amp() const;
  void clear_dark_current_amp() ;
  double dark_current_amp() const;
  void set_dark_current_amp(double value);

  private:
  double _internal_dark_current_amp() const;
  void _internal_set_dark_current_amp(double value);

  public:
  // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
  bool has_load_impedance_ohm() const;
  void clear_load_impedance_ohm() ;
  double load_impedance_ohm() const;
  void set_load_impedance_ohm(double value);

  private:
  double _internal_load_impedance_ohm() const;
  void _internal_set_load_impedance_ohm(double value);

  public:
  // optional double optical_bandpass_filter_bandwidth_hz = 7 [json_name = "opticalBandpassFilterBandwidthHz"];
  bool has_optical_bandpass_filter_bandwidth_hz() const;
  void clear_optical_bandpass_filter_bandwidth_hz() ;
  double optical_bandpass_filter_bandwidth_hz() const;
  void set_optical_bandpass_filter_bandwidth_hz(double value);

  private:
  double _internal_optical_bandpass_filter_bandwidth_hz() const;
  void _internal_set_optical_bandpass_filter_bandwidth_hz(double value);

  public:
  // optional double sky_spectral_radiance = 8 [json_name = "skySpectralRadiance"];
  bool has_sky_spectral_radiance() const;
  void clear_sky_spectral_radiance() ;
  double sky_spectral_radiance() const;
  void set_sky_spectral_radiance(double value);

  private:
  double _internal_sky_spectral_radiance() const;
  void _internal_set_sky_spectral_radiance(double value);

  public:
  // optional double sun_spectral_radiant_emittance = 9 [json_name = "sunSpectralRadiantEmittance"];
  bool has_sun_spectral_radiant_emittance() const;
  void clear_sun_spectral_radiant_emittance() ;
  double sun_spectral_radiant_emittance() const;
  void set_sun_spectral_radiant_emittance(double value);

  private:
  double _internal_sun_spectral_radiant_emittance() const;
  void _internal_set_sun_spectral_radiant_emittance(double value);

  public:
  // optional double wavelength_m = 10 [json_name = "wavelengthM"];
  bool has_wavelength_m() const;
  void clear_wavelength_m() ;
  double wavelength_m() const;
  void set_wavelength_m(double value);

  private:
  double _internal_wavelength_m() const;
  void _internal_set_wavelength_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double field_of_view_rad_;
    double bandwidth_hz_;
    double noise_temperature_k_;
    double efficiency_percent_;
    double dark_current_amp_;
    double load_impedance_ohm_;
    double optical_bandpass_filter_bandwidth_hz_;
    double sky_spectral_radiance_;
    double sun_spectral_radiant_emittance_;
    double wavelength_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};// -------------------------------------------------------------------

class PhotodetectorDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PhotodetectorDefinition) */ {
 public:
  inline PhotodetectorDefinition() : PhotodetectorDefinition(nullptr) {}
  ~PhotodetectorDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PhotodetectorDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhotodetectorDefinition(const PhotodetectorDefinition& from);
  PhotodetectorDefinition(PhotodetectorDefinition&& from) noexcept
    : PhotodetectorDefinition() {
    *this = ::std::move(from);
  }

  inline PhotodetectorDefinition& operator=(const PhotodetectorDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhotodetectorDefinition& operator=(PhotodetectorDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhotodetectorDefinition& default_instance() {
    return *internal_default_instance();
  }
  enum PhotodetectorTypeCase {
    kAvalanchePhotodiode = 1,
    kPinPhotodiode = 2,
    PHOTODETECTOR_TYPE_NOT_SET = 0,
  };

  static inline const PhotodetectorDefinition* internal_default_instance() {
    return reinterpret_cast<const PhotodetectorDefinition*>(
               &_PhotodetectorDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PhotodetectorDefinition& a, PhotodetectorDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(PhotodetectorDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhotodetectorDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhotodetectorDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhotodetectorDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhotodetectorDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhotodetectorDefinition& from) {
    PhotodetectorDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhotodetectorDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PhotodetectorDefinition";
  }
  protected:
  explicit PhotodetectorDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PhotodetectorDefinition_AvalanchePhotodiodeDefinition AvalanchePhotodiodeDefinition;
  typedef PhotodetectorDefinition_PinPhotodiodeDefinition PinPhotodiodeDefinition;

  // accessors -------------------------------------------------------

  enum : int {
    kAvalanchePhotodiodeFieldNumber = 1,
    kPinPhotodiodeFieldNumber = 2,
  };
  // .aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition avalanche_photodiode = 1 [json_name = "avalanchePhotodiode"];
  bool has_avalanche_photodiode() const;
  private:
  bool _internal_has_avalanche_photodiode() const;

  public:
  void clear_avalanche_photodiode() ;
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition& avalanche_photodiode() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* release_avalanche_photodiode();
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* mutable_avalanche_photodiode();
  void set_allocated_avalanche_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* avalanche_photodiode);
  private:
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition& _internal_avalanche_photodiode() const;
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* _internal_mutable_avalanche_photodiode();
  public:
  void unsafe_arena_set_allocated_avalanche_photodiode(
      ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* avalanche_photodiode);
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* unsafe_arena_release_avalanche_photodiode();
  // .aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition pin_photodiode = 2 [json_name = "pinPhotodiode"];
  bool has_pin_photodiode() const;
  private:
  bool _internal_has_pin_photodiode() const;

  public:
  void clear_pin_photodiode() ;
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition& pin_photodiode() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* release_pin_photodiode();
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* mutable_pin_photodiode();
  void set_allocated_pin_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* pin_photodiode);
  private:
  const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition& _internal_pin_photodiode() const;
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* _internal_mutable_pin_photodiode();
  public:
  void unsafe_arena_set_allocated_pin_photodiode(
      ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* pin_photodiode);
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* unsafe_arena_release_pin_photodiode();
  void clear_photodetector_type();
  PhotodetectorTypeCase photodetector_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PhotodetectorDefinition)
 private:
  class _Internal;
  void set_has_avalanche_photodiode();
  void set_has_pin_photodiode();

  inline bool has_photodetector_type() const;
  inline void clear_has_photodetector_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PhotodetectorTypeUnion {
      constexpr PhotodetectorTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* avalanche_photodiode_;
      ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* pin_photodiode_;
    } photodetector_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RxChannels

// repeated int64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
inline int RxChannels::_internal_center_frequency_hz_size() const {
  return _impl_.center_frequency_hz_.size();
}
inline int RxChannels::center_frequency_hz_size() const {
  return _internal_center_frequency_hz_size();
}
inline void RxChannels::clear_center_frequency_hz() {
  _internal_mutable_center_frequency_hz()->Clear();
}
inline ::int64_t RxChannels::center_frequency_hz(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RxChannels.center_frequency_hz)
  return _internal_center_frequency_hz(index);
}
inline void RxChannels::set_center_frequency_hz(int index, ::int64_t value) {
  _internal_mutable_center_frequency_hz()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RxChannels.center_frequency_hz)
}
inline void RxChannels::add_center_frequency_hz(::int64_t value) {
  _internal_add_center_frequency_hz(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.RxChannels.center_frequency_hz)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& RxChannels::center_frequency_hz() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.RxChannels.center_frequency_hz)
  return _internal_center_frequency_hz();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* RxChannels::mutable_center_frequency_hz() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.RxChannels.center_frequency_hz)
  return _internal_mutable_center_frequency_hz();
}

inline ::int64_t RxChannels::_internal_center_frequency_hz(int index) const {
  return _internal_center_frequency_hz().Get(index);
}
inline void RxChannels::_internal_add_center_frequency_hz(::int64_t value) {
  _internal_mutable_center_frequency_hz()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& RxChannels::_internal_center_frequency_hz() const {
  return _impl_.center_frequency_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* RxChannels::_internal_mutable_center_frequency_hz() {
  return &_impl_.center_frequency_hz_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReceiverDefinition

// optional string name = 2 [json_name = "name"];
inline bool ReceiverDefinition::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReceiverDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReceiverDefinition::name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverDefinition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReceiverDefinition::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverDefinition.name)
}
inline std::string* ReceiverDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiverDefinition.name)
  return _s;
}
inline const std::string& ReceiverDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ReceiverDefinition::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiverDefinition::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* ReceiverDefinition::release_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiverDefinition.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ReceiverDefinition::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiverDefinition.name)
}

// map<string, .aalyria.spacetime.api.common.RxChannels> channel_set = 10 [json_name = "channelSet"];
inline int ReceiverDefinition::_internal_channel_set_size() const {
  return _impl_.channel_set_.size();
}
inline int ReceiverDefinition::channel_set_size() const {
  return _internal_channel_set_size();
}
inline void ReceiverDefinition::clear_channel_set() {
  _impl_.channel_set_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >&
ReceiverDefinition::_internal_channel_set() const {
  return _impl_.channel_set_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >&
ReceiverDefinition::channel_set() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.ReceiverDefinition.channel_set)
  return _internal_channel_set();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >*
ReceiverDefinition::_internal_mutable_channel_set() {
  return _impl_.channel_set_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >*
ReceiverDefinition::mutable_channel_set() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.ReceiverDefinition.channel_set)
  return _internal_mutable_channel_set();
}

// optional .aalyria.spacetime.api.common.ChannelSelectionMethod channel_selection_method = 9 [json_name = "channelSelectionMethod"];
inline bool ReceiverDefinition::has_channel_selection_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReceiverDefinition::clear_channel_selection_method() {
  _impl_.channel_selection_method_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::ChannelSelectionMethod ReceiverDefinition::channel_selection_method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverDefinition.channel_selection_method)
  return _internal_channel_selection_method();
}
inline void ReceiverDefinition::set_channel_selection_method(::aalyria::spacetime::api::common::ChannelSelectionMethod value) {
   _internal_set_channel_selection_method(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverDefinition.channel_selection_method)
}
inline ::aalyria::spacetime::api::common::ChannelSelectionMethod ReceiverDefinition::_internal_channel_selection_method() const {
  return static_cast<::aalyria::spacetime::api::common::ChannelSelectionMethod>(_impl_.channel_selection_method_);
}
inline void ReceiverDefinition::_internal_set_channel_selection_method(::aalyria::spacetime::api::common::ChannelSelectionMethod value) {
  assert(::aalyria::spacetime::api::common::ChannelSelectionMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_selection_method_ = value;
}

// repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor signal_processing_step = 11 [json_name = "signalProcessingStep"];
inline int ReceiverDefinition::_internal_signal_processing_step_size() const {
  return _impl_.signal_processing_step_.size();
}
inline int ReceiverDefinition::signal_processing_step_size() const {
  return _internal_signal_processing_step_size();
}
inline void ReceiverDefinition::clear_signal_processing_step() {
  _internal_mutable_signal_processing_step()->Clear();
}
inline ::aalyria::spacetime::api::common::ReceiveSignalProcessor* ReceiverDefinition::mutable_signal_processing_step(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiverDefinition.signal_processing_step)
  return _internal_mutable_signal_processing_step()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >*
ReceiverDefinition::mutable_signal_processing_step() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.ReceiverDefinition.signal_processing_step)
  return _internal_mutable_signal_processing_step();
}
inline const ::aalyria::spacetime::api::common::ReceiveSignalProcessor& ReceiverDefinition::_internal_signal_processing_step(int index) const {
  return _internal_signal_processing_step().Get(index);
}
inline const ::aalyria::spacetime::api::common::ReceiveSignalProcessor& ReceiverDefinition::signal_processing_step(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverDefinition.signal_processing_step)
  return _internal_signal_processing_step(index);
}
inline ::aalyria::spacetime::api::common::ReceiveSignalProcessor* ReceiverDefinition::_internal_add_signal_processing_step() {
  return _internal_mutable_signal_processing_step()->Add();
}
inline ::aalyria::spacetime::api::common::ReceiveSignalProcessor* ReceiverDefinition::add_signal_processing_step() {
  ::aalyria::spacetime::api::common::ReceiveSignalProcessor* _add = _internal_add_signal_processing_step();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.ReceiverDefinition.signal_processing_step)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >&
ReceiverDefinition::signal_processing_step() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.ReceiverDefinition.signal_processing_step)
  return _internal_signal_processing_step();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiveSignalProcessor>&
ReceiverDefinition::_internal_signal_processing_step() const {
  return _impl_.signal_processing_step_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiveSignalProcessor>*
ReceiverDefinition::_internal_mutable_signal_processing_step() {
  return &_impl_.signal_processing_step_;
}

// -------------------------------------------------------------------

// ReceiveSignalProcessor

// .aalyria.spacetime.api.common.Filter filter = 1 [json_name = "filter"];
inline bool ReceiveSignalProcessor::has_filter() const {
  return type_case() == kFilter;
}
inline bool ReceiveSignalProcessor::_internal_has_filter() const {
  return type_case() == kFilter;
}
inline void ReceiveSignalProcessor::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void ReceiveSignalProcessor::clear_filter() {
  if (type_case() == kFilter) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.filter_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::Filter* ReceiveSignalProcessor::release_filter() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
  if (type_case() == kFilter) {
    clear_has_type();
    ::aalyria::spacetime::api::common::Filter* temp = _impl_.type_.filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Filter& ReceiveSignalProcessor::_internal_filter() const {
  return type_case() == kFilter
      ? *_impl_.type_.filter_
      : reinterpret_cast<::aalyria::spacetime::api::common::Filter&>(::aalyria::spacetime::api::common::_Filter_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Filter& ReceiveSignalProcessor::filter() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
  return _internal_filter();
}
inline ::aalyria::spacetime::api::common::Filter* ReceiveSignalProcessor::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
  if (type_case() == kFilter) {
    clear_has_type();
    ::aalyria::spacetime::api::common::Filter* temp = _impl_.type_.filter_;
    _impl_.type_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveSignalProcessor::unsafe_arena_set_allocated_filter(::aalyria::spacetime::api::common::Filter* filter) {
  clear_type();
  if (filter) {
    set_has_filter();
    _impl_.type_.filter_ = filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
}
inline ::aalyria::spacetime::api::common::Filter* ReceiveSignalProcessor::_internal_mutable_filter() {
  if (type_case() != kFilter) {
    clear_type();
    set_has_filter();
    _impl_.type_.filter_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter >(GetArenaForAllocation());
  }
  return _impl_.type_.filter_;
}
inline ::aalyria::spacetime::api::common::Filter* ReceiveSignalProcessor::mutable_filter() {
  ::aalyria::spacetime::api::common::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
  return _msg;
}

// .aalyria.spacetime.api.common.PhotodetectorDefinition photodetector = 2 [json_name = "photodetector"];
inline bool ReceiveSignalProcessor::has_photodetector() const {
  return type_case() == kPhotodetector;
}
inline bool ReceiveSignalProcessor::_internal_has_photodetector() const {
  return type_case() == kPhotodetector;
}
inline void ReceiveSignalProcessor::set_has_photodetector() {
  _impl_._oneof_case_[0] = kPhotodetector;
}
inline void ReceiveSignalProcessor::clear_photodetector() {
  if (type_case() == kPhotodetector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.photodetector_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition* ReceiveSignalProcessor::release_photodetector() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
  if (type_case() == kPhotodetector) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition* temp = _impl_.type_.photodetector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.photodetector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition& ReceiveSignalProcessor::_internal_photodetector() const {
  return type_case() == kPhotodetector
      ? *_impl_.type_.photodetector_
      : reinterpret_cast<::aalyria::spacetime::api::common::PhotodetectorDefinition&>(::aalyria::spacetime::api::common::_PhotodetectorDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition& ReceiveSignalProcessor::photodetector() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
  return _internal_photodetector();
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition* ReceiveSignalProcessor::unsafe_arena_release_photodetector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
  if (type_case() == kPhotodetector) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition* temp = _impl_.type_.photodetector_;
    _impl_.type_.photodetector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveSignalProcessor::unsafe_arena_set_allocated_photodetector(::aalyria::spacetime::api::common::PhotodetectorDefinition* photodetector) {
  clear_type();
  if (photodetector) {
    set_has_photodetector();
    _impl_.type_.photodetector_ = photodetector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition* ReceiveSignalProcessor::_internal_mutable_photodetector() {
  if (type_case() != kPhotodetector) {
    clear_type();
    set_has_photodetector();
    _impl_.type_.photodetector_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition >(GetArenaForAllocation());
  }
  return _impl_.type_.photodetector_;
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition* ReceiveSignalProcessor::mutable_photodetector() {
  ::aalyria::spacetime::api::common::PhotodetectorDefinition* _msg = _internal_mutable_photodetector();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
  return _msg;
}

// .aalyria.spacetime.api.common.AmplifierDefinition amplifier = 3 [json_name = "amplifier"];
inline bool ReceiveSignalProcessor::has_amplifier() const {
  return type_case() == kAmplifier;
}
inline bool ReceiveSignalProcessor::_internal_has_amplifier() const {
  return type_case() == kAmplifier;
}
inline void ReceiveSignalProcessor::set_has_amplifier() {
  _impl_._oneof_case_[0] = kAmplifier;
}
inline ::aalyria::spacetime::api::common::AmplifierDefinition* ReceiveSignalProcessor::release_amplifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
  if (type_case() == kAmplifier) {
    clear_has_type();
    ::aalyria::spacetime::api::common::AmplifierDefinition* temp = _impl_.type_.amplifier_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.amplifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::AmplifierDefinition& ReceiveSignalProcessor::_internal_amplifier() const {
  return type_case() == kAmplifier
      ? *_impl_.type_.amplifier_
      : reinterpret_cast<::aalyria::spacetime::api::common::AmplifierDefinition&>(::aalyria::spacetime::api::common::_AmplifierDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AmplifierDefinition& ReceiveSignalProcessor::amplifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
  return _internal_amplifier();
}
inline ::aalyria::spacetime::api::common::AmplifierDefinition* ReceiveSignalProcessor::unsafe_arena_release_amplifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
  if (type_case() == kAmplifier) {
    clear_has_type();
    ::aalyria::spacetime::api::common::AmplifierDefinition* temp = _impl_.type_.amplifier_;
    _impl_.type_.amplifier_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveSignalProcessor::unsafe_arena_set_allocated_amplifier(::aalyria::spacetime::api::common::AmplifierDefinition* amplifier) {
  clear_type();
  if (amplifier) {
    set_has_amplifier();
    _impl_.type_.amplifier_ = amplifier;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
}
inline ::aalyria::spacetime::api::common::AmplifierDefinition* ReceiveSignalProcessor::_internal_mutable_amplifier() {
  if (type_case() != kAmplifier) {
    clear_type();
    set_has_amplifier();
    _impl_.type_.amplifier_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::AmplifierDefinition >(GetArenaForAllocation());
  }
  return _impl_.type_.amplifier_;
}
inline ::aalyria::spacetime::api::common::AmplifierDefinition* ReceiveSignalProcessor::mutable_amplifier() {
  ::aalyria::spacetime::api::common::AmplifierDefinition* _msg = _internal_mutable_amplifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
  return _msg;
}

// .aalyria.spacetime.api.common.MiscGainOrLoss gain_or_loss = 4 [json_name = "gainOrLoss"];
inline bool ReceiveSignalProcessor::has_gain_or_loss() const {
  return type_case() == kGainOrLoss;
}
inline bool ReceiveSignalProcessor::_internal_has_gain_or_loss() const {
  return type_case() == kGainOrLoss;
}
inline void ReceiveSignalProcessor::set_has_gain_or_loss() {
  _impl_._oneof_case_[0] = kGainOrLoss;
}
inline ::aalyria::spacetime::api::common::MiscGainOrLoss* ReceiveSignalProcessor::release_gain_or_loss() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
  if (type_case() == kGainOrLoss) {
    clear_has_type();
    ::aalyria::spacetime::api::common::MiscGainOrLoss* temp = _impl_.type_.gain_or_loss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.gain_or_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::MiscGainOrLoss& ReceiveSignalProcessor::_internal_gain_or_loss() const {
  return type_case() == kGainOrLoss
      ? *_impl_.type_.gain_or_loss_
      : reinterpret_cast<::aalyria::spacetime::api::common::MiscGainOrLoss&>(::aalyria::spacetime::api::common::_MiscGainOrLoss_default_instance_);
}
inline const ::aalyria::spacetime::api::common::MiscGainOrLoss& ReceiveSignalProcessor::gain_or_loss() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
  return _internal_gain_or_loss();
}
inline ::aalyria::spacetime::api::common::MiscGainOrLoss* ReceiveSignalProcessor::unsafe_arena_release_gain_or_loss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
  if (type_case() == kGainOrLoss) {
    clear_has_type();
    ::aalyria::spacetime::api::common::MiscGainOrLoss* temp = _impl_.type_.gain_or_loss_;
    _impl_.type_.gain_or_loss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReceiveSignalProcessor::unsafe_arena_set_allocated_gain_or_loss(::aalyria::spacetime::api::common::MiscGainOrLoss* gain_or_loss) {
  clear_type();
  if (gain_or_loss) {
    set_has_gain_or_loss();
    _impl_.type_.gain_or_loss_ = gain_or_loss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
}
inline ::aalyria::spacetime::api::common::MiscGainOrLoss* ReceiveSignalProcessor::_internal_mutable_gain_or_loss() {
  if (type_case() != kGainOrLoss) {
    clear_type();
    set_has_gain_or_loss();
    _impl_.type_.gain_or_loss_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::MiscGainOrLoss >(GetArenaForAllocation());
  }
  return _impl_.type_.gain_or_loss_;
}
inline ::aalyria::spacetime::api::common::MiscGainOrLoss* ReceiveSignalProcessor::mutable_gain_or_loss() {
  ::aalyria::spacetime::api::common::MiscGainOrLoss* _msg = _internal_mutable_gain_or_loss();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
  return _msg;
}

inline bool ReceiveSignalProcessor::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ReceiveSignalProcessor::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline ReceiveSignalProcessor::TypeCase ReceiveSignalProcessor::type_case() const {
  return ReceiveSignalProcessor::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Filter_RectangularFilterDefinition

// -------------------------------------------------------------------

// Filter_LinearFilterDefinition

// optional double rejection_db_per_hz = 1 [json_name = "rejectionDbPerHz"];
inline bool Filter_LinearFilterDefinition::has_rejection_db_per_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Filter_LinearFilterDefinition::clear_rejection_db_per_hz() {
  _impl_.rejection_db_per_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Filter_LinearFilterDefinition::rejection_db_per_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.LinearFilterDefinition.rejection_db_per_hz)
  return _internal_rejection_db_per_hz();
}
inline void Filter_LinearFilterDefinition::set_rejection_db_per_hz(double value) {
  _internal_set_rejection_db_per_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Filter.LinearFilterDefinition.rejection_db_per_hz)
}
inline double Filter_LinearFilterDefinition::_internal_rejection_db_per_hz() const {
  return _impl_.rejection_db_per_hz_;
}
inline void Filter_LinearFilterDefinition::_internal_set_rejection_db_per_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rejection_db_per_hz_ = value;
}

// -------------------------------------------------------------------

// Filter

// optional double frequency_hz = 1 [json_name = "frequencyHz"];
inline bool Filter::has_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Filter::clear_frequency_hz() {
  _impl_.frequency_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Filter::frequency_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.frequency_hz)
  return _internal_frequency_hz();
}
inline void Filter::set_frequency_hz(double value) {
  _internal_set_frequency_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Filter.frequency_hz)
}
inline double Filter::_internal_frequency_hz() const {
  return _impl_.frequency_hz_;
}
inline void Filter::_internal_set_frequency_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.frequency_hz_ = value;
}

// optional double lower_bandwidth_limit_hz = 2 [json_name = "lowerBandwidthLimitHz"];
inline bool Filter::has_lower_bandwidth_limit_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Filter::clear_lower_bandwidth_limit_hz() {
  _impl_.lower_bandwidth_limit_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Filter::lower_bandwidth_limit_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.lower_bandwidth_limit_hz)
  return _internal_lower_bandwidth_limit_hz();
}
inline void Filter::set_lower_bandwidth_limit_hz(double value) {
  _internal_set_lower_bandwidth_limit_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Filter.lower_bandwidth_limit_hz)
}
inline double Filter::_internal_lower_bandwidth_limit_hz() const {
  return _impl_.lower_bandwidth_limit_hz_;
}
inline void Filter::_internal_set_lower_bandwidth_limit_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lower_bandwidth_limit_hz_ = value;
}

// optional double upper_bandwidth_limit_hz = 3 [json_name = "upperBandwidthLimitHz"];
inline bool Filter::has_upper_bandwidth_limit_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Filter::clear_upper_bandwidth_limit_hz() {
  _impl_.upper_bandwidth_limit_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Filter::upper_bandwidth_limit_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.upper_bandwidth_limit_hz)
  return _internal_upper_bandwidth_limit_hz();
}
inline void Filter::set_upper_bandwidth_limit_hz(double value) {
  _internal_set_upper_bandwidth_limit_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Filter.upper_bandwidth_limit_hz)
}
inline double Filter::_internal_upper_bandwidth_limit_hz() const {
  return _impl_.upper_bandwidth_limit_hz_;
}
inline void Filter::_internal_set_upper_bandwidth_limit_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.upper_bandwidth_limit_hz_ = value;
}

// optional double noise_temperature_k = 4 [json_name = "noiseTemperatureK"];
inline bool Filter::has_noise_temperature_k() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Filter::clear_noise_temperature_k() {
  _impl_.noise_temperature_k_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Filter::noise_temperature_k() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.noise_temperature_k)
  return _internal_noise_temperature_k();
}
inline void Filter::set_noise_temperature_k(double value) {
  _internal_set_noise_temperature_k(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Filter.noise_temperature_k)
}
inline double Filter::_internal_noise_temperature_k() const {
  return _impl_.noise_temperature_k_;
}
inline void Filter::_internal_set_noise_temperature_k(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.noise_temperature_k_ = value;
}

// .aalyria.spacetime.api.common.Filter.RectangularFilterDefinition rectangular = 5 [json_name = "rectangular"];
inline bool Filter::has_rectangular() const {
  return filter_type_case() == kRectangular;
}
inline bool Filter::_internal_has_rectangular() const {
  return filter_type_case() == kRectangular;
}
inline void Filter::set_has_rectangular() {
  _impl_._oneof_case_[0] = kRectangular;
}
inline void Filter::clear_rectangular() {
  if (filter_type_case() == kRectangular) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.filter_type_.rectangular_;
    }
    clear_has_filter_type();
  }
}
inline ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* Filter::release_rectangular() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Filter.rectangular)
  if (filter_type_case() == kRectangular) {
    clear_has_filter_type();
    ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* temp = _impl_.filter_type_.rectangular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.filter_type_.rectangular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition& Filter::_internal_rectangular() const {
  return filter_type_case() == kRectangular
      ? *_impl_.filter_type_.rectangular_
      : reinterpret_cast<::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition&>(::aalyria::spacetime::api::common::_Filter_RectangularFilterDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition& Filter::rectangular() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.rectangular)
  return _internal_rectangular();
}
inline ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* Filter::unsafe_arena_release_rectangular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Filter.rectangular)
  if (filter_type_case() == kRectangular) {
    clear_has_filter_type();
    ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* temp = _impl_.filter_type_.rectangular_;
    _impl_.filter_type_.rectangular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filter::unsafe_arena_set_allocated_rectangular(::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* rectangular) {
  clear_filter_type();
  if (rectangular) {
    set_has_rectangular();
    _impl_.filter_type_.rectangular_ = rectangular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Filter.rectangular)
}
inline ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* Filter::_internal_mutable_rectangular() {
  if (filter_type_case() != kRectangular) {
    clear_filter_type();
    set_has_rectangular();
    _impl_.filter_type_.rectangular_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition >(GetArenaForAllocation());
  }
  return _impl_.filter_type_.rectangular_;
}
inline ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* Filter::mutable_rectangular() {
  ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* _msg = _internal_mutable_rectangular();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Filter.rectangular)
  return _msg;
}

// .aalyria.spacetime.api.common.Filter.LinearFilterDefinition linear = 6 [json_name = "linear"];
inline bool Filter::has_linear() const {
  return filter_type_case() == kLinear;
}
inline bool Filter::_internal_has_linear() const {
  return filter_type_case() == kLinear;
}
inline void Filter::set_has_linear() {
  _impl_._oneof_case_[0] = kLinear;
}
inline void Filter::clear_linear() {
  if (filter_type_case() == kLinear) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.filter_type_.linear_;
    }
    clear_has_filter_type();
  }
}
inline ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* Filter::release_linear() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Filter.linear)
  if (filter_type_case() == kLinear) {
    clear_has_filter_type();
    ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* temp = _impl_.filter_type_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.filter_type_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition& Filter::_internal_linear() const {
  return filter_type_case() == kLinear
      ? *_impl_.filter_type_.linear_
      : reinterpret_cast<::aalyria::spacetime::api::common::Filter_LinearFilterDefinition&>(::aalyria::spacetime::api::common::_Filter_LinearFilterDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition& Filter::linear() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Filter.linear)
  return _internal_linear();
}
inline ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* Filter::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Filter.linear)
  if (filter_type_case() == kLinear) {
    clear_has_filter_type();
    ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* temp = _impl_.filter_type_.linear_;
    _impl_.filter_type_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filter::unsafe_arena_set_allocated_linear(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* linear) {
  clear_filter_type();
  if (linear) {
    set_has_linear();
    _impl_.filter_type_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Filter.linear)
}
inline ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* Filter::_internal_mutable_linear() {
  if (filter_type_case() != kLinear) {
    clear_filter_type();
    set_has_linear();
    _impl_.filter_type_.linear_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition >(GetArenaForAllocation());
  }
  return _impl_.filter_type_.linear_;
}
inline ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* Filter::mutable_linear() {
  ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Filter.linear)
  return _msg;
}

inline bool Filter::has_filter_type() const {
  return filter_type_case() != FILTER_TYPE_NOT_SET;
}
inline void Filter::clear_has_filter_type() {
  _impl_._oneof_case_[0] = FILTER_TYPE_NOT_SET;
}
inline Filter::FilterTypeCase Filter::filter_type_case() const {
  return Filter::FilterTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PhotodetectorDefinition_AvalanchePhotodiodeDefinition

// optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_field_of_view_rad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_field_of_view_rad() {
  _impl_.field_of_view_rad_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::field_of_view_rad() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.field_of_view_rad)
  return _internal_field_of_view_rad();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_field_of_view_rad(double value) {
  _internal_set_field_of_view_rad(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.field_of_view_rad)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_field_of_view_rad() const {
  return _impl_.field_of_view_rad_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_field_of_view_rad(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_of_view_rad_ = value;
}

// optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_bandwidth_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_bandwidth_hz() {
  _impl_.bandwidth_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::bandwidth_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.bandwidth_hz)
  return _internal_bandwidth_hz();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_bandwidth_hz(double value) {
  _internal_set_bandwidth_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.bandwidth_hz)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_bandwidth_hz() const {
  return _impl_.bandwidth_hz_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_bandwidth_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bandwidth_hz_ = value;
}

// optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_noise_temperature_k() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_noise_temperature_k() {
  _impl_.noise_temperature_k_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::noise_temperature_k() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.noise_temperature_k)
  return _internal_noise_temperature_k();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_noise_temperature_k(double value) {
  _internal_set_noise_temperature_k(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.noise_temperature_k)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_noise_temperature_k() const {
  return _impl_.noise_temperature_k_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_noise_temperature_k(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.noise_temperature_k_ = value;
}

// optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_efficiency_percent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_efficiency_percent() {
  _impl_.efficiency_percent_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::efficiency_percent() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.efficiency_percent)
  return _internal_efficiency_percent();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_efficiency_percent(double value) {
  _internal_set_efficiency_percent(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.efficiency_percent)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_efficiency_percent() const {
  return _impl_.efficiency_percent_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_efficiency_percent(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.efficiency_percent_ = value;
}

// optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_dark_current_amp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_dark_current_amp() {
  _impl_.dark_current_amp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::dark_current_amp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.dark_current_amp)
  return _internal_dark_current_amp();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_dark_current_amp(double value) {
  _internal_set_dark_current_amp(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.dark_current_amp)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_dark_current_amp() const {
  return _impl_.dark_current_amp_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_dark_current_amp(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dark_current_amp_ = value;
}

// optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_load_impedance_ohm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_load_impedance_ohm() {
  _impl_.load_impedance_ohm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::load_impedance_ohm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.load_impedance_ohm)
  return _internal_load_impedance_ohm();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_load_impedance_ohm(double value) {
  _internal_set_load_impedance_ohm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.load_impedance_ohm)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_load_impedance_ohm() const {
  return _impl_.load_impedance_ohm_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_load_impedance_ohm(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.load_impedance_ohm_ = value;
}

// optional double noise_factor = 7 [json_name = "noiseFactor"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_noise_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_noise_factor() {
  _impl_.noise_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::noise_factor() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.noise_factor)
  return _internal_noise_factor();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_noise_factor(double value) {
  _internal_set_noise_factor(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.noise_factor)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_noise_factor() const {
  return _impl_.noise_factor_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_noise_factor(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.noise_factor_ = value;
}

// optional double gain_db = 8 [json_name = "gainDb"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_gain_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_gain_db() {
  _impl_.gain_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::gain_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.gain_db)
  return _internal_gain_db();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_gain_db(double value) {
  _internal_set_gain_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.gain_db)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_gain_db() const {
  return _impl_.gain_db_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_gain_db(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.gain_db_ = value;
}

// optional double optical_bandpass_filter_bandwidth_hz = 9 [json_name = "opticalBandpassFilterBandwidthHz"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_optical_bandpass_filter_bandwidth_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_optical_bandpass_filter_bandwidth_hz() {
  _impl_.optical_bandpass_filter_bandwidth_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::optical_bandpass_filter_bandwidth_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.optical_bandpass_filter_bandwidth_hz)
  return _internal_optical_bandpass_filter_bandwidth_hz();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_optical_bandpass_filter_bandwidth_hz(double value) {
  _internal_set_optical_bandpass_filter_bandwidth_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.optical_bandpass_filter_bandwidth_hz)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_optical_bandpass_filter_bandwidth_hz() const {
  return _impl_.optical_bandpass_filter_bandwidth_hz_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_optical_bandpass_filter_bandwidth_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.optical_bandpass_filter_bandwidth_hz_ = value;
}

// optional double sky_spectral_radiance = 10 [json_name = "skySpectralRadiance"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_sky_spectral_radiance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_sky_spectral_radiance() {
  _impl_.sky_spectral_radiance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::sky_spectral_radiance() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.sky_spectral_radiance)
  return _internal_sky_spectral_radiance();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_sky_spectral_radiance(double value) {
  _internal_set_sky_spectral_radiance(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.sky_spectral_radiance)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_sky_spectral_radiance() const {
  return _impl_.sky_spectral_radiance_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_sky_spectral_radiance(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.sky_spectral_radiance_ = value;
}

// optional double sun_spectral_radiant_emittance = 11 [json_name = "sunSpectralRadiantEmittance"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_sun_spectral_radiant_emittance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_sun_spectral_radiant_emittance() {
  _impl_.sun_spectral_radiant_emittance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::sun_spectral_radiant_emittance() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.sun_spectral_radiant_emittance)
  return _internal_sun_spectral_radiant_emittance();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_sun_spectral_radiant_emittance(double value) {
  _internal_set_sun_spectral_radiant_emittance(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.sun_spectral_radiant_emittance)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_sun_spectral_radiant_emittance() const {
  return _impl_.sun_spectral_radiant_emittance_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_sun_spectral_radiant_emittance(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.sun_spectral_radiant_emittance_ = value;
}

// optional double wavelength_m = 12 [json_name = "wavelengthM"];
inline bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::has_wavelength_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::clear_wavelength_m() {
  _impl_.wavelength_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::wavelength_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.wavelength_m)
  return _internal_wavelength_m();
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::set_wavelength_m(double value) {
  _internal_set_wavelength_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition.wavelength_m)
}
inline double PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_wavelength_m() const {
  return _impl_.wavelength_m_;
}
inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_internal_set_wavelength_m(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.wavelength_m_ = value;
}

// -------------------------------------------------------------------

// PhotodetectorDefinition_PinPhotodiodeDefinition

// optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_field_of_view_rad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_field_of_view_rad() {
  _impl_.field_of_view_rad_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::field_of_view_rad() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.field_of_view_rad)
  return _internal_field_of_view_rad();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_field_of_view_rad(double value) {
  _internal_set_field_of_view_rad(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.field_of_view_rad)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_field_of_view_rad() const {
  return _impl_.field_of_view_rad_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_field_of_view_rad(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_of_view_rad_ = value;
}

// optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_bandwidth_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_bandwidth_hz() {
  _impl_.bandwidth_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::bandwidth_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.bandwidth_hz)
  return _internal_bandwidth_hz();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_bandwidth_hz(double value) {
  _internal_set_bandwidth_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.bandwidth_hz)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_bandwidth_hz() const {
  return _impl_.bandwidth_hz_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_bandwidth_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bandwidth_hz_ = value;
}

// optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_noise_temperature_k() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_noise_temperature_k() {
  _impl_.noise_temperature_k_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::noise_temperature_k() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.noise_temperature_k)
  return _internal_noise_temperature_k();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_noise_temperature_k(double value) {
  _internal_set_noise_temperature_k(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.noise_temperature_k)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_noise_temperature_k() const {
  return _impl_.noise_temperature_k_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_noise_temperature_k(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.noise_temperature_k_ = value;
}

// optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_efficiency_percent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_efficiency_percent() {
  _impl_.efficiency_percent_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::efficiency_percent() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.efficiency_percent)
  return _internal_efficiency_percent();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_efficiency_percent(double value) {
  _internal_set_efficiency_percent(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.efficiency_percent)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_efficiency_percent() const {
  return _impl_.efficiency_percent_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_efficiency_percent(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.efficiency_percent_ = value;
}

// optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_dark_current_amp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_dark_current_amp() {
  _impl_.dark_current_amp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::dark_current_amp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.dark_current_amp)
  return _internal_dark_current_amp();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_dark_current_amp(double value) {
  _internal_set_dark_current_amp(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.dark_current_amp)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_dark_current_amp() const {
  return _impl_.dark_current_amp_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_dark_current_amp(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dark_current_amp_ = value;
}

// optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_load_impedance_ohm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_load_impedance_ohm() {
  _impl_.load_impedance_ohm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::load_impedance_ohm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.load_impedance_ohm)
  return _internal_load_impedance_ohm();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_load_impedance_ohm(double value) {
  _internal_set_load_impedance_ohm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.load_impedance_ohm)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_load_impedance_ohm() const {
  return _impl_.load_impedance_ohm_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_load_impedance_ohm(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.load_impedance_ohm_ = value;
}

// optional double optical_bandpass_filter_bandwidth_hz = 7 [json_name = "opticalBandpassFilterBandwidthHz"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_optical_bandpass_filter_bandwidth_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_optical_bandpass_filter_bandwidth_hz() {
  _impl_.optical_bandpass_filter_bandwidth_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::optical_bandpass_filter_bandwidth_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.optical_bandpass_filter_bandwidth_hz)
  return _internal_optical_bandpass_filter_bandwidth_hz();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_optical_bandpass_filter_bandwidth_hz(double value) {
  _internal_set_optical_bandpass_filter_bandwidth_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.optical_bandpass_filter_bandwidth_hz)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_optical_bandpass_filter_bandwidth_hz() const {
  return _impl_.optical_bandpass_filter_bandwidth_hz_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_optical_bandpass_filter_bandwidth_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.optical_bandpass_filter_bandwidth_hz_ = value;
}

// optional double sky_spectral_radiance = 8 [json_name = "skySpectralRadiance"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_sky_spectral_radiance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_sky_spectral_radiance() {
  _impl_.sky_spectral_radiance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::sky_spectral_radiance() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.sky_spectral_radiance)
  return _internal_sky_spectral_radiance();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_sky_spectral_radiance(double value) {
  _internal_set_sky_spectral_radiance(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.sky_spectral_radiance)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_sky_spectral_radiance() const {
  return _impl_.sky_spectral_radiance_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_sky_spectral_radiance(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sky_spectral_radiance_ = value;
}

// optional double sun_spectral_radiant_emittance = 9 [json_name = "sunSpectralRadiantEmittance"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_sun_spectral_radiant_emittance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_sun_spectral_radiant_emittance() {
  _impl_.sun_spectral_radiant_emittance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::sun_spectral_radiant_emittance() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.sun_spectral_radiant_emittance)
  return _internal_sun_spectral_radiant_emittance();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_sun_spectral_radiant_emittance(double value) {
  _internal_set_sun_spectral_radiant_emittance(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.sun_spectral_radiant_emittance)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_sun_spectral_radiant_emittance() const {
  return _impl_.sun_spectral_radiant_emittance_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_sun_spectral_radiant_emittance(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sun_spectral_radiant_emittance_ = value;
}

// optional double wavelength_m = 10 [json_name = "wavelengthM"];
inline bool PhotodetectorDefinition_PinPhotodiodeDefinition::has_wavelength_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::clear_wavelength_m() {
  _impl_.wavelength_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::wavelength_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.wavelength_m)
  return _internal_wavelength_m();
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::set_wavelength_m(double value) {
  _internal_set_wavelength_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition.wavelength_m)
}
inline double PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_wavelength_m() const {
  return _impl_.wavelength_m_;
}
inline void PhotodetectorDefinition_PinPhotodiodeDefinition::_internal_set_wavelength_m(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.wavelength_m_ = value;
}

// -------------------------------------------------------------------

// PhotodetectorDefinition

// .aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition avalanche_photodiode = 1 [json_name = "avalanchePhotodiode"];
inline bool PhotodetectorDefinition::has_avalanche_photodiode() const {
  return photodetector_type_case() == kAvalanchePhotodiode;
}
inline bool PhotodetectorDefinition::_internal_has_avalanche_photodiode() const {
  return photodetector_type_case() == kAvalanchePhotodiode;
}
inline void PhotodetectorDefinition::set_has_avalanche_photodiode() {
  _impl_._oneof_case_[0] = kAvalanchePhotodiode;
}
inline void PhotodetectorDefinition::clear_avalanche_photodiode() {
  if (photodetector_type_case() == kAvalanchePhotodiode) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.photodetector_type_.avalanche_photodiode_;
    }
    clear_has_photodetector_type();
  }
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* PhotodetectorDefinition::release_avalanche_photodiode() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
  if (photodetector_type_case() == kAvalanchePhotodiode) {
    clear_has_photodetector_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* temp = _impl_.photodetector_type_.avalanche_photodiode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.photodetector_type_.avalanche_photodiode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition& PhotodetectorDefinition::_internal_avalanche_photodiode() const {
  return photodetector_type_case() == kAvalanchePhotodiode
      ? *_impl_.photodetector_type_.avalanche_photodiode_
      : reinterpret_cast<::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition&>(::aalyria::spacetime::api::common::_PhotodetectorDefinition_AvalanchePhotodiodeDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition& PhotodetectorDefinition::avalanche_photodiode() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
  return _internal_avalanche_photodiode();
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* PhotodetectorDefinition::unsafe_arena_release_avalanche_photodiode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
  if (photodetector_type_case() == kAvalanchePhotodiode) {
    clear_has_photodetector_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* temp = _impl_.photodetector_type_.avalanche_photodiode_;
    _impl_.photodetector_type_.avalanche_photodiode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PhotodetectorDefinition::unsafe_arena_set_allocated_avalanche_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* avalanche_photodiode) {
  clear_photodetector_type();
  if (avalanche_photodiode) {
    set_has_avalanche_photodiode();
    _impl_.photodetector_type_.avalanche_photodiode_ = avalanche_photodiode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* PhotodetectorDefinition::_internal_mutable_avalanche_photodiode() {
  if (photodetector_type_case() != kAvalanchePhotodiode) {
    clear_photodetector_type();
    set_has_avalanche_photodiode();
    _impl_.photodetector_type_.avalanche_photodiode_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition >(GetArenaForAllocation());
  }
  return _impl_.photodetector_type_.avalanche_photodiode_;
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* PhotodetectorDefinition::mutable_avalanche_photodiode() {
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* _msg = _internal_mutable_avalanche_photodiode();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
  return _msg;
}

// .aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition pin_photodiode = 2 [json_name = "pinPhotodiode"];
inline bool PhotodetectorDefinition::has_pin_photodiode() const {
  return photodetector_type_case() == kPinPhotodiode;
}
inline bool PhotodetectorDefinition::_internal_has_pin_photodiode() const {
  return photodetector_type_case() == kPinPhotodiode;
}
inline void PhotodetectorDefinition::set_has_pin_photodiode() {
  _impl_._oneof_case_[0] = kPinPhotodiode;
}
inline void PhotodetectorDefinition::clear_pin_photodiode() {
  if (photodetector_type_case() == kPinPhotodiode) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.photodetector_type_.pin_photodiode_;
    }
    clear_has_photodetector_type();
  }
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* PhotodetectorDefinition::release_pin_photodiode() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
  if (photodetector_type_case() == kPinPhotodiode) {
    clear_has_photodetector_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* temp = _impl_.photodetector_type_.pin_photodiode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.photodetector_type_.pin_photodiode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition& PhotodetectorDefinition::_internal_pin_photodiode() const {
  return photodetector_type_case() == kPinPhotodiode
      ? *_impl_.photodetector_type_.pin_photodiode_
      : reinterpret_cast<::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition&>(::aalyria::spacetime::api::common::_PhotodetectorDefinition_PinPhotodiodeDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition& PhotodetectorDefinition::pin_photodiode() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
  return _internal_pin_photodiode();
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* PhotodetectorDefinition::unsafe_arena_release_pin_photodiode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
  if (photodetector_type_case() == kPinPhotodiode) {
    clear_has_photodetector_type();
    ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* temp = _impl_.photodetector_type_.pin_photodiode_;
    _impl_.photodetector_type_.pin_photodiode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PhotodetectorDefinition::unsafe_arena_set_allocated_pin_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* pin_photodiode) {
  clear_photodetector_type();
  if (pin_photodiode) {
    set_has_pin_photodiode();
    _impl_.photodetector_type_.pin_photodiode_ = pin_photodiode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* PhotodetectorDefinition::_internal_mutable_pin_photodiode() {
  if (photodetector_type_case() != kPinPhotodiode) {
    clear_photodetector_type();
    set_has_pin_photodiode();
    _impl_.photodetector_type_.pin_photodiode_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition >(GetArenaForAllocation());
  }
  return _impl_.photodetector_type_.pin_photodiode_;
}
inline ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* PhotodetectorDefinition::mutable_pin_photodiode() {
  ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* _msg = _internal_mutable_pin_photodiode();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
  return _msg;
}

inline bool PhotodetectorDefinition::has_photodetector_type() const {
  return photodetector_type_case() != PHOTODETECTOR_TYPE_NOT_SET;
}
inline void PhotodetectorDefinition::clear_has_photodetector_type() {
  _impl_._oneof_case_[0] = PHOTODETECTOR_TYPE_NOT_SET;
}
inline PhotodetectorDefinition::PhotodetectorTypeCase PhotodetectorDefinition::photodetector_type_case() const {
  return PhotodetectorDefinition::PhotodetectorTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fwireless_5freceiver_2eproto_2epb_2eh
