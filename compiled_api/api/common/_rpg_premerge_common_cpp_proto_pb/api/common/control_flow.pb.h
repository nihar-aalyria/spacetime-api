// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/control_flow.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fflow_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fflow_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/network.pb.h"
#include "api/common/time.pb.h"
#include "api/types/ethernet.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fcontrol_5fflow_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fcontrol_5fflow_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class FlowRule;
struct FlowRuleDefaultTypeInternal;
extern FlowRuleDefaultTypeInternal _FlowRule_default_instance_;
class FlowRule_ActionBucket;
struct FlowRule_ActionBucketDefaultTypeInternal;
extern FlowRule_ActionBucketDefaultTypeInternal _FlowRule_ActionBucket_default_instance_;
class FlowRule_ActionBucket_Action;
struct FlowRule_ActionBucket_ActionDefaultTypeInternal;
extern FlowRule_ActionBucket_ActionDefaultTypeInternal _FlowRule_ActionBucket_Action_default_instance_;
class FlowRule_ActionBucket_Action_Forward;
struct FlowRule_ActionBucket_Action_ForwardDefaultTypeInternal;
extern FlowRule_ActionBucket_Action_ForwardDefaultTypeInternal _FlowRule_ActionBucket_Action_Forward_default_instance_;
class FlowRule_ActionBucket_Action_PopHeader;
struct FlowRule_ActionBucket_Action_PopHeaderDefaultTypeInternal;
extern FlowRule_ActionBucket_Action_PopHeaderDefaultTypeInternal _FlowRule_ActionBucket_Action_PopHeader_default_instance_;
class FlowRule_ActionBucket_Action_PushHeader;
struct FlowRule_ActionBucket_Action_PushHeaderDefaultTypeInternal;
extern FlowRule_ActionBucket_Action_PushHeaderDefaultTypeInternal _FlowRule_ActionBucket_Action_PushHeader_default_instance_;
class FlowRule_ActionBucket_Action_SetField;
struct FlowRule_ActionBucket_Action_SetFieldDefaultTypeInternal;
extern FlowRule_ActionBucket_Action_SetFieldDefaultTypeInternal _FlowRule_ActionBucket_Action_SetField_default_instance_;
class FlowState;
struct FlowStateDefaultTypeInternal;
extern FlowStateDefaultTypeInternal _FlowState_default_instance_;
class FlowUpdate;
struct FlowUpdateDefaultTypeInternal;
extern FlowUpdateDefaultTypeInternal _FlowUpdate_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::FlowRule* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowState* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowState>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowUpdate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum FlowUpdate_Operation : int {
  FlowUpdate_Operation_UNKNOWN = 0,
  FlowUpdate_Operation_ADD = 1,
  FlowUpdate_Operation_DELETE = 2,
};

bool FlowUpdate_Operation_IsValid(int value);
constexpr FlowUpdate_Operation FlowUpdate_Operation_Operation_MIN = static_cast<FlowUpdate_Operation>(0);
constexpr FlowUpdate_Operation FlowUpdate_Operation_Operation_MAX = static_cast<FlowUpdate_Operation>(2);
constexpr int FlowUpdate_Operation_Operation_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FlowUpdate_Operation_descriptor();
template <typename T>
const std::string& FlowUpdate_Operation_Name(T value) {
  static_assert(std::is_same<T, FlowUpdate_Operation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Operation_Name().");
  return FlowUpdate_Operation_Name(static_cast<FlowUpdate_Operation>(value));
}
template <>
inline const std::string& FlowUpdate_Operation_Name(FlowUpdate_Operation value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FlowUpdate_Operation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool FlowUpdate_Operation_Parse(absl::string_view name, FlowUpdate_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlowUpdate_Operation>(
      FlowUpdate_Operation_descriptor(), name, value);
}
enum FlowRule_ActionBucket_Action_SetField_Field : int {
  FlowRule_ActionBucket_Action_SetField_Field_FIELD_UNSPECIFIED = 0,
  FlowRule_ActionBucket_Action_SetField_Field_FIELD_ETH_DST = 2,
  FlowRule_ActionBucket_Action_SetField_Field_FIELD_MPLS_LABEL = 3,
  FlowRule_ActionBucket_Action_SetField_Field_FIELD_VLAN_ID = 4,
  FlowRule_ActionBucket_Action_SetField_Field_FIELD_PBB_ITAG = 5,
};

bool FlowRule_ActionBucket_Action_SetField_Field_IsValid(int value);
constexpr FlowRule_ActionBucket_Action_SetField_Field FlowRule_ActionBucket_Action_SetField_Field_Field_MIN = static_cast<FlowRule_ActionBucket_Action_SetField_Field>(0);
constexpr FlowRule_ActionBucket_Action_SetField_Field FlowRule_ActionBucket_Action_SetField_Field_Field_MAX = static_cast<FlowRule_ActionBucket_Action_SetField_Field>(5);
constexpr int FlowRule_ActionBucket_Action_SetField_Field_Field_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FlowRule_ActionBucket_Action_SetField_Field_descriptor();
template <typename T>
const std::string& FlowRule_ActionBucket_Action_SetField_Field_Name(T value) {
  static_assert(std::is_same<T, FlowRule_ActionBucket_Action_SetField_Field>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Field_Name().");
  return FlowRule_ActionBucket_Action_SetField_Field_Name(static_cast<FlowRule_ActionBucket_Action_SetField_Field>(value));
}
template <>
inline const std::string& FlowRule_ActionBucket_Action_SetField_Field_Name(FlowRule_ActionBucket_Action_SetField_Field value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FlowRule_ActionBucket_Action_SetField_Field_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool FlowRule_ActionBucket_Action_SetField_Field_Parse(absl::string_view name, FlowRule_ActionBucket_Action_SetField_Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlowRule_ActionBucket_Action_SetField_Field>(
      FlowRule_ActionBucket_Action_SetField_Field_descriptor(), name, value);
}
enum FlowRule_ActionBucket_Action_PushHeader_Field : int {
  FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_UNSPECIFIED = 0,
  FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_MPLS = 1,
  FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_VLAN = 2,
  FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_PBB = 3,
};

bool FlowRule_ActionBucket_Action_PushHeader_Field_IsValid(int value);
constexpr FlowRule_ActionBucket_Action_PushHeader_Field FlowRule_ActionBucket_Action_PushHeader_Field_Field_MIN = static_cast<FlowRule_ActionBucket_Action_PushHeader_Field>(0);
constexpr FlowRule_ActionBucket_Action_PushHeader_Field FlowRule_ActionBucket_Action_PushHeader_Field_Field_MAX = static_cast<FlowRule_ActionBucket_Action_PushHeader_Field>(3);
constexpr int FlowRule_ActionBucket_Action_PushHeader_Field_Field_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FlowRule_ActionBucket_Action_PushHeader_Field_descriptor();
template <typename T>
const std::string& FlowRule_ActionBucket_Action_PushHeader_Field_Name(T value) {
  static_assert(std::is_same<T, FlowRule_ActionBucket_Action_PushHeader_Field>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Field_Name().");
  return FlowRule_ActionBucket_Action_PushHeader_Field_Name(static_cast<FlowRule_ActionBucket_Action_PushHeader_Field>(value));
}
template <>
inline const std::string& FlowRule_ActionBucket_Action_PushHeader_Field_Name(FlowRule_ActionBucket_Action_PushHeader_Field value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FlowRule_ActionBucket_Action_PushHeader_Field_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FlowRule_ActionBucket_Action_PushHeader_Field_Parse(absl::string_view name, FlowRule_ActionBucket_Action_PushHeader_Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlowRule_ActionBucket_Action_PushHeader_Field>(
      FlowRule_ActionBucket_Action_PushHeader_Field_descriptor(), name, value);
}
enum FlowRule_ActionBucket_Action_PopHeader_Field : int {
  FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_UNSPECIFIED = 0,
  FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_MPLS = 1,
  FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_VLAN = 2,
  FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_PBB = 3,
};

bool FlowRule_ActionBucket_Action_PopHeader_Field_IsValid(int value);
constexpr FlowRule_ActionBucket_Action_PopHeader_Field FlowRule_ActionBucket_Action_PopHeader_Field_Field_MIN = static_cast<FlowRule_ActionBucket_Action_PopHeader_Field>(0);
constexpr FlowRule_ActionBucket_Action_PopHeader_Field FlowRule_ActionBucket_Action_PopHeader_Field_Field_MAX = static_cast<FlowRule_ActionBucket_Action_PopHeader_Field>(3);
constexpr int FlowRule_ActionBucket_Action_PopHeader_Field_Field_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FlowRule_ActionBucket_Action_PopHeader_Field_descriptor();
template <typename T>
const std::string& FlowRule_ActionBucket_Action_PopHeader_Field_Name(T value) {
  static_assert(std::is_same<T, FlowRule_ActionBucket_Action_PopHeader_Field>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Field_Name().");
  return FlowRule_ActionBucket_Action_PopHeader_Field_Name(static_cast<FlowRule_ActionBucket_Action_PopHeader_Field>(value));
}
template <>
inline const std::string& FlowRule_ActionBucket_Action_PopHeader_Field_Name(FlowRule_ActionBucket_Action_PopHeader_Field value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FlowRule_ActionBucket_Action_PopHeader_Field_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FlowRule_ActionBucket_Action_PopHeader_Field_Parse(absl::string_view name, FlowRule_ActionBucket_Action_PopHeader_Field* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlowRule_ActionBucket_Action_PopHeader_Field>(
      FlowRule_ActionBucket_Action_PopHeader_Field_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class FlowUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowUpdate) */ {
 public:
  inline FlowUpdate() : FlowUpdate(nullptr) {}
  ~FlowUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowUpdate(const FlowUpdate& from);
  FlowUpdate(FlowUpdate&& from) noexcept
    : FlowUpdate() {
    *this = ::std::move(from);
  }

  inline FlowUpdate& operator=(const FlowUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowUpdate& operator=(FlowUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowUpdate* internal_default_instance() {
    return reinterpret_cast<const FlowUpdate*>(
               &_FlowUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FlowUpdate& a, FlowUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowUpdate& from) {
    FlowUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowUpdate";
  }
  protected:
  explicit FlowUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Operation = FlowUpdate_Operation;
  static constexpr Operation UNKNOWN = FlowUpdate_Operation_UNKNOWN;
  static constexpr Operation ADD = FlowUpdate_Operation_ADD;
  static constexpr Operation DELETE = FlowUpdate_Operation_DELETE;
  static inline bool Operation_IsValid(int value) {
    return FlowUpdate_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN = FlowUpdate_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX = FlowUpdate_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE = FlowUpdate_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operation_descriptor() {
    return FlowUpdate_Operation_descriptor();
  }
  template <typename T>
  static inline const std::string& Operation_Name(T value) {
    return FlowUpdate_Operation_Name(value);
  }
  static inline bool Operation_Parse(absl::string_view name, Operation* value) {
    return FlowUpdate_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFlowRuleIdFieldNumber = 1,
    kRuleFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kOperationFieldNumber = 2,
  };
  // optional string flow_rule_id = 1 [json_name = "flowRuleId"];
  bool has_flow_rule_id() const;
  void clear_flow_rule_id() ;
  const std::string& flow_rule_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_flow_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_flow_rule_id();
  PROTOBUF_NODISCARD std::string* release_flow_rule_id();
  void set_allocated_flow_rule_id(std::string* ptr);

  private:
  const std::string& _internal_flow_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_rule_id(
      const std::string& value);
  std::string* _internal_mutable_flow_rule_id();

  public:
  // optional .aalyria.spacetime.api.common.FlowRule rule = 3 [json_name = "rule"];
  bool has_rule() const;
  void clear_rule() ;
  const ::aalyria::spacetime::api::common::FlowRule& rule() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowRule* release_rule();
  ::aalyria::spacetime::api::common::FlowRule* mutable_rule();
  void set_allocated_rule(::aalyria::spacetime::api::common::FlowRule* rule);
  private:
  const ::aalyria::spacetime::api::common::FlowRule& _internal_rule() const;
  ::aalyria::spacetime::api::common::FlowRule* _internal_mutable_rule();
  public:
  void unsafe_arena_set_allocated_rule(
      ::aalyria::spacetime::api::common::FlowRule* rule);
  ::aalyria::spacetime::api::common::FlowRule* unsafe_arena_release_rule();
  // optional int64 sequence_number = 4 [json_name = "sequenceNumber"];
  bool has_sequence_number() const;
  void clear_sequence_number() ;
  ::int64_t sequence_number() const;
  void set_sequence_number(::int64_t value);

  private:
  ::int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(::int64_t value);

  public:
  // optional .aalyria.spacetime.api.common.FlowUpdate.Operation operation = 2 [json_name = "operation"];
  bool has_operation() const;
  void clear_operation() ;
  ::aalyria::spacetime::api::common::FlowUpdate_Operation operation() const;
  void set_operation(::aalyria::spacetime::api::common::FlowUpdate_Operation value);

  private:
  ::aalyria::spacetime::api::common::FlowUpdate_Operation _internal_operation() const;
  void _internal_set_operation(::aalyria::spacetime::api::common::FlowUpdate_Operation value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_rule_id_;
    ::aalyria::spacetime::api::common::FlowRule* rule_;
    ::int64_t sequence_number_;
    int operation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket_Action_SetField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField) */ {
 public:
  inline FlowRule_ActionBucket_Action_SetField() : FlowRule_ActionBucket_Action_SetField(nullptr) {}
  ~FlowRule_ActionBucket_Action_SetField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket_Action_SetField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket_Action_SetField(const FlowRule_ActionBucket_Action_SetField& from);
  FlowRule_ActionBucket_Action_SetField(FlowRule_ActionBucket_Action_SetField&& from) noexcept
    : FlowRule_ActionBucket_Action_SetField() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket_Action_SetField& operator=(const FlowRule_ActionBucket_Action_SetField& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket_Action_SetField& operator=(FlowRule_ActionBucket_Action_SetField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket_Action_SetField& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule_ActionBucket_Action_SetField* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket_Action_SetField*>(
               &_FlowRule_ActionBucket_Action_SetField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FlowRule_ActionBucket_Action_SetField& a, FlowRule_ActionBucket_Action_SetField& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket_Action_SetField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket_Action_SetField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket_Action_SetField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket_Action_SetField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket_Action_SetField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket_Action_SetField& from) {
    FlowRule_ActionBucket_Action_SetField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket_Action_SetField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField";
  }
  protected:
  explicit FlowRule_ActionBucket_Action_SetField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Field = FlowRule_ActionBucket_Action_SetField_Field;
  static constexpr Field FIELD_UNSPECIFIED = FlowRule_ActionBucket_Action_SetField_Field_FIELD_UNSPECIFIED;
  static constexpr Field FIELD_ETH_DST = FlowRule_ActionBucket_Action_SetField_Field_FIELD_ETH_DST;
  static constexpr Field FIELD_MPLS_LABEL = FlowRule_ActionBucket_Action_SetField_Field_FIELD_MPLS_LABEL;
  static constexpr Field FIELD_VLAN_ID = FlowRule_ActionBucket_Action_SetField_Field_FIELD_VLAN_ID;
  static constexpr Field FIELD_PBB_ITAG = FlowRule_ActionBucket_Action_SetField_Field_FIELD_PBB_ITAG;
  static inline bool Field_IsValid(int value) {
    return FlowRule_ActionBucket_Action_SetField_Field_IsValid(value);
  }
  static constexpr Field Field_MIN = FlowRule_ActionBucket_Action_SetField_Field_Field_MIN;
  static constexpr Field Field_MAX = FlowRule_ActionBucket_Action_SetField_Field_Field_MAX;
  static constexpr int Field_ARRAYSIZE = FlowRule_ActionBucket_Action_SetField_Field_Field_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Field_descriptor() {
    return FlowRule_ActionBucket_Action_SetField_Field_descriptor();
  }
  template <typename T>
  static inline const std::string& Field_Name(T value) {
    return FlowRule_ActionBucket_Action_SetField_Field_Name(value);
  }
  static inline bool Field_Parse(absl::string_view name, Field* value) {
    return FlowRule_ActionBucket_Action_SetField_Field_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueAsciiFieldNumber = 3,
    kFieldFieldNumber = 1,
  };
  // optional string value_ascii = 3 [json_name = "valueAscii"];
  bool has_value_ascii() const;
  void clear_value_ascii() ;
  const std::string& value_ascii() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value_ascii(Arg_&& arg, Args_... args);
  std::string* mutable_value_ascii();
  PROTOBUF_NODISCARD std::string* release_value_ascii();
  void set_allocated_value_ascii(std::string* ptr);

  private:
  const std::string& _internal_value_ascii() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_ascii(
      const std::string& value);
  std::string* _internal_mutable_value_ascii();

  public:
  // optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.Field field = 1 [json_name = "field"];
  bool has_field() const;
  void clear_field() ;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field field() const;
  void set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field value);

  private:
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field _internal_field() const;
  void _internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_ascii_;
    int field_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket_Action_Forward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward) */ {
 public:
  inline FlowRule_ActionBucket_Action_Forward() : FlowRule_ActionBucket_Action_Forward(nullptr) {}
  ~FlowRule_ActionBucket_Action_Forward() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket_Action_Forward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket_Action_Forward(const FlowRule_ActionBucket_Action_Forward& from);
  FlowRule_ActionBucket_Action_Forward(FlowRule_ActionBucket_Action_Forward&& from) noexcept
    : FlowRule_ActionBucket_Action_Forward() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket_Action_Forward& operator=(const FlowRule_ActionBucket_Action_Forward& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket_Action_Forward& operator=(FlowRule_ActionBucket_Action_Forward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket_Action_Forward& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule_ActionBucket_Action_Forward* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket_Action_Forward*>(
               &_FlowRule_ActionBucket_Action_Forward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlowRule_ActionBucket_Action_Forward& a, FlowRule_ActionBucket_Action_Forward& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket_Action_Forward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket_Action_Forward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket_Action_Forward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket_Action_Forward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket_Action_Forward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket_Action_Forward& from) {
    FlowRule_ActionBucket_Action_Forward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket_Action_Forward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward";
  }
  protected:
  explicit FlowRule_ActionBucket_Action_Forward(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutInterfaceIdFieldNumber = 1,
    kNextHopIpFieldNumber = 2,
  };
  // optional string out_interface_id = 1 [json_name = "outInterfaceId"];
  bool has_out_interface_id() const;
  void clear_out_interface_id() ;
  const std::string& out_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_out_interface_id();
  PROTOBUF_NODISCARD std::string* release_out_interface_id();
  void set_allocated_out_interface_id(std::string* ptr);

  private:
  const std::string& _internal_out_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_interface_id(
      const std::string& value);
  std::string* _internal_mutable_out_interface_id();

  public:
  // optional string next_hop_ip = 2 [json_name = "nextHopIp"];
  bool has_next_hop_ip() const;
  void clear_next_hop_ip() ;
  const std::string& next_hop_ip() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_hop_ip(Arg_&& arg, Args_... args);
  std::string* mutable_next_hop_ip();
  PROTOBUF_NODISCARD std::string* release_next_hop_ip();
  void set_allocated_next_hop_ip(std::string* ptr);

  private:
  const std::string& _internal_next_hop_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_hop_ip(
      const std::string& value);
  std::string* _internal_mutable_next_hop_ip();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_hop_ip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket_Action_PushHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader) */ {
 public:
  inline FlowRule_ActionBucket_Action_PushHeader() : FlowRule_ActionBucket_Action_PushHeader(nullptr) {}
  ~FlowRule_ActionBucket_Action_PushHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket_Action_PushHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket_Action_PushHeader(const FlowRule_ActionBucket_Action_PushHeader& from);
  FlowRule_ActionBucket_Action_PushHeader(FlowRule_ActionBucket_Action_PushHeader&& from) noexcept
    : FlowRule_ActionBucket_Action_PushHeader() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket_Action_PushHeader& operator=(const FlowRule_ActionBucket_Action_PushHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket_Action_PushHeader& operator=(FlowRule_ActionBucket_Action_PushHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket_Action_PushHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule_ActionBucket_Action_PushHeader* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket_Action_PushHeader*>(
               &_FlowRule_ActionBucket_Action_PushHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FlowRule_ActionBucket_Action_PushHeader& a, FlowRule_ActionBucket_Action_PushHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket_Action_PushHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket_Action_PushHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket_Action_PushHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket_Action_PushHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket_Action_PushHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket_Action_PushHeader& from) {
    FlowRule_ActionBucket_Action_PushHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket_Action_PushHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader";
  }
  protected:
  explicit FlowRule_ActionBucket_Action_PushHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Field = FlowRule_ActionBucket_Action_PushHeader_Field;
  static constexpr Field FIELD_UNSPECIFIED = FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_UNSPECIFIED;
  static constexpr Field FIELD_MPLS = FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_MPLS;
  static constexpr Field FIELD_VLAN = FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_VLAN;
  static constexpr Field FIELD_PBB = FlowRule_ActionBucket_Action_PushHeader_Field_FIELD_PBB;
  static inline bool Field_IsValid(int value) {
    return FlowRule_ActionBucket_Action_PushHeader_Field_IsValid(value);
  }
  static constexpr Field Field_MIN = FlowRule_ActionBucket_Action_PushHeader_Field_Field_MIN;
  static constexpr Field Field_MAX = FlowRule_ActionBucket_Action_PushHeader_Field_Field_MAX;
  static constexpr int Field_ARRAYSIZE = FlowRule_ActionBucket_Action_PushHeader_Field_Field_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Field_descriptor() {
    return FlowRule_ActionBucket_Action_PushHeader_Field_descriptor();
  }
  template <typename T>
  static inline const std::string& Field_Name(T value) {
    return FlowRule_ActionBucket_Action_PushHeader_Field_Name(value);
  }
  static inline bool Field_Parse(absl::string_view name, Field* value) {
    return FlowRule_ActionBucket_Action_PushHeader_Field_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEtherTypeFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.types.EtherType ether_type = 2 [json_name = "etherType"];
  bool has_ether_type() const;
  void clear_ether_type() ;
  const ::aalyria::spacetime::api::types::EtherType& ether_type() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::types::EtherType* release_ether_type();
  ::aalyria::spacetime::api::types::EtherType* mutable_ether_type();
  void set_allocated_ether_type(::aalyria::spacetime::api::types::EtherType* ether_type);
  private:
  const ::aalyria::spacetime::api::types::EtherType& _internal_ether_type() const;
  ::aalyria::spacetime::api::types::EtherType* _internal_mutable_ether_type();
  public:
  void unsafe_arena_set_allocated_ether_type(
      ::aalyria::spacetime::api::types::EtherType* ether_type);
  ::aalyria::spacetime::api::types::EtherType* unsafe_arena_release_ether_type();
  // optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.Field field = 1 [json_name = "field"];
  bool has_field() const;
  void clear_field() ;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field field() const;
  void set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field value);

  private:
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field _internal_field() const;
  void _internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::types::EtherType* ether_type_;
    int field_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket_Action_PopHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader) */ {
 public:
  inline FlowRule_ActionBucket_Action_PopHeader() : FlowRule_ActionBucket_Action_PopHeader(nullptr) {}
  ~FlowRule_ActionBucket_Action_PopHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket_Action_PopHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket_Action_PopHeader(const FlowRule_ActionBucket_Action_PopHeader& from);
  FlowRule_ActionBucket_Action_PopHeader(FlowRule_ActionBucket_Action_PopHeader&& from) noexcept
    : FlowRule_ActionBucket_Action_PopHeader() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket_Action_PopHeader& operator=(const FlowRule_ActionBucket_Action_PopHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket_Action_PopHeader& operator=(FlowRule_ActionBucket_Action_PopHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket_Action_PopHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule_ActionBucket_Action_PopHeader* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket_Action_PopHeader*>(
               &_FlowRule_ActionBucket_Action_PopHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlowRule_ActionBucket_Action_PopHeader& a, FlowRule_ActionBucket_Action_PopHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket_Action_PopHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket_Action_PopHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket_Action_PopHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket_Action_PopHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket_Action_PopHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket_Action_PopHeader& from) {
    FlowRule_ActionBucket_Action_PopHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket_Action_PopHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader";
  }
  protected:
  explicit FlowRule_ActionBucket_Action_PopHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Field = FlowRule_ActionBucket_Action_PopHeader_Field;
  static constexpr Field FIELD_UNSPECIFIED = FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_UNSPECIFIED;
  static constexpr Field FIELD_MPLS = FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_MPLS;
  static constexpr Field FIELD_VLAN = FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_VLAN;
  static constexpr Field FIELD_PBB = FlowRule_ActionBucket_Action_PopHeader_Field_FIELD_PBB;
  static inline bool Field_IsValid(int value) {
    return FlowRule_ActionBucket_Action_PopHeader_Field_IsValid(value);
  }
  static constexpr Field Field_MIN = FlowRule_ActionBucket_Action_PopHeader_Field_Field_MIN;
  static constexpr Field Field_MAX = FlowRule_ActionBucket_Action_PopHeader_Field_Field_MAX;
  static constexpr int Field_ARRAYSIZE = FlowRule_ActionBucket_Action_PopHeader_Field_Field_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Field_descriptor() {
    return FlowRule_ActionBucket_Action_PopHeader_Field_descriptor();
  }
  template <typename T>
  static inline const std::string& Field_Name(T value) {
    return FlowRule_ActionBucket_Action_PopHeader_Field_Name(value);
  }
  static inline bool Field_Parse(absl::string_view name, Field* value) {
    return FlowRule_ActionBucket_Action_PopHeader_Field_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEtherTypeFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.types.EtherType ether_type = 2 [json_name = "etherType"];
  bool has_ether_type() const;
  void clear_ether_type() ;
  const ::aalyria::spacetime::api::types::EtherType& ether_type() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::types::EtherType* release_ether_type();
  ::aalyria::spacetime::api::types::EtherType* mutable_ether_type();
  void set_allocated_ether_type(::aalyria::spacetime::api::types::EtherType* ether_type);
  private:
  const ::aalyria::spacetime::api::types::EtherType& _internal_ether_type() const;
  ::aalyria::spacetime::api::types::EtherType* _internal_mutable_ether_type();
  public:
  void unsafe_arena_set_allocated_ether_type(
      ::aalyria::spacetime::api::types::EtherType* ether_type);
  ::aalyria::spacetime::api::types::EtherType* unsafe_arena_release_ether_type();
  // optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.Field field = 1 [json_name = "field"];
  bool has_field() const;
  void clear_field() ;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field field() const;
  void set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field value);

  private:
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field _internal_field() const;
  void _internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::types::EtherType* ether_type_;
    int field_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket_Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action) */ {
 public:
  inline FlowRule_ActionBucket_Action() : FlowRule_ActionBucket_Action(nullptr) {}
  ~FlowRule_ActionBucket_Action() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket_Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket_Action(const FlowRule_ActionBucket_Action& from);
  FlowRule_ActionBucket_Action(FlowRule_ActionBucket_Action&& from) noexcept
    : FlowRule_ActionBucket_Action() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket_Action& operator=(const FlowRule_ActionBucket_Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket_Action& operator=(FlowRule_ActionBucket_Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket_Action& default_instance() {
    return *internal_default_instance();
  }
  enum ActionTypeCase {
    kSetField = 1,
    kForward = 2,
    kPushHeader = 3,
    kPopHeader = 4,
    ACTION_TYPE_NOT_SET = 0,
  };

  static inline const FlowRule_ActionBucket_Action* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket_Action*>(
               &_FlowRule_ActionBucket_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FlowRule_ActionBucket_Action& a, FlowRule_ActionBucket_Action& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket_Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket_Action* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket_Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket_Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket_Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket_Action& from) {
    FlowRule_ActionBucket_Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket_Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket.Action";
  }
  protected:
  explicit FlowRule_ActionBucket_Action(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlowRule_ActionBucket_Action_SetField SetField;
  typedef FlowRule_ActionBucket_Action_Forward Forward;
  typedef FlowRule_ActionBucket_Action_PushHeader PushHeader;
  typedef FlowRule_ActionBucket_Action_PopHeader PopHeader;

  // accessors -------------------------------------------------------

  enum : int {
    kSetFieldFieldNumber = 1,
    kForwardFieldNumber = 2,
    kPushHeaderFieldNumber = 3,
    kPopHeaderFieldNumber = 4,
  };
  // .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField set_field = 1 [json_name = "setField"];
  bool has_set_field() const;
  private:
  bool _internal_has_set_field() const;

  public:
  void clear_set_field() ;
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField& set_field() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* release_set_field();
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* mutable_set_field();
  void set_allocated_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* set_field);
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField& _internal_set_field() const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* _internal_mutable_set_field();
  public:
  void unsafe_arena_set_allocated_set_field(
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* set_field);
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* unsafe_arena_release_set_field();
  // .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward forward = 2 [json_name = "forward"];
  bool has_forward() const;
  private:
  bool _internal_has_forward() const;

  public:
  void clear_forward() ;
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward& forward() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* release_forward();
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* mutable_forward();
  void set_allocated_forward(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* forward);
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward& _internal_forward() const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* _internal_mutable_forward();
  public:
  void unsafe_arena_set_allocated_forward(
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* forward);
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* unsafe_arena_release_forward();
  // .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader push_header = 3 [json_name = "pushHeader"];
  bool has_push_header() const;
  private:
  bool _internal_has_push_header() const;

  public:
  void clear_push_header() ;
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader& push_header() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* release_push_header();
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* mutable_push_header();
  void set_allocated_push_header(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* push_header);
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader& _internal_push_header() const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* _internal_mutable_push_header();
  public:
  void unsafe_arena_set_allocated_push_header(
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* push_header);
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* unsafe_arena_release_push_header();
  // .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader pop_header = 4 [json_name = "popHeader"];
  bool has_pop_header() const;
  private:
  bool _internal_has_pop_header() const;

  public:
  void clear_pop_header() ;
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader& pop_header() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* release_pop_header();
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* mutable_pop_header();
  void set_allocated_pop_header(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* pop_header);
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader& _internal_pop_header() const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* _internal_mutable_pop_header();
  public:
  void unsafe_arena_set_allocated_pop_header(
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* pop_header);
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* unsafe_arena_release_pop_header();
  void clear_action_type();
  ActionTypeCase action_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action)
 private:
  class _Internal;
  void set_has_set_field();
  void set_has_forward();
  void set_has_push_header();
  void set_has_pop_header();

  inline bool has_action_type() const;
  inline void clear_has_action_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionTypeUnion {
      constexpr ActionTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* set_field_;
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* forward_;
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* push_header_;
      ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* pop_header_;
    } action_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule_ActionBucket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule.ActionBucket) */ {
 public:
  inline FlowRule_ActionBucket() : FlowRule_ActionBucket(nullptr) {}
  ~FlowRule_ActionBucket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule_ActionBucket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule_ActionBucket(const FlowRule_ActionBucket& from);
  FlowRule_ActionBucket(FlowRule_ActionBucket&& from) noexcept
    : FlowRule_ActionBucket() {
    *this = ::std::move(from);
  }

  inline FlowRule_ActionBucket& operator=(const FlowRule_ActionBucket& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule_ActionBucket& operator=(FlowRule_ActionBucket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule_ActionBucket& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule_ActionBucket* internal_default_instance() {
    return reinterpret_cast<const FlowRule_ActionBucket*>(
               &_FlowRule_ActionBucket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowRule_ActionBucket& a, FlowRule_ActionBucket& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule_ActionBucket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule_ActionBucket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule_ActionBucket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule_ActionBucket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule_ActionBucket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule_ActionBucket& from) {
    FlowRule_ActionBucket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule_ActionBucket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule.ActionBucket";
  }
  protected:
  explicit FlowRule_ActionBucket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlowRule_ActionBucket_Action Action;

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action action = 1 [json_name = "action"];
  int action_size() const;
  private:
  int _internal_action_size() const;

  public:
  void clear_action() ;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* mutable_action(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action >*
      mutable_action();
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action& _internal_action(int index) const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* _internal_add_action();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action>& _internal_action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action>* _internal_mutable_action();
  public:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action& action(int index) const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* add_action();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action >&
      action() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule.ActionBucket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action > action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowRule) */ {
 public:
  inline FlowRule() : FlowRule(nullptr) {}
  ~FlowRule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRule(const FlowRule& from);
  FlowRule(FlowRule&& from) noexcept
    : FlowRule() {
    *this = ::std::move(from);
  }

  inline FlowRule& operator=(const FlowRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRule& operator=(FlowRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRule* internal_default_instance() {
    return reinterpret_cast<const FlowRule*>(
               &_FlowRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FlowRule& a, FlowRule& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRule& from) {
    FlowRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowRule";
  }
  protected:
  explicit FlowRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlowRule_ActionBucket ActionBucket;

  // accessors -------------------------------------------------------

  enum : int {
    kActionBucketFieldNumber = 4,
    kClassifierFieldNumber = 5,
  };
  // repeated .aalyria.spacetime.api.common.FlowRule.ActionBucket action_bucket = 4 [json_name = "actionBucket"];
  int action_bucket_size() const;
  private:
  int _internal_action_bucket_size() const;

  public:
  void clear_action_bucket() ;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket* mutable_action_bucket(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket >*
      mutable_action_bucket();
  private:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket& _internal_action_bucket(int index) const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket* _internal_add_action_bucket();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket>& _internal_action_bucket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket>* _internal_mutable_action_bucket();
  public:
  const ::aalyria::spacetime::api::common::FlowRule_ActionBucket& action_bucket(int index) const;
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket* add_action_bucket();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket >&
      action_bucket() const;
  // optional .aalyria.spacetime.api.common.PacketClassifier classifier = 5 [json_name = "classifier"];
  bool has_classifier() const;
  void clear_classifier() ;
  const ::aalyria::spacetime::api::common::PacketClassifier& classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier* release_classifier();
  ::aalyria::spacetime::api::common::PacketClassifier* mutable_classifier();
  void set_allocated_classifier(::aalyria::spacetime::api::common::PacketClassifier* classifier);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier& _internal_classifier() const;
  ::aalyria::spacetime::api::common::PacketClassifier* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::aalyria::spacetime::api::common::PacketClassifier* classifier);
  ::aalyria::spacetime::api::common::PacketClassifier* unsafe_arena_release_classifier();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket > action_bucket_;
    ::aalyria::spacetime::api::common::PacketClassifier* classifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};// -------------------------------------------------------------------

class FlowState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowState) */ {
 public:
  inline FlowState() : FlowState(nullptr) {}
  ~FlowState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowState(const FlowState& from);
  FlowState(FlowState&& from) noexcept
    : FlowState() {
    *this = ::std::move(from);
  }

  inline FlowState& operator=(const FlowState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowState& operator=(FlowState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowState* internal_default_instance() {
    return reinterpret_cast<const FlowState*>(
               &_FlowState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FlowState& a, FlowState& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowState& from) {
    FlowState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowState";
  }
  protected:
  explicit FlowState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowRuleIdsFieldNumber = 3,
    kTimestampFieldNumber = 2,
  };
  // repeated string flow_rule_ids = 3 [json_name = "flowRuleIds"];
  int flow_rule_ids_size() const;
  private:
  int _internal_flow_rule_ids_size() const;

  public:
  void clear_flow_rule_ids() ;
  const std::string& flow_rule_ids(int index) const;
  std::string* mutable_flow_rule_ids(int index);
  void set_flow_rule_ids(int index, const std::string& value);
  void set_flow_rule_ids(int index, std::string&& value);
  void set_flow_rule_ids(int index, const char* value);
  void set_flow_rule_ids(int index, const char* value, std::size_t size);
  void set_flow_rule_ids(int index, absl::string_view value);
  std::string* add_flow_rule_ids();
  void add_flow_rule_ids(const std::string& value);
  void add_flow_rule_ids(std::string&& value);
  void add_flow_rule_ids(const char* value);
  void add_flow_rule_ids(const char* value, std::size_t size);
  void add_flow_rule_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& flow_rule_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_flow_rule_ids();

  private:
  const std::string& _internal_flow_rule_ids(int index) const;
  std::string* _internal_add_flow_rule_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_flow_rule_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_flow_rule_ids();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 2 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> flow_rule_ids_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fflow_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FlowUpdate

// optional string flow_rule_id = 1 [json_name = "flowRuleId"];
inline bool FlowUpdate::has_flow_rule_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FlowUpdate::clear_flow_rule_id() {
  _impl_.flow_rule_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlowUpdate::flow_rule_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowUpdate.flow_rule_id)
  return _internal_flow_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowUpdate::set_flow_rule_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.flow_rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowUpdate.flow_rule_id)
}
inline std::string* FlowUpdate::mutable_flow_rule_id() {
  std::string* _s = _internal_mutable_flow_rule_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowUpdate.flow_rule_id)
  return _s;
}
inline const std::string& FlowUpdate::_internal_flow_rule_id() const {
  return _impl_.flow_rule_id_.Get();
}
inline void FlowUpdate::_internal_set_flow_rule_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.flow_rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowUpdate::_internal_mutable_flow_rule_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.flow_rule_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FlowUpdate::release_flow_rule_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowUpdate.flow_rule_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.flow_rule_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.flow_rule_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FlowUpdate::set_allocated_flow_rule_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.flow_rule_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.flow_rule_id_.IsDefault()) {
          _impl_.flow_rule_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowUpdate.flow_rule_id)
}

// optional .aalyria.spacetime.api.common.FlowUpdate.Operation operation = 2 [json_name = "operation"];
inline bool FlowUpdate::has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FlowUpdate::clear_operation() {
  _impl_.operation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::aalyria::spacetime::api::common::FlowUpdate_Operation FlowUpdate::operation() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowUpdate.operation)
  return _internal_operation();
}
inline void FlowUpdate::set_operation(::aalyria::spacetime::api::common::FlowUpdate_Operation value) {
   _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowUpdate.operation)
}
inline ::aalyria::spacetime::api::common::FlowUpdate_Operation FlowUpdate::_internal_operation() const {
  return static_cast<::aalyria::spacetime::api::common::FlowUpdate_Operation>(_impl_.operation_);
}
inline void FlowUpdate::_internal_set_operation(::aalyria::spacetime::api::common::FlowUpdate_Operation value) {
  assert(::aalyria::spacetime::api::common::FlowUpdate_Operation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.operation_ = value;
}

// optional .aalyria.spacetime.api.common.FlowRule rule = 3 [json_name = "rule"];
inline bool FlowUpdate::has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline void FlowUpdate::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::FlowRule& FlowUpdate::_internal_rule() const {
  const ::aalyria::spacetime::api::common::FlowRule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowRule&>(
      ::aalyria::spacetime::api::common::_FlowRule_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowRule& FlowUpdate::rule() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowUpdate.rule)
  return _internal_rule();
}
inline void FlowUpdate::unsafe_arena_set_allocated_rule(
    ::aalyria::spacetime::api::common::FlowRule* rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = rule;
  if (rule) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowUpdate.rule)
}
inline ::aalyria::spacetime::api::common::FlowRule* FlowUpdate::release_rule() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::FlowRule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowRule* FlowUpdate::unsafe_arena_release_rule() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowUpdate.rule)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::FlowRule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowRule* FlowUpdate::_internal_mutable_rule() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowRule>(GetArenaForAllocation());
    _impl_.rule_ = p;
  }
  return _impl_.rule_;
}
inline ::aalyria::spacetime::api::common::FlowRule* FlowUpdate::mutable_rule() {
  ::aalyria::spacetime::api::common::FlowRule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowUpdate.rule)
  return _msg;
}
inline void FlowUpdate::set_allocated_rule(::aalyria::spacetime::api::common::FlowRule* rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rule_;
  }
  if (rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rule);
    if (message_arena != submessage_arena) {
      rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rule_ = rule;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowUpdate.rule)
}

// optional int64 sequence_number = 4 [json_name = "sequenceNumber"];
inline bool FlowUpdate::has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FlowUpdate::clear_sequence_number() {
  _impl_.sequence_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t FlowUpdate::sequence_number() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowUpdate.sequence_number)
  return _internal_sequence_number();
}
inline void FlowUpdate::set_sequence_number(::int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowUpdate.sequence_number)
}
inline ::int64_t FlowUpdate::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline void FlowUpdate::_internal_set_sequence_number(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_number_ = value;
}

// -------------------------------------------------------------------

// FlowRule_ActionBucket_Action_SetField

// optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.Field field = 1 [json_name = "field"];
inline bool FlowRule_ActionBucket_Action_SetField::has_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_SetField::clear_field() {
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field FlowRule_ActionBucket_Action_SetField::field() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.field)
  return _internal_field();
}
inline void FlowRule_ActionBucket_Action_SetField::set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field value) {
   _internal_set_field(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.field)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field FlowRule_ActionBucket_Action_SetField::_internal_field() const {
  return static_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field>(_impl_.field_);
}
inline void FlowRule_ActionBucket_Action_SetField::_internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field value) {
  assert(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.field_ = value;
}

// optional string value_ascii = 3 [json_name = "valueAscii"];
inline bool FlowRule_ActionBucket_Action_SetField::has_value_ascii() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_SetField::clear_value_ascii() {
  _impl_.value_ascii_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlowRule_ActionBucket_Action_SetField::value_ascii() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.value_ascii)
  return _internal_value_ascii();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowRule_ActionBucket_Action_SetField::set_value_ascii(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ascii_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.value_ascii)
}
inline std::string* FlowRule_ActionBucket_Action_SetField::mutable_value_ascii() {
  std::string* _s = _internal_mutable_value_ascii();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.value_ascii)
  return _s;
}
inline const std::string& FlowRule_ActionBucket_Action_SetField::_internal_value_ascii() const {
  return _impl_.value_ascii_.Get();
}
inline void FlowRule_ActionBucket_Action_SetField::_internal_set_value_ascii(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.value_ascii_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_SetField::_internal_mutable_value_ascii() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_ascii_.Mutable( GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_SetField::release_value_ascii() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.value_ascii)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_ascii_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_ascii_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FlowRule_ActionBucket_Action_SetField::set_allocated_value_ascii(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ascii_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_ascii_.IsDefault()) {
          _impl_.value_ascii_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField.value_ascii)
}

// -------------------------------------------------------------------

// FlowRule_ActionBucket_Action_Forward

// optional string out_interface_id = 1 [json_name = "outInterfaceId"];
inline bool FlowRule_ActionBucket_Action_Forward::has_out_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_Forward::clear_out_interface_id() {
  _impl_.out_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlowRule_ActionBucket_Action_Forward::out_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.out_interface_id)
  return _internal_out_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowRule_ActionBucket_Action_Forward::set_out_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.out_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.out_interface_id)
}
inline std::string* FlowRule_ActionBucket_Action_Forward::mutable_out_interface_id() {
  std::string* _s = _internal_mutable_out_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.out_interface_id)
  return _s;
}
inline const std::string& FlowRule_ActionBucket_Action_Forward::_internal_out_interface_id() const {
  return _impl_.out_interface_id_.Get();
}
inline void FlowRule_ActionBucket_Action_Forward::_internal_set_out_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.out_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_Forward::_internal_mutable_out_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.out_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_Forward::release_out_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.out_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.out_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.out_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FlowRule_ActionBucket_Action_Forward::set_allocated_out_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.out_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_interface_id_.IsDefault()) {
          _impl_.out_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.out_interface_id)
}

// optional string next_hop_ip = 2 [json_name = "nextHopIp"];
inline bool FlowRule_ActionBucket_Action_Forward::has_next_hop_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_Forward::clear_next_hop_ip() {
  _impl_.next_hop_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlowRule_ActionBucket_Action_Forward::next_hop_ip() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.next_hop_ip)
  return _internal_next_hop_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FlowRule_ActionBucket_Action_Forward::set_next_hop_ip(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.next_hop_ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.next_hop_ip)
}
inline std::string* FlowRule_ActionBucket_Action_Forward::mutable_next_hop_ip() {
  std::string* _s = _internal_mutable_next_hop_ip();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.next_hop_ip)
  return _s;
}
inline const std::string& FlowRule_ActionBucket_Action_Forward::_internal_next_hop_ip() const {
  return _impl_.next_hop_ip_.Get();
}
inline void FlowRule_ActionBucket_Action_Forward::_internal_set_next_hop_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.next_hop_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_Forward::_internal_mutable_next_hop_ip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.next_hop_ip_.Mutable( GetArenaForAllocation());
}
inline std::string* FlowRule_ActionBucket_Action_Forward::release_next_hop_ip() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.next_hop_ip)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.next_hop_ip_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.next_hop_ip_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FlowRule_ActionBucket_Action_Forward::set_allocated_next_hop_ip(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.next_hop_ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_hop_ip_.IsDefault()) {
          _impl_.next_hop_ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward.next_hop_ip)
}

// -------------------------------------------------------------------

// FlowRule_ActionBucket_Action_PushHeader

// optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.Field field = 1 [json_name = "field"];
inline bool FlowRule_ActionBucket_Action_PushHeader::has_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_PushHeader::clear_field() {
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field FlowRule_ActionBucket_Action_PushHeader::field() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.field)
  return _internal_field();
}
inline void FlowRule_ActionBucket_Action_PushHeader::set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field value) {
   _internal_set_field(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.field)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field FlowRule_ActionBucket_Action_PushHeader::_internal_field() const {
  return static_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field>(_impl_.field_);
}
inline void FlowRule_ActionBucket_Action_PushHeader::_internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field value) {
  assert(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.field_ = value;
}

// optional .aalyria.spacetime.api.types.EtherType ether_type = 2 [json_name = "etherType"];
inline bool FlowRule_ActionBucket_Action_PushHeader::has_ether_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ether_type_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::types::EtherType& FlowRule_ActionBucket_Action_PushHeader::_internal_ether_type() const {
  const ::aalyria::spacetime::api::types::EtherType* p = _impl_.ether_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::types::EtherType&>(
      ::aalyria::spacetime::api::types::_EtherType_default_instance_);
}
inline const ::aalyria::spacetime::api::types::EtherType& FlowRule_ActionBucket_Action_PushHeader::ether_type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.ether_type)
  return _internal_ether_type();
}
inline void FlowRule_ActionBucket_Action_PushHeader::unsafe_arena_set_allocated_ether_type(
    ::aalyria::spacetime::api::types::EtherType* ether_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ether_type_);
  }
  _impl_.ether_type_ = ether_type;
  if (ether_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.ether_type)
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PushHeader::release_ether_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::types::EtherType* temp = _impl_.ether_type_;
  _impl_.ether_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PushHeader::unsafe_arena_release_ether_type() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.ether_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::types::EtherType* temp = _impl_.ether_type_;
  _impl_.ether_type_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PushHeader::_internal_mutable_ether_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ether_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::types::EtherType>(GetArenaForAllocation());
    _impl_.ether_type_ = p;
  }
  return _impl_.ether_type_;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PushHeader::mutable_ether_type() {
  ::aalyria::spacetime::api::types::EtherType* _msg = _internal_mutable_ether_type();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.ether_type)
  return _msg;
}
inline void FlowRule_ActionBucket_Action_PushHeader::set_allocated_ether_type(::aalyria::spacetime::api::types::EtherType* ether_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ether_type_);
  }
  if (ether_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ether_type));
    if (message_arena != submessage_arena) {
      ether_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ether_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ether_type_ = ether_type;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader.ether_type)
}

// -------------------------------------------------------------------

// FlowRule_ActionBucket_Action_PopHeader

// optional .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.Field field = 1 [json_name = "field"];
inline bool FlowRule_ActionBucket_Action_PopHeader::has_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowRule_ActionBucket_Action_PopHeader::clear_field() {
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field FlowRule_ActionBucket_Action_PopHeader::field() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.field)
  return _internal_field();
}
inline void FlowRule_ActionBucket_Action_PopHeader::set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field value) {
   _internal_set_field(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.field)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field FlowRule_ActionBucket_Action_PopHeader::_internal_field() const {
  return static_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field>(_impl_.field_);
}
inline void FlowRule_ActionBucket_Action_PopHeader::_internal_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field value) {
  assert(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.field_ = value;
}

// optional .aalyria.spacetime.api.types.EtherType ether_type = 2 [json_name = "etherType"];
inline bool FlowRule_ActionBucket_Action_PopHeader::has_ether_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ether_type_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::types::EtherType& FlowRule_ActionBucket_Action_PopHeader::_internal_ether_type() const {
  const ::aalyria::spacetime::api::types::EtherType* p = _impl_.ether_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::types::EtherType&>(
      ::aalyria::spacetime::api::types::_EtherType_default_instance_);
}
inline const ::aalyria::spacetime::api::types::EtherType& FlowRule_ActionBucket_Action_PopHeader::ether_type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.ether_type)
  return _internal_ether_type();
}
inline void FlowRule_ActionBucket_Action_PopHeader::unsafe_arena_set_allocated_ether_type(
    ::aalyria::spacetime::api::types::EtherType* ether_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ether_type_);
  }
  _impl_.ether_type_ = ether_type;
  if (ether_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.ether_type)
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PopHeader::release_ether_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::types::EtherType* temp = _impl_.ether_type_;
  _impl_.ether_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PopHeader::unsafe_arena_release_ether_type() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.ether_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::types::EtherType* temp = _impl_.ether_type_;
  _impl_.ether_type_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PopHeader::_internal_mutable_ether_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ether_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::types::EtherType>(GetArenaForAllocation());
    _impl_.ether_type_ = p;
  }
  return _impl_.ether_type_;
}
inline ::aalyria::spacetime::api::types::EtherType* FlowRule_ActionBucket_Action_PopHeader::mutable_ether_type() {
  ::aalyria::spacetime::api::types::EtherType* _msg = _internal_mutable_ether_type();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.ether_type)
  return _msg;
}
inline void FlowRule_ActionBucket_Action_PopHeader::set_allocated_ether_type(::aalyria::spacetime::api::types::EtherType* ether_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ether_type_);
  }
  if (ether_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ether_type));
    if (message_arena != submessage_arena) {
      ether_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ether_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ether_type_ = ether_type;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader.ether_type)
}

// -------------------------------------------------------------------

// FlowRule_ActionBucket_Action

// .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.SetField set_field = 1 [json_name = "setField"];
inline bool FlowRule_ActionBucket_Action::has_set_field() const {
  return action_type_case() == kSetField;
}
inline bool FlowRule_ActionBucket_Action::_internal_has_set_field() const {
  return action_type_case() == kSetField;
}
inline void FlowRule_ActionBucket_Action::set_has_set_field() {
  _impl_._oneof_case_[0] = kSetField;
}
inline void FlowRule_ActionBucket_Action::clear_set_field() {
  if (action_type_case() == kSetField) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_type_.set_field_;
    }
    clear_has_action_type();
  }
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* FlowRule_ActionBucket_Action::release_set_field() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.set_field)
  if (action_type_case() == kSetField) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* temp = _impl_.action_type_.set_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_type_.set_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField& FlowRule_ActionBucket_Action::_internal_set_field() const {
  return action_type_case() == kSetField
      ? *_impl_.action_type_.set_field_
      : reinterpret_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField&>(::aalyria::spacetime::api::common::_FlowRule_ActionBucket_Action_SetField_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField& FlowRule_ActionBucket_Action::set_field() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.set_field)
  return _internal_set_field();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* FlowRule_ActionBucket_Action::unsafe_arena_release_set_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.set_field)
  if (action_type_case() == kSetField) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* temp = _impl_.action_type_.set_field_;
    _impl_.action_type_.set_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRule_ActionBucket_Action::unsafe_arena_set_allocated_set_field(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* set_field) {
  clear_action_type();
  if (set_field) {
    set_has_set_field();
    _impl_.action_type_.set_field_ = set_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.set_field)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* FlowRule_ActionBucket_Action::_internal_mutable_set_field() {
  if (action_type_case() != kSetField) {
    clear_action_type();
    set_has_set_field();
    _impl_.action_type_.set_field_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField >(GetArenaForAllocation());
  }
  return _impl_.action_type_.set_field_;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* FlowRule_ActionBucket_Action::mutable_set_field() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField* _msg = _internal_mutable_set_field();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.set_field)
  return _msg;
}

// .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.Forward forward = 2 [json_name = "forward"];
inline bool FlowRule_ActionBucket_Action::has_forward() const {
  return action_type_case() == kForward;
}
inline bool FlowRule_ActionBucket_Action::_internal_has_forward() const {
  return action_type_case() == kForward;
}
inline void FlowRule_ActionBucket_Action::set_has_forward() {
  _impl_._oneof_case_[0] = kForward;
}
inline void FlowRule_ActionBucket_Action::clear_forward() {
  if (action_type_case() == kForward) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_type_.forward_;
    }
    clear_has_action_type();
  }
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* FlowRule_ActionBucket_Action::release_forward() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.forward)
  if (action_type_case() == kForward) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* temp = _impl_.action_type_.forward_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_type_.forward_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward& FlowRule_ActionBucket_Action::_internal_forward() const {
  return action_type_case() == kForward
      ? *_impl_.action_type_.forward_
      : reinterpret_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward&>(::aalyria::spacetime::api::common::_FlowRule_ActionBucket_Action_Forward_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward& FlowRule_ActionBucket_Action::forward() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.forward)
  return _internal_forward();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* FlowRule_ActionBucket_Action::unsafe_arena_release_forward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.forward)
  if (action_type_case() == kForward) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* temp = _impl_.action_type_.forward_;
    _impl_.action_type_.forward_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRule_ActionBucket_Action::unsafe_arena_set_allocated_forward(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* forward) {
  clear_action_type();
  if (forward) {
    set_has_forward();
    _impl_.action_type_.forward_ = forward;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.forward)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* FlowRule_ActionBucket_Action::_internal_mutable_forward() {
  if (action_type_case() != kForward) {
    clear_action_type();
    set_has_forward();
    _impl_.action_type_.forward_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward >(GetArenaForAllocation());
  }
  return _impl_.action_type_.forward_;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* FlowRule_ActionBucket_Action::mutable_forward() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_Forward* _msg = _internal_mutable_forward();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.forward)
  return _msg;
}

// .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PushHeader push_header = 3 [json_name = "pushHeader"];
inline bool FlowRule_ActionBucket_Action::has_push_header() const {
  return action_type_case() == kPushHeader;
}
inline bool FlowRule_ActionBucket_Action::_internal_has_push_header() const {
  return action_type_case() == kPushHeader;
}
inline void FlowRule_ActionBucket_Action::set_has_push_header() {
  _impl_._oneof_case_[0] = kPushHeader;
}
inline void FlowRule_ActionBucket_Action::clear_push_header() {
  if (action_type_case() == kPushHeader) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_type_.push_header_;
    }
    clear_has_action_type();
  }
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* FlowRule_ActionBucket_Action::release_push_header() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.push_header)
  if (action_type_case() == kPushHeader) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* temp = _impl_.action_type_.push_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_type_.push_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader& FlowRule_ActionBucket_Action::_internal_push_header() const {
  return action_type_case() == kPushHeader
      ? *_impl_.action_type_.push_header_
      : reinterpret_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader&>(::aalyria::spacetime::api::common::_FlowRule_ActionBucket_Action_PushHeader_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader& FlowRule_ActionBucket_Action::push_header() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.push_header)
  return _internal_push_header();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* FlowRule_ActionBucket_Action::unsafe_arena_release_push_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.push_header)
  if (action_type_case() == kPushHeader) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* temp = _impl_.action_type_.push_header_;
    _impl_.action_type_.push_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRule_ActionBucket_Action::unsafe_arena_set_allocated_push_header(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* push_header) {
  clear_action_type();
  if (push_header) {
    set_has_push_header();
    _impl_.action_type_.push_header_ = push_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.push_header)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* FlowRule_ActionBucket_Action::_internal_mutable_push_header() {
  if (action_type_case() != kPushHeader) {
    clear_action_type();
    set_has_push_header();
    _impl_.action_type_.push_header_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader >(GetArenaForAllocation());
  }
  return _impl_.action_type_.push_header_;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* FlowRule_ActionBucket_Action::mutable_push_header() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader* _msg = _internal_mutable_push_header();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.push_header)
  return _msg;
}

// .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.PopHeader pop_header = 4 [json_name = "popHeader"];
inline bool FlowRule_ActionBucket_Action::has_pop_header() const {
  return action_type_case() == kPopHeader;
}
inline bool FlowRule_ActionBucket_Action::_internal_has_pop_header() const {
  return action_type_case() == kPopHeader;
}
inline void FlowRule_ActionBucket_Action::set_has_pop_header() {
  _impl_._oneof_case_[0] = kPopHeader;
}
inline void FlowRule_ActionBucket_Action::clear_pop_header() {
  if (action_type_case() == kPopHeader) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_type_.pop_header_;
    }
    clear_has_action_type();
  }
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* FlowRule_ActionBucket_Action::release_pop_header() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.pop_header)
  if (action_type_case() == kPopHeader) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* temp = _impl_.action_type_.pop_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_type_.pop_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader& FlowRule_ActionBucket_Action::_internal_pop_header() const {
  return action_type_case() == kPopHeader
      ? *_impl_.action_type_.pop_header_
      : reinterpret_cast<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader&>(::aalyria::spacetime::api::common::_FlowRule_ActionBucket_Action_PopHeader_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader& FlowRule_ActionBucket_Action::pop_header() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.pop_header)
  return _internal_pop_header();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* FlowRule_ActionBucket_Action::unsafe_arena_release_pop_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.pop_header)
  if (action_type_case() == kPopHeader) {
    clear_has_action_type();
    ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* temp = _impl_.action_type_.pop_header_;
    _impl_.action_type_.pop_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRule_ActionBucket_Action::unsafe_arena_set_allocated_pop_header(::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* pop_header) {
  clear_action_type();
  if (pop_header) {
    set_has_pop_header();
    _impl_.action_type_.pop_header_ = pop_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.pop_header)
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* FlowRule_ActionBucket_Action::_internal_mutable_pop_header() {
  if (action_type_case() != kPopHeader) {
    clear_action_type();
    set_has_pop_header();
    _impl_.action_type_.pop_header_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader >(GetArenaForAllocation());
  }
  return _impl_.action_type_.pop_header_;
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* FlowRule_ActionBucket_Action::mutable_pop_header() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader* _msg = _internal_mutable_pop_header();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.Action.pop_header)
  return _msg;
}

inline bool FlowRule_ActionBucket_Action::has_action_type() const {
  return action_type_case() != ACTION_TYPE_NOT_SET;
}
inline void FlowRule_ActionBucket_Action::clear_has_action_type() {
  _impl_._oneof_case_[0] = ACTION_TYPE_NOT_SET;
}
inline FlowRule_ActionBucket_Action::ActionTypeCase FlowRule_ActionBucket_Action::action_type_case() const {
  return FlowRule_ActionBucket_Action::ActionTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FlowRule_ActionBucket

// repeated .aalyria.spacetime.api.common.FlowRule.ActionBucket.Action action = 1 [json_name = "action"];
inline int FlowRule_ActionBucket::_internal_action_size() const {
  return _impl_.action_.size();
}
inline int FlowRule_ActionBucket::action_size() const {
  return _internal_action_size();
}
inline void FlowRule_ActionBucket::clear_action() {
  _internal_mutable_action()->Clear();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* FlowRule_ActionBucket::mutable_action(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.ActionBucket.action)
  return _internal_mutable_action()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action >*
FlowRule_ActionBucket::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.FlowRule.ActionBucket.action)
  return _internal_mutable_action();
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action& FlowRule_ActionBucket::_internal_action(int index) const {
  return _internal_action().Get(index);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action& FlowRule_ActionBucket::action(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.ActionBucket.action)
  return _internal_action(index);
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* FlowRule_ActionBucket::_internal_add_action() {
  return _internal_mutable_action()->Add();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* FlowRule_ActionBucket::add_action() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action* _add = _internal_add_action();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.FlowRule.ActionBucket.action)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action >&
FlowRule_ActionBucket::action() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.FlowRule.ActionBucket.action)
  return _internal_action();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action>&
FlowRule_ActionBucket::_internal_action() const {
  return _impl_.action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action>*
FlowRule_ActionBucket::_internal_mutable_action() {
  return &_impl_.action_;
}

// -------------------------------------------------------------------

// FlowRule

// optional .aalyria.spacetime.api.common.PacketClassifier classifier = 5 [json_name = "classifier"];
inline bool FlowRule::has_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classifier_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier& FlowRule::_internal_classifier() const {
  const ::aalyria::spacetime::api::common::PacketClassifier* p = _impl_.classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier& FlowRule::classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.classifier)
  return _internal_classifier();
}
inline void FlowRule::unsafe_arena_set_allocated_classifier(
    ::aalyria::spacetime::api::common::PacketClassifier* classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  _impl_.classifier_ = classifier;
  if (classifier) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowRule.classifier)
}
inline ::aalyria::spacetime::api::common::PacketClassifier* FlowRule::release_classifier() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::PacketClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier* FlowRule::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowRule.classifier)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::PacketClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier* FlowRule::_internal_mutable_classifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier>(GetArenaForAllocation());
    _impl_.classifier_ = p;
  }
  return _impl_.classifier_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier* FlowRule::mutable_classifier() {
  ::aalyria::spacetime::api::common::PacketClassifier* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.classifier)
  return _msg;
}
inline void FlowRule::set_allocated_classifier(::aalyria::spacetime::api::common::PacketClassifier* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier));
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowRule.classifier)
}

// repeated .aalyria.spacetime.api.common.FlowRule.ActionBucket action_bucket = 4 [json_name = "actionBucket"];
inline int FlowRule::_internal_action_bucket_size() const {
  return _impl_.action_bucket_.size();
}
inline int FlowRule::action_bucket_size() const {
  return _internal_action_bucket_size();
}
inline void FlowRule::clear_action_bucket() {
  _internal_mutable_action_bucket()->Clear();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket* FlowRule::mutable_action_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowRule.action_bucket)
  return _internal_mutable_action_bucket()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket >*
FlowRule::mutable_action_bucket() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.FlowRule.action_bucket)
  return _internal_mutable_action_bucket();
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket& FlowRule::_internal_action_bucket(int index) const {
  return _internal_action_bucket().Get(index);
}
inline const ::aalyria::spacetime::api::common::FlowRule_ActionBucket& FlowRule::action_bucket(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowRule.action_bucket)
  return _internal_action_bucket(index);
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket* FlowRule::_internal_add_action_bucket() {
  return _internal_mutable_action_bucket()->Add();
}
inline ::aalyria::spacetime::api::common::FlowRule_ActionBucket* FlowRule::add_action_bucket() {
  ::aalyria::spacetime::api::common::FlowRule_ActionBucket* _add = _internal_add_action_bucket();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.FlowRule.action_bucket)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::FlowRule_ActionBucket >&
FlowRule::action_bucket() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.FlowRule.action_bucket)
  return _internal_action_bucket();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket>&
FlowRule::_internal_action_bucket() const {
  return _impl_.action_bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::FlowRule_ActionBucket>*
FlowRule::_internal_mutable_action_bucket() {
  return &_impl_.action_bucket_;
}

// -------------------------------------------------------------------

// FlowState

// optional .aalyria.spacetime.api.common.DateTime timestamp = 2 [json_name = "timestamp"];
inline bool FlowState::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& FlowState::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& FlowState::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowState.timestamp)
  return _internal_timestamp();
}
inline void FlowState::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowState.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* FlowState::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowState.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowState::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowState::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowState.timestamp)
  return _msg;
}
inline void FlowState::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowState.timestamp)
}

// repeated string flow_rule_ids = 3 [json_name = "flowRuleIds"];
inline int FlowState::_internal_flow_rule_ids_size() const {
  return _impl_.flow_rule_ids_.size();
}
inline int FlowState::flow_rule_ids_size() const {
  return _internal_flow_rule_ids_size();
}
inline void FlowState::clear_flow_rule_ids() {
  _internal_mutable_flow_rule_ids()->Clear();
}
inline std::string* FlowState::add_flow_rule_ids() {
  std::string* _s = _internal_add_flow_rule_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
  return _s;
}
inline const std::string& FlowState::flow_rule_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
  return _internal_flow_rule_ids(index);
}
inline std::string* FlowState::mutable_flow_rule_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
  return _internal_mutable_flow_rule_ids()->Mutable(index);
}
inline void FlowState::set_flow_rule_ids(int index, const std::string& value) {
  _internal_mutable_flow_rule_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::set_flow_rule_ids(int index, std::string&& value) {
  _internal_mutable_flow_rule_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::set_flow_rule_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_flow_rule_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::set_flow_rule_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_flow_rule_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::set_flow_rule_ids(int index, absl::string_view value) {
  _internal_mutable_flow_rule_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::add_flow_rule_ids(const std::string& value) {
  _internal_mutable_flow_rule_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::add_flow_rule_ids(std::string&& value) {
  _internal_mutable_flow_rule_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::add_flow_rule_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_flow_rule_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::add_flow_rule_ids(const char* value, std::size_t size) {
  _internal_mutable_flow_rule_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline void FlowState::add_flow_rule_ids(absl::string_view value) {
  _internal_mutable_flow_rule_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowState::flow_rule_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
  return _internal_flow_rule_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FlowState::mutable_flow_rule_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.FlowState.flow_rule_ids)
  return _internal_mutable_flow_rule_ids();
}
inline const std::string& FlowState::_internal_flow_rule_ids(int index) const {
  return _internal_flow_rule_ids().Get(index);
}
inline std::string* FlowState::_internal_add_flow_rule_ids() {
  return _internal_mutable_flow_rule_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlowState::_internal_flow_rule_ids() const {
  return _impl_.flow_rule_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlowState::_internal_mutable_flow_rule_ids() {
  return &_impl_.flow_rule_ids_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::FlowUpdate_Operation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::FlowUpdate_Operation>() {
  return ::aalyria::spacetime::api::common::FlowUpdate_Operation_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field>() {
  return ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_SetField_Field_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field>() {
  return ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PushHeader_Field_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field>() {
  return ::aalyria::spacetime::api::common::FlowRule_ActionBucket_Action_PopHeader_Field_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fflow_2eproto_2epb_2eh
