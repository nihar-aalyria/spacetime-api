// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/coordinates.proto

#include "api/common/coordinates.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
template <typename>
PROTOBUF_CONSTEXPR GeodeticWgs84::GeodeticWgs84(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.longitude_deg_)*/ 0

  , /*decltype(_impl_.latitude_deg_)*/ 0

  , /*decltype(_impl_.height_wgs84_m_)*/ 0
} {}
struct GeodeticWgs84DefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeodeticWgs84DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeodeticWgs84DefaultTypeInternal() {}
  union {
    GeodeticWgs84 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeodeticWgs84DefaultTypeInternal _GeodeticWgs84_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeodeticMsl::GeodeticMsl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.longitude_deg_)*/ 0

  , /*decltype(_impl_.latitude_deg_)*/ 0

  , /*decltype(_impl_.height_msl_m_)*/ 0
} {}
struct GeodeticMslDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeodeticMslDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeodeticMslDefaultTypeInternal() {}
  union {
    GeodeticMsl _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeodeticMslDefaultTypeInternal _GeodeticMsl_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR S2Cells::S2Cells(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/ {}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S2CellsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S2CellsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~S2CellsDefaultTypeInternal() {}
  union {
    S2Cells _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S2CellsDefaultTypeInternal _S2Cells_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Cartesian::Cartesian(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_m_)*/ 0

  , /*decltype(_impl_.y_m_)*/ 0

  , /*decltype(_impl_.z_m_)*/ 0
} {}
struct CartesianDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CartesianDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CartesianDefaultTypeInternal() {}
  union {
    Cartesian _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CartesianDefaultTypeInternal _Cartesian_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CartesianDot::CartesianDot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_mps_)*/ 0

  , /*decltype(_impl_.y_mps_)*/ 0

  , /*decltype(_impl_.z_mps_)*/ 0
} {}
struct CartesianDotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CartesianDotDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CartesianDotDefaultTypeInternal() {}
  union {
    CartesianDot _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CartesianDotDefaultTypeInternal _CartesianDot_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Quaternion::Quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.w_)*/ 0

  , /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.z_)*/ 0
} {}
struct QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuaternionDefaultTypeInternal() {}
  union {
    Quaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuaternionDefaultTypeInternal _Quaternion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR YawPitchRoll::YawPitchRoll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.yaw_deg_)*/ 0

  , /*decltype(_impl_.pitch_deg_)*/ 0

  , /*decltype(_impl_.roll_deg_)*/ 0
} {}
struct YawPitchRollDefaultTypeInternal {
  PROTOBUF_CONSTEXPR YawPitchRollDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~YawPitchRollDefaultTypeInternal() {}
  union {
    YawPitchRoll _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 YawPitchRollDefaultTypeInternal _YawPitchRoll_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointingVector::PointingVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.azimuth_deg_)*/ 0

  , /*decltype(_impl_.elevation_deg_)*/ 0
} {}
struct PointingVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointingVectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointingVectorDefaultTypeInternal() {}
  union {
    PointingVector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointingVectorDefaultTypeInternal _PointingVector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointAxes::PointAxes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.axes_)*/nullptr} {}
struct PointAxesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointAxesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointAxesDefaultTypeInternal() {}
  union {
    PointAxes _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointAxesDefaultTypeInternal _PointAxes_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointAxesTemporal::PointAxesTemporal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.axes_)*/nullptr
  , /*decltype(_impl_.gps_time_)*/nullptr
  , /*decltype(_impl_.time_)*/nullptr} {}
struct PointAxesTemporalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointAxesTemporalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointAxesTemporalDefaultTypeInternal() {}
  union {
    PointAxesTemporal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointAxesTemporalDefaultTypeInternal _PointAxesTemporal_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeodeticWgs84Temporal::GeodeticWgs84Temporal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.time_)*/nullptr} {}
struct GeodeticWgs84TemporalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeodeticWgs84TemporalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeodeticWgs84TemporalDefaultTypeInternal() {}
  union {
    GeodeticWgs84Temporal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeodeticWgs84TemporalDefaultTypeInternal _GeodeticWgs84Temporal_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointAxesTemporalInterpolation::PointAxesTemporalInterpolation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.locations_orientations_over_time_)*/{}
  , /*decltype(_impl_.interpolation_method_)*/ 1

  , /*decltype(_impl_.interpolation_degree_)*/ 1
} {}
struct PointAxesTemporalInterpolationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointAxesTemporalInterpolationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointAxesTemporalInterpolationDefaultTypeInternal() {}
  union {
    PointAxesTemporalInterpolation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointAxesTemporalInterpolationDefaultTypeInternal _PointAxesTemporalInterpolation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeodeticWgs84TemporalInterpolation::GeodeticWgs84TemporalInterpolation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.locations_over_time_)*/{}
  , /*decltype(_impl_.interpolation_method_)*/ 1

  , /*decltype(_impl_.interpolation_degree_)*/ 1
} {}
struct GeodeticWgs84TemporalInterpolationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeodeticWgs84TemporalInterpolationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeodeticWgs84TemporalInterpolationDefaultTypeInternal() {}
  union {
    GeodeticWgs84TemporalInterpolation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeodeticWgs84TemporalInterpolationDefaultTypeInternal _GeodeticWgs84TemporalInterpolation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TwoLineElementSet::TwoLineElementSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.line1_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.line2_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TwoLineElementSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TwoLineElementSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TwoLineElementSetDefaultTypeInternal() {}
  union {
    TwoLineElementSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TwoLineElementSetDefaultTypeInternal _TwoLineElementSet_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KeplerianElements::KeplerianElements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.epoch_)*/nullptr
  , /*decltype(_impl_.semimajor_axis_m_)*/ 0

  , /*decltype(_impl_.eccentricity_)*/ 0

  , /*decltype(_impl_.inclination_deg_)*/ 0

  , /*decltype(_impl_.argument_of_periapsis_deg_)*/ 0

  , /*decltype(_impl_.raan_deg_)*/ 0

  , /*decltype(_impl_.true_anomaly_deg_)*/ 0

  , /*decltype(_impl_.central_body_)*/ 1
} {}
struct KeplerianElementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeplerianElementsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeplerianElementsDefaultTypeInternal() {}
  union {
    KeplerianElements _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeplerianElementsDefaultTypeInternal _KeplerianElements_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StateVector::StateVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.epoch_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.coordinate_frame_)*/ 0

  , /*decltype(_impl_.propagation_algorithm_)*/ 0

  , /*decltype(_impl_.mass_kg_)*/ 2000

  , /*decltype(_impl_.reflectivity_)*/ 1

  , /*decltype(_impl_.reflective_area_sqm_)*/ 20
} {}
struct StateVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateVectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateVectorDefaultTypeInternal() {}
  union {
    StateVector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateVectorDefaultTypeInternal _StateVector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SelenographicMlr::SelenographicMlr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.longitude_deg_)*/ 0

  , /*decltype(_impl_.latitude_deg_)*/ 0

  , /*decltype(_impl_.height_mlr_m_)*/ 0
} {}
struct SelenographicMlrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelenographicMlrDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelenographicMlrDefaultTypeInternal() {}
  union {
    SelenographicMlr _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelenographicMlrDefaultTypeInternal _SelenographicMlr_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StkEphemAndAttitudeFile::StkEphemAndAttitudeFile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ephem_file_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.attitude_file_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct StkEphemAndAttitudeFileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StkEphemAndAttitudeFileDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StkEphemAndAttitudeFileDefaultTypeInternal() {}
  union {
    StkEphemAndAttitudeFile _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StkEphemAndAttitudeFileDefaultTypeInternal _StkEphemAndAttitudeFile_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Motion::Motion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interval_)*/nullptr
  , /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MotionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotionDefaultTypeInternal() {}
  union {
    Motion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotionDefaultTypeInternal _Motion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR MotionDefinition::MotionDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.motions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MotionDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotionDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotionDefinitionDefaultTypeInternal() {}
  union {
    MotionDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotionDefinitionDefaultTypeInternal _MotionDefinition_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fcommon_2fcoordinates_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fcommon_2fcoordinates_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fcommon_2fcoordinates_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84, _impl_.longitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84, _impl_.latitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84, _impl_.height_wgs84_m_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticMsl, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticMsl, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticMsl, _impl_.longitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticMsl, _impl_.latitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticMsl, _impl_.height_msl_m_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::S2Cells, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::S2Cells, _impl_.ids_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Cartesian, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Cartesian, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Cartesian, _impl_.x_m_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Cartesian, _impl_.y_m_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Cartesian, _impl_.z_m_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::CartesianDot, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::CartesianDot, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::CartesianDot, _impl_.x_mps_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::CartesianDot, _impl_.y_mps_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::CartesianDot, _impl_.z_mps_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _impl_.w_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Quaternion, _impl_.z_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::YawPitchRoll, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::YawPitchRoll, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::YawPitchRoll, _impl_.yaw_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::YawPitchRoll, _impl_.pitch_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::YawPitchRoll, _impl_.roll_deg_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointingVector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointingVector, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointingVector, _impl_.azimuth_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointingVector, _impl_.elevation_deg_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxes, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxes, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxes, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxes, _impl_.axes_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _impl_.axes_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _impl_.gps_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporal, _impl_.time_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84Temporal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84Temporal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84Temporal, _impl_.point_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84Temporal, _impl_.time_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation, _impl_.locations_orientations_over_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation, _impl_.interpolation_method_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation, _impl_.interpolation_degree_),
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation, _impl_.locations_over_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation, _impl_.interpolation_method_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation, _impl_.interpolation_degree_),
    ~0u,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TwoLineElementSet, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TwoLineElementSet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TwoLineElementSet, _impl_.line1_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TwoLineElementSet, _impl_.line2_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.semimajor_axis_m_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.eccentricity_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.inclination_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.argument_of_periapsis_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.raan_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.true_anomaly_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::KeplerianElements, _impl_.central_body_),
    1,
    2,
    3,
    4,
    5,
    6,
    0,
    7,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.coordinate_frame_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.propagation_algorithm_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.mass_kg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.reflectivity_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StateVector, _impl_.reflective_area_sqm_),
    0,
    3,
    1,
    2,
    4,
    5,
    6,
    7,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::SelenographicMlr, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::SelenographicMlr, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::SelenographicMlr, _impl_.longitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::SelenographicMlr, _impl_.latitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::SelenographicMlr, _impl_.height_mlr_m_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile, _impl_.ephem_file_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile, _impl_.attitude_file_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _impl_.interval_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _impl_.type_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::MotionDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::MotionDefinition, _impl_.motions_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 11, -1, sizeof(::aalyria::spacetime::api::common::GeodeticWgs84)},
        { 14, 25, -1, sizeof(::aalyria::spacetime::api::common::GeodeticMsl)},
        { 28, -1, -1, sizeof(::aalyria::spacetime::api::common::S2Cells)},
        { 37, 48, -1, sizeof(::aalyria::spacetime::api::common::Cartesian)},
        { 51, 62, -1, sizeof(::aalyria::spacetime::api::common::CartesianDot)},
        { 65, 77, -1, sizeof(::aalyria::spacetime::api::common::Quaternion)},
        { 81, 92, -1, sizeof(::aalyria::spacetime::api::common::YawPitchRoll)},
        { 95, 105, -1, sizeof(::aalyria::spacetime::api::common::PointingVector)},
        { 107, 117, -1, sizeof(::aalyria::spacetime::api::common::PointAxes)},
        { 119, 131, -1, sizeof(::aalyria::spacetime::api::common::PointAxesTemporal)},
        { 135, 145, -1, sizeof(::aalyria::spacetime::api::common::GeodeticWgs84Temporal)},
        { 147, 158, -1, sizeof(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation)},
        { 161, 172, -1, sizeof(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation)},
        { 175, 185, -1, sizeof(::aalyria::spacetime::api::common::TwoLineElementSet)},
        { 187, 203, -1, sizeof(::aalyria::spacetime::api::common::KeplerianElements)},
        { 211, 227, -1, sizeof(::aalyria::spacetime::api::common::StateVector)},
        { 235, 246, -1, sizeof(::aalyria::spacetime::api::common::SelenographicMlr)},
        { 249, 259, -1, sizeof(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile)},
        { 261, 281, -1, sizeof(::aalyria::spacetime::api::common::Motion)},
        { 292, -1, -1, sizeof(::aalyria::spacetime::api::common::MotionDefinition)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_._instance,
    &::aalyria::spacetime::api::common::_GeodeticMsl_default_instance_._instance,
    &::aalyria::spacetime::api::common::_S2Cells_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Cartesian_default_instance_._instance,
    &::aalyria::spacetime::api::common::_CartesianDot_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Quaternion_default_instance_._instance,
    &::aalyria::spacetime::api::common::_YawPitchRoll_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PointingVector_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PointAxes_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PointAxesTemporal_default_instance_._instance,
    &::aalyria::spacetime::api::common::_GeodeticWgs84Temporal_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PointAxesTemporalInterpolation_default_instance_._instance,
    &::aalyria::spacetime::api::common::_GeodeticWgs84TemporalInterpolation_default_instance_._instance,
    &::aalyria::spacetime::api::common::_TwoLineElementSet_default_instance_._instance,
    &::aalyria::spacetime::api::common::_KeplerianElements_default_instance_._instance,
    &::aalyria::spacetime::api::common::_StateVector_default_instance_._instance,
    &::aalyria::spacetime::api::common::_SelenographicMlr_default_instance_._instance,
    &::aalyria::spacetime::api::common::_StkEphemAndAttitudeFile_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Motion_default_instance_._instance,
    &::aalyria::spacetime::api::common::_MotionDefinition_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fcommon_2fcoordinates_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\034api/common/coordinates.proto\022\034aalyria."
    "spacetime.api.common\032\025api/common/time.pr"
    "oto\032\037google/protobuf/timestamp.proto\032\032go"
    "ogle/type/interval.proto\"}\n\rGeodeticWgs8"
    "4\022#\n\rlongitude_deg\030\001 \001(\001R\014longitudeDeg\022!"
    "\n\014latitude_deg\030\002 \001(\001R\013latitudeDeg\022$\n\016hei"
    "ght_wgs84_m\030\003 \001(\001R\014heightWgs84M\"w\n\013Geode"
    "ticMsl\022#\n\rlongitude_deg\030\001 \001(\001R\014longitude"
    "Deg\022!\n\014latitude_deg\030\002 \001(\001R\013latitudeDeg\022 "
    "\n\014height_msl_m\030\003 \001(\001R\nheightMslM\"\033\n\007S2Ce"
    "lls\022\020\n\003ids\030\001 \003(\004R\003ids\">\n\tCartesian\022\017\n\003x_"
    "m\030\001 \002(\001R\002xM\022\017\n\003y_m\030\002 \002(\001R\002yM\022\017\n\003z_m\030\003 \002("
    "\001R\002zM\"M\n\014CartesianDot\022\023\n\005x_mps\030\001 \002(\001R\004xM"
    "ps\022\023\n\005y_mps\030\002 \002(\001R\004yMps\022\023\n\005z_mps\030\003 \002(\001R\004"
    "zMps\"D\n\nQuaternion\022\014\n\001w\030\001 \002(\001R\001w\022\014\n\001x\030\002 "
    "\002(\001R\001x\022\014\n\001y\030\003 \002(\001R\001y\022\014\n\001z\030\004 \002(\001R\001z\"_\n\014Ya"
    "wPitchRoll\022\027\n\007yaw_deg\030\001 \002(\001R\006yawDeg\022\033\n\tp"
    "itch_deg\030\002 \002(\001R\010pitchDeg\022\031\n\010roll_deg\030\003 \002"
    "(\001R\007rollDeg\"V\n\016PointingVector\022\037\n\013azimuth"
    "_deg\030\001 \001(\001R\nazimuthDeg\022#\n\relevation_deg\030"
    "\002 \001(\001R\014elevationDeg\"\210\001\n\tPointAxes\022=\n\005poi"
    "nt\030\001 \001(\0132\'.aalyria.spacetime.api.common."
    "CartesianR\005point\022<\n\004axes\030\002 \001(\0132(.aalyria"
    ".spacetime.api.common.QuaternionR\004axes\"\202"
    "\002\n\021PointAxesTemporal\022=\n\005point\030\001 \001(\0132\'.aa"
    "lyria.spacetime.api.common.CartesianR\005po"
    "int\022<\n\004axes\030\002 \001(\0132(.aalyria.spacetime.ap"
    "i.common.QuaternionR\004axes\022@\n\010gps_time\030\004 "
    "\001(\0132%.aalyria.spacetime.api.common.GpsTi"
    "meR\007gpsTime\022.\n\004time\030\005 \001(\0132\032.google.proto"
    "buf.TimestampR\004time\"\212\001\n\025GeodeticWgs84Tem"
    "poral\022A\n\005point\030\001 \001(\0132+.aalyria.spacetime"
    ".api.common.GeodeticWgs84R\005point\022.\n\004time"
    "\030\002 \001(\0132\032.google.protobuf.TimestampR\004time"
    "\"\276\002\n\036PointAxesTemporalInterpolation\022x\n l"
    "ocations_orientations_over_time\030\001 \003(\0132/."
    "aalyria.spacetime.api.common.PointAxesTe"
    "mporalR\035locationsOrientationsOverTime\022l\n"
    "\024interpolation_method\030\002 \001(\01621.aalyria.sp"
    "acetime.api.common.InterpolationMethod:\006"
    "LINEARR\023interpolationMethod\0224\n\024interpola"
    "tion_degree\030\003 \001(\005:\0011R\023interpolationDegre"
    "e\"\255\002\n\"GeodeticWgs84TemporalInterpolation"
    "\022c\n\023locations_over_time\030\001 \003(\01323.aalyria."
    "spacetime.api.common.GeodeticWgs84Tempor"
    "alR\021locationsOverTime\022l\n\024interpolation_m"
    "ethod\030\002 \001(\01621.aalyria.spacetime.api.comm"
    "on.InterpolationMethod:\006LINEARR\023interpol"
    "ationMethod\0224\n\024interpolation_degree\030\003 \001("
    "\005:\0011R\023interpolationDegree\"\?\n\021TwoLineElem"
    "entSet\022\024\n\005line1\030\001 \001(\tR\005line1\022\024\n\005line2\030\002 "
    "\001(\tR\005line2\"\247\003\n\021KeplerianElements\022(\n\020semi"
    "major_axis_m\030\001 \001(\001R\016semimajorAxisM\022\"\n\014ec"
    "centricity\030\002 \001(\001R\014eccentricity\022\'\n\017inclin"
    "ation_deg\030\003 \001(\001R\016inclinationDeg\0229\n\031argum"
    "ent_of_periapsis_deg\030\004 \001(\001R\026argumentOfPe"
    "riapsisDeg\022\031\n\010raan_deg\030\005 \001(\001R\007raanDeg\022(\n"
    "\020true_anomaly_deg\030\006 \001(\001R\016trueAnomalyDeg\022"
    "<\n\005epoch\030\007 \001(\0132&.aalyria.spacetime.api.c"
    "ommon.DateTimeR\005epoch\022S\n\014central_body\030\010 "
    "\001(\0162).aalyria.spacetime.api.common.Centr"
    "alBody:\005EARTHR\013centralBodyJ\010\010\t\020\200\200\200\200\002\"\342\005\n"
    "\013StateVector\0220\n\005epoch\030\001 \002(\0132\032.google.pro"
    "tobuf.TimestampR\005epoch\022d\n\020coordinate_fra"
    "me\030\002 \001(\01629.aalyria.spacetime.api.common."
    "StateVector.CoordinateFrameR\017coordinateF"
    "rame\022C\n\010position\030\003 \002(\0132\'.aalyria.spaceti"
    "me.api.common.CartesianR\010position\022F\n\010vel"
    "ocity\030\004 \002(\0132*.aalyria.spacetime.api.comm"
    "on.CartesianDotR\010velocity\022s\n\025propagation"
    "_algorithm\030\005 \001(\0162>.aalyria.spacetime.api"
    ".common.StateVector.PropagationAlgorithm"
    "R\024propagationAlgorithm\022\035\n\007mass_kg\030\006 \001(\001:"
    "\0042000R\006massKg\022%\n\014reflectivity\030\007 \001(\001:\0011R\014"
    "reflectivity\0222\n\023reflective_area_sqm\030\010 \001("
    "\001:\00220R\021reflectiveAreaSqm\"]\n\017CoordinateFr"
    "ame\022\021\n\rUNKNOWN_FRAME\020\000\022\'\n#EARTH_MOON_BAR"
    "YCENTER_SYNODIC_FRAME\020\001\022\016\n\nECEF_FRAME\020\002\""
    "`\n\024PropagationAlgorithm\022\031\n\025UNSPECIFIED_A"
    "LGORITHM\020\000\022-\n)EARTH_MOON_THREE_BODY_NUME"
    "RICAL_ALGORITHM\020\001\"|\n\020SelenographicMlr\022#\n"
    "\rlongitude_deg\030\001 \001(\001R\014longitudeDeg\022!\n\014la"
    "titude_deg\030\002 \001(\001R\013latitudeDeg\022 \n\014height_"
    "mlr_m\030\003 \001(\001R\nheightMlrM\"]\n\027StkEphemAndAt"
    "titudeFile\022\035\n\nephem_file\030\001 \001(\tR\tephemFil"
    "e\022#\n\rattitude_file\030\002 \001(\tR\014attitudeFile\"\352"
    "\t\n\006Motion\0221\n\010interval\030\n \001(\0132\025.google.typ"
    "e.IntervalR\010interval\022N\n\014geodetic_msl\030\007 \001"
    "(\0132).aalyria.spacetime.api.common.Geodet"
    "icMslH\000R\013geodeticMsl\022T\n\016geodetic_wgs84\030\001"
    " \001(\0132+.aalyria.spacetime.api.common.Geod"
    "eticWgs84H\000R\rgeodeticWgs84\022H\n\necef_fixed"
    "\030\002 \001(\0132\'.aalyria.spacetime.api.common.Po"
    "intAxesH\000R\tecefFixed\022m\n\022ecef_interpolati"
    "on\030\003 \001(\0132<.aalyria.spacetime.api.common."
    "PointAxesTemporalInterpolationH\000R\021ecefIn"
    "terpolation\022y\n\026cartographic_waypoints\030\004 "
    "\001(\0132@.aalyria.spacetime.api.common.Geode"
    "ticWgs84TemporalInterpolationH\000R\025cartogr"
    "aphicWaypoints\022C\n\003tle\030\005 \001(\0132/.aalyria.sp"
    "acetime.api.common.TwoLineElementSetH\000R\003"
    "tle\022`\n\022keplerian_elements\030\006 \001(\0132/.aalyri"
    "a.spacetime.api.common.KeplerianElements"
    "H\000R\021keplerianElements\022N\n\014state_vector\030\t "
    "\001(\0132).aalyria.spacetime.api.common.State"
    "VectorH\000R\013stateVector\022]\n\021selenographic_m"
    "lr\030\010 \001(\0132..aalyria.spacetime.api.common."
    "SelenographicMlrH\000R\020selenographicMlr\022u\n\033"
    "stk_ephem_and_attitude_file\030\013 \001(\01325.aaly"
    "ria.spacetime.api.common.StkEphemAndAtti"
    "tudeFileH\000R\027stkEphemAndAttitudeFile\"\363\001\n\004"
    "Type\022\026\n\022MOTION_UNSPECIFIED\020\000\022\020\n\014GEODETIC"
    "_MSL\020\007\022\022\n\016GEODETIC_WGS84\020\001\022\016\n\nECEF_FIXED"
    "\020\002\022\026\n\022ECEF_INTERPOLATION\020\003\022\032\n\026CARTOGRAPH"
    "IC_WAYPOINTS\020\004\022\007\n\003TLE\020\005\022\026\n\022KEPLERIAN_ELE"
    "MENTS\020\006\022\020\n\014STATE_VECTOR\020\t\022\025\n\021SELENOGRAPH"
    "IC_MLR\020\010\022\037\n\033STK_EPHEM_AND_ATTITUDE_FILE\020"
    "\013B\006\n\004typeJ\010\010\014\020\200\200\200\200\002\"R\n\020MotionDefinition\022"
    ">\n\007motions\030\001 \003(\0132$.aalyria.spacetime.api"
    ".common.MotionR\007motions*<\n\013CentralBody\022\030"
    "\n\024UNKNOWN_CENTRAL_BODY\020\000\022\t\n\005EARTH\020\001\022\010\n\004M"
    "OON\020\002*R\n\023InterpolationMethod\022\022\n\016UNKNOWN_"
    "METHOD\020\000\022\n\n\006LINEAR\020\001\022\014\n\010LAGRANGE\020\002\022\r\n\tHE"
    "RMITIAN\020\003BD\n com.aalyria.spacetime.api.c"
    "ommonZ aalyria.com/spacetime/api/common"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fcommon_2fcoordinates_2eproto_deps[3] =
    {
        &::descriptor_table_api_2fcommon_2ftime_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_google_2ftype_2finterval_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fcommon_2fcoordinates_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fcommon_2fcoordinates_2eproto = {
    false,
    false,
    4999,
    descriptor_table_protodef_api_2fcommon_2fcoordinates_2eproto,
    "api/common/coordinates.proto",
    &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
    descriptor_table_api_2fcommon_2fcoordinates_2eproto_deps,
    3,
    20,
    schemas,
    file_default_instances,
    TableStruct_api_2fcommon_2fcoordinates_2eproto::offsets,
    file_level_metadata_api_2fcommon_2fcoordinates_2eproto,
    file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto,
    file_level_service_descriptors_api_2fcommon_2fcoordinates_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter() {
  return &descriptor_table_api_2fcommon_2fcoordinates_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fcommon_2fcoordinates_2eproto(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateVector_CoordinateFrame_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[0];
}
bool StateVector_CoordinateFrame_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr StateVector_CoordinateFrame StateVector::UNKNOWN_FRAME;
constexpr StateVector_CoordinateFrame StateVector::EARTH_MOON_BARYCENTER_SYNODIC_FRAME;
constexpr StateVector_CoordinateFrame StateVector::ECEF_FRAME;
constexpr StateVector_CoordinateFrame StateVector::CoordinateFrame_MIN;
constexpr StateVector_CoordinateFrame StateVector::CoordinateFrame_MAX;
constexpr int StateVector::CoordinateFrame_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateVector_PropagationAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[1];
}
bool StateVector_PropagationAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr StateVector_PropagationAlgorithm StateVector::UNSPECIFIED_ALGORITHM;
constexpr StateVector_PropagationAlgorithm StateVector::EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM;
constexpr StateVector_PropagationAlgorithm StateVector::PropagationAlgorithm_MIN;
constexpr StateVector_PropagationAlgorithm StateVector::PropagationAlgorithm_MAX;
constexpr int StateVector::PropagationAlgorithm_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Motion_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[2];
}
bool Motion_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Motion_Type Motion::MOTION_UNSPECIFIED;
constexpr Motion_Type Motion::GEODETIC_MSL;
constexpr Motion_Type Motion::GEODETIC_WGS84;
constexpr Motion_Type Motion::ECEF_FIXED;
constexpr Motion_Type Motion::ECEF_INTERPOLATION;
constexpr Motion_Type Motion::CARTOGRAPHIC_WAYPOINTS;
constexpr Motion_Type Motion::TLE;
constexpr Motion_Type Motion::KEPLERIAN_ELEMENTS;
constexpr Motion_Type Motion::STATE_VECTOR;
constexpr Motion_Type Motion::SELENOGRAPHIC_MLR;
constexpr Motion_Type Motion::STK_EPHEM_AND_ATTITUDE_FILE;
constexpr Motion_Type Motion::Type_MIN;
constexpr Motion_Type Motion::Type_MAX;
constexpr int Motion::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CentralBody_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[3];
}
bool CentralBody_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterpolationMethod_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fcoordinates_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fcoordinates_2eproto[4];
}
bool InterpolationMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class GeodeticWgs84::_Internal {
 public:
  using HasBits = decltype(std::declval<GeodeticWgs84>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeodeticWgs84, _impl_._has_bits_);
  static void set_has_longitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height_wgs84_m(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GeodeticWgs84::GeodeticWgs84(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.GeodeticWgs84)
}
GeodeticWgs84::GeodeticWgs84(const GeodeticWgs84& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.GeodeticWgs84)
}

inline void GeodeticWgs84::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_deg_) { 0 }

    , decltype(_impl_.latitude_deg_) { 0 }

    , decltype(_impl_.height_wgs84_m_) { 0 }

  };
}

GeodeticWgs84::~GeodeticWgs84() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.GeodeticWgs84)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeodeticWgs84::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeodeticWgs84::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeodeticWgs84::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.GeodeticWgs84)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.longitude_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.height_wgs84_m_) -
        reinterpret_cast<char*>(&_impl_.longitude_deg_)) + sizeof(_impl_.height_wgs84_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeodeticWgs84::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_longitude_deg(&has_bits);
          _impl_.longitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude_deg(&has_bits);
          _impl_.latitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double height_wgs84_m = 3 [json_name = "heightWgs84M"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_height_wgs84_m(&has_bits);
          _impl_.height_wgs84_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeodeticWgs84::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.GeodeticWgs84)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_longitude_deg(), target);
  }

  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_latitude_deg(), target);
  }

  // optional double height_wgs84_m = 3 [json_name = "heightWgs84M"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_height_wgs84_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.GeodeticWgs84)
  return target;
}

::size_t GeodeticWgs84::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.GeodeticWgs84)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double height_wgs84_m = 3 [json_name = "heightWgs84M"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeodeticWgs84::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeodeticWgs84::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeodeticWgs84::GetClassData() const { return &_class_data_; }


void GeodeticWgs84::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeodeticWgs84*>(&to_msg);
  auto& from = static_cast<const GeodeticWgs84&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.GeodeticWgs84)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_deg_ = from._impl_.longitude_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_deg_ = from._impl_.latitude_deg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_wgs84_m_ = from._impl_.height_wgs84_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeodeticWgs84::CopyFrom(const GeodeticWgs84& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.GeodeticWgs84)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeodeticWgs84::IsInitialized() const {
  return true;
}

void GeodeticWgs84::InternalSwap(GeodeticWgs84* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeodeticWgs84, _impl_.height_wgs84_m_)
      + sizeof(GeodeticWgs84::_impl_.height_wgs84_m_)
      - PROTOBUF_FIELD_OFFSET(GeodeticWgs84, _impl_.longitude_deg_)>(
          reinterpret_cast<char*>(&_impl_.longitude_deg_),
          reinterpret_cast<char*>(&other->_impl_.longitude_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeodeticWgs84::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[0]);
}
// ===================================================================

class GeodeticMsl::_Internal {
 public:
  using HasBits = decltype(std::declval<GeodeticMsl>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeodeticMsl, _impl_._has_bits_);
  static void set_has_longitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height_msl_m(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GeodeticMsl::GeodeticMsl(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.GeodeticMsl)
}
GeodeticMsl::GeodeticMsl(const GeodeticMsl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.GeodeticMsl)
}

inline void GeodeticMsl::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_deg_) { 0 }

    , decltype(_impl_.latitude_deg_) { 0 }

    , decltype(_impl_.height_msl_m_) { 0 }

  };
}

GeodeticMsl::~GeodeticMsl() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.GeodeticMsl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeodeticMsl::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeodeticMsl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeodeticMsl::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.GeodeticMsl)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.longitude_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.height_msl_m_) -
        reinterpret_cast<char*>(&_impl_.longitude_deg_)) + sizeof(_impl_.height_msl_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeodeticMsl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_longitude_deg(&has_bits);
          _impl_.longitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude_deg(&has_bits);
          _impl_.latitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double height_msl_m = 3 [json_name = "heightMslM"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_height_msl_m(&has_bits);
          _impl_.height_msl_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeodeticMsl::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.GeodeticMsl)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_longitude_deg(), target);
  }

  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_latitude_deg(), target);
  }

  // optional double height_msl_m = 3 [json_name = "heightMslM"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_height_msl_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.GeodeticMsl)
  return target;
}

::size_t GeodeticMsl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.GeodeticMsl)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double height_msl_m = 3 [json_name = "heightMslM"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeodeticMsl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeodeticMsl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeodeticMsl::GetClassData() const { return &_class_data_; }


void GeodeticMsl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeodeticMsl*>(&to_msg);
  auto& from = static_cast<const GeodeticMsl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.GeodeticMsl)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_deg_ = from._impl_.longitude_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_deg_ = from._impl_.latitude_deg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_msl_m_ = from._impl_.height_msl_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeodeticMsl::CopyFrom(const GeodeticMsl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.GeodeticMsl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeodeticMsl::IsInitialized() const {
  return true;
}

void GeodeticMsl::InternalSwap(GeodeticMsl* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeodeticMsl, _impl_.height_msl_m_)
      + sizeof(GeodeticMsl::_impl_.height_msl_m_)
      - PROTOBUF_FIELD_OFFSET(GeodeticMsl, _impl_.longitude_deg_)>(
          reinterpret_cast<char*>(&_impl_.longitude_deg_),
          reinterpret_cast<char*>(&other->_impl_.longitude_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeodeticMsl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[1]);
}
// ===================================================================

class S2Cells::_Internal {
 public:
};

S2Cells::S2Cells(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.S2Cells)
}
S2Cells::S2Cells(const S2Cells& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S2Cells* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_) { from._impl_.ids_ }

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.S2Cells)
}

inline void S2Cells::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_) { arena }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S2Cells::~S2Cells() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.S2Cells)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S2Cells::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
}

void S2Cells::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S2Cells::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.S2Cells)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S2Cells::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 ids = 1 [json_name = "ids"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* S2Cells::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.S2Cells)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 ids = 1 [json_name = "ids"];
  for (int i = 0, n = this->_internal_ids_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.S2Cells)
  return target;
}

::size_t S2Cells::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.S2Cells)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 ids = 1 [json_name = "ids"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_ids())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_ids_size());
    ;
    total_size += tag_size + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S2Cells::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S2Cells::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S2Cells::GetClassData() const { return &_class_data_; }


void S2Cells::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S2Cells*>(&to_msg);
  auto& from = static_cast<const S2Cells&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.S2Cells)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S2Cells::CopyFrom(const S2Cells& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.S2Cells)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S2Cells::IsInitialized() const {
  return true;
}

void S2Cells::InternalSwap(S2Cells* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S2Cells::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[2]);
}
// ===================================================================

class Cartesian::_Internal {
 public:
  using HasBits = decltype(std::declval<Cartesian>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Cartesian, _impl_._has_bits_);
  static void set_has_x_m(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y_m(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z_m(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Cartesian::Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Cartesian)
}

inline void Cartesian::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_m_) { 0 }

    , decltype(_impl_.y_m_) { 0 }

    , decltype(_impl_.z_m_) { 0 }

  };
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Cartesian)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Cartesian::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Cartesian::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Cartesian)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_m_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.z_m_) -
        reinterpret_cast<char*>(&_impl_.x_m_)) + sizeof(_impl_.z_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cartesian::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double x_m = 1 [json_name = "xM"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_x_m(&has_bits);
          _impl_.x_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double y_m = 2 [json_name = "yM"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_y_m(&has_bits);
          _impl_.y_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double z_m = 3 [json_name = "zM"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_z_m(&has_bits);
          _impl_.z_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Cartesian::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Cartesian)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double x_m = 1 [json_name = "xM"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x_m(), target);
  }

  // required double y_m = 2 [json_name = "yM"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y_m(), target);
  }

  // required double z_m = 3 [json_name = "zM"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_z_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Cartesian)
  return target;
}

::size_t Cartesian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.common.Cartesian)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double x_m = 1 [json_name = "xM"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double y_m = 2 [json_name = "yM"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double z_m = 3 [json_name = "zM"];
    total_size += 9;
  }

  return total_size;
}
::size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Cartesian)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x_m = 1 [json_name = "xM"];
    total_size += 9;

    // required double y_m = 2 [json_name = "yM"];
    total_size += 9;

    // required double z_m = 3 [json_name = "zM"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cartesian::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Cartesian::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cartesian::GetClassData() const { return &_class_data_; }


void Cartesian::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Cartesian*>(&to_msg);
  auto& from = static_cast<const Cartesian&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Cartesian)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_m_ = from._impl_.x_m_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_m_ = from._impl_.y_m_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_m_ = from._impl_.z_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cartesian, _impl_.z_m_)
      + sizeof(Cartesian::_impl_.z_m_)
      - PROTOBUF_FIELD_OFFSET(Cartesian, _impl_.x_m_)>(
          reinterpret_cast<char*>(&_impl_.x_m_),
          reinterpret_cast<char*>(&other->_impl_.x_m_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cartesian::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[3]);
}
// ===================================================================

class CartesianDot::_Internal {
 public:
  using HasBits = decltype(std::declval<CartesianDot>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CartesianDot, _impl_._has_bits_);
  static void set_has_x_mps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y_mps(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z_mps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CartesianDot::CartesianDot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.CartesianDot)
}
CartesianDot::CartesianDot(const CartesianDot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.CartesianDot)
}

inline void CartesianDot::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_mps_) { 0 }

    , decltype(_impl_.y_mps_) { 0 }

    , decltype(_impl_.z_mps_) { 0 }

  };
}

CartesianDot::~CartesianDot() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.CartesianDot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CartesianDot::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CartesianDot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CartesianDot::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.CartesianDot)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_mps_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.z_mps_) -
        reinterpret_cast<char*>(&_impl_.x_mps_)) + sizeof(_impl_.z_mps_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CartesianDot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double x_mps = 1 [json_name = "xMps"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_x_mps(&has_bits);
          _impl_.x_mps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double y_mps = 2 [json_name = "yMps"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_y_mps(&has_bits);
          _impl_.y_mps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double z_mps = 3 [json_name = "zMps"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_z_mps(&has_bits);
          _impl_.z_mps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CartesianDot::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.CartesianDot)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double x_mps = 1 [json_name = "xMps"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x_mps(), target);
  }

  // required double y_mps = 2 [json_name = "yMps"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y_mps(), target);
  }

  // required double z_mps = 3 [json_name = "zMps"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_z_mps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.CartesianDot)
  return target;
}

::size_t CartesianDot::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.common.CartesianDot)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double x_mps = 1 [json_name = "xMps"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double y_mps = 2 [json_name = "yMps"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double z_mps = 3 [json_name = "zMps"];
    total_size += 9;
  }

  return total_size;
}
::size_t CartesianDot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.CartesianDot)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x_mps = 1 [json_name = "xMps"];
    total_size += 9;

    // required double y_mps = 2 [json_name = "yMps"];
    total_size += 9;

    // required double z_mps = 3 [json_name = "zMps"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CartesianDot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CartesianDot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CartesianDot::GetClassData() const { return &_class_data_; }


void CartesianDot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CartesianDot*>(&to_msg);
  auto& from = static_cast<const CartesianDot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.CartesianDot)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_mps_ = from._impl_.x_mps_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_mps_ = from._impl_.y_mps_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_mps_ = from._impl_.z_mps_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CartesianDot::CopyFrom(const CartesianDot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.CartesianDot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianDot::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CartesianDot::InternalSwap(CartesianDot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CartesianDot, _impl_.z_mps_)
      + sizeof(CartesianDot::_impl_.z_mps_)
      - PROTOBUF_FIELD_OFFSET(CartesianDot, _impl_.x_mps_)>(
          reinterpret_cast<char*>(&_impl_.x_mps_),
          reinterpret_cast<char*>(&other->_impl_.x_mps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CartesianDot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[4]);
}
// ===================================================================

class Quaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<Quaternion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Quaternion, _impl_._has_bits_);
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

Quaternion::Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Quaternion)
}

inline void Quaternion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.w_) { 0 }

    , decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.z_) { 0 }

  };
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Quaternion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Quaternion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.w_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.w_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double w = 1 [json_name = "w"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_w(&has_bits);
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double x = 2 [json_name = "x"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double y = 3 [json_name = "y"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double z = 4 [json_name = "z"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Quaternion::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Quaternion)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double w = 1 [json_name = "w"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_w(), target);
  }

  // required double x = 2 [json_name = "x"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_x(), target);
  }

  // required double y = 3 [json_name = "y"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_y(), target);
  }

  // required double z = 4 [json_name = "z"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Quaternion)
  return target;
}

::size_t Quaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.common.Quaternion)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double w = 1 [json_name = "w"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double x = 2 [json_name = "x"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double y = 3 [json_name = "y"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required double z = 4 [json_name = "z"];
    total_size += 9;
  }

  return total_size;
}
::size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Quaternion)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double w = 1 [json_name = "w"];
    total_size += 9;

    // required double x = 2 [json_name = "x"];
    total_size += 9;

    // required double y = 3 [json_name = "y"];
    total_size += 9;

    // required double z = 4 [json_name = "z"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Quaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Quaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Quaternion::GetClassData() const { return &_class_data_; }


void Quaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Quaternion*>(&to_msg);
  auto& from = static_cast<const Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Quaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.w_ = from._impl_.w_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.z_)
      + sizeof(Quaternion::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Quaternion, _impl_.w_)>(
          reinterpret_cast<char*>(&_impl_.w_),
          reinterpret_cast<char*>(&other->_impl_.w_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[5]);
}
// ===================================================================

class YawPitchRoll::_Internal {
 public:
  using HasBits = decltype(std::declval<YawPitchRoll>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(YawPitchRoll, _impl_._has_bits_);
  static void set_has_yaw_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pitch_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_roll_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

YawPitchRoll::YawPitchRoll(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.YawPitchRoll)
}
YawPitchRoll::YawPitchRoll(const YawPitchRoll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.YawPitchRoll)
}

inline void YawPitchRoll::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.yaw_deg_) { 0 }

    , decltype(_impl_.pitch_deg_) { 0 }

    , decltype(_impl_.roll_deg_) { 0 }

  };
}

YawPitchRoll::~YawPitchRoll() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.YawPitchRoll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void YawPitchRoll::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void YawPitchRoll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void YawPitchRoll::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.YawPitchRoll)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.yaw_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.roll_deg_) -
        reinterpret_cast<char*>(&_impl_.yaw_deg_)) + sizeof(_impl_.roll_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* YawPitchRoll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double yaw_deg = 1 [json_name = "yawDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_yaw_deg(&has_bits);
          _impl_.yaw_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double pitch_deg = 2 [json_name = "pitchDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_pitch_deg(&has_bits);
          _impl_.pitch_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double roll_deg = 3 [json_name = "rollDeg"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_roll_deg(&has_bits);
          _impl_.roll_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* YawPitchRoll::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.YawPitchRoll)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double yaw_deg = 1 [json_name = "yawDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_yaw_deg(), target);
  }

  // required double pitch_deg = 2 [json_name = "pitchDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_pitch_deg(), target);
  }

  // required double roll_deg = 3 [json_name = "rollDeg"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_roll_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.YawPitchRoll)
  return target;
}

::size_t YawPitchRoll::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.common.YawPitchRoll)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double yaw_deg = 1 [json_name = "yawDeg"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double pitch_deg = 2 [json_name = "pitchDeg"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double roll_deg = 3 [json_name = "rollDeg"];
    total_size += 9;
  }

  return total_size;
}
::size_t YawPitchRoll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.YawPitchRoll)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double yaw_deg = 1 [json_name = "yawDeg"];
    total_size += 9;

    // required double pitch_deg = 2 [json_name = "pitchDeg"];
    total_size += 9;

    // required double roll_deg = 3 [json_name = "rollDeg"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData YawPitchRoll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    YawPitchRoll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*YawPitchRoll::GetClassData() const { return &_class_data_; }


void YawPitchRoll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<YawPitchRoll*>(&to_msg);
  auto& from = static_cast<const YawPitchRoll&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.YawPitchRoll)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.yaw_deg_ = from._impl_.yaw_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pitch_deg_ = from._impl_.pitch_deg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.roll_deg_ = from._impl_.roll_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void YawPitchRoll::CopyFrom(const YawPitchRoll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.YawPitchRoll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool YawPitchRoll::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void YawPitchRoll::InternalSwap(YawPitchRoll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(YawPitchRoll, _impl_.roll_deg_)
      + sizeof(YawPitchRoll::_impl_.roll_deg_)
      - PROTOBUF_FIELD_OFFSET(YawPitchRoll, _impl_.yaw_deg_)>(
          reinterpret_cast<char*>(&_impl_.yaw_deg_),
          reinterpret_cast<char*>(&other->_impl_.yaw_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata YawPitchRoll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[6]);
}
// ===================================================================

class PointingVector::_Internal {
 public:
  using HasBits = decltype(std::declval<PointingVector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PointingVector, _impl_._has_bits_);
  static void set_has_azimuth_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_elevation_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PointingVector::PointingVector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PointingVector)
}
PointingVector::PointingVector(const PointingVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PointingVector)
}

inline void PointingVector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.azimuth_deg_) { 0 }

    , decltype(_impl_.elevation_deg_) { 0 }

  };
}

PointingVector::~PointingVector() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PointingVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointingVector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointingVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointingVector::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PointingVector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.azimuth_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.elevation_deg_) -
        reinterpret_cast<char*>(&_impl_.azimuth_deg_)) + sizeof(_impl_.elevation_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointingVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_azimuth_deg(&has_bits);
          _impl_.azimuth_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double elevation_deg = 2 [json_name = "elevationDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_elevation_deg(&has_bits);
          _impl_.elevation_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointingVector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PointingVector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_azimuth_deg(), target);
  }

  // optional double elevation_deg = 2 [json_name = "elevationDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_elevation_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PointingVector)
  return target;
}

::size_t PointingVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PointingVector)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double elevation_deg = 2 [json_name = "elevationDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointingVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointingVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointingVector::GetClassData() const { return &_class_data_; }


void PointingVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointingVector*>(&to_msg);
  auto& from = static_cast<const PointingVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PointingVector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.azimuth_deg_ = from._impl_.azimuth_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.elevation_deg_ = from._impl_.elevation_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointingVector::CopyFrom(const PointingVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PointingVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointingVector::IsInitialized() const {
  return true;
}

void PointingVector::InternalSwap(PointingVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointingVector, _impl_.elevation_deg_)
      + sizeof(PointingVector::_impl_.elevation_deg_)
      - PROTOBUF_FIELD_OFFSET(PointingVector, _impl_.azimuth_deg_)>(
          reinterpret_cast<char*>(&_impl_.azimuth_deg_),
          reinterpret_cast<char*>(&other->_impl_.azimuth_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointingVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[7]);
}
// ===================================================================

class PointAxes::_Internal {
 public:
  using HasBits = decltype(std::declval<PointAxes>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PointAxes, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::Cartesian& point(const PointAxes* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::Quaternion& axes(const PointAxes* msg);
  static void set_has_axes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::Cartesian&
PointAxes::_Internal::point(const PointAxes* msg) {
  return *msg->_impl_.point_;
}
const ::aalyria::spacetime::api::common::Quaternion&
PointAxes::_Internal::axes(const PointAxes* msg) {
  return *msg->_impl_.axes_;
}
PointAxes::PointAxes(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PointAxes)
}
PointAxes::PointAxes(const PointAxes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointAxes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.axes_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::aalyria::spacetime::api::common::Cartesian(*from._impl_.point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.axes_ = new ::aalyria::spacetime::api::common::Quaternion(*from._impl_.axes_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PointAxes)
}

inline void PointAxes::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.axes_){nullptr}
  };
}

PointAxes::~PointAxes() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PointAxes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointAxes::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.axes_;
}

void PointAxes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointAxes::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PointAxes)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.axes_ != nullptr);
      _impl_.axes_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointAxes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_axes(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointAxes::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PointAxes)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::axes(this),
        _Internal::axes(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PointAxes)
  return target;
}

::size_t PointAxes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PointAxes)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.axes_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointAxes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointAxes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointAxes::GetClassData() const { return &_class_data_; }


void PointAxes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointAxes*>(&to_msg);
  auto& from = static_cast<const PointAxes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PointAxes)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::aalyria::spacetime::api::common::Cartesian::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_axes()->::aalyria::spacetime::api::common::Quaternion::MergeFrom(
          from._internal_axes());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointAxes::CopyFrom(const PointAxes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PointAxes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointAxes::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.point_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.axes_->IsInitialized()) return false;
  }
  return true;
}

void PointAxes::InternalSwap(PointAxes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointAxes, _impl_.axes_)
      + sizeof(PointAxes::_impl_.axes_)
      - PROTOBUF_FIELD_OFFSET(PointAxes, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointAxes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[8]);
}
// ===================================================================

class PointAxesTemporal::_Internal {
 public:
  using HasBits = decltype(std::declval<PointAxesTemporal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PointAxesTemporal, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::Cartesian& point(const PointAxesTemporal* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::Quaternion& axes(const PointAxesTemporal* msg);
  static void set_has_axes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::GpsTime& gps_time(const PointAxesTemporal* msg);
  static void set_has_gps_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& time(const PointAxesTemporal* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::common::Cartesian&
PointAxesTemporal::_Internal::point(const PointAxesTemporal* msg) {
  return *msg->_impl_.point_;
}
const ::aalyria::spacetime::api::common::Quaternion&
PointAxesTemporal::_Internal::axes(const PointAxesTemporal* msg) {
  return *msg->_impl_.axes_;
}
const ::aalyria::spacetime::api::common::GpsTime&
PointAxesTemporal::_Internal::gps_time(const PointAxesTemporal* msg) {
  return *msg->_impl_.gps_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
PointAxesTemporal::_Internal::time(const PointAxesTemporal* msg) {
  return *msg->_impl_.time_;
}
void PointAxesTemporal::clear_gps_time() {
  if (_impl_.gps_time_ != nullptr) _impl_.gps_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PointAxesTemporal::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PointAxesTemporal::PointAxesTemporal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PointAxesTemporal)
}
PointAxesTemporal::PointAxesTemporal(const PointAxesTemporal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointAxesTemporal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.axes_){nullptr}
    , decltype(_impl_.gps_time_){nullptr}
    , decltype(_impl_.time_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::aalyria::spacetime::api::common::Cartesian(*from._impl_.point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.axes_ = new ::aalyria::spacetime::api::common::Quaternion(*from._impl_.axes_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.gps_time_ = new ::aalyria::spacetime::api::common::GpsTime(*from._impl_.gps_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.time_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PointAxesTemporal)
}

inline void PointAxesTemporal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.axes_){nullptr}
    , decltype(_impl_.gps_time_){nullptr}
    , decltype(_impl_.time_){nullptr}
  };
}

PointAxesTemporal::~PointAxesTemporal() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PointAxesTemporal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointAxesTemporal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.axes_;
  if (this != internal_default_instance()) delete _impl_.gps_time_;
  if (this != internal_default_instance()) delete _impl_.time_;
}

void PointAxesTemporal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointAxesTemporal::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PointAxesTemporal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.axes_ != nullptr);
      _impl_.axes_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.gps_time_ != nullptr);
      _impl_.gps_time_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointAxesTemporal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_axes(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.GpsTime gps_time = 4 [json_name = "gpsTime"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_gps_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp time = 5 [json_name = "time"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointAxesTemporal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PointAxesTemporal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::axes(this),
        _Internal::axes(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.GpsTime gps_time = 4 [json_name = "gpsTime"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::gps_time(this),
        _Internal::gps_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp time = 5 [json_name = "time"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::time(this),
        _Internal::time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PointAxesTemporal)
  return target;
}

::size_t PointAxesTemporal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PointAxesTemporal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.axes_);
    }

    // optional .aalyria.spacetime.api.common.GpsTime gps_time = 4 [json_name = "gpsTime"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gps_time_);
    }

    // optional .google.protobuf.Timestamp time = 5 [json_name = "time"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointAxesTemporal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointAxesTemporal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointAxesTemporal::GetClassData() const { return &_class_data_; }


void PointAxesTemporal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointAxesTemporal*>(&to_msg);
  auto& from = static_cast<const PointAxesTemporal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PointAxesTemporal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::aalyria::spacetime::api::common::Cartesian::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_axes()->::aalyria::spacetime::api::common::Quaternion::MergeFrom(
          from._internal_axes());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_gps_time()->::aalyria::spacetime::api::common::GpsTime::MergeFrom(
          from._internal_gps_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_time());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointAxesTemporal::CopyFrom(const PointAxesTemporal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PointAxesTemporal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointAxesTemporal::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.point_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.axes_->IsInitialized()) return false;
  }
  return true;
}

void PointAxesTemporal::InternalSwap(PointAxesTemporal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointAxesTemporal, _impl_.time_)
      + sizeof(PointAxesTemporal::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(PointAxesTemporal, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointAxesTemporal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[9]);
}
// ===================================================================

class GeodeticWgs84Temporal::_Internal {
 public:
  using HasBits = decltype(std::declval<GeodeticWgs84Temporal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeodeticWgs84Temporal, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::GeodeticWgs84& point(const GeodeticWgs84Temporal* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& time(const GeodeticWgs84Temporal* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::GeodeticWgs84&
GeodeticWgs84Temporal::_Internal::point(const GeodeticWgs84Temporal* msg) {
  return *msg->_impl_.point_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GeodeticWgs84Temporal::_Internal::time(const GeodeticWgs84Temporal* msg) {
  return *msg->_impl_.time_;
}
void GeodeticWgs84Temporal::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GeodeticWgs84Temporal::GeodeticWgs84Temporal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
}
GeodeticWgs84Temporal::GeodeticWgs84Temporal(const GeodeticWgs84Temporal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeodeticWgs84Temporal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.time_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.point_ = new ::aalyria::spacetime::api::common::GeodeticWgs84(*from._impl_.point_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.time_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
}

inline void GeodeticWgs84Temporal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.time_){nullptr}
  };
}

GeodeticWgs84Temporal::~GeodeticWgs84Temporal() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeodeticWgs84Temporal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.time_;
}

void GeodeticWgs84Temporal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeodeticWgs84Temporal::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeodeticWgs84Temporal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.GeodeticWgs84 point = 1 [json_name = "point"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp time = 2 [json_name = "time"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeodeticWgs84Temporal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 point = 1 [json_name = "point"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp time = 2 [json_name = "time"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::time(this),
        _Internal::time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  return target;
}

::size_t GeodeticWgs84Temporal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.GeodeticWgs84 point = 1 [json_name = "point"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .google.protobuf.Timestamp time = 2 [json_name = "time"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeodeticWgs84Temporal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeodeticWgs84Temporal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeodeticWgs84Temporal::GetClassData() const { return &_class_data_; }


void GeodeticWgs84Temporal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeodeticWgs84Temporal*>(&to_msg);
  auto& from = static_cast<const GeodeticWgs84Temporal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::aalyria::spacetime::api::common::GeodeticWgs84::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_time());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeodeticWgs84Temporal::CopyFrom(const GeodeticWgs84Temporal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeodeticWgs84Temporal::IsInitialized() const {
  return true;
}

void GeodeticWgs84Temporal::InternalSwap(GeodeticWgs84Temporal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeodeticWgs84Temporal, _impl_.time_)
      + sizeof(GeodeticWgs84Temporal::_impl_.time_)
      - PROTOBUF_FIELD_OFFSET(GeodeticWgs84Temporal, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeodeticWgs84Temporal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[10]);
}
// ===================================================================

class PointAxesTemporalInterpolation::_Internal {
 public:
  using HasBits = decltype(std::declval<PointAxesTemporalInterpolation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PointAxesTemporalInterpolation, _impl_._has_bits_);
  static void set_has_interpolation_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_interpolation_degree(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PointAxesTemporalInterpolation::PointAxesTemporalInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
}
PointAxesTemporalInterpolation::PointAxesTemporalInterpolation(const PointAxesTemporalInterpolation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointAxesTemporalInterpolation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locations_orientations_over_time_){from._impl_.locations_orientations_over_time_}
    , decltype(_impl_.interpolation_method_) {}

    , decltype(_impl_.interpolation_degree_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.interpolation_method_, &from._impl_.interpolation_method_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.interpolation_degree_) -
    reinterpret_cast<char*>(&_impl_.interpolation_method_)) + sizeof(_impl_.interpolation_degree_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
}

inline void PointAxesTemporalInterpolation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locations_orientations_over_time_){arena}
    , decltype(_impl_.interpolation_method_) { 1 }

    , decltype(_impl_.interpolation_degree_) { 1 }

  };
}

PointAxesTemporalInterpolation::~PointAxesTemporalInterpolation() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointAxesTemporalInterpolation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_locations_orientations_over_time()->~RepeatedPtrField();
}

void PointAxesTemporalInterpolation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointAxesTemporalInterpolation::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_locations_orientations_over_time()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.interpolation_method_ = 1;
    _impl_.interpolation_degree_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointAxesTemporalInterpolation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.PointAxesTemporal locations_orientations_over_time = 1 [json_name = "locationsOrientationsOverTime"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locations_orientations_over_time(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::InterpolationMethod_IsValid(static_cast<int>(val)))) {
            _internal_set_interpolation_method(static_cast<::aalyria::spacetime::api::common::InterpolationMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_interpolation_degree(&has_bits);
          _impl_.interpolation_degree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointAxesTemporalInterpolation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.PointAxesTemporal locations_orientations_over_time = 1 [json_name = "locationsOrientationsOverTime"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locations_orientations_over_time_size()); i < n; i++) {
    const auto& repfield = this->_internal_locations_orientations_over_time(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_interpolation_method(), target);
  }

  // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_interpolation_degree(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  return target;
}

::size_t PointAxesTemporalInterpolation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.PointAxesTemporal locations_orientations_over_time = 1 [json_name = "locationsOrientationsOverTime"];
  total_size += 1UL * this->_internal_locations_orientations_over_time_size();
  for (const auto& msg : this->_internal_locations_orientations_over_time()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_interpolation_method());
    }

    // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_interpolation_degree());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointAxesTemporalInterpolation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointAxesTemporalInterpolation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointAxesTemporalInterpolation::GetClassData() const { return &_class_data_; }


void PointAxesTemporalInterpolation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointAxesTemporalInterpolation*>(&to_msg);
  auto& from = static_cast<const PointAxesTemporalInterpolation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_locations_orientations_over_time()->MergeFrom(from._internal_locations_orientations_over_time());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.interpolation_method_ = from._impl_.interpolation_method_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.interpolation_degree_ = from._impl_.interpolation_degree_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointAxesTemporalInterpolation::CopyFrom(const PointAxesTemporalInterpolation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointAxesTemporalInterpolation::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_locations_orientations_over_time()))
    return false;
  return true;
}

void PointAxesTemporalInterpolation::InternalSwap(PointAxesTemporalInterpolation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_locations_orientations_over_time()->InternalSwap(other->_internal_mutable_locations_orientations_over_time());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointAxesTemporalInterpolation, _impl_.interpolation_degree_)
      + sizeof(PointAxesTemporalInterpolation::_impl_.interpolation_degree_)
      - PROTOBUF_FIELD_OFFSET(PointAxesTemporalInterpolation, _impl_.interpolation_method_)>(
          reinterpret_cast<char*>(&_impl_.interpolation_method_),
          reinterpret_cast<char*>(&other->_impl_.interpolation_method_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointAxesTemporalInterpolation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[11]);
}
// ===================================================================

class GeodeticWgs84TemporalInterpolation::_Internal {
 public:
  using HasBits = decltype(std::declval<GeodeticWgs84TemporalInterpolation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeodeticWgs84TemporalInterpolation, _impl_._has_bits_);
  static void set_has_interpolation_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_interpolation_degree(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GeodeticWgs84TemporalInterpolation::GeodeticWgs84TemporalInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
}
GeodeticWgs84TemporalInterpolation::GeodeticWgs84TemporalInterpolation(const GeodeticWgs84TemporalInterpolation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeodeticWgs84TemporalInterpolation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locations_over_time_){from._impl_.locations_over_time_}
    , decltype(_impl_.interpolation_method_) {}

    , decltype(_impl_.interpolation_degree_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.interpolation_method_, &from._impl_.interpolation_method_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.interpolation_degree_) -
    reinterpret_cast<char*>(&_impl_.interpolation_method_)) + sizeof(_impl_.interpolation_degree_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
}

inline void GeodeticWgs84TemporalInterpolation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locations_over_time_){arena}
    , decltype(_impl_.interpolation_method_) { 1 }

    , decltype(_impl_.interpolation_degree_) { 1 }

  };
}

GeodeticWgs84TemporalInterpolation::~GeodeticWgs84TemporalInterpolation() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeodeticWgs84TemporalInterpolation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_locations_over_time()->~RepeatedPtrField();
}

void GeodeticWgs84TemporalInterpolation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeodeticWgs84TemporalInterpolation::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_locations_over_time()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.interpolation_method_ = 1;
    _impl_.interpolation_degree_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeodeticWgs84TemporalInterpolation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.GeodeticWgs84Temporal locations_over_time = 1 [json_name = "locationsOverTime"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locations_over_time(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::InterpolationMethod_IsValid(static_cast<int>(val)))) {
            _internal_set_interpolation_method(static_cast<::aalyria::spacetime::api::common::InterpolationMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_interpolation_degree(&has_bits);
          _impl_.interpolation_degree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeodeticWgs84TemporalInterpolation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.GeodeticWgs84Temporal locations_over_time = 1 [json_name = "locationsOverTime"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locations_over_time_size()); i < n; i++) {
    const auto& repfield = this->_internal_locations_over_time(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_interpolation_method(), target);
  }

  // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_interpolation_degree(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  return target;
}

::size_t GeodeticWgs84TemporalInterpolation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.GeodeticWgs84Temporal locations_over_time = 1 [json_name = "locationsOverTime"];
  total_size += 1UL * this->_internal_locations_over_time_size();
  for (const auto& msg : this->_internal_locations_over_time()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_interpolation_method());
    }

    // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_interpolation_degree());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeodeticWgs84TemporalInterpolation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeodeticWgs84TemporalInterpolation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeodeticWgs84TemporalInterpolation::GetClassData() const { return &_class_data_; }


void GeodeticWgs84TemporalInterpolation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeodeticWgs84TemporalInterpolation*>(&to_msg);
  auto& from = static_cast<const GeodeticWgs84TemporalInterpolation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_locations_over_time()->MergeFrom(from._internal_locations_over_time());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.interpolation_method_ = from._impl_.interpolation_method_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.interpolation_degree_ = from._impl_.interpolation_degree_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeodeticWgs84TemporalInterpolation::CopyFrom(const GeodeticWgs84TemporalInterpolation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeodeticWgs84TemporalInterpolation::IsInitialized() const {
  return true;
}

void GeodeticWgs84TemporalInterpolation::InternalSwap(GeodeticWgs84TemporalInterpolation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_locations_over_time()->InternalSwap(other->_internal_mutable_locations_over_time());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeodeticWgs84TemporalInterpolation, _impl_.interpolation_degree_)
      + sizeof(GeodeticWgs84TemporalInterpolation::_impl_.interpolation_degree_)
      - PROTOBUF_FIELD_OFFSET(GeodeticWgs84TemporalInterpolation, _impl_.interpolation_method_)>(
          reinterpret_cast<char*>(&_impl_.interpolation_method_),
          reinterpret_cast<char*>(&other->_impl_.interpolation_method_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeodeticWgs84TemporalInterpolation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[12]);
}
// ===================================================================

class TwoLineElementSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TwoLineElementSet>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TwoLineElementSet, _impl_._has_bits_);
  static void set_has_line1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_line2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TwoLineElementSet::TwoLineElementSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.TwoLineElementSet)
}
TwoLineElementSet::TwoLineElementSet(const TwoLineElementSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TwoLineElementSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.line1_) {}

    , decltype(_impl_.line2_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.line1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.line1_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.line1_.Set(from._internal_line1(), _this->GetArenaForAllocation());
  }
  _impl_.line2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.line2_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.line2_.Set(from._internal_line2(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.TwoLineElementSet)
}

inline void TwoLineElementSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.line1_) {}

    , decltype(_impl_.line2_) {}

  };
  _impl_.line1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.line1_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.line2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.line2_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TwoLineElementSet::~TwoLineElementSet() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.TwoLineElementSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TwoLineElementSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.line1_.Destroy();
  _impl_.line2_.Destroy();
}

void TwoLineElementSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TwoLineElementSet::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.TwoLineElementSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.line1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.line2_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TwoLineElementSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string line1 = 1 [json_name = "line1"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_line1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.TwoLineElementSet.line1");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string line2 = 2 [json_name = "line2"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_line2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.TwoLineElementSet.line2");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TwoLineElementSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.TwoLineElementSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string line1 = 1 [json_name = "line1"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_line1();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.TwoLineElementSet.line1");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string line2 = 2 [json_name = "line2"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_line2();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.TwoLineElementSet.line2");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.TwoLineElementSet)
  return target;
}

::size_t TwoLineElementSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.TwoLineElementSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string line1 = 1 [json_name = "line1"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_line1());
    }

    // optional string line2 = 2 [json_name = "line2"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_line2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TwoLineElementSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TwoLineElementSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TwoLineElementSet::GetClassData() const { return &_class_data_; }


void TwoLineElementSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TwoLineElementSet*>(&to_msg);
  auto& from = static_cast<const TwoLineElementSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.TwoLineElementSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_line1(from._internal_line1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_line2(from._internal_line2());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TwoLineElementSet::CopyFrom(const TwoLineElementSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.TwoLineElementSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TwoLineElementSet::IsInitialized() const {
  return true;
}

void TwoLineElementSet::InternalSwap(TwoLineElementSet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.line1_, lhs_arena,
                                       &other->_impl_.line1_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.line2_, lhs_arena,
                                       &other->_impl_.line2_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TwoLineElementSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[13]);
}
// ===================================================================

class KeplerianElements::_Internal {
 public:
  using HasBits = decltype(std::declval<KeplerianElements>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KeplerianElements, _impl_._has_bits_);
  static void set_has_semimajor_axis_m(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_eccentricity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_inclination_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_argument_of_periapsis_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_raan_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_true_anomaly_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::aalyria::spacetime::api::common::DateTime& epoch(const KeplerianElements* msg);
  static void set_has_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_central_body(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
KeplerianElements::_Internal::epoch(const KeplerianElements* msg) {
  return *msg->_impl_.epoch_;
}
void KeplerianElements::clear_epoch() {
  if (_impl_.epoch_ != nullptr) _impl_.epoch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
KeplerianElements::KeplerianElements(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.KeplerianElements)
}
KeplerianElements::KeplerianElements(const KeplerianElements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeplerianElements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.epoch_){nullptr}
    , decltype(_impl_.semimajor_axis_m_) {}

    , decltype(_impl_.eccentricity_) {}

    , decltype(_impl_.inclination_deg_) {}

    , decltype(_impl_.argument_of_periapsis_deg_) {}

    , decltype(_impl_.raan_deg_) {}

    , decltype(_impl_.true_anomaly_deg_) {}

    , decltype(_impl_.central_body_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.epoch_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.epoch_);
  }
  ::memcpy(&_impl_.semimajor_axis_m_, &from._impl_.semimajor_axis_m_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.central_body_) -
    reinterpret_cast<char*>(&_impl_.semimajor_axis_m_)) + sizeof(_impl_.central_body_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.KeplerianElements)
}

inline void KeplerianElements::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.epoch_){nullptr}
    , decltype(_impl_.semimajor_axis_m_) { 0 }

    , decltype(_impl_.eccentricity_) { 0 }

    , decltype(_impl_.inclination_deg_) { 0 }

    , decltype(_impl_.argument_of_periapsis_deg_) { 0 }

    , decltype(_impl_.raan_deg_) { 0 }

    , decltype(_impl_.true_anomaly_deg_) { 0 }

    , decltype(_impl_.central_body_) { 1 }

  };
}

KeplerianElements::~KeplerianElements() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.KeplerianElements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeplerianElements::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.epoch_;
}

void KeplerianElements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeplerianElements::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.KeplerianElements)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.epoch_ != nullptr);
    _impl_.epoch_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.semimajor_axis_m_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.true_anomaly_deg_) -
        reinterpret_cast<char*>(&_impl_.semimajor_axis_m_)) + sizeof(_impl_.true_anomaly_deg_));
    _impl_.central_body_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeplerianElements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double semimajor_axis_m = 1 [json_name = "semimajorAxisM"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_semimajor_axis_m(&has_bits);
          _impl_.semimajor_axis_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double eccentricity = 2 [json_name = "eccentricity"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_eccentricity(&has_bits);
          _impl_.eccentricity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double inclination_deg = 3 [json_name = "inclinationDeg"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_inclination_deg(&has_bits);
          _impl_.inclination_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double argument_of_periapsis_deg = 4 [json_name = "argumentOfPeriapsisDeg"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_argument_of_periapsis_deg(&has_bits);
          _impl_.argument_of_periapsis_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double raan_deg = 5 [json_name = "raanDeg"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_raan_deg(&has_bits);
          _impl_.raan_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double true_anomaly_deg = 6 [json_name = "trueAnomalyDeg"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_true_anomaly_deg(&has_bits);
          _impl_.true_anomaly_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.DateTime epoch = 7 [json_name = "epoch"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_epoch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.CentralBody central_body = 8 [default = EARTH, json_name = "centralBody"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::CentralBody_IsValid(static_cast<int>(val)))) {
            _internal_set_central_body(static_cast<::aalyria::spacetime::api::common::CentralBody>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* KeplerianElements::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.KeplerianElements)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double semimajor_axis_m = 1 [json_name = "semimajorAxisM"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_semimajor_axis_m(), target);
  }

  // optional double eccentricity = 2 [json_name = "eccentricity"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_eccentricity(), target);
  }

  // optional double inclination_deg = 3 [json_name = "inclinationDeg"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_inclination_deg(), target);
  }

  // optional double argument_of_periapsis_deg = 4 [json_name = "argumentOfPeriapsisDeg"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_argument_of_periapsis_deg(), target);
  }

  // optional double raan_deg = 5 [json_name = "raanDeg"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_raan_deg(), target);
  }

  // optional double true_anomaly_deg = 6 [json_name = "trueAnomalyDeg"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_true_anomaly_deg(), target);
  }

  // optional .aalyria.spacetime.api.common.DateTime epoch = 7 [json_name = "epoch"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::epoch(this),
        _Internal::epoch(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.CentralBody central_body = 8 [default = EARTH, json_name = "centralBody"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_central_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.KeplerianElements)
  return target;
}

::size_t KeplerianElements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.KeplerianElements)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .aalyria.spacetime.api.common.DateTime epoch = 7 [json_name = "epoch"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.epoch_);
    }

    // optional double semimajor_axis_m = 1 [json_name = "semimajorAxisM"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double eccentricity = 2 [json_name = "eccentricity"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double inclination_deg = 3 [json_name = "inclinationDeg"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double argument_of_periapsis_deg = 4 [json_name = "argumentOfPeriapsisDeg"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double raan_deg = 5 [json_name = "raanDeg"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional double true_anomaly_deg = 6 [json_name = "trueAnomalyDeg"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }

    // optional .aalyria.spacetime.api.common.CentralBody central_body = 8 [default = EARTH, json_name = "centralBody"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_central_body());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeplerianElements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeplerianElements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeplerianElements::GetClassData() const { return &_class_data_; }


void KeplerianElements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeplerianElements*>(&to_msg);
  auto& from = static_cast<const KeplerianElements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.KeplerianElements)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_epoch()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_epoch());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.semimajor_axis_m_ = from._impl_.semimajor_axis_m_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.eccentricity_ = from._impl_.eccentricity_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.inclination_deg_ = from._impl_.inclination_deg_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.argument_of_periapsis_deg_ = from._impl_.argument_of_periapsis_deg_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.raan_deg_ = from._impl_.raan_deg_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.true_anomaly_deg_ = from._impl_.true_anomaly_deg_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.central_body_ = from._impl_.central_body_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeplerianElements::CopyFrom(const KeplerianElements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.KeplerianElements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeplerianElements::IsInitialized() const {
  return true;
}

void KeplerianElements::InternalSwap(KeplerianElements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeplerianElements, _impl_.central_body_)
      + sizeof(KeplerianElements::_impl_.central_body_)
      - PROTOBUF_FIELD_OFFSET(KeplerianElements, _impl_.epoch_)>(
          reinterpret_cast<char*>(&_impl_.epoch_),
          reinterpret_cast<char*>(&other->_impl_.epoch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeplerianElements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[14]);
}
// ===================================================================

class StateVector::_Internal {
 public:
  using HasBits = decltype(std::declval<StateVector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StateVector, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& epoch(const StateVector* msg);
  static void set_has_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coordinate_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::aalyria::spacetime::api::common::Cartesian& position(const StateVector* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::CartesianDot& velocity(const StateVector* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_propagation_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mass_kg(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reflectivity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_reflective_area_sqm(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
StateVector::_Internal::epoch(const StateVector* msg) {
  return *msg->_impl_.epoch_;
}
const ::aalyria::spacetime::api::common::Cartesian&
StateVector::_Internal::position(const StateVector* msg) {
  return *msg->_impl_.position_;
}
const ::aalyria::spacetime::api::common::CartesianDot&
StateVector::_Internal::velocity(const StateVector* msg) {
  return *msg->_impl_.velocity_;
}
void StateVector::clear_epoch() {
  if (_impl_.epoch_ != nullptr) _impl_.epoch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StateVector::StateVector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.StateVector)
}
StateVector::StateVector(const StateVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StateVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.epoch_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.coordinate_frame_) {}

    , decltype(_impl_.propagation_algorithm_) {}

    , decltype(_impl_.mass_kg_) {}

    , decltype(_impl_.reflectivity_) {}

    , decltype(_impl_.reflective_area_sqm_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.epoch_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.epoch_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.position_ = new ::aalyria::spacetime::api::common::Cartesian(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.velocity_ = new ::aalyria::spacetime::api::common::CartesianDot(*from._impl_.velocity_);
  }
  ::memcpy(&_impl_.coordinate_frame_, &from._impl_.coordinate_frame_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.reflective_area_sqm_) -
    reinterpret_cast<char*>(&_impl_.coordinate_frame_)) + sizeof(_impl_.reflective_area_sqm_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.StateVector)
}

inline void StateVector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.epoch_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.coordinate_frame_) { 0 }

    , decltype(_impl_.propagation_algorithm_) { 0 }

    , decltype(_impl_.mass_kg_) { 2000 }

    , decltype(_impl_.reflectivity_) { 1 }

    , decltype(_impl_.reflective_area_sqm_) { 20 }

  };
}

StateVector::~StateVector() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.StateVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StateVector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.epoch_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void StateVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StateVector::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.StateVector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.epoch_ != nullptr);
      _impl_.epoch_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.coordinate_frame_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.propagation_algorithm_) -
        reinterpret_cast<char*>(&_impl_.coordinate_frame_)) + sizeof(_impl_.propagation_algorithm_));
    _impl_.mass_kg_ = 2000;
    _impl_.reflectivity_ = 1;
    _impl_.reflective_area_sqm_ = 20;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StateVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_epoch(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.StateVector.CoordinateFrame coordinate_frame = 2 [json_name = "coordinateFrame"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::StateVector_CoordinateFrame_IsValid(static_cast<int>(val)))) {
            _internal_set_coordinate_frame(static_cast<::aalyria::spacetime::api::common::StateVector_CoordinateFrame>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.StateVector.PropagationAlgorithm propagation_algorithm = 5 [json_name = "propagationAlgorithm"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm_IsValid(static_cast<int>(val)))) {
            _internal_set_propagation_algorithm(static_cast<::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double mass_kg = 6 [default = 2000, json_name = "massKg"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_mass_kg(&has_bits);
          _impl_.mass_kg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double reflectivity = 7 [default = 1, json_name = "reflectivity"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_reflectivity(&has_bits);
          _impl_.reflectivity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double reflective_area_sqm = 8 [default = 20, json_name = "reflectiveAreaSqm"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _Internal::set_has_reflective_area_sqm(&has_bits);
          _impl_.reflective_area_sqm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StateVector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.StateVector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::epoch(this),
        _Internal::epoch(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.StateVector.CoordinateFrame coordinate_frame = 2 [json_name = "coordinateFrame"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_coordinate_frame(), target);
  }

  // required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.StateVector.PropagationAlgorithm propagation_algorithm = 5 [json_name = "propagationAlgorithm"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_propagation_algorithm(), target);
  }

  // optional double mass_kg = 6 [default = 2000, json_name = "massKg"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_mass_kg(), target);
  }

  // optional double reflectivity = 7 [default = 1, json_name = "reflectivity"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_reflectivity(), target);
  }

  // optional double reflective_area_sqm = 8 [default = 20, json_name = "reflectiveAreaSqm"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_reflective_area_sqm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.StateVector)
  return target;
}

::size_t StateVector::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.common.StateVector)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.epoch_);
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  return total_size;
}
::size_t StateVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.StateVector)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.epoch_);

    // required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);

    // required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000f8u) {
    // optional .aalyria.spacetime.api.common.StateVector.CoordinateFrame coordinate_frame = 2 [json_name = "coordinateFrame"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_coordinate_frame());
    }

    // optional .aalyria.spacetime.api.common.StateVector.PropagationAlgorithm propagation_algorithm = 5 [json_name = "propagationAlgorithm"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_propagation_algorithm());
    }

    // optional double mass_kg = 6 [default = 2000, json_name = "massKg"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional double reflectivity = 7 [default = 1, json_name = "reflectivity"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }

    // optional double reflective_area_sqm = 8 [default = 20, json_name = "reflectiveAreaSqm"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StateVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StateVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StateVector::GetClassData() const { return &_class_data_; }


void StateVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StateVector*>(&to_msg);
  auto& from = static_cast<const StateVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.StateVector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_epoch()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_epoch());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::aalyria::spacetime::api::common::Cartesian::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_velocity()->::aalyria::spacetime::api::common::CartesianDot::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.coordinate_frame_ = from._impl_.coordinate_frame_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.propagation_algorithm_ = from._impl_.propagation_algorithm_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.mass_kg_ = from._impl_.mass_kg_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.reflectivity_ = from._impl_.reflectivity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.reflective_area_sqm_ = from._impl_.reflective_area_sqm_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StateVector::CopyFrom(const StateVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.StateVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateVector::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.position_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.velocity_->IsInitialized()) return false;
  }
  return true;
}

void StateVector::InternalSwap(StateVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StateVector, _impl_.reflective_area_sqm_)
      + sizeof(StateVector::_impl_.reflective_area_sqm_)
      - PROTOBUF_FIELD_OFFSET(StateVector, _impl_.epoch_)>(
          reinterpret_cast<char*>(&_impl_.epoch_),
          reinterpret_cast<char*>(&other->_impl_.epoch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StateVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[15]);
}
// ===================================================================

class SelenographicMlr::_Internal {
 public:
  using HasBits = decltype(std::declval<SelenographicMlr>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SelenographicMlr, _impl_._has_bits_);
  static void set_has_longitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height_mlr_m(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SelenographicMlr::SelenographicMlr(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.SelenographicMlr)
}
SelenographicMlr::SelenographicMlr(const SelenographicMlr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.SelenographicMlr)
}

inline void SelenographicMlr::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_deg_) { 0 }

    , decltype(_impl_.latitude_deg_) { 0 }

    , decltype(_impl_.height_mlr_m_) { 0 }

  };
}

SelenographicMlr::~SelenographicMlr() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.SelenographicMlr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelenographicMlr::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelenographicMlr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelenographicMlr::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.SelenographicMlr)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.longitude_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.height_mlr_m_) -
        reinterpret_cast<char*>(&_impl_.longitude_deg_)) + sizeof(_impl_.height_mlr_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelenographicMlr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_longitude_deg(&has_bits);
          _impl_.longitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude_deg(&has_bits);
          _impl_.latitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double height_mlr_m = 3 [json_name = "heightMlrM"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_height_mlr_m(&has_bits);
          _impl_.height_mlr_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SelenographicMlr::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.SelenographicMlr)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_longitude_deg(), target);
  }

  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_latitude_deg(), target);
  }

  // optional double height_mlr_m = 3 [json_name = "heightMlrM"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_height_mlr_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.SelenographicMlr)
  return target;
}

::size_t SelenographicMlr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.SelenographicMlr)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double height_mlr_m = 3 [json_name = "heightMlrM"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelenographicMlr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelenographicMlr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelenographicMlr::GetClassData() const { return &_class_data_; }


void SelenographicMlr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelenographicMlr*>(&to_msg);
  auto& from = static_cast<const SelenographicMlr&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.SelenographicMlr)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_deg_ = from._impl_.longitude_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_deg_ = from._impl_.latitude_deg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_mlr_m_ = from._impl_.height_mlr_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelenographicMlr::CopyFrom(const SelenographicMlr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.SelenographicMlr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelenographicMlr::IsInitialized() const {
  return true;
}

void SelenographicMlr::InternalSwap(SelenographicMlr* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelenographicMlr, _impl_.height_mlr_m_)
      + sizeof(SelenographicMlr::_impl_.height_mlr_m_)
      - PROTOBUF_FIELD_OFFSET(SelenographicMlr, _impl_.longitude_deg_)>(
          reinterpret_cast<char*>(&_impl_.longitude_deg_),
          reinterpret_cast<char*>(&other->_impl_.longitude_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelenographicMlr::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[16]);
}
// ===================================================================

class StkEphemAndAttitudeFile::_Internal {
 public:
  using HasBits = decltype(std::declval<StkEphemAndAttitudeFile>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StkEphemAndAttitudeFile, _impl_._has_bits_);
  static void set_has_ephem_file(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attitude_file(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StkEphemAndAttitudeFile::StkEphemAndAttitudeFile(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
}
StkEphemAndAttitudeFile::StkEphemAndAttitudeFile(const StkEphemAndAttitudeFile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StkEphemAndAttitudeFile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ephem_file_) {}

    , decltype(_impl_.attitude_file_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ephem_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ephem_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ephem_file_.Set(from._internal_ephem_file(), _this->GetArenaForAllocation());
  }
  _impl_.attitude_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.attitude_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.attitude_file_.Set(from._internal_attitude_file(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
}

inline void StkEphemAndAttitudeFile::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ephem_file_) {}

    , decltype(_impl_.attitude_file_) {}

  };
  _impl_.ephem_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ephem_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attitude_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.attitude_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StkEphemAndAttitudeFile::~StkEphemAndAttitudeFile() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StkEphemAndAttitudeFile::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ephem_file_.Destroy();
  _impl_.attitude_file_.Destroy();
}

void StkEphemAndAttitudeFile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StkEphemAndAttitudeFile::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ephem_file_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.attitude_file_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StkEphemAndAttitudeFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ephem_file = 1 [json_name = "ephemFile"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ephem_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string attitude_file = 2 [json_name = "attitudeFile"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_attitude_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StkEphemAndAttitudeFile::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string ephem_file = 1 [json_name = "ephemFile"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_ephem_file();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string attitude_file = 2 [json_name = "attitudeFile"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_attitude_file();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  return target;
}

::size_t StkEphemAndAttitudeFile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ephem_file = 1 [json_name = "ephemFile"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_ephem_file());
    }

    // optional string attitude_file = 2 [json_name = "attitudeFile"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_attitude_file());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StkEphemAndAttitudeFile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StkEphemAndAttitudeFile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StkEphemAndAttitudeFile::GetClassData() const { return &_class_data_; }


void StkEphemAndAttitudeFile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StkEphemAndAttitudeFile*>(&to_msg);
  auto& from = static_cast<const StkEphemAndAttitudeFile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ephem_file(from._internal_ephem_file());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_attitude_file(from._internal_attitude_file());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StkEphemAndAttitudeFile::CopyFrom(const StkEphemAndAttitudeFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StkEphemAndAttitudeFile::IsInitialized() const {
  return true;
}

void StkEphemAndAttitudeFile::InternalSwap(StkEphemAndAttitudeFile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ephem_file_, lhs_arena,
                                       &other->_impl_.ephem_file_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.attitude_file_, lhs_arena,
                                       &other->_impl_.attitude_file_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata StkEphemAndAttitudeFile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[17]);
}
// ===================================================================

class Motion::_Internal {
 public:
  using HasBits = decltype(std::declval<Motion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Motion, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Motion, _impl_._oneof_case_);
  static const ::google::type::Interval& interval(const Motion* msg);
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::GeodeticMsl& geodetic_msl(const Motion* msg);
  static const ::aalyria::spacetime::api::common::GeodeticWgs84& geodetic_wgs84(const Motion* msg);
  static const ::aalyria::spacetime::api::common::PointAxes& ecef_fixed(const Motion* msg);
  static const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation& ecef_interpolation(const Motion* msg);
  static const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation& cartographic_waypoints(const Motion* msg);
  static const ::aalyria::spacetime::api::common::TwoLineElementSet& tle(const Motion* msg);
  static const ::aalyria::spacetime::api::common::KeplerianElements& keplerian_elements(const Motion* msg);
  static const ::aalyria::spacetime::api::common::StateVector& state_vector(const Motion* msg);
  static const ::aalyria::spacetime::api::common::SelenographicMlr& selenographic_mlr(const Motion* msg);
  static const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile& stk_ephem_and_attitude_file(const Motion* msg);
};

const ::google::type::Interval&
Motion::_Internal::interval(const Motion* msg) {
  return *msg->_impl_.interval_;
}
const ::aalyria::spacetime::api::common::GeodeticMsl&
Motion::_Internal::geodetic_msl(const Motion* msg) {
  return *msg->_impl_.type_.geodetic_msl_;
}
const ::aalyria::spacetime::api::common::GeodeticWgs84&
Motion::_Internal::geodetic_wgs84(const Motion* msg) {
  return *msg->_impl_.type_.geodetic_wgs84_;
}
const ::aalyria::spacetime::api::common::PointAxes&
Motion::_Internal::ecef_fixed(const Motion* msg) {
  return *msg->_impl_.type_.ecef_fixed_;
}
const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation&
Motion::_Internal::ecef_interpolation(const Motion* msg) {
  return *msg->_impl_.type_.ecef_interpolation_;
}
const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation&
Motion::_Internal::cartographic_waypoints(const Motion* msg) {
  return *msg->_impl_.type_.cartographic_waypoints_;
}
const ::aalyria::spacetime::api::common::TwoLineElementSet&
Motion::_Internal::tle(const Motion* msg) {
  return *msg->_impl_.type_.tle_;
}
const ::aalyria::spacetime::api::common::KeplerianElements&
Motion::_Internal::keplerian_elements(const Motion* msg) {
  return *msg->_impl_.type_.keplerian_elements_;
}
const ::aalyria::spacetime::api::common::StateVector&
Motion::_Internal::state_vector(const Motion* msg) {
  return *msg->_impl_.type_.state_vector_;
}
const ::aalyria::spacetime::api::common::SelenographicMlr&
Motion::_Internal::selenographic_mlr(const Motion* msg) {
  return *msg->_impl_.type_.selenographic_mlr_;
}
const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile&
Motion::_Internal::stk_ephem_and_attitude_file(const Motion* msg) {
  return *msg->_impl_.type_.stk_ephem_and_attitude_file_;
}
void Motion::clear_interval() {
  if (_impl_.interval_ != nullptr) _impl_.interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Motion::set_allocated_geodetic_msl(::aalyria::spacetime::api::common::GeodeticMsl* geodetic_msl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (geodetic_msl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geodetic_msl);
    if (message_arena != submessage_arena) {
      geodetic_msl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geodetic_msl, submessage_arena);
    }
    set_has_geodetic_msl();
    _impl_.type_.geodetic_msl_ = geodetic_msl;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.geodetic_msl)
}
void Motion::set_allocated_geodetic_wgs84(::aalyria::spacetime::api::common::GeodeticWgs84* geodetic_wgs84) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (geodetic_wgs84) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geodetic_wgs84);
    if (message_arena != submessage_arena) {
      geodetic_wgs84 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geodetic_wgs84, submessage_arena);
    }
    set_has_geodetic_wgs84();
    _impl_.type_.geodetic_wgs84_ = geodetic_wgs84;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
}
void Motion::set_allocated_ecef_fixed(::aalyria::spacetime::api::common::PointAxes* ecef_fixed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (ecef_fixed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ecef_fixed);
    if (message_arena != submessage_arena) {
      ecef_fixed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecef_fixed, submessage_arena);
    }
    set_has_ecef_fixed();
    _impl_.type_.ecef_fixed_ = ecef_fixed;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.ecef_fixed)
}
void Motion::set_allocated_ecef_interpolation(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* ecef_interpolation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (ecef_interpolation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ecef_interpolation);
    if (message_arena != submessage_arena) {
      ecef_interpolation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecef_interpolation, submessage_arena);
    }
    set_has_ecef_interpolation();
    _impl_.type_.ecef_interpolation_ = ecef_interpolation;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.ecef_interpolation)
}
void Motion::set_allocated_cartographic_waypoints(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* cartographic_waypoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (cartographic_waypoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cartographic_waypoints);
    if (message_arena != submessage_arena) {
      cartographic_waypoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cartographic_waypoints, submessage_arena);
    }
    set_has_cartographic_waypoints();
    _impl_.type_.cartographic_waypoints_ = cartographic_waypoints;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
}
void Motion::set_allocated_tle(::aalyria::spacetime::api::common::TwoLineElementSet* tle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (tle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tle);
    if (message_arena != submessage_arena) {
      tle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tle, submessage_arena);
    }
    set_has_tle();
    _impl_.type_.tle_ = tle;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.tle)
}
void Motion::set_allocated_keplerian_elements(::aalyria::spacetime::api::common::KeplerianElements* keplerian_elements) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (keplerian_elements) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keplerian_elements);
    if (message_arena != submessage_arena) {
      keplerian_elements = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keplerian_elements, submessage_arena);
    }
    set_has_keplerian_elements();
    _impl_.type_.keplerian_elements_ = keplerian_elements;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.keplerian_elements)
}
void Motion::set_allocated_state_vector(::aalyria::spacetime::api::common::StateVector* state_vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (state_vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state_vector);
    if (message_arena != submessage_arena) {
      state_vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_vector, submessage_arena);
    }
    set_has_state_vector();
    _impl_.type_.state_vector_ = state_vector;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.state_vector)
}
void Motion::set_allocated_selenographic_mlr(::aalyria::spacetime::api::common::SelenographicMlr* selenographic_mlr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (selenographic_mlr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selenographic_mlr);
    if (message_arena != submessage_arena) {
      selenographic_mlr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selenographic_mlr, submessage_arena);
    }
    set_has_selenographic_mlr();
    _impl_.type_.selenographic_mlr_ = selenographic_mlr;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.selenographic_mlr)
}
void Motion::set_allocated_stk_ephem_and_attitude_file(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* stk_ephem_and_attitude_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (stk_ephem_and_attitude_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stk_ephem_and_attitude_file);
    if (message_arena != submessage_arena) {
      stk_ephem_and_attitude_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stk_ephem_and_attitude_file, submessage_arena);
    }
    set_has_stk_ephem_and_attitude_file();
    _impl_.type_.stk_ephem_and_attitude_file_ = stk_ephem_and_attitude_file;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
}
Motion::Motion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Motion)
}
Motion::Motion(const Motion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Motion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){nullptr}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.interval_ = new ::google::type::Interval(*from._impl_.interval_);
  }
  clear_has_type();
  switch (from.type_case()) {
    case kGeodeticMsl: {
      _this->_internal_mutable_geodetic_msl()->::aalyria::spacetime::api::common::GeodeticMsl::MergeFrom(
          from._internal_geodetic_msl());
      break;
    }
    case kGeodeticWgs84: {
      _this->_internal_mutable_geodetic_wgs84()->::aalyria::spacetime::api::common::GeodeticWgs84::MergeFrom(
          from._internal_geodetic_wgs84());
      break;
    }
    case kEcefFixed: {
      _this->_internal_mutable_ecef_fixed()->::aalyria::spacetime::api::common::PointAxes::MergeFrom(
          from._internal_ecef_fixed());
      break;
    }
    case kEcefInterpolation: {
      _this->_internal_mutable_ecef_interpolation()->::aalyria::spacetime::api::common::PointAxesTemporalInterpolation::MergeFrom(
          from._internal_ecef_interpolation());
      break;
    }
    case kCartographicWaypoints: {
      _this->_internal_mutable_cartographic_waypoints()->::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation::MergeFrom(
          from._internal_cartographic_waypoints());
      break;
    }
    case kTle: {
      _this->_internal_mutable_tle()->::aalyria::spacetime::api::common::TwoLineElementSet::MergeFrom(
          from._internal_tle());
      break;
    }
    case kKeplerianElements: {
      _this->_internal_mutable_keplerian_elements()->::aalyria::spacetime::api::common::KeplerianElements::MergeFrom(
          from._internal_keplerian_elements());
      break;
    }
    case kStateVector: {
      _this->_internal_mutable_state_vector()->::aalyria::spacetime::api::common::StateVector::MergeFrom(
          from._internal_state_vector());
      break;
    }
    case kSelenographicMlr: {
      _this->_internal_mutable_selenographic_mlr()->::aalyria::spacetime::api::common::SelenographicMlr::MergeFrom(
          from._internal_selenographic_mlr());
      break;
    }
    case kStkEphemAndAttitudeFile: {
      _this->_internal_mutable_stk_ephem_and_attitude_file()->::aalyria::spacetime::api::common::StkEphemAndAttitudeFile::MergeFrom(
          from._internal_stk_ephem_and_attitude_file());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Motion)
}

inline void Motion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){nullptr}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type();
}

Motion::~Motion() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Motion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Motion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.interval_;
  if (has_type()) {
    clear_type();
  }
}

void Motion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Motion::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.Motion)
  switch (type_case()) {
    case kGeodeticMsl: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.geodetic_msl_;
      }
      break;
    }
    case kGeodeticWgs84: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.geodetic_wgs84_;
      }
      break;
    }
    case kEcefFixed: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.ecef_fixed_;
      }
      break;
    }
    case kEcefInterpolation: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.ecef_interpolation_;
      }
      break;
    }
    case kCartographicWaypoints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.cartographic_waypoints_;
      }
      break;
    }
    case kTle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.tle_;
      }
      break;
    }
    case kKeplerianElements: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.keplerian_elements_;
      }
      break;
    }
    case kStateVector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.state_vector_;
      }
      break;
    }
    case kSelenographicMlr: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.selenographic_mlr_;
      }
      break;
    }
    case kStkEphemAndAttitudeFile: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.stk_ephem_and_attitude_file_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void Motion::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Motion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.interval_ != nullptr);
    _impl_.interval_->Clear();
  }
  clear_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Motion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.GeodeticWgs84 geodetic_wgs84 = 1 [json_name = "geodeticWgs84"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geodetic_wgs84(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PointAxes ecef_fixed = 2 [json_name = "ecefFixed"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecef_fixed(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PointAxesTemporalInterpolation ecef_interpolation = 3 [json_name = "ecefInterpolation"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ecef_interpolation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation cartographic_waypoints = 4 [json_name = "cartographicWaypoints"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cartographic_waypoints(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.TwoLineElementSet tle = 5 [json_name = "tle"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.KeplerianElements keplerian_elements = 6 [json_name = "keplerianElements"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_keplerian_elements(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.GeodeticMsl geodetic_msl = 7 [json_name = "geodeticMsl"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_geodetic_msl(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.SelenographicMlr selenographic_mlr = 8 [json_name = "selenographicMlr"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_selenographic_mlr(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.StateVector state_vector = 9 [json_name = "stateVector"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_state_vector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.type.Interval interval = 10 [json_name = "interval"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_interval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.StkEphemAndAttitudeFile stk_ephem_and_attitude_file = 11 [json_name = "stkEphemAndAttitudeFile"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stk_ephem_and_attitude_file(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Motion::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Motion)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kGeodeticWgs84: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::geodetic_wgs84(this),
          _Internal::geodetic_wgs84(this).GetCachedSize(), target, stream);
      break;
    }
    case kEcefFixed: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::ecef_fixed(this),
          _Internal::ecef_fixed(this).GetCachedSize(), target, stream);
      break;
    }
    case kEcefInterpolation: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ecef_interpolation(this),
          _Internal::ecef_interpolation(this).GetCachedSize(), target, stream);
      break;
    }
    case kCartographicWaypoints: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::cartographic_waypoints(this),
          _Internal::cartographic_waypoints(this).GetCachedSize(), target, stream);
      break;
    }
    case kTle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::tle(this),
          _Internal::tle(this).GetCachedSize(), target, stream);
      break;
    }
    case kKeplerianElements: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::keplerian_elements(this),
          _Internal::keplerian_elements(this).GetCachedSize(), target, stream);
      break;
    }
    case kGeodeticMsl: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::geodetic_msl(this),
          _Internal::geodetic_msl(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelenographicMlr: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::selenographic_mlr(this),
          _Internal::selenographic_mlr(this).GetCachedSize(), target, stream);
      break;
    }
    case kStateVector: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::state_vector(this),
          _Internal::state_vector(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.type.Interval interval = 10 [json_name = "interval"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::interval(this),
        _Internal::interval(this).GetCachedSize(), target, stream);
  }

  // .aalyria.spacetime.api.common.StkEphemAndAttitudeFile stk_ephem_and_attitude_file = 11 [json_name = "stkEphemAndAttitudeFile"];
  if (type_case() == kStkEphemAndAttitudeFile) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::stk_ephem_and_attitude_file(this),
        _Internal::stk_ephem_and_attitude_file(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Motion)
  return target;
}

::size_t Motion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Motion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .google.type.Interval interval = 10 [json_name = "interval"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.interval_);
  }

  switch (type_case()) {
    // .aalyria.spacetime.api.common.GeodeticMsl geodetic_msl = 7 [json_name = "geodeticMsl"];
    case kGeodeticMsl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.geodetic_msl_);
      break;
    }
    // .aalyria.spacetime.api.common.GeodeticWgs84 geodetic_wgs84 = 1 [json_name = "geodeticWgs84"];
    case kGeodeticWgs84: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.geodetic_wgs84_);
      break;
    }
    // .aalyria.spacetime.api.common.PointAxes ecef_fixed = 2 [json_name = "ecefFixed"];
    case kEcefFixed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.ecef_fixed_);
      break;
    }
    // .aalyria.spacetime.api.common.PointAxesTemporalInterpolation ecef_interpolation = 3 [json_name = "ecefInterpolation"];
    case kEcefInterpolation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.ecef_interpolation_);
      break;
    }
    // .aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation cartographic_waypoints = 4 [json_name = "cartographicWaypoints"];
    case kCartographicWaypoints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.cartographic_waypoints_);
      break;
    }
    // .aalyria.spacetime.api.common.TwoLineElementSet tle = 5 [json_name = "tle"];
    case kTle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.tle_);
      break;
    }
    // .aalyria.spacetime.api.common.KeplerianElements keplerian_elements = 6 [json_name = "keplerianElements"];
    case kKeplerianElements: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.keplerian_elements_);
      break;
    }
    // .aalyria.spacetime.api.common.StateVector state_vector = 9 [json_name = "stateVector"];
    case kStateVector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.state_vector_);
      break;
    }
    // .aalyria.spacetime.api.common.SelenographicMlr selenographic_mlr = 8 [json_name = "selenographicMlr"];
    case kSelenographicMlr: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.selenographic_mlr_);
      break;
    }
    // .aalyria.spacetime.api.common.StkEphemAndAttitudeFile stk_ephem_and_attitude_file = 11 [json_name = "stkEphemAndAttitudeFile"];
    case kStkEphemAndAttitudeFile: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.stk_ephem_and_attitude_file_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Motion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Motion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Motion::GetClassData() const { return &_class_data_; }


void Motion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Motion*>(&to_msg);
  auto& from = static_cast<const Motion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Motion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_interval()->::google::type::Interval::MergeFrom(
        from._internal_interval());
  }
  switch (from.type_case()) {
    case kGeodeticMsl: {
      _this->_internal_mutable_geodetic_msl()->::aalyria::spacetime::api::common::GeodeticMsl::MergeFrom(
          from._internal_geodetic_msl());
      break;
    }
    case kGeodeticWgs84: {
      _this->_internal_mutable_geodetic_wgs84()->::aalyria::spacetime::api::common::GeodeticWgs84::MergeFrom(
          from._internal_geodetic_wgs84());
      break;
    }
    case kEcefFixed: {
      _this->_internal_mutable_ecef_fixed()->::aalyria::spacetime::api::common::PointAxes::MergeFrom(
          from._internal_ecef_fixed());
      break;
    }
    case kEcefInterpolation: {
      _this->_internal_mutable_ecef_interpolation()->::aalyria::spacetime::api::common::PointAxesTemporalInterpolation::MergeFrom(
          from._internal_ecef_interpolation());
      break;
    }
    case kCartographicWaypoints: {
      _this->_internal_mutable_cartographic_waypoints()->::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation::MergeFrom(
          from._internal_cartographic_waypoints());
      break;
    }
    case kTle: {
      _this->_internal_mutable_tle()->::aalyria::spacetime::api::common::TwoLineElementSet::MergeFrom(
          from._internal_tle());
      break;
    }
    case kKeplerianElements: {
      _this->_internal_mutable_keplerian_elements()->::aalyria::spacetime::api::common::KeplerianElements::MergeFrom(
          from._internal_keplerian_elements());
      break;
    }
    case kStateVector: {
      _this->_internal_mutable_state_vector()->::aalyria::spacetime::api::common::StateVector::MergeFrom(
          from._internal_state_vector());
      break;
    }
    case kSelenographicMlr: {
      _this->_internal_mutable_selenographic_mlr()->::aalyria::spacetime::api::common::SelenographicMlr::MergeFrom(
          from._internal_selenographic_mlr());
      break;
    }
    case kStkEphemAndAttitudeFile: {
      _this->_internal_mutable_stk_ephem_and_attitude_file()->::aalyria::spacetime::api::common::StkEphemAndAttitudeFile::MergeFrom(
          from._internal_stk_ephem_and_attitude_file());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Motion::CopyFrom(const Motion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Motion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Motion::IsInitialized() const {
  switch (type_case()) {
    case kGeodeticMsl: {
      break;
    }
    case kGeodeticWgs84: {
      break;
    }
    case kEcefFixed: {
      if (type_case() == kEcefFixed) {
        if (!_impl_.type_.ecef_fixed_->IsInitialized()) return false;
      }
      break;
    }
    case kEcefInterpolation: {
      if (type_case() == kEcefInterpolation) {
        if (!_impl_.type_.ecef_interpolation_->IsInitialized()) return false;
      }
      break;
    }
    case kCartographicWaypoints: {
      break;
    }
    case kTle: {
      break;
    }
    case kKeplerianElements: {
      break;
    }
    case kStateVector: {
      if (type_case() == kStateVector) {
        if (!_impl_.type_.state_vector_->IsInitialized()) return false;
      }
      break;
    }
    case kSelenographicMlr: {
      break;
    }
    case kStkEphemAndAttitudeFile: {
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void Motion::InternalSwap(Motion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.interval_, other->_impl_.interval_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Motion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[18]);
}
// ===================================================================

class MotionDefinition::_Internal {
 public:
};

MotionDefinition::MotionDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.MotionDefinition)
}
MotionDefinition::MotionDefinition(const MotionDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MotionDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.motions_){from._impl_.motions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.MotionDefinition)
}

inline void MotionDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.motions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MotionDefinition::~MotionDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.MotionDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MotionDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_motions()->~RepeatedPtrField();
}

void MotionDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MotionDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.MotionDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_motions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.Motion motions = 1 [json_name = "motions"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* MotionDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.MotionDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.Motion motions = 1 [json_name = "motions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_motions_size()); i < n; i++) {
    const auto& repfield = this->_internal_motions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.MotionDefinition)
  return target;
}

::size_t MotionDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.MotionDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.Motion motions = 1 [json_name = "motions"];
  total_size += 1UL * this->_internal_motions_size();
  for (const auto& msg : this->_internal_motions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotionDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MotionDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotionDefinition::GetClassData() const { return &_class_data_; }


void MotionDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MotionDefinition*>(&to_msg);
  auto& from = static_cast<const MotionDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.MotionDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_motions()->MergeFrom(from._internal_motions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotionDefinition::CopyFrom(const MotionDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.MotionDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionDefinition::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_motions()))
    return false;
  return true;
}

void MotionDefinition::InternalSwap(MotionDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_motions()->InternalSwap(other->_internal_mutable_motions());
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fcoordinates_2eproto_getter, &descriptor_table_api_2fcommon_2fcoordinates_2eproto_once,
      file_level_metadata_api_2fcommon_2fcoordinates_2eproto[19]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::GeodeticWgs84*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticWgs84 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::GeodeticWgs84 >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::GeodeticMsl*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticMsl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::GeodeticMsl >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::S2Cells*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::S2Cells >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::S2Cells >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Cartesian*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Cartesian >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Cartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::CartesianDot*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::CartesianDot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::CartesianDot >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Quaternion*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::YawPitchRoll*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::YawPitchRoll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::YawPitchRoll >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PointingVector*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PointingVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PointingVector >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PointAxes*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PointAxes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PointAxes >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PointAxesTemporal*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PointAxesTemporal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PointAxesTemporal >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::GeodeticWgs84Temporal*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::TwoLineElementSet*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::TwoLineElementSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::TwoLineElementSet >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::KeplerianElements*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::KeplerianElements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::KeplerianElements >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::StateVector*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::StateVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::StateVector >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::SelenographicMlr*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::SelenographicMlr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::SelenographicMlr >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Motion*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Motion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Motion >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::MotionDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::MotionDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::MotionDefinition >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
