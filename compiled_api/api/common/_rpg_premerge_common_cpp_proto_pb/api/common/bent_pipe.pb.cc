// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/bent_pipe.proto

#include "api/common/bent_pipe.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload_AntennaAndSignalProcessors::BentPipePayload_AntennaAndSignalProcessors(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transmit_signal_processors_)*/{}
  , /*decltype(_impl_.receive_signal_processors_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.antenna_)*/nullptr
  , /*decltype(_impl_.direction_)*/ 0
} {}
struct BentPipePayload_AntennaAndSignalProcessorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayload_AntennaAndSignalProcessorsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayload_AntennaAndSignalProcessorsDefaultTypeInternal() {}
  union {
    BentPipePayload_AntennaAndSignalProcessors _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayload_AntennaAndSignalProcessorsDefaultTypeInternal _BentPipePayload_AntennaAndSignalProcessors_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload_FixedPayload_Channel::BentPipePayload_FixedPayload_Channel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.antenna_and_signal_processors_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.signal_)*/nullptr} {}
struct BentPipePayload_FixedPayload_ChannelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayload_FixedPayload_ChannelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayload_FixedPayload_ChannelDefaultTypeInternal() {}
  union {
    BentPipePayload_FixedPayload_Channel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayload_FixedPayload_ChannelDefaultTypeInternal _BentPipePayload_FixedPayload_Channel_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload_FixedPayload_ChannelConfiguration::BentPipePayload_FixedPayload_ChannelConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_channel_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.output_channel_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.bandwidth_hz_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BentPipePayload_FixedPayload_ChannelConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayload_FixedPayload_ChannelConfigurationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayload_FixedPayload_ChannelConfigurationDefaultTypeInternal() {}
  union {
    BentPipePayload_FixedPayload_ChannelConfiguration _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayload_FixedPayload_ChannelConfigurationDefaultTypeInternal _BentPipePayload_FixedPayload_ChannelConfiguration_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload_FixedPayload::BentPipePayload_FixedPayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.channels_)*/{}
  , /*decltype(_impl_.channel_configurations_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BentPipePayload_FixedPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayload_FixedPayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayload_FixedPayloadDefaultTypeInternal() {}
  union {
    BentPipePayload_FixedPayload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayload_FixedPayloadDefaultTypeInternal _BentPipePayload_FixedPayload_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload_DigitalPayload::BentPipePayload_DigitalPayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.min_input_frequency_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.max_input_frequency_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.min_output_frequency_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.max_output_frequency_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.min_channel_bandwidth_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.max_channel_bandwidth_hz_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BentPipePayload_DigitalPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayload_DigitalPayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayload_DigitalPayloadDefaultTypeInternal() {}
  union {
    BentPipePayload_DigitalPayload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayload_DigitalPayloadDefaultTypeInternal _BentPipePayload_DigitalPayload_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BentPipePayload::BentPipePayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.antennas_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fixed_payload_)*/nullptr
  , /*decltype(_impl_.digital_payload_)*/nullptr
  , /*decltype(_impl_.max_processed_bandwidth_hz_)*/ 0u

  , /*decltype(_impl_.max_channels_)*/ 0u
} {}
struct BentPipePayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BentPipePayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BentPipePayloadDefaultTypeInternal() {}
  union {
    BentPipePayload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BentPipePayloadDefaultTypeInternal _BentPipePayload_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[6];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fcommon_2fbent_5fpipe_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fcommon_2fbent_5fpipe_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fcommon_2fbent_5fpipe_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_.antenna_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_.transmit_signal_processors_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_.receive_signal_processors_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors, _impl_.direction_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel, _impl_.signal_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel, _impl_.antenna_and_signal_processors_id_),
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration, _impl_.input_channel_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration, _impl_.output_channel_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration, _impl_.bandwidth_hz_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload, _impl_.channels_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload, _impl_.channel_configurations_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.min_input_frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.max_input_frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.min_output_frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.max_output_frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.min_channel_bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload, _impl_.max_channel_bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.antennas_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.fixed_payload_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.digital_payload_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.max_processed_bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BentPipePayload, _impl_.max_channels_),
    ~0u,
    ~0u,
    0,
    1,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 13, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors)},
        { 18, 29, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel)},
        { 32, -1, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration)},
        { 43, -1, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload_FixedPayload)},
        { 53, -1, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload)},
        { 67, 81, -1, sizeof(::aalyria::spacetime::api::common::BentPipePayload)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::common::_BentPipePayload_AntennaAndSignalProcessors_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BentPipePayload_FixedPayload_Channel_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BentPipePayload_FixedPayload_ChannelConfiguration_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BentPipePayload_FixedPayload_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BentPipePayload_DigitalPayload_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BentPipePayload_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fcommon_2fbent_5fpipe_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\032api/common/bent_pipe.proto\022\034aalyria.sp"
    "acetime.api.common\032!api/common/platform_"
    "antenna.proto\032\031api/common/wireless.proto"
    "\032\"api/common/wireless_receiver.proto\032%ap"
    "i/common/wireless_transmitter.proto\"\303\016\n\017"
    "BentPipePayload\022\016\n\002id\030\001 \001(\tR\002id\022d\n\010anten"
    "nas\030\002 \003(\0132H.aalyria.spacetime.api.common"
    ".BentPipePayload.AntennaAndSignalProcess"
    "orsR\010antennas\022_\n\rfixed_payload\030\003 \001(\0132:.a"
    "alyria.spacetime.api.common.BentPipePayl"
    "oad.FixedPayloadR\014fixedPayload\022e\n\017digita"
    "l_payload\030\004 \001(\0132<.aalyria.spacetime.api."
    "common.BentPipePayload.DigitalPayloadR\016d"
    "igitalPayload\022;\n\032max_processed_bandwidth"
    "_hz\030\005 \001(\rR\027maxProcessedBandwidthHz\022!\n\014ma"
    "x_channels\030\006 \001(\rR\013maxChannels\032\206\004\n\032Antenn"
    "aAndSignalProcessors\022\016\n\002id\030\001 \001(\tR\002id\022I\n\007"
    "antenna\030\002 \001(\0132/.aalyria.spacetime.api.co"
    "mmon.AntennaDefinitionR\007antenna\022s\n\032trans"
    "mit_signal_processors\030\003 \003(\01325.aalyria.sp"
    "acetime.api.common.TransmitSignalProcess"
    "orR\030transmitSignalProcessors\022p\n\031receive_"
    "signal_processors\030\004 \003(\01324.aalyria.spacet"
    "ime.api.common.ReceiveSignalProcessorR\027r"
    "eceiveSignalProcessors\022p\n\tdirection\030\005 \001("
    "\0162R.aalyria.spacetime.api.common.BentPip"
    "ePayload.AntennaAndSignalProcessors.Dire"
    "ctionR\tdirection\"4\n\tDirection\022\031\n\025DIRECTI"
    "ON_UNSPECIFIED\020\000\022\005\n\001A\020\001\022\005\n\001B\020\002\032\253\004\n\014Fixed"
    "Payload\022^\n\010channels\030\001 \003(\0132B.aalyria.spac"
    "etime.api.common.BentPipePayload.FixedPa"
    "yload.ChannelR\010channels\022\206\001\n\026channel_conf"
    "igurations\030\003 \003(\0132O.aalyria.spacetime.api"
    ".common.BentPipePayload.FixedPayload.Cha"
    "nnelConfigurationR\025channelConfigurations"
    "\032\237\001\n\007Channel\022\016\n\002id\030\001 \001(\tR\002id\022<\n\006signal\030\002"
    " \001(\0132$.aalyria.spacetime.api.common.Sign"
    "alR\006signal\022F\n antenna_and_signal_process"
    "ors_id\030\003 \001(\tR\034antennaAndSignalProcessors"
    "Id\032\217\001\n\024ChannelConfiguration\022(\n\020input_cha"
    "nnel_id\030\001 \001(\tR\016inputChannelId\022*\n\021output_"
    "channel_id\030\002 \001(\tR\017outputChannelId\022!\n\014ban"
    "dwidth_hz\030\003 \001(\001R\013bandwidthHz\032\332\002\n\016Digital"
    "Payload\0223\n\026min_input_frequency_hz\030\001 \001(\004R"
    "\023minInputFrequencyHz\0223\n\026max_input_freque"
    "ncy_hz\030\002 \001(\004R\023maxInputFrequencyHz\0225\n\027min"
    "_output_frequency_hz\030\003 \001(\004R\024minOutputFre"
    "quencyHz\0225\n\027max_output_frequency_hz\030\004 \001("
    "\004R\024maxOutputFrequencyHz\0227\n\030min_channel_b"
    "andwidth_hz\030\005 \001(\004R\025minChannelBandwidthHz"
    "\0227\n\030max_channel_bandwidth_hz\030\006 \001(\004R\025maxC"
    "hannelBandwidthHzBD\n com.aalyria.spaceti"
    "me.api.commonZ aalyria.com/spacetime/api"
    "/commonb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_deps[4] =
    {
        &::descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_5ftransmitter_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto = {
    false,
    false,
    2135,
    descriptor_table_protodef_api_2fcommon_2fbent_5fpipe_2eproto,
    "api/common/bent_pipe.proto",
    &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
    descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_deps,
    4,
    6,
    schemas,
    file_default_instances,
    TableStruct_api_2fcommon_2fbent_5fpipe_2eproto::offsets,
    file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto,
    file_level_enum_descriptors_api_2fcommon_2fbent_5fpipe_2eproto,
    file_level_service_descriptors_api_2fcommon_2fbent_5fpipe_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter() {
  return &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fcommon_2fbent_5fpipe_2eproto(&descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BentPipePayload_AntennaAndSignalProcessors_Direction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2fbent_5fpipe_2eproto[0];
}
bool BentPipePayload_AntennaAndSignalProcessors_Direction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr BentPipePayload_AntennaAndSignalProcessors_Direction BentPipePayload_AntennaAndSignalProcessors::DIRECTION_UNSPECIFIED;
constexpr BentPipePayload_AntennaAndSignalProcessors_Direction BentPipePayload_AntennaAndSignalProcessors::A;
constexpr BentPipePayload_AntennaAndSignalProcessors_Direction BentPipePayload_AntennaAndSignalProcessors::B;
constexpr BentPipePayload_AntennaAndSignalProcessors_Direction BentPipePayload_AntennaAndSignalProcessors::Direction_MIN;
constexpr BentPipePayload_AntennaAndSignalProcessors_Direction BentPipePayload_AntennaAndSignalProcessors::Direction_MAX;
constexpr int BentPipePayload_AntennaAndSignalProcessors::Direction_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class BentPipePayload_AntennaAndSignalProcessors::_Internal {
 public:
  using HasBits = decltype(std::declval<BentPipePayload_AntennaAndSignalProcessors>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BentPipePayload_AntennaAndSignalProcessors, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::AntennaDefinition& antenna(const BentPipePayload_AntennaAndSignalProcessors* msg);
  static void set_has_antenna(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::aalyria::spacetime::api::common::AntennaDefinition&
BentPipePayload_AntennaAndSignalProcessors::_Internal::antenna(const BentPipePayload_AntennaAndSignalProcessors* msg) {
  return *msg->_impl_.antenna_;
}
void BentPipePayload_AntennaAndSignalProcessors::clear_antenna() {
  if (_impl_.antenna_ != nullptr) _impl_.antenna_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void BentPipePayload_AntennaAndSignalProcessors::clear_transmit_signal_processors() {
  _internal_mutable_transmit_signal_processors()->Clear();
}
void BentPipePayload_AntennaAndSignalProcessors::clear_receive_signal_processors() {
  _internal_mutable_receive_signal_processors()->Clear();
}
BentPipePayload_AntennaAndSignalProcessors::BentPipePayload_AntennaAndSignalProcessors(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
}
BentPipePayload_AntennaAndSignalProcessors::BentPipePayload_AntennaAndSignalProcessors(const BentPipePayload_AntennaAndSignalProcessors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BentPipePayload_AntennaAndSignalProcessors* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmit_signal_processors_){from._impl_.transmit_signal_processors_}
    , decltype(_impl_.receive_signal_processors_){from._impl_.receive_signal_processors_}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.antenna_){nullptr}
    , decltype(_impl_.direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.antenna_ = new ::aalyria::spacetime::api::common::AntennaDefinition(*from._impl_.antenna_);
  }
  _this->_impl_.direction_ = from._impl_.direction_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
}

inline void BentPipePayload_AntennaAndSignalProcessors::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmit_signal_processors_){arena}
    , decltype(_impl_.receive_signal_processors_){arena}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.antenna_){nullptr}
    , decltype(_impl_.direction_) { 0 }

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BentPipePayload_AntennaAndSignalProcessors::~BentPipePayload_AntennaAndSignalProcessors() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload_AntennaAndSignalProcessors::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_transmit_signal_processors()->~RepeatedPtrField();
  _internal_mutable_receive_signal_processors()->~RepeatedPtrField();
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.antenna_;
}

void BentPipePayload_AntennaAndSignalProcessors::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload_AntennaAndSignalProcessors::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_transmit_signal_processors()->Clear();
  _internal_mutable_receive_signal_processors()->Clear();
  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.antenna_ != nullptr);
    _impl_.antenna_->Clear();
  }
  _impl_.direction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload_AntennaAndSignalProcessors::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors.id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.AntennaDefinition antenna = 2 [json_name = "antenna"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_antenna(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.TransmitSignalProcessor transmit_signal_processors = 3 [json_name = "transmitSignalProcessors"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transmit_signal_processors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor receive_signal_processors = 4 [json_name = "receiveSignalProcessors"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_receive_signal_processors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors.Direction direction = 5 [json_name = "direction"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_direction(static_cast<::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors_Direction>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload_AntennaAndSignalProcessors::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .aalyria.spacetime.api.common.AntennaDefinition antenna = 2 [json_name = "antenna"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::antenna(this),
        _Internal::antenna(this).GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.TransmitSignalProcessor transmit_signal_processors = 3 [json_name = "transmitSignalProcessors"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transmit_signal_processors_size()); i < n; i++) {
    const auto& repfield = this->_internal_transmit_signal_processors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor receive_signal_processors = 4 [json_name = "receiveSignalProcessors"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_receive_signal_processors_size()); i < n; i++) {
    const auto& repfield = this->_internal_receive_signal_processors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors.Direction direction = 5 [json_name = "direction"];
  if (this->_internal_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  return target;
}

::size_t BentPipePayload_AntennaAndSignalProcessors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.TransmitSignalProcessor transmit_signal_processors = 3 [json_name = "transmitSignalProcessors"];
  total_size += 1UL * this->_internal_transmit_signal_processors_size();
  for (const auto& msg : this->_internal_transmit_signal_processors()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor receive_signal_processors = 4 [json_name = "receiveSignalProcessors"];
  total_size += 1UL * this->_internal_receive_signal_processors_size();
  for (const auto& msg : this->_internal_receive_signal_processors()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }

  // .aalyria.spacetime.api.common.AntennaDefinition antenna = 2 [json_name = "antenna"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.antenna_);
  }

  // .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors.Direction direction = 5 [json_name = "direction"];
  if (this->_internal_direction() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload_AntennaAndSignalProcessors::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload_AntennaAndSignalProcessors::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload_AntennaAndSignalProcessors::GetClassData() const { return &_class_data_; }


void BentPipePayload_AntennaAndSignalProcessors::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload_AntennaAndSignalProcessors*>(&to_msg);
  auto& from = static_cast<const BentPipePayload_AntennaAndSignalProcessors&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transmit_signal_processors()->MergeFrom(from._internal_transmit_signal_processors());
  _this->_internal_mutable_receive_signal_processors()->MergeFrom(from._internal_receive_signal_processors());
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_antenna()->::aalyria::spacetime::api::common::AntennaDefinition::MergeFrom(
        from._internal_antenna());
  }
  if (from._internal_direction() != 0) {
    _this->_internal_set_direction(from._internal_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload_AntennaAndSignalProcessors::CopyFrom(const BentPipePayload_AntennaAndSignalProcessors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload_AntennaAndSignalProcessors::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.antenna_->IsInitialized()) return false;
  }
  return true;
}

void BentPipePayload_AntennaAndSignalProcessors::InternalSwap(BentPipePayload_AntennaAndSignalProcessors* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_transmit_signal_processors()->InternalSwap(other->_internal_mutable_transmit_signal_processors());
  _internal_mutable_receive_signal_processors()->InternalSwap(other->_internal_mutable_receive_signal_processors());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BentPipePayload_AntennaAndSignalProcessors, _impl_.direction_)
      + sizeof(BentPipePayload_AntennaAndSignalProcessors::_impl_.direction_)
      - PROTOBUF_FIELD_OFFSET(BentPipePayload_AntennaAndSignalProcessors, _impl_.antenna_)>(
          reinterpret_cast<char*>(&_impl_.antenna_),
          reinterpret_cast<char*>(&other->_impl_.antenna_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload_AntennaAndSignalProcessors::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[0]);
}
// ===================================================================

class BentPipePayload_FixedPayload_Channel::_Internal {
 public:
  using HasBits = decltype(std::declval<BentPipePayload_FixedPayload_Channel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BentPipePayload_FixedPayload_Channel, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::Signal& signal(const BentPipePayload_FixedPayload_Channel* msg);
  static void set_has_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::aalyria::spacetime::api::common::Signal&
BentPipePayload_FixedPayload_Channel::_Internal::signal(const BentPipePayload_FixedPayload_Channel* msg) {
  return *msg->_impl_.signal_;
}
void BentPipePayload_FixedPayload_Channel::clear_signal() {
  if (_impl_.signal_ != nullptr) _impl_.signal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
BentPipePayload_FixedPayload_Channel::BentPipePayload_FixedPayload_Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
}
BentPipePayload_FixedPayload_Channel::BentPipePayload_FixedPayload_Channel(const BentPipePayload_FixedPayload_Channel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BentPipePayload_FixedPayload_Channel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.antenna_and_signal_processors_id_) {}

    , decltype(_impl_.signal_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.antenna_and_signal_processors_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.antenna_and_signal_processors_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_antenna_and_signal_processors_id().empty()) {
    _this->_impl_.antenna_and_signal_processors_id_.Set(from._internal_antenna_and_signal_processors_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.signal_ = new ::aalyria::spacetime::api::common::Signal(*from._impl_.signal_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
}

inline void BentPipePayload_FixedPayload_Channel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.antenna_and_signal_processors_id_) {}

    , decltype(_impl_.signal_){nullptr}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.antenna_and_signal_processors_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.antenna_and_signal_processors_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BentPipePayload_FixedPayload_Channel::~BentPipePayload_FixedPayload_Channel() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload_FixedPayload_Channel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.antenna_and_signal_processors_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.signal_;
}

void BentPipePayload_FixedPayload_Channel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload_FixedPayload_Channel::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.antenna_and_signal_processors_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.signal_ != nullptr);
    _impl_.signal_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload_FixedPayload_Channel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel.id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Signal signal = 2 [json_name = "signal"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string antenna_and_signal_processors_id = 3 [json_name = "antennaAndSignalProcessorsId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_antenna_and_signal_processors_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel.antenna_and_signal_processors_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload_FixedPayload_Channel::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .aalyria.spacetime.api.common.Signal signal = 2 [json_name = "signal"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signal(this),
        _Internal::signal(this).GetCachedSize(), target, stream);
  }

  // string antenna_and_signal_processors_id = 3 [json_name = "antennaAndSignalProcessorsId"];
  if (!this->_internal_antenna_and_signal_processors_id().empty()) {
    const std::string& _s = this->_internal_antenna_and_signal_processors_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel.antenna_and_signal_processors_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  return target;
}

::size_t BentPipePayload_FixedPayload_Channel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }

  // string antenna_and_signal_processors_id = 3 [json_name = "antennaAndSignalProcessorsId"];
  if (!this->_internal_antenna_and_signal_processors_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_antenna_and_signal_processors_id());
  }

  // .aalyria.spacetime.api.common.Signal signal = 2 [json_name = "signal"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.signal_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload_FixedPayload_Channel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload_FixedPayload_Channel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload_FixedPayload_Channel::GetClassData() const { return &_class_data_; }


void BentPipePayload_FixedPayload_Channel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload_FixedPayload_Channel*>(&to_msg);
  auto& from = static_cast<const BentPipePayload_FixedPayload_Channel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_antenna_and_signal_processors_id().empty()) {
    _this->_internal_set_antenna_and_signal_processors_id(from._internal_antenna_and_signal_processors_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_signal()->::aalyria::spacetime::api::common::Signal::MergeFrom(
        from._internal_signal());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload_FixedPayload_Channel::CopyFrom(const BentPipePayload_FixedPayload_Channel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload_FixedPayload_Channel::IsInitialized() const {
  return true;
}

void BentPipePayload_FixedPayload_Channel::InternalSwap(BentPipePayload_FixedPayload_Channel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.antenna_and_signal_processors_id_, lhs_arena,
                                       &other->_impl_.antenna_and_signal_processors_id_, rhs_arena);
  swap(_impl_.signal_, other->_impl_.signal_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload_FixedPayload_Channel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[1]);
}
// ===================================================================

class BentPipePayload_FixedPayload_ChannelConfiguration::_Internal {
 public:
};

BentPipePayload_FixedPayload_ChannelConfiguration::BentPipePayload_FixedPayload_ChannelConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
}
BentPipePayload_FixedPayload_ChannelConfiguration::BentPipePayload_FixedPayload_ChannelConfiguration(const BentPipePayload_FixedPayload_ChannelConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BentPipePayload_FixedPayload_ChannelConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.input_channel_id_) {}

    , decltype(_impl_.output_channel_id_) {}

    , decltype(_impl_.bandwidth_hz_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.input_channel_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.input_channel_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_input_channel_id().empty()) {
    _this->_impl_.input_channel_id_.Set(from._internal_input_channel_id(), _this->GetArenaForAllocation());
  }
  _impl_.output_channel_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.output_channel_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_output_channel_id().empty()) {
    _this->_impl_.output_channel_id_.Set(from._internal_output_channel_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.bandwidth_hz_ = from._impl_.bandwidth_hz_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
}

inline void BentPipePayload_FixedPayload_ChannelConfiguration::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.input_channel_id_) {}

    , decltype(_impl_.output_channel_id_) {}

    , decltype(_impl_.bandwidth_hz_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.input_channel_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.input_channel_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.output_channel_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.output_channel_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BentPipePayload_FixedPayload_ChannelConfiguration::~BentPipePayload_FixedPayload_ChannelConfiguration() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload_FixedPayload_ChannelConfiguration::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_channel_id_.Destroy();
  _impl_.output_channel_id_.Destroy();
}

void BentPipePayload_FixedPayload_ChannelConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload_FixedPayload_ChannelConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_channel_id_.ClearToEmpty();
  _impl_.output_channel_id_.ClearToEmpty();
  _impl_.bandwidth_hz_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload_FixedPayload_ChannelConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string input_channel_id = 1 [json_name = "inputChannelId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_input_channel_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration.input_channel_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string output_channel_id = 2 [json_name = "outputChannelId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_output_channel_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration.output_channel_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // double bandwidth_hz = 3 [json_name = "bandwidthHz"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _impl_.bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload_FixedPayload_ChannelConfiguration::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string input_channel_id = 1 [json_name = "inputChannelId"];
  if (!this->_internal_input_channel_id().empty()) {
    const std::string& _s = this->_internal_input_channel_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration.input_channel_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string output_channel_id = 2 [json_name = "outputChannelId"];
  if (!this->_internal_output_channel_id().empty()) {
    const std::string& _s = this->_internal_output_channel_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration.output_channel_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // double bandwidth_hz = 3 [json_name = "bandwidthHz"];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_bandwidth_hz = this->_internal_bandwidth_hz();
  ::uint64_t raw_bandwidth_hz;
  memcpy(&raw_bandwidth_hz, &tmp_bandwidth_hz, sizeof(tmp_bandwidth_hz));
  if (raw_bandwidth_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_bandwidth_hz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  return target;
}

::size_t BentPipePayload_FixedPayload_ChannelConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string input_channel_id = 1 [json_name = "inputChannelId"];
  if (!this->_internal_input_channel_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_input_channel_id());
  }

  // string output_channel_id = 2 [json_name = "outputChannelId"];
  if (!this->_internal_output_channel_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_output_channel_id());
  }

  // double bandwidth_hz = 3 [json_name = "bandwidthHz"];
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_bandwidth_hz = this->_internal_bandwidth_hz();
  ::uint64_t raw_bandwidth_hz;
  memcpy(&raw_bandwidth_hz, &tmp_bandwidth_hz, sizeof(tmp_bandwidth_hz));
  if (raw_bandwidth_hz != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload_FixedPayload_ChannelConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload_FixedPayload_ChannelConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload_FixedPayload_ChannelConfiguration::GetClassData() const { return &_class_data_; }


void BentPipePayload_FixedPayload_ChannelConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload_FixedPayload_ChannelConfiguration*>(&to_msg);
  auto& from = static_cast<const BentPipePayload_FixedPayload_ChannelConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_input_channel_id().empty()) {
    _this->_internal_set_input_channel_id(from._internal_input_channel_id());
  }
  if (!from._internal_output_channel_id().empty()) {
    _this->_internal_set_output_channel_id(from._internal_output_channel_id());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_bandwidth_hz = from._internal_bandwidth_hz();
  ::uint64_t raw_bandwidth_hz;
  memcpy(&raw_bandwidth_hz, &tmp_bandwidth_hz, sizeof(tmp_bandwidth_hz));
  if (raw_bandwidth_hz != 0) {
    _this->_internal_set_bandwidth_hz(from._internal_bandwidth_hz());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload_FixedPayload_ChannelConfiguration::CopyFrom(const BentPipePayload_FixedPayload_ChannelConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload_FixedPayload_ChannelConfiguration::IsInitialized() const {
  return true;
}

void BentPipePayload_FixedPayload_ChannelConfiguration::InternalSwap(BentPipePayload_FixedPayload_ChannelConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.input_channel_id_, lhs_arena,
                                       &other->_impl_.input_channel_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.output_channel_id_, lhs_arena,
                                       &other->_impl_.output_channel_id_, rhs_arena);

  swap(_impl_.bandwidth_hz_, other->_impl_.bandwidth_hz_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload_FixedPayload_ChannelConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[2]);
}
// ===================================================================

class BentPipePayload_FixedPayload::_Internal {
 public:
};

BentPipePayload_FixedPayload::BentPipePayload_FixedPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
}
BentPipePayload_FixedPayload::BentPipePayload_FixedPayload(const BentPipePayload_FixedPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BentPipePayload_FixedPayload* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.channels_){from._impl_.channels_}
    , decltype(_impl_.channel_configurations_){from._impl_.channel_configurations_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
}

inline void BentPipePayload_FixedPayload::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.channels_){arena}
    , decltype(_impl_.channel_configurations_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BentPipePayload_FixedPayload::~BentPipePayload_FixedPayload() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload_FixedPayload::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_channels()->~RepeatedPtrField();
  _internal_mutable_channel_configurations()->~RepeatedPtrField();
}

void BentPipePayload_FixedPayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload_FixedPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_channels()->Clear();
  _internal_mutable_channel_configurations()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload_FixedPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel channels = 1 [json_name = "channels"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration channel_configurations = 3 [json_name = "channelConfigurations"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_channel_configurations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload_FixedPayload::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel channels = 1 [json_name = "channels"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_channels_size()); i < n; i++) {
    const auto& repfield = this->_internal_channels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration channel_configurations = 3 [json_name = "channelConfigurations"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_channel_configurations_size()); i < n; i++) {
    const auto& repfield = this->_internal_channel_configurations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  return target;
}

::size_t BentPipePayload_FixedPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.Channel channels = 1 [json_name = "channels"];
  total_size += 1UL * this->_internal_channels_size();
  for (const auto& msg : this->_internal_channels()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.common.BentPipePayload.FixedPayload.ChannelConfiguration channel_configurations = 3 [json_name = "channelConfigurations"];
  total_size += 1UL * this->_internal_channel_configurations_size();
  for (const auto& msg : this->_internal_channel_configurations()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload_FixedPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload_FixedPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload_FixedPayload::GetClassData() const { return &_class_data_; }


void BentPipePayload_FixedPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload_FixedPayload*>(&to_msg);
  auto& from = static_cast<const BentPipePayload_FixedPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_channels()->MergeFrom(from._internal_channels());
  _this->_internal_mutable_channel_configurations()->MergeFrom(from._internal_channel_configurations());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload_FixedPayload::CopyFrom(const BentPipePayload_FixedPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload.FixedPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload_FixedPayload::IsInitialized() const {
  return true;
}

void BentPipePayload_FixedPayload::InternalSwap(BentPipePayload_FixedPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_channels()->InternalSwap(other->_internal_mutable_channels());
  _internal_mutable_channel_configurations()->InternalSwap(other->_internal_mutable_channel_configurations());
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload_FixedPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[3]);
}
// ===================================================================

class BentPipePayload_DigitalPayload::_Internal {
 public:
};

BentPipePayload_DigitalPayload::BentPipePayload_DigitalPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
}
BentPipePayload_DigitalPayload::BentPipePayload_DigitalPayload(const BentPipePayload_DigitalPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
}

inline void BentPipePayload_DigitalPayload::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.min_input_frequency_hz_) { ::uint64_t{0u} }

    , decltype(_impl_.max_input_frequency_hz_) { ::uint64_t{0u} }

    , decltype(_impl_.min_output_frequency_hz_) { ::uint64_t{0u} }

    , decltype(_impl_.max_output_frequency_hz_) { ::uint64_t{0u} }

    , decltype(_impl_.min_channel_bandwidth_hz_) { ::uint64_t{0u} }

    , decltype(_impl_.max_channel_bandwidth_hz_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BentPipePayload_DigitalPayload::~BentPipePayload_DigitalPayload() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload_DigitalPayload::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void BentPipePayload_DigitalPayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload_DigitalPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.min_input_frequency_hz_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_channel_bandwidth_hz_) -
      reinterpret_cast<char*>(&_impl_.min_input_frequency_hz_)) + sizeof(_impl_.max_channel_bandwidth_hz_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload_DigitalPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 min_input_frequency_hz = 1 [json_name = "minInputFrequencyHz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.min_input_frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 max_input_frequency_hz = 2 [json_name = "maxInputFrequencyHz"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.max_input_frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 min_output_frequency_hz = 3 [json_name = "minOutputFrequencyHz"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.min_output_frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 max_output_frequency_hz = 4 [json_name = "maxOutputFrequencyHz"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.max_output_frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 min_channel_bandwidth_hz = 5 [json_name = "minChannelBandwidthHz"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.min_channel_bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 max_channel_bandwidth_hz = 6 [json_name = "maxChannelBandwidthHz"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.max_channel_bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload_DigitalPayload::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 min_input_frequency_hz = 1 [json_name = "minInputFrequencyHz"];
  if (this->_internal_min_input_frequency_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min_input_frequency_hz(), target);
  }

  // uint64 max_input_frequency_hz = 2 [json_name = "maxInputFrequencyHz"];
  if (this->_internal_max_input_frequency_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max_input_frequency_hz(), target);
  }

  // uint64 min_output_frequency_hz = 3 [json_name = "minOutputFrequencyHz"];
  if (this->_internal_min_output_frequency_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_min_output_frequency_hz(), target);
  }

  // uint64 max_output_frequency_hz = 4 [json_name = "maxOutputFrequencyHz"];
  if (this->_internal_max_output_frequency_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_max_output_frequency_hz(), target);
  }

  // uint64 min_channel_bandwidth_hz = 5 [json_name = "minChannelBandwidthHz"];
  if (this->_internal_min_channel_bandwidth_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_min_channel_bandwidth_hz(), target);
  }

  // uint64 max_channel_bandwidth_hz = 6 [json_name = "maxChannelBandwidthHz"];
  if (this->_internal_max_channel_bandwidth_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_max_channel_bandwidth_hz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  return target;
}

::size_t BentPipePayload_DigitalPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 min_input_frequency_hz = 1 [json_name = "minInputFrequencyHz"];
  if (this->_internal_min_input_frequency_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min_input_frequency_hz());
  }

  // uint64 max_input_frequency_hz = 2 [json_name = "maxInputFrequencyHz"];
  if (this->_internal_max_input_frequency_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_max_input_frequency_hz());
  }

  // uint64 min_output_frequency_hz = 3 [json_name = "minOutputFrequencyHz"];
  if (this->_internal_min_output_frequency_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min_output_frequency_hz());
  }

  // uint64 max_output_frequency_hz = 4 [json_name = "maxOutputFrequencyHz"];
  if (this->_internal_max_output_frequency_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_max_output_frequency_hz());
  }

  // uint64 min_channel_bandwidth_hz = 5 [json_name = "minChannelBandwidthHz"];
  if (this->_internal_min_channel_bandwidth_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_min_channel_bandwidth_hz());
  }

  // uint64 max_channel_bandwidth_hz = 6 [json_name = "maxChannelBandwidthHz"];
  if (this->_internal_max_channel_bandwidth_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_max_channel_bandwidth_hz());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload_DigitalPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload_DigitalPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload_DigitalPayload::GetClassData() const { return &_class_data_; }


void BentPipePayload_DigitalPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload_DigitalPayload*>(&to_msg);
  auto& from = static_cast<const BentPipePayload_DigitalPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_min_input_frequency_hz() != 0) {
    _this->_internal_set_min_input_frequency_hz(from._internal_min_input_frequency_hz());
  }
  if (from._internal_max_input_frequency_hz() != 0) {
    _this->_internal_set_max_input_frequency_hz(from._internal_max_input_frequency_hz());
  }
  if (from._internal_min_output_frequency_hz() != 0) {
    _this->_internal_set_min_output_frequency_hz(from._internal_min_output_frequency_hz());
  }
  if (from._internal_max_output_frequency_hz() != 0) {
    _this->_internal_set_max_output_frequency_hz(from._internal_max_output_frequency_hz());
  }
  if (from._internal_min_channel_bandwidth_hz() != 0) {
    _this->_internal_set_min_channel_bandwidth_hz(from._internal_min_channel_bandwidth_hz());
  }
  if (from._internal_max_channel_bandwidth_hz() != 0) {
    _this->_internal_set_max_channel_bandwidth_hz(from._internal_max_channel_bandwidth_hz());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload_DigitalPayload::CopyFrom(const BentPipePayload_DigitalPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload.DigitalPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload_DigitalPayload::IsInitialized() const {
  return true;
}

void BentPipePayload_DigitalPayload::InternalSwap(BentPipePayload_DigitalPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BentPipePayload_DigitalPayload, _impl_.max_channel_bandwidth_hz_)
      + sizeof(BentPipePayload_DigitalPayload::_impl_.max_channel_bandwidth_hz_)
      - PROTOBUF_FIELD_OFFSET(BentPipePayload_DigitalPayload, _impl_.min_input_frequency_hz_)>(
          reinterpret_cast<char*>(&_impl_.min_input_frequency_hz_),
          reinterpret_cast<char*>(&other->_impl_.min_input_frequency_hz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload_DigitalPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[4]);
}
// ===================================================================

class BentPipePayload::_Internal {
 public:
  using HasBits = decltype(std::declval<BentPipePayload>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BentPipePayload, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload& fixed_payload(const BentPipePayload* msg);
  static void set_has_fixed_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload& digital_payload(const BentPipePayload* msg);
  static void set_has_digital_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload&
BentPipePayload::_Internal::fixed_payload(const BentPipePayload* msg) {
  return *msg->_impl_.fixed_payload_;
}
const ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload&
BentPipePayload::_Internal::digital_payload(const BentPipePayload* msg) {
  return *msg->_impl_.digital_payload_;
}
BentPipePayload::BentPipePayload(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BentPipePayload)
}
BentPipePayload::BentPipePayload(const BentPipePayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BentPipePayload* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.antennas_){from._impl_.antennas_}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.fixed_payload_){nullptr}
    , decltype(_impl_.digital_payload_){nullptr}
    , decltype(_impl_.max_processed_bandwidth_hz_) {}

    , decltype(_impl_.max_channels_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.fixed_payload_ = new ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload(*from._impl_.fixed_payload_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.digital_payload_ = new ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload(*from._impl_.digital_payload_);
  }
  ::memcpy(&_impl_.max_processed_bandwidth_hz_, &from._impl_.max_processed_bandwidth_hz_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.max_channels_) -
    reinterpret_cast<char*>(&_impl_.max_processed_bandwidth_hz_)) + sizeof(_impl_.max_channels_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BentPipePayload)
}

inline void BentPipePayload::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.antennas_){arena}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.fixed_payload_){nullptr}
    , decltype(_impl_.digital_payload_){nullptr}
    , decltype(_impl_.max_processed_bandwidth_hz_) { 0u }

    , decltype(_impl_.max_channels_) { 0u }

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BentPipePayload::~BentPipePayload() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BentPipePayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BentPipePayload::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_antennas()->~RepeatedPtrField();
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fixed_payload_;
  if (this != internal_default_instance()) delete _impl_.digital_payload_;
}

void BentPipePayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BentPipePayload::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BentPipePayload)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_antennas()->Clear();
  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.fixed_payload_ != nullptr);
      _impl_.fixed_payload_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.digital_payload_ != nullptr);
      _impl_.digital_payload_->Clear();
    }
  }
  ::memset(&_impl_.max_processed_bandwidth_hz_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_channels_) -
      reinterpret_cast<char*>(&_impl_.max_processed_bandwidth_hz_)) + sizeof(_impl_.max_channels_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BentPipePayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BentPipePayload.id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors antennas = 2 [json_name = "antennas"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_antennas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.BentPipePayload.FixedPayload fixed_payload = 3 [json_name = "fixedPayload"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed_payload(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.BentPipePayload.DigitalPayload digital_payload = 4 [json_name = "digitalPayload"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_digital_payload(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 max_processed_bandwidth_hz = 5 [json_name = "maxProcessedBandwidthHz"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.max_processed_bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 max_channels = 6 [json_name = "maxChannels"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.max_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BentPipePayload::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BentPipePayload)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "aalyria.spacetime.api.common.BentPipePayload.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors antennas = 2 [json_name = "antennas"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_antennas_size()); i < n; i++) {
    const auto& repfield = this->_internal_antennas(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .aalyria.spacetime.api.common.BentPipePayload.FixedPayload fixed_payload = 3 [json_name = "fixedPayload"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fixed_payload(this),
        _Internal::fixed_payload(this).GetCachedSize(), target, stream);
  }

  // .aalyria.spacetime.api.common.BentPipePayload.DigitalPayload digital_payload = 4 [json_name = "digitalPayload"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::digital_payload(this),
        _Internal::digital_payload(this).GetCachedSize(), target, stream);
  }

  // uint32 max_processed_bandwidth_hz = 5 [json_name = "maxProcessedBandwidthHz"];
  if (this->_internal_max_processed_bandwidth_hz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_max_processed_bandwidth_hz(), target);
  }

  // uint32 max_channels = 6 [json_name = "maxChannels"];
  if (this->_internal_max_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_max_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BentPipePayload)
  return target;
}

::size_t BentPipePayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BentPipePayload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.BentPipePayload.AntennaAndSignalProcessors antennas = 2 [json_name = "antennas"];
  total_size += 1UL * this->_internal_antennas_size();
  for (const auto& msg : this->_internal_antennas()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1 [json_name = "id"];
  if (!this->_internal_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .aalyria.spacetime.api.common.BentPipePayload.FixedPayload fixed_payload = 3 [json_name = "fixedPayload"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fixed_payload_);
    }

    // .aalyria.spacetime.api.common.BentPipePayload.DigitalPayload digital_payload = 4 [json_name = "digitalPayload"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.digital_payload_);
    }

  }
  // uint32 max_processed_bandwidth_hz = 5 [json_name = "maxProcessedBandwidthHz"];
  if (this->_internal_max_processed_bandwidth_hz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_max_processed_bandwidth_hz());
  }

  // uint32 max_channels = 6 [json_name = "maxChannels"];
  if (this->_internal_max_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_max_channels());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BentPipePayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BentPipePayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BentPipePayload::GetClassData() const { return &_class_data_; }


void BentPipePayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BentPipePayload*>(&to_msg);
  auto& from = static_cast<const BentPipePayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BentPipePayload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_antennas()->MergeFrom(from._internal_antennas());
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_fixed_payload()->::aalyria::spacetime::api::common::BentPipePayload_FixedPayload::MergeFrom(
          from._internal_fixed_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_digital_payload()->::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload::MergeFrom(
          from._internal_digital_payload());
    }
  }
  if (from._internal_max_processed_bandwidth_hz() != 0) {
    _this->_internal_set_max_processed_bandwidth_hz(from._internal_max_processed_bandwidth_hz());
  }
  if (from._internal_max_channels() != 0) {
    _this->_internal_set_max_channels(from._internal_max_channels());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BentPipePayload::CopyFrom(const BentPipePayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BentPipePayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BentPipePayload::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_antennas()))
    return false;
  return true;
}

void BentPipePayload::InternalSwap(BentPipePayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_antennas()->InternalSwap(other->_internal_mutable_antennas());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BentPipePayload, _impl_.max_channels_)
      + sizeof(BentPipePayload::_impl_.max_channels_)
      - PROTOBUF_FIELD_OFFSET(BentPipePayload, _impl_.fixed_payload_)>(
          reinterpret_cast<char*>(&_impl_.fixed_payload_),
          reinterpret_cast<char*>(&other->_impl_.fixed_payload_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BentPipePayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_getter, &descriptor_table_api_2fcommon_2fbent_5fpipe_2eproto_once,
      file_level_metadata_api_2fcommon_2fbent_5fpipe_2eproto[5]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload_AntennaAndSignalProcessors >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_Channel >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload_ChannelConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload_FixedPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload_DigitalPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BentPipePayload*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BentPipePayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BentPipePayload >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
