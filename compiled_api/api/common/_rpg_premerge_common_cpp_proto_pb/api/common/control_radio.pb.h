// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/control_radio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fradio_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fradio_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/time.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fcontrol_5fradio_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fcontrol_5fradio_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class RadioStates;
struct RadioStatesDefaultTypeInternal;
extern RadioStatesDefaultTypeInternal _RadioStates_default_instance_;
class RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse;
struct RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUseDefaultTypeInternal;
extern RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUseDefaultTypeInternal _RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse_default_instance_;
class RadioStates_RadioState;
struct RadioStates_RadioStateDefaultTypeInternal;
extern RadioStates_RadioStateDefaultTypeInternal _RadioStates_RadioState_default_instance_;
class RadioUpdate;
struct RadioUpdateDefaultTypeInternal;
extern RadioUpdateDefaultTypeInternal _RadioUpdate_default_instance_;
class ReceiverState;
struct ReceiverStateDefaultTypeInternal;
extern ReceiverStateDefaultTypeInternal _ReceiverState_default_instance_;
class TdmaSchedule;
struct TdmaScheduleDefaultTypeInternal;
extern TdmaScheduleDefaultTypeInternal _TdmaSchedule_default_instance_;
class TdmaSchedule_TdmaSlot;
struct TdmaSchedule_TdmaSlotDefaultTypeInternal;
extern TdmaSchedule_TdmaSlotDefaultTypeInternal _TdmaSchedule_TdmaSlot_default_instance_;
class TdmaSchedule_TdmaSlot_RxSlot;
struct TdmaSchedule_TdmaSlot_RxSlotDefaultTypeInternal;
extern TdmaSchedule_TdmaSlot_RxSlotDefaultTypeInternal _TdmaSchedule_TdmaSlot_RxSlot_default_instance_;
class TdmaSchedule_TdmaSlot_TxSlot;
struct TdmaSchedule_TdmaSlot_TxSlotDefaultTypeInternal;
extern TdmaSchedule_TdmaSlot_TxSlotDefaultTypeInternal _TdmaSchedule_TdmaSlot_TxSlot_default_instance_;
class TransmitterState;
struct TransmitterStateDefaultTypeInternal;
extern TransmitterStateDefaultTypeInternal _TransmitterState_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::RadioStates* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioStates>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioStates_RadioState* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioStates_RadioState>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioUpdate>(Arena*);
template <>
::aalyria::spacetime::api::common::ReceiverState* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverState>(Arena*);
template <>
::aalyria::spacetime::api::common::TdmaSchedule* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule>(Arena*);
template <>
::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot>(Arena*);
template <>
::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot>(Arena*);
template <>
::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot>(Arena*);
template <>
::aalyria::spacetime::api::common::TransmitterState* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TransmitterState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum TdmaSchedule_TdmaSlot_TxSlot_TxSlotType : int {
  TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_UNKNOWN = 0,
  TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_UNICAST = 1,
  TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_BEACON = 2,
  TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_POLLED = 3,
  TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_CONTENTION = 4,
};

bool TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_IsValid(int value);
constexpr TdmaSchedule_TdmaSlot_TxSlot_TxSlotType TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_MIN = static_cast<TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>(0);
constexpr TdmaSchedule_TdmaSlot_TxSlot_TxSlotType TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_MAX = static_cast<TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>(4);
constexpr int TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_descriptor();
template <typename T>
const std::string& TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Name(T value) {
  static_assert(std::is_same<T, TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TxSlotType_Name().");
  return TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Name(static_cast<TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>(value));
}
template <>
inline const std::string& TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Name(TdmaSchedule_TdmaSlot_TxSlot_TxSlotType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Parse(absl::string_view name, TdmaSchedule_TdmaSlot_TxSlot_TxSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>(
      TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_descriptor(), name, value);
}
enum TdmaSchedule_TdmaSlot_RxSlot_RxSlotType : int {
  TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_UNKNOWN = 0,
  TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_UNICAST = 1,
  TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_BROADCAST = 2,
};

bool TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_IsValid(int value);
constexpr TdmaSchedule_TdmaSlot_RxSlot_RxSlotType TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_MIN = static_cast<TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>(0);
constexpr TdmaSchedule_TdmaSlot_RxSlot_RxSlotType TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_MAX = static_cast<TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>(2);
constexpr int TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_descriptor();
template <typename T>
const std::string& TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Name(T value) {
  static_assert(std::is_same<T, TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RxSlotType_Name().");
  return TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Name(static_cast<TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>(value));
}
template <>
inline const std::string& TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Name(TdmaSchedule_TdmaSlot_RxSlot_RxSlotType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Parse(absl::string_view name, TdmaSchedule_TdmaSlot_RxSlot_RxSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>(
      TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_descriptor(), name, value);
}
enum TdmaSchedule_ScheduleType : int {
  TdmaSchedule_ScheduleType_UNKNOWN = 0,
  TdmaSchedule_ScheduleType_TX_ONLY = 1,
  TdmaSchedule_ScheduleType_RX_ONLY = 2,
  TdmaSchedule_ScheduleType_TX_RX = 3,
};

bool TdmaSchedule_ScheduleType_IsValid(int value);
constexpr TdmaSchedule_ScheduleType TdmaSchedule_ScheduleType_ScheduleType_MIN = static_cast<TdmaSchedule_ScheduleType>(0);
constexpr TdmaSchedule_ScheduleType TdmaSchedule_ScheduleType_ScheduleType_MAX = static_cast<TdmaSchedule_ScheduleType>(3);
constexpr int TdmaSchedule_ScheduleType_ScheduleType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
TdmaSchedule_ScheduleType_descriptor();
template <typename T>
const std::string& TdmaSchedule_ScheduleType_Name(T value) {
  static_assert(std::is_same<T, TdmaSchedule_ScheduleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleType_Name().");
  return TdmaSchedule_ScheduleType_Name(static_cast<TdmaSchedule_ScheduleType>(value));
}
template <>
inline const std::string& TdmaSchedule_ScheduleType_Name(TdmaSchedule_ScheduleType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<TdmaSchedule_ScheduleType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TdmaSchedule_ScheduleType_Parse(absl::string_view name, TdmaSchedule_ScheduleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TdmaSchedule_ScheduleType>(
      TdmaSchedule_ScheduleType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TransmitterState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TransmitterState) */ {
 public:
  inline TransmitterState() : TransmitterState(nullptr) {}
  ~TransmitterState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransmitterState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransmitterState(const TransmitterState& from);
  TransmitterState(TransmitterState&& from) noexcept
    : TransmitterState() {
    *this = ::std::move(from);
  }

  inline TransmitterState& operator=(const TransmitterState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransmitterState& operator=(TransmitterState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransmitterState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransmitterState* internal_default_instance() {
    return reinterpret_cast<const TransmitterState*>(
               &_TransmitterState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransmitterState& a, TransmitterState& b) {
    a.Swap(&b);
  }
  inline void Swap(TransmitterState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransmitterState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransmitterState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransmitterState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransmitterState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransmitterState& from) {
    TransmitterState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransmitterState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TransmitterState";
  }
  protected:
  explicit TransmitterState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmitPowerWattsFieldNumber = 3,
    kCenterFrequencyHzFieldNumber = 5,
    kChannelWidthHzFieldNumber = 6,
  };
  // optional double transmit_power_watts = 3 [json_name = "transmitPowerWatts"];
  bool has_transmit_power_watts() const;
  void clear_transmit_power_watts() ;
  double transmit_power_watts() const;
  void set_transmit_power_watts(double value);

  private:
  double _internal_transmit_power_watts() const;
  void _internal_set_transmit_power_watts(double value);

  public:
  // optional uint64 center_frequency_hz = 5 [json_name = "centerFrequencyHz"];
  bool has_center_frequency_hz() const;
  void clear_center_frequency_hz() ;
  ::uint64_t center_frequency_hz() const;
  void set_center_frequency_hz(::uint64_t value);

  private:
  ::uint64_t _internal_center_frequency_hz() const;
  void _internal_set_center_frequency_hz(::uint64_t value);

  public:
  // optional uint64 channel_width_hz = 6 [json_name = "channelWidthHz"];
  bool has_channel_width_hz() const;
  void clear_channel_width_hz() ;
  ::uint64_t channel_width_hz() const;
  void set_channel_width_hz(::uint64_t value);

  private:
  ::uint64_t _internal_channel_width_hz() const;
  void _internal_set_channel_width_hz(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TransmitterState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double transmit_power_watts_;
    ::uint64_t center_frequency_hz_;
    ::uint64_t channel_width_hz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class ReceiverState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ReceiverState) */ {
 public:
  inline ReceiverState() : ReceiverState(nullptr) {}
  ~ReceiverState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiverState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiverState(const ReceiverState& from);
  ReceiverState(ReceiverState&& from) noexcept
    : ReceiverState() {
    *this = ::std::move(from);
  }

  inline ReceiverState& operator=(const ReceiverState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiverState& operator=(ReceiverState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiverState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiverState* internal_default_instance() {
    return reinterpret_cast<const ReceiverState*>(
               &_ReceiverState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReceiverState& a, ReceiverState& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiverState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiverState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiverState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiverState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiverState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiverState& from) {
    ReceiverState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiverState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ReceiverState";
  }
  protected:
  explicit ReceiverState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFrequencyHzFieldNumber = 4,
    kChannelWidthHzFieldNumber = 5,
  };
  // optional uint64 center_frequency_hz = 4 [json_name = "centerFrequencyHz"];
  bool has_center_frequency_hz() const;
  void clear_center_frequency_hz() ;
  ::uint64_t center_frequency_hz() const;
  void set_center_frequency_hz(::uint64_t value);

  private:
  ::uint64_t _internal_center_frequency_hz() const;
  void _internal_set_center_frequency_hz(::uint64_t value);

  public:
  // optional uint64 channel_width_hz = 5 [json_name = "channelWidthHz"];
  bool has_channel_width_hz() const;
  void clear_channel_width_hz() ;
  ::uint64_t channel_width_hz() const;
  void set_channel_width_hz(::uint64_t value);

  private:
  ::uint64_t _internal_channel_width_hz() const;
  void _internal_set_channel_width_hz(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ReceiverState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t center_frequency_hz_;
    ::uint64_t channel_width_hz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class TdmaSchedule_TdmaSlot_TxSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot) */ {
 public:
  inline TdmaSchedule_TdmaSlot_TxSlot() : TdmaSchedule_TdmaSlot_TxSlot(nullptr) {}
  ~TdmaSchedule_TdmaSlot_TxSlot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TdmaSchedule_TdmaSlot_TxSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TdmaSchedule_TdmaSlot_TxSlot(const TdmaSchedule_TdmaSlot_TxSlot& from);
  TdmaSchedule_TdmaSlot_TxSlot(TdmaSchedule_TdmaSlot_TxSlot&& from) noexcept
    : TdmaSchedule_TdmaSlot_TxSlot() {
    *this = ::std::move(from);
  }

  inline TdmaSchedule_TdmaSlot_TxSlot& operator=(const TdmaSchedule_TdmaSlot_TxSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline TdmaSchedule_TdmaSlot_TxSlot& operator=(TdmaSchedule_TdmaSlot_TxSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TdmaSchedule_TdmaSlot_TxSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const TdmaSchedule_TdmaSlot_TxSlot* internal_default_instance() {
    return reinterpret_cast<const TdmaSchedule_TdmaSlot_TxSlot*>(
               &_TdmaSchedule_TdmaSlot_TxSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TdmaSchedule_TdmaSlot_TxSlot& a, TdmaSchedule_TdmaSlot_TxSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(TdmaSchedule_TdmaSlot_TxSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TdmaSchedule_TdmaSlot_TxSlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TdmaSchedule_TdmaSlot_TxSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TdmaSchedule_TdmaSlot_TxSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TdmaSchedule_TdmaSlot_TxSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TdmaSchedule_TdmaSlot_TxSlot& from) {
    TdmaSchedule_TdmaSlot_TxSlot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TdmaSchedule_TdmaSlot_TxSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot";
  }
  protected:
  explicit TdmaSchedule_TdmaSlot_TxSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TxSlotType = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType;
  static constexpr TxSlotType UNKNOWN = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_UNKNOWN;
  static constexpr TxSlotType UNICAST = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_UNICAST;
  static constexpr TxSlotType BEACON = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_BEACON;
  static constexpr TxSlotType POLLED = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_POLLED;
  static constexpr TxSlotType CONTENTION = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_CONTENTION;
  static inline bool TxSlotType_IsValid(int value) {
    return TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_IsValid(value);
  }
  static constexpr TxSlotType TxSlotType_MIN = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_MIN;
  static constexpr TxSlotType TxSlotType_MAX = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_MAX;
  static constexpr int TxSlotType_ARRAYSIZE = TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_TxSlotType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSlotType_descriptor() {
    return TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_descriptor();
  }
  template <typename T>
  static inline const std::string& TxSlotType_Name(T value) {
    return TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Name(value);
  }
  static inline bool TxSlotType_Parse(absl::string_view name, TxSlotType* value) {
    return TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteReceiverIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string remote_receiver_id = 2 [json_name = "remoteReceiverId"];
  bool has_remote_receiver_id() const;
  void clear_remote_receiver_id() ;
  const std::string& remote_receiver_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_receiver_id(Arg_&& arg, Args_... args);
  std::string* mutable_remote_receiver_id();
  PROTOBUF_NODISCARD std::string* release_remote_receiver_id();
  void set_allocated_remote_receiver_id(std::string* ptr);

  private:
  const std::string& _internal_remote_receiver_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_receiver_id(
      const std::string& value);
  std::string* _internal_mutable_remote_receiver_id();

  public:
  // optional .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.TxSlotType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType type() const;
  void set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType value);

  private:
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_receiver_id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class TdmaSchedule_TdmaSlot_RxSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot) */ {
 public:
  inline TdmaSchedule_TdmaSlot_RxSlot() : TdmaSchedule_TdmaSlot_RxSlot(nullptr) {}
  ~TdmaSchedule_TdmaSlot_RxSlot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TdmaSchedule_TdmaSlot_RxSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TdmaSchedule_TdmaSlot_RxSlot(const TdmaSchedule_TdmaSlot_RxSlot& from);
  TdmaSchedule_TdmaSlot_RxSlot(TdmaSchedule_TdmaSlot_RxSlot&& from) noexcept
    : TdmaSchedule_TdmaSlot_RxSlot() {
    *this = ::std::move(from);
  }

  inline TdmaSchedule_TdmaSlot_RxSlot& operator=(const TdmaSchedule_TdmaSlot_RxSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline TdmaSchedule_TdmaSlot_RxSlot& operator=(TdmaSchedule_TdmaSlot_RxSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TdmaSchedule_TdmaSlot_RxSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const TdmaSchedule_TdmaSlot_RxSlot* internal_default_instance() {
    return reinterpret_cast<const TdmaSchedule_TdmaSlot_RxSlot*>(
               &_TdmaSchedule_TdmaSlot_RxSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TdmaSchedule_TdmaSlot_RxSlot& a, TdmaSchedule_TdmaSlot_RxSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(TdmaSchedule_TdmaSlot_RxSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TdmaSchedule_TdmaSlot_RxSlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TdmaSchedule_TdmaSlot_RxSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TdmaSchedule_TdmaSlot_RxSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TdmaSchedule_TdmaSlot_RxSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TdmaSchedule_TdmaSlot_RxSlot& from) {
    TdmaSchedule_TdmaSlot_RxSlot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TdmaSchedule_TdmaSlot_RxSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot";
  }
  protected:
  explicit TdmaSchedule_TdmaSlot_RxSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RxSlotType = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType;
  static constexpr RxSlotType UNKNOWN = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_UNKNOWN;
  static constexpr RxSlotType UNICAST = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_UNICAST;
  static constexpr RxSlotType BROADCAST = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_BROADCAST;
  static inline bool RxSlotType_IsValid(int value) {
    return TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_IsValid(value);
  }
  static constexpr RxSlotType RxSlotType_MIN = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_MIN;
  static constexpr RxSlotType RxSlotType_MAX = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_MAX;
  static constexpr int RxSlotType_ARRAYSIZE = TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_RxSlotType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RxSlotType_descriptor() {
    return TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_descriptor();
  }
  template <typename T>
  static inline const std::string& RxSlotType_Name(T value) {
    return TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Name(value);
  }
  static inline bool RxSlotType_Parse(absl::string_view name, RxSlotType* value) {
    return TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteTransmitterIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string remote_transmitter_id = 2 [json_name = "remoteTransmitterId"];
  bool has_remote_transmitter_id() const;
  void clear_remote_transmitter_id() ;
  const std::string& remote_transmitter_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_transmitter_id(Arg_&& arg, Args_... args);
  std::string* mutable_remote_transmitter_id();
  PROTOBUF_NODISCARD std::string* release_remote_transmitter_id();
  void set_allocated_remote_transmitter_id(std::string* ptr);

  private:
  const std::string& _internal_remote_transmitter_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_transmitter_id(
      const std::string& value);
  std::string* _internal_mutable_remote_transmitter_id();

  public:
  // optional .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.RxSlotType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType type() const;
  void set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType value);

  private:
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_transmitter_id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class TdmaSchedule_TdmaSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot) */ {
 public:
  inline TdmaSchedule_TdmaSlot() : TdmaSchedule_TdmaSlot(nullptr) {}
  ~TdmaSchedule_TdmaSlot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TdmaSchedule_TdmaSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TdmaSchedule_TdmaSlot(const TdmaSchedule_TdmaSlot& from);
  TdmaSchedule_TdmaSlot(TdmaSchedule_TdmaSlot&& from) noexcept
    : TdmaSchedule_TdmaSlot() {
    *this = ::std::move(from);
  }

  inline TdmaSchedule_TdmaSlot& operator=(const TdmaSchedule_TdmaSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline TdmaSchedule_TdmaSlot& operator=(TdmaSchedule_TdmaSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TdmaSchedule_TdmaSlot& default_instance() {
    return *internal_default_instance();
  }
  enum SlotTypeCase {
    kTransmit = 2,
    kReceive = 3,
    SLOT_TYPE_NOT_SET = 0,
  };

  static inline const TdmaSchedule_TdmaSlot* internal_default_instance() {
    return reinterpret_cast<const TdmaSchedule_TdmaSlot*>(
               &_TdmaSchedule_TdmaSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TdmaSchedule_TdmaSlot& a, TdmaSchedule_TdmaSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(TdmaSchedule_TdmaSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TdmaSchedule_TdmaSlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TdmaSchedule_TdmaSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TdmaSchedule_TdmaSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TdmaSchedule_TdmaSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TdmaSchedule_TdmaSlot& from) {
    TdmaSchedule_TdmaSlot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TdmaSchedule_TdmaSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot";
  }
  protected:
  explicit TdmaSchedule_TdmaSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TdmaSchedule_TdmaSlot_TxSlot TxSlot;
  typedef TdmaSchedule_TdmaSlot_RxSlot RxSlot;

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kTransmitFieldNumber = 2,
    kReceiveFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.Duration duration = 1 [json_name = "duration"];
  bool has_duration() const;
  void clear_duration() ;
  const ::aalyria::spacetime::api::common::Duration& duration() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Duration* release_duration();
  ::aalyria::spacetime::api::common::Duration* mutable_duration();
  void set_allocated_duration(::aalyria::spacetime::api::common::Duration* duration);
  private:
  const ::aalyria::spacetime::api::common::Duration& _internal_duration() const;
  ::aalyria::spacetime::api::common::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::aalyria::spacetime::api::common::Duration* duration);
  ::aalyria::spacetime::api::common::Duration* unsafe_arena_release_duration();
  // .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot transmit = 2 [json_name = "transmit"];
  bool has_transmit() const;
  private:
  bool _internal_has_transmit() const;

  public:
  void clear_transmit() ;
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot& transmit() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* release_transmit();
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* mutable_transmit();
  void set_allocated_transmit(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* transmit);
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot& _internal_transmit() const;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* _internal_mutable_transmit();
  public:
  void unsafe_arena_set_allocated_transmit(
      ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* transmit);
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* unsafe_arena_release_transmit();
  // .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot receive = 3 [json_name = "receive"];
  bool has_receive() const;
  private:
  bool _internal_has_receive() const;

  public:
  void clear_receive() ;
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot& receive() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* release_receive();
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* mutable_receive();
  void set_allocated_receive(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* receive);
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot& _internal_receive() const;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* _internal_mutable_receive();
  public:
  void unsafe_arena_set_allocated_receive(
      ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* receive);
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* unsafe_arena_release_receive();
  void clear_slot_type();
  SlotTypeCase slot_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot)
 private:
  class _Internal;
  void set_has_transmit();
  void set_has_receive();

  inline bool has_slot_type() const;
  inline void clear_has_slot_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::Duration* duration_;
    union SlotTypeUnion {
      constexpr SlotTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* transmit_;
      ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* receive_;
    } slot_type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class TdmaSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TdmaSchedule) */ {
 public:
  inline TdmaSchedule() : TdmaSchedule(nullptr) {}
  ~TdmaSchedule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TdmaSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TdmaSchedule(const TdmaSchedule& from);
  TdmaSchedule(TdmaSchedule&& from) noexcept
    : TdmaSchedule() {
    *this = ::std::move(from);
  }

  inline TdmaSchedule& operator=(const TdmaSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TdmaSchedule& operator=(TdmaSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TdmaSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const TdmaSchedule* internal_default_instance() {
    return reinterpret_cast<const TdmaSchedule*>(
               &_TdmaSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TdmaSchedule& a, TdmaSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(TdmaSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TdmaSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TdmaSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TdmaSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TdmaSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TdmaSchedule& from) {
    TdmaSchedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TdmaSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TdmaSchedule";
  }
  protected:
  explicit TdmaSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TdmaSchedule_TdmaSlot TdmaSlot;

  using ScheduleType = TdmaSchedule_ScheduleType;
  static constexpr ScheduleType UNKNOWN = TdmaSchedule_ScheduleType_UNKNOWN;
  static constexpr ScheduleType TX_ONLY = TdmaSchedule_ScheduleType_TX_ONLY;
  static constexpr ScheduleType RX_ONLY = TdmaSchedule_ScheduleType_RX_ONLY;
  static constexpr ScheduleType TX_RX = TdmaSchedule_ScheduleType_TX_RX;
  static inline bool ScheduleType_IsValid(int value) {
    return TdmaSchedule_ScheduleType_IsValid(value);
  }
  static constexpr ScheduleType ScheduleType_MIN = TdmaSchedule_ScheduleType_ScheduleType_MIN;
  static constexpr ScheduleType ScheduleType_MAX = TdmaSchedule_ScheduleType_ScheduleType_MAX;
  static constexpr int ScheduleType_ARRAYSIZE = TdmaSchedule_ScheduleType_ScheduleType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScheduleType_descriptor() {
    return TdmaSchedule_ScheduleType_descriptor();
  }
  template <typename T>
  static inline const std::string& ScheduleType_Name(T value) {
    return TdmaSchedule_ScheduleType_Name(value);
  }
  static inline bool ScheduleType_Parse(absl::string_view name, ScheduleType* value) {
    return TdmaSchedule_ScheduleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 3,
    kScheduleDurationFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot schedule = 3 [json_name = "schedule"];
  int schedule_size() const;
  private:
  int _internal_schedule_size() const;

  public:
  void clear_schedule() ;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* mutable_schedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot >*
      mutable_schedule();
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot& _internal_schedule(int index) const;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* _internal_add_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot>& _internal_schedule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot>* _internal_mutable_schedule();
  public:
  const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot& schedule(int index) const;
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* add_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot >&
      schedule() const;
  // optional .aalyria.spacetime.api.common.Duration schedule_duration = 2 [json_name = "scheduleDuration"];
  bool has_schedule_duration() const;
  void clear_schedule_duration() ;
  const ::aalyria::spacetime::api::common::Duration& schedule_duration() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Duration* release_schedule_duration();
  ::aalyria::spacetime::api::common::Duration* mutable_schedule_duration();
  void set_allocated_schedule_duration(::aalyria::spacetime::api::common::Duration* schedule_duration);
  private:
  const ::aalyria::spacetime::api::common::Duration& _internal_schedule_duration() const;
  ::aalyria::spacetime::api::common::Duration* _internal_mutable_schedule_duration();
  public:
  void unsafe_arena_set_allocated_schedule_duration(
      ::aalyria::spacetime::api::common::Duration* schedule_duration);
  ::aalyria::spacetime::api::common::Duration* unsafe_arena_release_schedule_duration();
  // optional .aalyria.spacetime.api.common.TdmaSchedule.ScheduleType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType type() const;
  void set_type(::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType value);

  private:
  ::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TdmaSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot > schedule_;
    ::aalyria::spacetime::api::common::Duration* schedule_duration_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class RadioUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioUpdate) */ {
 public:
  inline RadioUpdate() : RadioUpdate(nullptr) {}
  ~RadioUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioUpdate(const RadioUpdate& from);
  RadioUpdate(RadioUpdate&& from) noexcept
    : RadioUpdate() {
    *this = ::std::move(from);
  }

  inline RadioUpdate& operator=(const RadioUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioUpdate& operator=(RadioUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioUpdate* internal_default_instance() {
    return reinterpret_cast<const RadioUpdate*>(
               &_RadioUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RadioUpdate& a, RadioUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioUpdate& from) {
    RadioUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioUpdate";
  }
  protected:
  explicit RadioUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceIdFieldNumber = 4,
    kRadioConfigIdFieldNumber = 6,
    kModemConfigIdFieldNumber = 8,
    kTxStateFieldNumber = 1,
    kRxStateFieldNumber = 2,
    kTdmaScheduleFieldNumber = 3,
    kPerInterfaceSequenceNumberFieldNumber = 5,
  };
  // optional string interface_id = 4 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // optional string radio_config_id = 6 [json_name = "radioConfigId"];
  bool has_radio_config_id() const;
  void clear_radio_config_id() ;
  const std::string& radio_config_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_radio_config_id(Arg_&& arg, Args_... args);
  std::string* mutable_radio_config_id();
  PROTOBUF_NODISCARD std::string* release_radio_config_id();
  void set_allocated_radio_config_id(std::string* ptr);

  private:
  const std::string& _internal_radio_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_radio_config_id(
      const std::string& value);
  std::string* _internal_mutable_radio_config_id();

  public:
  // optional string modem_config_id = 8 [json_name = "modemConfigId"];
  bool has_modem_config_id() const;
  void clear_modem_config_id() ;
  const std::string& modem_config_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modem_config_id(Arg_&& arg, Args_... args);
  std::string* mutable_modem_config_id();
  PROTOBUF_NODISCARD std::string* release_modem_config_id();
  void set_allocated_modem_config_id(std::string* ptr);

  private:
  const std::string& _internal_modem_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modem_config_id(
      const std::string& value);
  std::string* _internal_mutable_modem_config_id();

  public:
  // optional .aalyria.spacetime.api.common.TransmitterState tx_state = 1 [json_name = "txState"];
  bool has_tx_state() const;
  void clear_tx_state() ;
  const ::aalyria::spacetime::api::common::TransmitterState& tx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransmitterState* release_tx_state();
  ::aalyria::spacetime::api::common::TransmitterState* mutable_tx_state();
  void set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state);
  private:
  const ::aalyria::spacetime::api::common::TransmitterState& _internal_tx_state() const;
  ::aalyria::spacetime::api::common::TransmitterState* _internal_mutable_tx_state();
  public:
  void unsafe_arena_set_allocated_tx_state(
      ::aalyria::spacetime::api::common::TransmitterState* tx_state);
  ::aalyria::spacetime::api::common::TransmitterState* unsafe_arena_release_tx_state();
  // optional .aalyria.spacetime.api.common.ReceiverState rx_state = 2 [json_name = "rxState"];
  bool has_rx_state() const;
  void clear_rx_state() ;
  const ::aalyria::spacetime::api::common::ReceiverState& rx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ReceiverState* release_rx_state();
  ::aalyria::spacetime::api::common::ReceiverState* mutable_rx_state();
  void set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state);
  private:
  const ::aalyria::spacetime::api::common::ReceiverState& _internal_rx_state() const;
  ::aalyria::spacetime::api::common::ReceiverState* _internal_mutable_rx_state();
  public:
  void unsafe_arena_set_allocated_rx_state(
      ::aalyria::spacetime::api::common::ReceiverState* rx_state);
  ::aalyria::spacetime::api::common::ReceiverState* unsafe_arena_release_rx_state();
  // optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 3 [json_name = "tdmaSchedule"];
  bool has_tdma_schedule() const;
  void clear_tdma_schedule() ;
  const ::aalyria::spacetime::api::common::TdmaSchedule& tdma_schedule() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TdmaSchedule* release_tdma_schedule();
  ::aalyria::spacetime::api::common::TdmaSchedule* mutable_tdma_schedule();
  void set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule& _internal_tdma_schedule() const;
  ::aalyria::spacetime::api::common::TdmaSchedule* _internal_mutable_tdma_schedule();
  public:
  void unsafe_arena_set_allocated_tdma_schedule(
      ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  ::aalyria::spacetime::api::common::TdmaSchedule* unsafe_arena_release_tdma_schedule();
  // optional int64 per_interface_sequence_number = 5 [json_name = "perInterfaceSequenceNumber"];
  bool has_per_interface_sequence_number() const;
  void clear_per_interface_sequence_number() ;
  ::int64_t per_interface_sequence_number() const;
  void set_per_interface_sequence_number(::int64_t value);

  private:
  ::int64_t _internal_per_interface_sequence_number() const;
  void _internal_set_per_interface_sequence_number(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radio_config_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modem_config_id_;
    ::aalyria::spacetime::api::common::TransmitterState* tx_state_;
    ::aalyria::spacetime::api::common::ReceiverState* rx_state_;
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule_;
    ::int64_t per_interface_sequence_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class RadioStates_RadioState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioStates.RadioState) */ {
 public:
  inline RadioStates_RadioState() : RadioStates_RadioState(nullptr) {}
  ~RadioStates_RadioState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioStates_RadioState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioStates_RadioState(const RadioStates_RadioState& from);
  RadioStates_RadioState(RadioStates_RadioState&& from) noexcept
    : RadioStates_RadioState() {
    *this = ::std::move(from);
  }

  inline RadioStates_RadioState& operator=(const RadioStates_RadioState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioStates_RadioState& operator=(RadioStates_RadioState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioStates_RadioState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioStates_RadioState* internal_default_instance() {
    return reinterpret_cast<const RadioStates_RadioState*>(
               &_RadioStates_RadioState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RadioStates_RadioState& a, RadioStates_RadioState& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioStates_RadioState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioStates_RadioState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioStates_RadioState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioStates_RadioState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioStates_RadioState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioStates_RadioState& from) {
    RadioStates_RadioState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioStates_RadioState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioStates.RadioState";
  }
  protected:
  explicit RadioStates_RadioState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadioConfigIdFieldNumber = 4,
    kTxStateFieldNumber = 1,
    kRxStateFieldNumber = 2,
    kTdmaScheduleFieldNumber = 3,
  };
  // optional string radio_config_id = 4 [json_name = "radioConfigId"];
  bool has_radio_config_id() const;
  void clear_radio_config_id() ;
  const std::string& radio_config_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_radio_config_id(Arg_&& arg, Args_... args);
  std::string* mutable_radio_config_id();
  PROTOBUF_NODISCARD std::string* release_radio_config_id();
  void set_allocated_radio_config_id(std::string* ptr);

  private:
  const std::string& _internal_radio_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_radio_config_id(
      const std::string& value);
  std::string* _internal_mutable_radio_config_id();

  public:
  // optional .aalyria.spacetime.api.common.TransmitterState tx_state = 1 [json_name = "txState"];
  bool has_tx_state() const;
  void clear_tx_state() ;
  const ::aalyria::spacetime::api::common::TransmitterState& tx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransmitterState* release_tx_state();
  ::aalyria::spacetime::api::common::TransmitterState* mutable_tx_state();
  void set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state);
  private:
  const ::aalyria::spacetime::api::common::TransmitterState& _internal_tx_state() const;
  ::aalyria::spacetime::api::common::TransmitterState* _internal_mutable_tx_state();
  public:
  void unsafe_arena_set_allocated_tx_state(
      ::aalyria::spacetime::api::common::TransmitterState* tx_state);
  ::aalyria::spacetime::api::common::TransmitterState* unsafe_arena_release_tx_state();
  // optional .aalyria.spacetime.api.common.ReceiverState rx_state = 2 [json_name = "rxState"];
  bool has_rx_state() const;
  void clear_rx_state() ;
  const ::aalyria::spacetime::api::common::ReceiverState& rx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ReceiverState* release_rx_state();
  ::aalyria::spacetime::api::common::ReceiverState* mutable_rx_state();
  void set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state);
  private:
  const ::aalyria::spacetime::api::common::ReceiverState& _internal_rx_state() const;
  ::aalyria::spacetime::api::common::ReceiverState* _internal_mutable_rx_state();
  public:
  void unsafe_arena_set_allocated_rx_state(
      ::aalyria::spacetime::api::common::ReceiverState* rx_state);
  ::aalyria::spacetime::api::common::ReceiverState* unsafe_arena_release_rx_state();
  // optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 3 [json_name = "tdmaSchedule"];
  bool has_tdma_schedule() const;
  void clear_tdma_schedule() ;
  const ::aalyria::spacetime::api::common::TdmaSchedule& tdma_schedule() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TdmaSchedule* release_tdma_schedule();
  ::aalyria::spacetime::api::common::TdmaSchedule* mutable_tdma_schedule();
  void set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule& _internal_tdma_schedule() const;
  ::aalyria::spacetime::api::common::TdmaSchedule* _internal_mutable_tdma_schedule();
  public:
  void unsafe_arena_set_allocated_tdma_schedule(
      ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  ::aalyria::spacetime::api::common::TdmaSchedule* unsafe_arena_release_tdma_schedule();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioStates.RadioState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radio_config_id_;
    ::aalyria::spacetime::api::common::TransmitterState* tx_state_;
    ::aalyria::spacetime::api::common::ReceiverState* rx_state_;
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};// -------------------------------------------------------------------

class RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse& other);
  static const RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse*>(&_RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.RadioStates.RadioConfigIdByInterfaceIdEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.RadioStates.RadioConfigIdByInterfaceIdEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};
// -------------------------------------------------------------------

class RadioStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioStates) */ {
 public:
  inline RadioStates() : RadioStates(nullptr) {}
  ~RadioStates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioStates(const RadioStates& from);
  RadioStates(RadioStates&& from) noexcept
    : RadioStates() {
    *this = ::std::move(from);
  }

  inline RadioStates& operator=(const RadioStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioStates& operator=(RadioStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioStates* internal_default_instance() {
    return reinterpret_cast<const RadioStates*>(
               &_RadioStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RadioStates& a, RadioStates& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioStates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioStates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioStates& from) {
    RadioStates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioStates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioStates";
  }
  protected:
  explicit RadioStates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RadioStates_RadioState RadioState;

  // accessors -------------------------------------------------------

  enum : int {
    kRadioConfigIdByInterfaceIdFieldNumber = 4,
    kTimestampFieldNumber = 3,
  };
  // map<string, string> radio_config_id_by_interface_id = 4 [json_name = "radioConfigIdByInterfaceId"];
  int radio_config_id_by_interface_id_size() const;
  private:
  int _internal_radio_config_id_by_interface_id_size() const;

  public:
  void clear_radio_config_id_by_interface_id() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_radio_config_id_by_interface_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_radio_config_id_by_interface_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      radio_config_id_by_interface_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_radio_config_id_by_interface_id();
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RadioStates_RadioConfigIdByInterfaceIdEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> radio_config_id_by_interface_id_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fradio_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TransmitterState

// optional uint64 center_frequency_hz = 5 [json_name = "centerFrequencyHz"];
inline bool TransmitterState::has_center_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TransmitterState::clear_center_frequency_hz() {
  _impl_.center_frequency_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t TransmitterState::center_frequency_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterState.center_frequency_hz)
  return _internal_center_frequency_hz();
}
inline void TransmitterState::set_center_frequency_hz(::uint64_t value) {
  _internal_set_center_frequency_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterState.center_frequency_hz)
}
inline ::uint64_t TransmitterState::_internal_center_frequency_hz() const {
  return _impl_.center_frequency_hz_;
}
inline void TransmitterState::_internal_set_center_frequency_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.center_frequency_hz_ = value;
}

// optional uint64 channel_width_hz = 6 [json_name = "channelWidthHz"];
inline bool TransmitterState::has_channel_width_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransmitterState::clear_channel_width_hz() {
  _impl_.channel_width_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t TransmitterState::channel_width_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterState.channel_width_hz)
  return _internal_channel_width_hz();
}
inline void TransmitterState::set_channel_width_hz(::uint64_t value) {
  _internal_set_channel_width_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterState.channel_width_hz)
}
inline ::uint64_t TransmitterState::_internal_channel_width_hz() const {
  return _impl_.channel_width_hz_;
}
inline void TransmitterState::_internal_set_channel_width_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_width_hz_ = value;
}

// optional double transmit_power_watts = 3 [json_name = "transmitPowerWatts"];
inline bool TransmitterState::has_transmit_power_watts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransmitterState::clear_transmit_power_watts() {
  _impl_.transmit_power_watts_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double TransmitterState::transmit_power_watts() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterState.transmit_power_watts)
  return _internal_transmit_power_watts();
}
inline void TransmitterState::set_transmit_power_watts(double value) {
  _internal_set_transmit_power_watts(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterState.transmit_power_watts)
}
inline double TransmitterState::_internal_transmit_power_watts() const {
  return _impl_.transmit_power_watts_;
}
inline void TransmitterState::_internal_set_transmit_power_watts(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transmit_power_watts_ = value;
}

// -------------------------------------------------------------------

// ReceiverState

// optional uint64 center_frequency_hz = 4 [json_name = "centerFrequencyHz"];
inline bool ReceiverState::has_center_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReceiverState::clear_center_frequency_hz() {
  _impl_.center_frequency_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t ReceiverState::center_frequency_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverState.center_frequency_hz)
  return _internal_center_frequency_hz();
}
inline void ReceiverState::set_center_frequency_hz(::uint64_t value) {
  _internal_set_center_frequency_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverState.center_frequency_hz)
}
inline ::uint64_t ReceiverState::_internal_center_frequency_hz() const {
  return _impl_.center_frequency_hz_;
}
inline void ReceiverState::_internal_set_center_frequency_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.center_frequency_hz_ = value;
}

// optional uint64 channel_width_hz = 5 [json_name = "channelWidthHz"];
inline bool ReceiverState::has_channel_width_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReceiverState::clear_channel_width_hz() {
  _impl_.channel_width_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t ReceiverState::channel_width_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverState.channel_width_hz)
  return _internal_channel_width_hz();
}
inline void ReceiverState::set_channel_width_hz(::uint64_t value) {
  _internal_set_channel_width_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverState.channel_width_hz)
}
inline ::uint64_t ReceiverState::_internal_channel_width_hz() const {
  return _impl_.channel_width_hz_;
}
inline void ReceiverState::_internal_set_channel_width_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_width_hz_ = value;
}

// -------------------------------------------------------------------

// TdmaSchedule_TdmaSlot_TxSlot

// optional .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.TxSlotType type = 1 [json_name = "type"];
inline bool TdmaSchedule_TdmaSlot_TxSlot::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TdmaSchedule_TdmaSlot_TxSlot::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType TdmaSchedule_TdmaSlot_TxSlot::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.type)
  return _internal_type();
}
inline void TdmaSchedule_TdmaSlot_TxSlot::set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.type)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType TdmaSchedule_TdmaSlot_TxSlot::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>(_impl_.type_);
}
inline void TdmaSchedule_TdmaSlot_TxSlot::_internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType value) {
  assert(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string remote_receiver_id = 2 [json_name = "remoteReceiverId"];
inline bool TdmaSchedule_TdmaSlot_TxSlot::has_remote_receiver_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TdmaSchedule_TdmaSlot_TxSlot::clear_remote_receiver_id() {
  _impl_.remote_receiver_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TdmaSchedule_TdmaSlot_TxSlot::remote_receiver_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.remote_receiver_id)
  return _internal_remote_receiver_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TdmaSchedule_TdmaSlot_TxSlot::set_remote_receiver_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remote_receiver_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.remote_receiver_id)
}
inline std::string* TdmaSchedule_TdmaSlot_TxSlot::mutable_remote_receiver_id() {
  std::string* _s = _internal_mutable_remote_receiver_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.remote_receiver_id)
  return _s;
}
inline const std::string& TdmaSchedule_TdmaSlot_TxSlot::_internal_remote_receiver_id() const {
  return _impl_.remote_receiver_id_.Get();
}
inline void TdmaSchedule_TdmaSlot_TxSlot::_internal_set_remote_receiver_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.remote_receiver_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TdmaSchedule_TdmaSlot_TxSlot::_internal_mutable_remote_receiver_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.remote_receiver_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TdmaSchedule_TdmaSlot_TxSlot::release_remote_receiver_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.remote_receiver_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.remote_receiver_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_receiver_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TdmaSchedule_TdmaSlot_TxSlot::set_allocated_remote_receiver_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.remote_receiver_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.remote_receiver_id_.IsDefault()) {
          _impl_.remote_receiver_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot.remote_receiver_id)
}

// -------------------------------------------------------------------

// TdmaSchedule_TdmaSlot_RxSlot

// optional .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.RxSlotType type = 1 [json_name = "type"];
inline bool TdmaSchedule_TdmaSlot_RxSlot::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TdmaSchedule_TdmaSlot_RxSlot::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType TdmaSchedule_TdmaSlot_RxSlot::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.type)
  return _internal_type();
}
inline void TdmaSchedule_TdmaSlot_RxSlot::set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.type)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType TdmaSchedule_TdmaSlot_RxSlot::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>(_impl_.type_);
}
inline void TdmaSchedule_TdmaSlot_RxSlot::_internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType value) {
  assert(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string remote_transmitter_id = 2 [json_name = "remoteTransmitterId"];
inline bool TdmaSchedule_TdmaSlot_RxSlot::has_remote_transmitter_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TdmaSchedule_TdmaSlot_RxSlot::clear_remote_transmitter_id() {
  _impl_.remote_transmitter_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TdmaSchedule_TdmaSlot_RxSlot::remote_transmitter_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.remote_transmitter_id)
  return _internal_remote_transmitter_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TdmaSchedule_TdmaSlot_RxSlot::set_remote_transmitter_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remote_transmitter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.remote_transmitter_id)
}
inline std::string* TdmaSchedule_TdmaSlot_RxSlot::mutable_remote_transmitter_id() {
  std::string* _s = _internal_mutable_remote_transmitter_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.remote_transmitter_id)
  return _s;
}
inline const std::string& TdmaSchedule_TdmaSlot_RxSlot::_internal_remote_transmitter_id() const {
  return _impl_.remote_transmitter_id_.Get();
}
inline void TdmaSchedule_TdmaSlot_RxSlot::_internal_set_remote_transmitter_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.remote_transmitter_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TdmaSchedule_TdmaSlot_RxSlot::_internal_mutable_remote_transmitter_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.remote_transmitter_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TdmaSchedule_TdmaSlot_RxSlot::release_remote_transmitter_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.remote_transmitter_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.remote_transmitter_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_transmitter_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TdmaSchedule_TdmaSlot_RxSlot::set_allocated_remote_transmitter_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.remote_transmitter_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.remote_transmitter_id_.IsDefault()) {
          _impl_.remote_transmitter_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot.remote_transmitter_id)
}

// -------------------------------------------------------------------

// TdmaSchedule_TdmaSlot

// optional .aalyria.spacetime.api.common.Duration duration = 1 [json_name = "duration"];
inline bool TdmaSchedule_TdmaSlot::has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.duration_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::Duration& TdmaSchedule_TdmaSlot::_internal_duration() const {
  const ::aalyria::spacetime::api::common::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Duration&>(
      ::aalyria::spacetime::api::common::_Duration_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Duration& TdmaSchedule_TdmaSlot::duration() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.duration)
  return _internal_duration();
}
inline void TdmaSchedule_TdmaSlot::unsafe_arena_set_allocated_duration(
    ::aalyria::spacetime::api::common::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.duration)
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule_TdmaSlot::release_duration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule_TdmaSlot::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.duration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule_TdmaSlot::_internal_mutable_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule_TdmaSlot::mutable_duration() {
  ::aalyria::spacetime::api::common::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.duration)
  return _msg;
}
inline void TdmaSchedule_TdmaSlot::set_allocated_duration(::aalyria::spacetime::api::common::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.duration)
}

// .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.TxSlot transmit = 2 [json_name = "transmit"];
inline bool TdmaSchedule_TdmaSlot::has_transmit() const {
  return slot_type_case() == kTransmit;
}
inline bool TdmaSchedule_TdmaSlot::_internal_has_transmit() const {
  return slot_type_case() == kTransmit;
}
inline void TdmaSchedule_TdmaSlot::set_has_transmit() {
  _impl_._oneof_case_[0] = kTransmit;
}
inline void TdmaSchedule_TdmaSlot::clear_transmit() {
  if (slot_type_case() == kTransmit) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.slot_type_.transmit_;
    }
    clear_has_slot_type();
  }
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* TdmaSchedule_TdmaSlot::release_transmit() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.transmit)
  if (slot_type_case() == kTransmit) {
    clear_has_slot_type();
    ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* temp = _impl_.slot_type_.transmit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.slot_type_.transmit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot& TdmaSchedule_TdmaSlot::_internal_transmit() const {
  return slot_type_case() == kTransmit
      ? *_impl_.slot_type_.transmit_
      : reinterpret_cast<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot&>(::aalyria::spacetime::api::common::_TdmaSchedule_TdmaSlot_TxSlot_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot& TdmaSchedule_TdmaSlot::transmit() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.transmit)
  return _internal_transmit();
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* TdmaSchedule_TdmaSlot::unsafe_arena_release_transmit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.transmit)
  if (slot_type_case() == kTransmit) {
    clear_has_slot_type();
    ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* temp = _impl_.slot_type_.transmit_;
    _impl_.slot_type_.transmit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TdmaSchedule_TdmaSlot::unsafe_arena_set_allocated_transmit(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* transmit) {
  clear_slot_type();
  if (transmit) {
    set_has_transmit();
    _impl_.slot_type_.transmit_ = transmit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.transmit)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* TdmaSchedule_TdmaSlot::_internal_mutable_transmit() {
  if (slot_type_case() != kTransmit) {
    clear_slot_type();
    set_has_transmit();
    _impl_.slot_type_.transmit_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot >(GetArenaForAllocation());
  }
  return _impl_.slot_type_.transmit_;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* TdmaSchedule_TdmaSlot::mutable_transmit() {
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot* _msg = _internal_mutable_transmit();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.transmit)
  return _msg;
}

// .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.RxSlot receive = 3 [json_name = "receive"];
inline bool TdmaSchedule_TdmaSlot::has_receive() const {
  return slot_type_case() == kReceive;
}
inline bool TdmaSchedule_TdmaSlot::_internal_has_receive() const {
  return slot_type_case() == kReceive;
}
inline void TdmaSchedule_TdmaSlot::set_has_receive() {
  _impl_._oneof_case_[0] = kReceive;
}
inline void TdmaSchedule_TdmaSlot::clear_receive() {
  if (slot_type_case() == kReceive) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.slot_type_.receive_;
    }
    clear_has_slot_type();
  }
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* TdmaSchedule_TdmaSlot::release_receive() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.receive)
  if (slot_type_case() == kReceive) {
    clear_has_slot_type();
    ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* temp = _impl_.slot_type_.receive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.slot_type_.receive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot& TdmaSchedule_TdmaSlot::_internal_receive() const {
  return slot_type_case() == kReceive
      ? *_impl_.slot_type_.receive_
      : reinterpret_cast<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot&>(::aalyria::spacetime::api::common::_TdmaSchedule_TdmaSlot_RxSlot_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot& TdmaSchedule_TdmaSlot::receive() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.receive)
  return _internal_receive();
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* TdmaSchedule_TdmaSlot::unsafe_arena_release_receive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.receive)
  if (slot_type_case() == kReceive) {
    clear_has_slot_type();
    ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* temp = _impl_.slot_type_.receive_;
    _impl_.slot_type_.receive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TdmaSchedule_TdmaSlot::unsafe_arena_set_allocated_receive(::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* receive) {
  clear_slot_type();
  if (receive) {
    set_has_receive();
    _impl_.slot_type_.receive_ = receive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.receive)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* TdmaSchedule_TdmaSlot::_internal_mutable_receive() {
  if (slot_type_case() != kReceive) {
    clear_slot_type();
    set_has_receive();
    _impl_.slot_type_.receive_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot >(GetArenaForAllocation());
  }
  return _impl_.slot_type_.receive_;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* TdmaSchedule_TdmaSlot::mutable_receive() {
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot* _msg = _internal_mutable_receive();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot.receive)
  return _msg;
}

inline bool TdmaSchedule_TdmaSlot::has_slot_type() const {
  return slot_type_case() != SLOT_TYPE_NOT_SET;
}
inline void TdmaSchedule_TdmaSlot::clear_has_slot_type() {
  _impl_._oneof_case_[0] = SLOT_TYPE_NOT_SET;
}
inline TdmaSchedule_TdmaSlot::SlotTypeCase TdmaSchedule_TdmaSlot::slot_type_case() const {
  return TdmaSchedule_TdmaSlot::SlotTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TdmaSchedule

// optional .aalyria.spacetime.api.common.TdmaSchedule.ScheduleType type = 1 [json_name = "type"];
inline bool TdmaSchedule::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TdmaSchedule::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType TdmaSchedule::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.type)
  return _internal_type();
}
inline void TdmaSchedule::set_type(::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TdmaSchedule.type)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType TdmaSchedule::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType>(_impl_.type_);
}
inline void TdmaSchedule::_internal_set_type(::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType value) {
  assert(::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .aalyria.spacetime.api.common.Duration schedule_duration = 2 [json_name = "scheduleDuration"];
inline bool TdmaSchedule::has_schedule_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schedule_duration_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::Duration& TdmaSchedule::_internal_schedule_duration() const {
  const ::aalyria::spacetime::api::common::Duration* p = _impl_.schedule_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Duration&>(
      ::aalyria::spacetime::api::common::_Duration_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Duration& TdmaSchedule::schedule_duration() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.schedule_duration)
  return _internal_schedule_duration();
}
inline void TdmaSchedule::unsafe_arena_set_allocated_schedule_duration(
    ::aalyria::spacetime::api::common::Duration* schedule_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_duration_);
  }
  _impl_.schedule_duration_ = schedule_duration;
  if (schedule_duration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.schedule_duration)
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule::release_schedule_duration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.schedule_duration_;
  _impl_.schedule_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule::unsafe_arena_release_schedule_duration() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TdmaSchedule.schedule_duration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.schedule_duration_;
  _impl_.schedule_duration_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule::_internal_mutable_schedule_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schedule_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Duration>(GetArenaForAllocation());
    _impl_.schedule_duration_ = p;
  }
  return _impl_.schedule_duration_;
}
inline ::aalyria::spacetime::api::common::Duration* TdmaSchedule::mutable_schedule_duration() {
  ::aalyria::spacetime::api::common::Duration* _msg = _internal_mutable_schedule_duration();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.schedule_duration)
  return _msg;
}
inline void TdmaSchedule::set_allocated_schedule_duration(::aalyria::spacetime::api::common::Duration* schedule_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_duration_);
  }
  if (schedule_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schedule_duration));
    if (message_arena != submessage_arena) {
      schedule_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule_duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schedule_duration_ = schedule_duration;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TdmaSchedule.schedule_duration)
}

// repeated .aalyria.spacetime.api.common.TdmaSchedule.TdmaSlot schedule = 3 [json_name = "schedule"];
inline int TdmaSchedule::_internal_schedule_size() const {
  return _impl_.schedule_.size();
}
inline int TdmaSchedule::schedule_size() const {
  return _internal_schedule_size();
}
inline void TdmaSchedule::clear_schedule() {
  _internal_mutable_schedule()->Clear();
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* TdmaSchedule::mutable_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TdmaSchedule.schedule)
  return _internal_mutable_schedule()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot >*
TdmaSchedule::mutable_schedule() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.TdmaSchedule.schedule)
  return _internal_mutable_schedule();
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot& TdmaSchedule::_internal_schedule(int index) const {
  return _internal_schedule().Get(index);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot& TdmaSchedule::schedule(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TdmaSchedule.schedule)
  return _internal_schedule(index);
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* TdmaSchedule::_internal_add_schedule() {
  return _internal_mutable_schedule()->Add();
}
inline ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* TdmaSchedule::add_schedule() {
  ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot* _add = _internal_add_schedule();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.TdmaSchedule.schedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot >&
TdmaSchedule::schedule() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.TdmaSchedule.schedule)
  return _internal_schedule();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot>&
TdmaSchedule::_internal_schedule() const {
  return _impl_.schedule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot>*
TdmaSchedule::_internal_mutable_schedule() {
  return &_impl_.schedule_;
}

// -------------------------------------------------------------------

// RadioUpdate

// optional string radio_config_id = 6 [json_name = "radioConfigId"];
inline bool RadioUpdate::has_radio_config_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RadioUpdate::clear_radio_config_id() {
  _impl_.radio_config_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RadioUpdate::radio_config_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.radio_config_id)
  return _internal_radio_config_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioUpdate::set_radio_config_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.radio_config_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioUpdate.radio_config_id)
}
inline std::string* RadioUpdate::mutable_radio_config_id() {
  std::string* _s = _internal_mutable_radio_config_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.radio_config_id)
  return _s;
}
inline const std::string& RadioUpdate::_internal_radio_config_id() const {
  return _impl_.radio_config_id_.Get();
}
inline void RadioUpdate::_internal_set_radio_config_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.radio_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioUpdate::_internal_mutable_radio_config_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.radio_config_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioUpdate::release_radio_config_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.radio_config_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.radio_config_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.radio_config_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioUpdate::set_allocated_radio_config_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.radio_config_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.radio_config_id_.IsDefault()) {
          _impl_.radio_config_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.radio_config_id)
}

// optional string interface_id = 4 [json_name = "interfaceId"];
inline bool RadioUpdate::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioUpdate::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RadioUpdate::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioUpdate::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioUpdate.interface_id)
}
inline std::string* RadioUpdate::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.interface_id)
  return _s;
}
inline const std::string& RadioUpdate::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void RadioUpdate::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioUpdate::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioUpdate::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioUpdate::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.interface_id)
}

// optional .aalyria.spacetime.api.common.TransmitterState tx_state = 1 [json_name = "txState"];
inline bool RadioUpdate::has_tx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tx_state_ != nullptr);
  return value;
}
inline void RadioUpdate::clear_tx_state() {
  if (_impl_.tx_state_ != nullptr) _impl_.tx_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioUpdate::_internal_tx_state() const {
  const ::aalyria::spacetime::api::common::TransmitterState* p = _impl_.tx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransmitterState&>(
      ::aalyria::spacetime::api::common::_TransmitterState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioUpdate::tx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.tx_state)
  return _internal_tx_state();
}
inline void RadioUpdate::unsafe_arena_set_allocated_tx_state(
    ::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_state_);
  }
  _impl_.tx_state_ = tx_state;
  if (tx_state) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioUpdate.tx_state)
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioUpdate::release_tx_state() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioUpdate::unsafe_arena_release_tx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.tx_state)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioUpdate::_internal_mutable_tx_state() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransmitterState>(GetArenaForAllocation());
    _impl_.tx_state_ = p;
  }
  return _impl_.tx_state_;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioUpdate::mutable_tx_state() {
  ::aalyria::spacetime::api::common::TransmitterState* _msg = _internal_mutable_tx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.tx_state)
  return _msg;
}
inline void RadioUpdate::set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tx_state_;
  }
  if (tx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_state);
    if (message_arena != submessage_arena) {
      tx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tx_state_ = tx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.tx_state)
}

// optional .aalyria.spacetime.api.common.ReceiverState rx_state = 2 [json_name = "rxState"];
inline bool RadioUpdate::has_rx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_state_ != nullptr);
  return value;
}
inline void RadioUpdate::clear_rx_state() {
  if (_impl_.rx_state_ != nullptr) _impl_.rx_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioUpdate::_internal_rx_state() const {
  const ::aalyria::spacetime::api::common::ReceiverState* p = _impl_.rx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ReceiverState&>(
      ::aalyria::spacetime::api::common::_ReceiverState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioUpdate::rx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.rx_state)
  return _internal_rx_state();
}
inline void RadioUpdate::unsafe_arena_set_allocated_rx_state(
    ::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_state_);
  }
  _impl_.rx_state_ = rx_state;
  if (rx_state) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioUpdate.rx_state)
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioUpdate::release_rx_state() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioUpdate::unsafe_arena_release_rx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.rx_state)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioUpdate::_internal_mutable_rx_state() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.rx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverState>(GetArenaForAllocation());
    _impl_.rx_state_ = p;
  }
  return _impl_.rx_state_;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioUpdate::mutable_rx_state() {
  ::aalyria::spacetime::api::common::ReceiverState* _msg = _internal_mutable_rx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.rx_state)
  return _msg;
}
inline void RadioUpdate::set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rx_state_;
  }
  if (rx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rx_state);
    if (message_arena != submessage_arena) {
      rx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rx_state_ = rx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.rx_state)
}

// optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 3 [json_name = "tdmaSchedule"];
inline bool RadioUpdate::has_tdma_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tdma_schedule_ != nullptr);
  return value;
}
inline void RadioUpdate::clear_tdma_schedule() {
  if (_impl_.tdma_schedule_ != nullptr) _impl_.tdma_schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioUpdate::_internal_tdma_schedule() const {
  const ::aalyria::spacetime::api::common::TdmaSchedule* p = _impl_.tdma_schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TdmaSchedule&>(
      ::aalyria::spacetime::api::common::_TdmaSchedule_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioUpdate::tdma_schedule() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.tdma_schedule)
  return _internal_tdma_schedule();
}
inline void RadioUpdate::unsafe_arena_set_allocated_tdma_schedule(
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tdma_schedule_);
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  if (tdma_schedule) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioUpdate.tdma_schedule)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioUpdate::release_tdma_schedule() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioUpdate::unsafe_arena_release_tdma_schedule() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.tdma_schedule)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioUpdate::_internal_mutable_tdma_schedule() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.tdma_schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule>(GetArenaForAllocation());
    _impl_.tdma_schedule_ = p;
  }
  return _impl_.tdma_schedule_;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioUpdate::mutable_tdma_schedule() {
  ::aalyria::spacetime::api::common::TdmaSchedule* _msg = _internal_mutable_tdma_schedule();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.tdma_schedule)
  return _msg;
}
inline void RadioUpdate::set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tdma_schedule_;
  }
  if (tdma_schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tdma_schedule);
    if (message_arena != submessage_arena) {
      tdma_schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tdma_schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.tdma_schedule)
}

// optional string modem_config_id = 8 [json_name = "modemConfigId"];
inline bool RadioUpdate::has_modem_config_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RadioUpdate::clear_modem_config_id() {
  _impl_.modem_config_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RadioUpdate::modem_config_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.modem_config_id)
  return _internal_modem_config_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioUpdate::set_modem_config_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.modem_config_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioUpdate.modem_config_id)
}
inline std::string* RadioUpdate::mutable_modem_config_id() {
  std::string* _s = _internal_mutable_modem_config_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioUpdate.modem_config_id)
  return _s;
}
inline const std::string& RadioUpdate::_internal_modem_config_id() const {
  return _impl_.modem_config_id_.Get();
}
inline void RadioUpdate::_internal_set_modem_config_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.modem_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioUpdate::_internal_mutable_modem_config_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.modem_config_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioUpdate::release_modem_config_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioUpdate.modem_config_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.modem_config_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modem_config_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioUpdate::set_allocated_modem_config_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.modem_config_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modem_config_id_.IsDefault()) {
          _impl_.modem_config_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioUpdate.modem_config_id)
}

// optional int64 per_interface_sequence_number = 5 [json_name = "perInterfaceSequenceNumber"];
inline bool RadioUpdate::has_per_interface_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RadioUpdate::clear_per_interface_sequence_number() {
  _impl_.per_interface_sequence_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t RadioUpdate::per_interface_sequence_number() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioUpdate.per_interface_sequence_number)
  return _internal_per_interface_sequence_number();
}
inline void RadioUpdate::set_per_interface_sequence_number(::int64_t value) {
  _internal_set_per_interface_sequence_number(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioUpdate.per_interface_sequence_number)
}
inline ::int64_t RadioUpdate::_internal_per_interface_sequence_number() const {
  return _impl_.per_interface_sequence_number_;
}
inline void RadioUpdate::_internal_set_per_interface_sequence_number(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.per_interface_sequence_number_ = value;
}

// -------------------------------------------------------------------

// RadioStates_RadioState

// optional string radio_config_id = 4 [json_name = "radioConfigId"];
inline bool RadioStates_RadioState::has_radio_config_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioStates_RadioState::clear_radio_config_id() {
  _impl_.radio_config_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RadioStates_RadioState::radio_config_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStates.RadioState.radio_config_id)
  return _internal_radio_config_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioStates_RadioState::set_radio_config_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.radio_config_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioStates.RadioState.radio_config_id)
}
inline std::string* RadioStates_RadioState::mutable_radio_config_id() {
  std::string* _s = _internal_mutable_radio_config_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStates.RadioState.radio_config_id)
  return _s;
}
inline const std::string& RadioStates_RadioState::_internal_radio_config_id() const {
  return _impl_.radio_config_id_.Get();
}
inline void RadioStates_RadioState::_internal_set_radio_config_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.radio_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioStates_RadioState::_internal_mutable_radio_config_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.radio_config_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioStates_RadioState::release_radio_config_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStates.RadioState.radio_config_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.radio_config_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.radio_config_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioStates_RadioState::set_allocated_radio_config_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.radio_config_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.radio_config_id_.IsDefault()) {
          _impl_.radio_config_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.radio_config_id)
}

// optional .aalyria.spacetime.api.common.TransmitterState tx_state = 1 [json_name = "txState"];
inline bool RadioStates_RadioState::has_tx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tx_state_ != nullptr);
  return value;
}
inline void RadioStates_RadioState::clear_tx_state() {
  if (_impl_.tx_state_ != nullptr) _impl_.tx_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioStates_RadioState::_internal_tx_state() const {
  const ::aalyria::spacetime::api::common::TransmitterState* p = _impl_.tx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransmitterState&>(
      ::aalyria::spacetime::api::common::_TransmitterState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioStates_RadioState::tx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStates.RadioState.tx_state)
  return _internal_tx_state();
}
inline void RadioStates_RadioState::unsafe_arena_set_allocated_tx_state(
    ::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_state_);
  }
  _impl_.tx_state_ = tx_state;
  if (tx_state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.tx_state)
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioStates_RadioState::release_tx_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioStates_RadioState::unsafe_arena_release_tx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStates.RadioState.tx_state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioStates_RadioState::_internal_mutable_tx_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransmitterState>(GetArenaForAllocation());
    _impl_.tx_state_ = p;
  }
  return _impl_.tx_state_;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioStates_RadioState::mutable_tx_state() {
  ::aalyria::spacetime::api::common::TransmitterState* _msg = _internal_mutable_tx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStates.RadioState.tx_state)
  return _msg;
}
inline void RadioStates_RadioState::set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tx_state_;
  }
  if (tx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_state);
    if (message_arena != submessage_arena) {
      tx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tx_state_ = tx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.tx_state)
}

// optional .aalyria.spacetime.api.common.ReceiverState rx_state = 2 [json_name = "rxState"];
inline bool RadioStates_RadioState::has_rx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_state_ != nullptr);
  return value;
}
inline void RadioStates_RadioState::clear_rx_state() {
  if (_impl_.rx_state_ != nullptr) _impl_.rx_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioStates_RadioState::_internal_rx_state() const {
  const ::aalyria::spacetime::api::common::ReceiverState* p = _impl_.rx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ReceiverState&>(
      ::aalyria::spacetime::api::common::_ReceiverState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioStates_RadioState::rx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStates.RadioState.rx_state)
  return _internal_rx_state();
}
inline void RadioStates_RadioState::unsafe_arena_set_allocated_rx_state(
    ::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_state_);
  }
  _impl_.rx_state_ = rx_state;
  if (rx_state) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.rx_state)
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioStates_RadioState::release_rx_state() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioStates_RadioState::unsafe_arena_release_rx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStates.RadioState.rx_state)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioStates_RadioState::_internal_mutable_rx_state() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverState>(GetArenaForAllocation());
    _impl_.rx_state_ = p;
  }
  return _impl_.rx_state_;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioStates_RadioState::mutable_rx_state() {
  ::aalyria::spacetime::api::common::ReceiverState* _msg = _internal_mutable_rx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStates.RadioState.rx_state)
  return _msg;
}
inline void RadioStates_RadioState::set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rx_state_;
  }
  if (rx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rx_state);
    if (message_arena != submessage_arena) {
      rx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rx_state_ = rx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.rx_state)
}

// optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 3 [json_name = "tdmaSchedule"];
inline bool RadioStates_RadioState::has_tdma_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tdma_schedule_ != nullptr);
  return value;
}
inline void RadioStates_RadioState::clear_tdma_schedule() {
  if (_impl_.tdma_schedule_ != nullptr) _impl_.tdma_schedule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioStates_RadioState::_internal_tdma_schedule() const {
  const ::aalyria::spacetime::api::common::TdmaSchedule* p = _impl_.tdma_schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TdmaSchedule&>(
      ::aalyria::spacetime::api::common::_TdmaSchedule_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioStates_RadioState::tdma_schedule() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStates.RadioState.tdma_schedule)
  return _internal_tdma_schedule();
}
inline void RadioStates_RadioState::unsafe_arena_set_allocated_tdma_schedule(
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tdma_schedule_);
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  if (tdma_schedule) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.tdma_schedule)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioStates_RadioState::release_tdma_schedule() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioStates_RadioState::unsafe_arena_release_tdma_schedule() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStates.RadioState.tdma_schedule)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioStates_RadioState::_internal_mutable_tdma_schedule() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tdma_schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule>(GetArenaForAllocation());
    _impl_.tdma_schedule_ = p;
  }
  return _impl_.tdma_schedule_;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioStates_RadioState::mutable_tdma_schedule() {
  ::aalyria::spacetime::api::common::TdmaSchedule* _msg = _internal_mutable_tdma_schedule();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStates.RadioState.tdma_schedule)
  return _msg;
}
inline void RadioStates_RadioState::set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tdma_schedule_;
  }
  if (tdma_schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tdma_schedule);
    if (message_arena != submessage_arena) {
      tdma_schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tdma_schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStates.RadioState.tdma_schedule)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RadioStates

// optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
inline bool RadioStates::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& RadioStates::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& RadioStates::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStates.timestamp)
  return _internal_timestamp();
}
inline void RadioStates::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioStates.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* RadioStates::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* RadioStates::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStates.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* RadioStates::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* RadioStates::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStates.timestamp)
  return _msg;
}
inline void RadioStates::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStates.timestamp)
}

// map<string, string> radio_config_id_by_interface_id = 4 [json_name = "radioConfigIdByInterfaceId"];
inline int RadioStates::_internal_radio_config_id_by_interface_id_size() const {
  return _impl_.radio_config_id_by_interface_id_.size();
}
inline int RadioStates::radio_config_id_by_interface_id_size() const {
  return _internal_radio_config_id_by_interface_id_size();
}
inline void RadioStates::clear_radio_config_id_by_interface_id() {
  _impl_.radio_config_id_by_interface_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadioStates::_internal_radio_config_id_by_interface_id() const {
  return _impl_.radio_config_id_by_interface_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadioStates::radio_config_id_by_interface_id() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.RadioStates.radio_config_id_by_interface_id)
  return _internal_radio_config_id_by_interface_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadioStates::_internal_mutable_radio_config_id_by_interface_id() {
  return _impl_.radio_config_id_by_interface_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadioStates::mutable_radio_config_id_by_interface_id() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.RadioStates.radio_config_id_by_interface_id)
  return _internal_mutable_radio_config_id_by_interface_id();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType>() {
  return ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_TxSlot_TxSlotType_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType>() {
  return ::aalyria::spacetime::api::common::TdmaSchedule_TdmaSlot_RxSlot_RxSlotType_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType>() {
  return ::aalyria::spacetime::api::common::TdmaSchedule_ScheduleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fradio_2eproto_2epb_2eh
