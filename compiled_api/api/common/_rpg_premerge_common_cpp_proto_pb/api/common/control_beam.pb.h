// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/control_beam.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fbeam_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fbeam_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/coordinates.pb.h"
#include "api/common/network.pb.h"
#include "api/common/platform.pb.h"
#include "api/common/time.pb.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fcontrol_5fbeam_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fcontrol_5fbeam_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class BeamStates;
struct BeamStatesDefaultTypeInternal;
extern BeamStatesDefaultTypeInternal _BeamStates_default_instance_;
class BeamTask;
struct BeamTaskDefaultTypeInternal;
extern BeamTaskDefaultTypeInternal _BeamTask_default_instance_;
class BeamUpdate;
struct BeamUpdateDefaultTypeInternal;
extern BeamUpdateDefaultTypeInternal _BeamUpdate_default_instance_;
class RadioConfig;
struct RadioConfigDefaultTypeInternal;
extern RadioConfigDefaultTypeInternal _RadioConfig_default_instance_;
class RadioConfig_Channel;
struct RadioConfig_ChannelDefaultTypeInternal;
extern RadioConfig_ChannelDefaultTypeInternal _RadioConfig_Channel_default_instance_;
class SignalAcquisitionInfo;
struct SignalAcquisitionInfoDefaultTypeInternal;
extern SignalAcquisitionInfoDefaultTypeInternal _SignalAcquisitionInfo_default_instance_;
class TargetAcquisitionInfo;
struct TargetAcquisitionInfoDefaultTypeInternal;
extern TargetAcquisitionInfoDefaultTypeInternal _TargetAcquisitionInfo_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::BeamStates* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStates>(Arena*);
template <>
::aalyria::spacetime::api::common::BeamTask* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamTask>(Arena*);
template <>
::aalyria::spacetime::api::common::BeamUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamUpdate>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioConfig* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioConfig>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioConfig_Channel* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioConfig_Channel>(Arena*);
template <>
::aalyria::spacetime::api::common::SignalAcquisitionInfo* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::SignalAcquisitionInfo>(Arena*);
template <>
::aalyria::spacetime::api::common::TargetAcquisitionInfo* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TargetAcquisitionInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum BeamUpdate_Operation : int {
  BeamUpdate_Operation_UNKNOWN = 0,
  BeamUpdate_Operation_ADD = 1,
  BeamUpdate_Operation_DELETE = 2,
};

bool BeamUpdate_Operation_IsValid(int value);
constexpr BeamUpdate_Operation BeamUpdate_Operation_Operation_MIN = static_cast<BeamUpdate_Operation>(0);
constexpr BeamUpdate_Operation BeamUpdate_Operation_Operation_MAX = static_cast<BeamUpdate_Operation>(2);
constexpr int BeamUpdate_Operation_Operation_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BeamUpdate_Operation_descriptor();
template <typename T>
const std::string& BeamUpdate_Operation_Name(T value) {
  static_assert(std::is_same<T, BeamUpdate_Operation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Operation_Name().");
  return BeamUpdate_Operation_Name(static_cast<BeamUpdate_Operation>(value));
}
template <>
inline const std::string& BeamUpdate_Operation_Name(BeamUpdate_Operation value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BeamUpdate_Operation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool BeamUpdate_Operation_Parse(absl::string_view name, BeamUpdate_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BeamUpdate_Operation>(
      BeamUpdate_Operation_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class BeamUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamUpdate) */ {
 public:
  inline BeamUpdate() : BeamUpdate(nullptr) {}
  ~BeamUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamUpdate(const BeamUpdate& from);
  BeamUpdate(BeamUpdate&& from) noexcept
    : BeamUpdate() {
    *this = ::std::move(from);
  }

  inline BeamUpdate& operator=(const BeamUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamUpdate& operator=(BeamUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeamUpdate* internal_default_instance() {
    return reinterpret_cast<const BeamUpdate*>(
               &_BeamUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BeamUpdate& a, BeamUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamUpdate& from) {
    BeamUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamUpdate";
  }
  protected:
  explicit BeamUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Operation = BeamUpdate_Operation;
  static constexpr Operation UNKNOWN = BeamUpdate_Operation_UNKNOWN;
  static constexpr Operation ADD = BeamUpdate_Operation_ADD;
  static constexpr Operation DELETE = BeamUpdate_Operation_DELETE;
  static inline bool Operation_IsValid(int value) {
    return BeamUpdate_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN = BeamUpdate_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX = BeamUpdate_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE = BeamUpdate_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Operation_descriptor() {
    return BeamUpdate_Operation_descriptor();
  }
  template <typename T>
  static inline const std::string& Operation_Name(T value) {
    return BeamUpdate_Operation_Name(value);
  }
  static inline bool Operation_Parse(absl::string_view name, Operation* value) {
    return BeamUpdate_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceInterfaceIdFieldNumber = 1,
    kTargetInterfaceIdFieldNumber = 2,
    kBeamTaskIdFieldNumber = 3,
    kAcquisitionInfoFieldNumber = 5,
    kTargetIdFieldNumber = 8,
    kEstablishmentTimeoutFieldNumber = 9,
    kInterfaceIdFieldNumber = 10,
    kRadioConfigFieldNumber = 11,
    kSignalInfoFieldNumber = 12,
    kPerInterfaceSequenceNumberFieldNumber = 7,
    kOperationFieldNumber = 4,
  };
  // optional string source_interface_id = 1 [json_name = "sourceInterfaceId", deprecated = true];
  [[deprecated]]  bool has_source_interface_id() const;
  [[deprecated]]  void clear_source_interface_id() ;
  [[deprecated]] const std::string& source_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_source_interface_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_source_interface_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_source_interface_id();
  [[deprecated]] void set_allocated_source_interface_id(std::string* ptr);

  private:
  const std::string& _internal_source_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_interface_id(
      const std::string& value);
  std::string* _internal_mutable_source_interface_id();

  public:
  // optional string target_interface_id = 2 [json_name = "targetInterfaceId", deprecated = true];
  [[deprecated]]  bool has_target_interface_id() const;
  [[deprecated]]  void clear_target_interface_id() ;
  [[deprecated]] const std::string& target_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_target_interface_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_target_interface_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_target_interface_id();
  [[deprecated]] void set_allocated_target_interface_id(std::string* ptr);

  private:
  const std::string& _internal_target_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_interface_id(
      const std::string& value);
  std::string* _internal_mutable_target_interface_id();

  public:
  // optional string beam_task_id = 3 [json_name = "beamTaskId"];
  bool has_beam_task_id() const;
  void clear_beam_task_id() ;
  const std::string& beam_task_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_beam_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_beam_task_id();
  PROTOBUF_NODISCARD std::string* release_beam_task_id();
  void set_allocated_beam_task_id(std::string* ptr);

  private:
  const std::string& _internal_beam_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beam_task_id(
      const std::string& value);
  std::string* _internal_mutable_beam_task_id();

  public:
  // optional .aalyria.spacetime.api.common.TargetAcquisitionInfo acquisition_info = 5 [json_name = "acquisitionInfo"];
  bool has_acquisition_info() const;
  void clear_acquisition_info() ;
  const ::aalyria::spacetime::api::common::TargetAcquisitionInfo& acquisition_info() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TargetAcquisitionInfo* release_acquisition_info();
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* mutable_acquisition_info();
  void set_allocated_acquisition_info(::aalyria::spacetime::api::common::TargetAcquisitionInfo* acquisition_info);
  private:
  const ::aalyria::spacetime::api::common::TargetAcquisitionInfo& _internal_acquisition_info() const;
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* _internal_mutable_acquisition_info();
  public:
  void unsafe_arena_set_allocated_acquisition_info(
      ::aalyria::spacetime::api::common::TargetAcquisitionInfo* acquisition_info);
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* unsafe_arena_release_acquisition_info();
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId target_id = 8 [json_name = "targetId"];
  bool has_target_id() const;
  void clear_target_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& target_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_target_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_target_id();
  void set_allocated_target_id(::aalyria::spacetime::api::common::NetworkInterfaceId* target_id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_target_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_target_id();
  public:
  void unsafe_arena_set_allocated_target_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_target_id();
  // optional .google.protobuf.Duration establishment_timeout = 9 [json_name = "establishmentTimeout"];
  bool has_establishment_timeout() const;
  void clear_establishment_timeout() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& establishment_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_establishment_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_establishment_timeout();
  void set_allocated_establishment_timeout(::PROTOBUF_NAMESPACE_ID::Duration* establishment_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_establishment_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_establishment_timeout();
  public:
  void unsafe_arena_set_allocated_establishment_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* establishment_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_establishment_timeout();
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 10 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& interface_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_interface_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_interface_id();
  void set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_interface_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_interface_id();
  public:
  void unsafe_arena_set_allocated_interface_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_interface_id();
  // optional .aalyria.spacetime.api.common.RadioConfig radio_config = 11 [json_name = "radioConfig"];
  bool has_radio_config() const;
  void clear_radio_config() ;
  const ::aalyria::spacetime::api::common::RadioConfig& radio_config() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioConfig* release_radio_config();
  ::aalyria::spacetime::api::common::RadioConfig* mutable_radio_config();
  void set_allocated_radio_config(::aalyria::spacetime::api::common::RadioConfig* radio_config);
  private:
  const ::aalyria::spacetime::api::common::RadioConfig& _internal_radio_config() const;
  ::aalyria::spacetime::api::common::RadioConfig* _internal_mutable_radio_config();
  public:
  void unsafe_arena_set_allocated_radio_config(
      ::aalyria::spacetime::api::common::RadioConfig* radio_config);
  ::aalyria::spacetime::api::common::RadioConfig* unsafe_arena_release_radio_config();
  // optional .aalyria.spacetime.api.common.SignalAcquisitionInfo signal_info = 12 [json_name = "signalInfo"];
  bool has_signal_info() const;
  void clear_signal_info() ;
  const ::aalyria::spacetime::api::common::SignalAcquisitionInfo& signal_info() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::SignalAcquisitionInfo* release_signal_info();
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* mutable_signal_info();
  void set_allocated_signal_info(::aalyria::spacetime::api::common::SignalAcquisitionInfo* signal_info);
  private:
  const ::aalyria::spacetime::api::common::SignalAcquisitionInfo& _internal_signal_info() const;
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* _internal_mutable_signal_info();
  public:
  void unsafe_arena_set_allocated_signal_info(
      ::aalyria::spacetime::api::common::SignalAcquisitionInfo* signal_info);
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* unsafe_arena_release_signal_info();
  // optional int64 per_interface_sequence_number = 7 [json_name = "perInterfaceSequenceNumber"];
  bool has_per_interface_sequence_number() const;
  void clear_per_interface_sequence_number() ;
  ::int64_t per_interface_sequence_number() const;
  void set_per_interface_sequence_number(::int64_t value);

  private:
  ::int64_t _internal_per_interface_sequence_number() const;
  void _internal_set_per_interface_sequence_number(::int64_t value);

  public:
  // optional .aalyria.spacetime.api.common.BeamUpdate.Operation operation = 4 [json_name = "operation"];
  bool has_operation() const;
  void clear_operation() ;
  ::aalyria::spacetime::api::common::BeamUpdate_Operation operation() const;
  void set_operation(::aalyria::spacetime::api::common::BeamUpdate_Operation value);

  private:
  ::aalyria::spacetime::api::common::BeamUpdate_Operation _internal_operation() const;
  void _internal_set_operation(::aalyria::spacetime::api::common::BeamUpdate_Operation value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beam_task_id_;
    ::aalyria::spacetime::api::common::TargetAcquisitionInfo* acquisition_info_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id_;
    ::PROTOBUF_NAMESPACE_ID::Duration* establishment_timeout_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id_;
    ::aalyria::spacetime::api::common::RadioConfig* radio_config_;
    ::aalyria::spacetime::api::common::SignalAcquisitionInfo* signal_info_;
    ::int64_t per_interface_sequence_number_;
    int operation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class RadioConfig_Channel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioConfig.Channel) */ {
 public:
  inline RadioConfig_Channel() : RadioConfig_Channel(nullptr) {}
  ~RadioConfig_Channel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioConfig_Channel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioConfig_Channel(const RadioConfig_Channel& from);
  RadioConfig_Channel(RadioConfig_Channel&& from) noexcept
    : RadioConfig_Channel() {
    *this = ::std::move(from);
  }

  inline RadioConfig_Channel& operator=(const RadioConfig_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioConfig_Channel& operator=(RadioConfig_Channel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioConfig_Channel& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioConfig_Channel* internal_default_instance() {
    return reinterpret_cast<const RadioConfig_Channel*>(
               &_RadioConfig_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RadioConfig_Channel& a, RadioConfig_Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioConfig_Channel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioConfig_Channel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioConfig_Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioConfig_Channel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioConfig_Channel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioConfig_Channel& from) {
    RadioConfig_Channel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioConfig_Channel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioConfig.Channel";
  }
  protected:
  explicit RadioConfig_Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFrequencyHzFieldNumber = 1,
    kChannelWidthHzFieldNumber = 2,
  };
  // optional uint64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
  bool has_center_frequency_hz() const;
  void clear_center_frequency_hz() ;
  ::uint64_t center_frequency_hz() const;
  void set_center_frequency_hz(::uint64_t value);

  private:
  ::uint64_t _internal_center_frequency_hz() const;
  void _internal_set_center_frequency_hz(::uint64_t value);

  public:
  // optional uint64 channel_width_hz = 2 [json_name = "channelWidthHz"];
  bool has_channel_width_hz() const;
  void clear_channel_width_hz() ;
  ::uint64_t channel_width_hz() const;
  void set_channel_width_hz(::uint64_t value);

  private:
  ::uint64_t _internal_channel_width_hz() const;
  void _internal_set_channel_width_hz(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioConfig.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint64_t center_frequency_hz_;
    ::uint64_t channel_width_hz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class RadioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioConfig) */ {
 public:
  inline RadioConfig() : RadioConfig(nullptr) {}
  ~RadioConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioConfig(const RadioConfig& from);
  RadioConfig(RadioConfig&& from) noexcept
    : RadioConfig() {
    *this = ::std::move(from);
  }

  inline RadioConfig& operator=(const RadioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioConfig& operator=(RadioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioConfig* internal_default_instance() {
    return reinterpret_cast<const RadioConfig*>(
               &_RadioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RadioConfig& a, RadioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioConfig& from) {
    RadioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioConfig";
  }
  protected:
  explicit RadioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RadioConfig_Channel Channel;

  // accessors -------------------------------------------------------

  enum : int {
    kModemConfigIdFieldNumber = 3,
    kTxChannelFieldNumber = 1,
    kRxChannelFieldNumber = 2,
  };
  // optional string modem_config_id = 3 [json_name = "modemConfigId"];
  bool has_modem_config_id() const;
  void clear_modem_config_id() ;
  const std::string& modem_config_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modem_config_id(Arg_&& arg, Args_... args);
  std::string* mutable_modem_config_id();
  PROTOBUF_NODISCARD std::string* release_modem_config_id();
  void set_allocated_modem_config_id(std::string* ptr);

  private:
  const std::string& _internal_modem_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modem_config_id(
      const std::string& value);
  std::string* _internal_mutable_modem_config_id();

  public:
  // optional .aalyria.spacetime.api.common.RadioConfig.Channel tx_channel = 1 [json_name = "txChannel"];
  bool has_tx_channel() const;
  void clear_tx_channel() ;
  const ::aalyria::spacetime::api::common::RadioConfig_Channel& tx_channel() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioConfig_Channel* release_tx_channel();
  ::aalyria::spacetime::api::common::RadioConfig_Channel* mutable_tx_channel();
  void set_allocated_tx_channel(::aalyria::spacetime::api::common::RadioConfig_Channel* tx_channel);
  private:
  const ::aalyria::spacetime::api::common::RadioConfig_Channel& _internal_tx_channel() const;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* _internal_mutable_tx_channel();
  public:
  void unsafe_arena_set_allocated_tx_channel(
      ::aalyria::spacetime::api::common::RadioConfig_Channel* tx_channel);
  ::aalyria::spacetime::api::common::RadioConfig_Channel* unsafe_arena_release_tx_channel();
  // optional .aalyria.spacetime.api.common.RadioConfig.Channel rx_channel = 2 [json_name = "rxChannel"];
  bool has_rx_channel() const;
  void clear_rx_channel() ;
  const ::aalyria::spacetime::api::common::RadioConfig_Channel& rx_channel() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioConfig_Channel* release_rx_channel();
  ::aalyria::spacetime::api::common::RadioConfig_Channel* mutable_rx_channel();
  void set_allocated_rx_channel(::aalyria::spacetime::api::common::RadioConfig_Channel* rx_channel);
  private:
  const ::aalyria::spacetime::api::common::RadioConfig_Channel& _internal_rx_channel() const;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* _internal_mutable_rx_channel();
  public:
  void unsafe_arena_set_allocated_rx_channel(
      ::aalyria::spacetime::api::common::RadioConfig_Channel* rx_channel);
  ::aalyria::spacetime::api::common::RadioConfig_Channel* unsafe_arena_release_rx_channel();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modem_config_id_;
    ::aalyria::spacetime::api::common::RadioConfig_Channel* tx_channel_;
    ::aalyria::spacetime::api::common::RadioConfig_Channel* rx_channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class SignalAcquisitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.SignalAcquisitionInfo) */ {
 public:
  inline SignalAcquisitionInfo() : SignalAcquisitionInfo(nullptr) {}
  ~SignalAcquisitionInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignalAcquisitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalAcquisitionInfo(const SignalAcquisitionInfo& from);
  SignalAcquisitionInfo(SignalAcquisitionInfo&& from) noexcept
    : SignalAcquisitionInfo() {
    *this = ::std::move(from);
  }

  inline SignalAcquisitionInfo& operator=(const SignalAcquisitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalAcquisitionInfo& operator=(SignalAcquisitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalAcquisitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalAcquisitionInfo* internal_default_instance() {
    return reinterpret_cast<const SignalAcquisitionInfo*>(
               &_SignalAcquisitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignalAcquisitionInfo& a, SignalAcquisitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalAcquisitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalAcquisitionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalAcquisitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalAcquisitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalAcquisitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalAcquisitionInfo& from) {
    SignalAcquisitionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalAcquisitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.SignalAcquisitionInfo";
  }
  protected:
  explicit SignalAcquisitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeledPowerAtReceiverOutputDbwFieldNumber = 1,
  };
  // optional double modeled_power_at_receiver_output_dbw = 1 [json_name = "modeledPowerAtReceiverOutputDbw"];
  bool has_modeled_power_at_receiver_output_dbw() const;
  void clear_modeled_power_at_receiver_output_dbw() ;
  double modeled_power_at_receiver_output_dbw() const;
  void set_modeled_power_at_receiver_output_dbw(double value);

  private:
  double _internal_modeled_power_at_receiver_output_dbw() const;
  void _internal_set_modeled_power_at_receiver_output_dbw(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.SignalAcquisitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double modeled_power_at_receiver_output_dbw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class TargetAcquisitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TargetAcquisitionInfo) */ {
 public:
  inline TargetAcquisitionInfo() : TargetAcquisitionInfo(nullptr) {}
  ~TargetAcquisitionInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TargetAcquisitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetAcquisitionInfo(const TargetAcquisitionInfo& from);
  TargetAcquisitionInfo(TargetAcquisitionInfo&& from) noexcept
    : TargetAcquisitionInfo() {
    *this = ::std::move(from);
  }

  inline TargetAcquisitionInfo& operator=(const TargetAcquisitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetAcquisitionInfo& operator=(TargetAcquisitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetAcquisitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetAcquisitionInfo* internal_default_instance() {
    return reinterpret_cast<const TargetAcquisitionInfo*>(
               &_TargetAcquisitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TargetAcquisitionInfo& a, TargetAcquisitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetAcquisitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetAcquisitionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetAcquisitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetAcquisitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetAcquisitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TargetAcquisitionInfo& from) {
    TargetAcquisitionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetAcquisitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TargetAcquisitionInfo";
  }
  protected:
  explicit TargetAcquisitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalAddressFieldNumber = 10,
    kAdsbTransponderFieldNumber = 9,
    kCoordinatesFieldNumber = 12,
    kLongitudeFieldNumber = 3,
    kLatitudeFieldNumber = 4,
    kHeightFieldNumber = 5,
  };
  // optional bytes physical_address = 10 [json_name = "physicalAddress"];
  bool has_physical_address() const;
  void clear_physical_address() ;
  const std::string& physical_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_physical_address(Arg_&& arg, Args_... args);
  std::string* mutable_physical_address();
  PROTOBUF_NODISCARD std::string* release_physical_address();
  void set_allocated_physical_address(std::string* ptr);

  private:
  const std::string& _internal_physical_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_address(
      const std::string& value);
  std::string* _internal_mutable_physical_address();

  public:
  // optional .aalyria.spacetime.api.common.AdsbTransponder adsb_transponder = 9 [json_name = "adsbTransponder"];
  bool has_adsb_transponder() const;
  void clear_adsb_transponder() ;
  const ::aalyria::spacetime::api::common::AdsbTransponder& adsb_transponder() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AdsbTransponder* release_adsb_transponder();
  ::aalyria::spacetime::api::common::AdsbTransponder* mutable_adsb_transponder();
  void set_allocated_adsb_transponder(::aalyria::spacetime::api::common::AdsbTransponder* adsb_transponder);
  private:
  const ::aalyria::spacetime::api::common::AdsbTransponder& _internal_adsb_transponder() const;
  ::aalyria::spacetime::api::common::AdsbTransponder* _internal_mutable_adsb_transponder();
  public:
  void unsafe_arena_set_allocated_adsb_transponder(
      ::aalyria::spacetime::api::common::AdsbTransponder* adsb_transponder);
  ::aalyria::spacetime::api::common::AdsbTransponder* unsafe_arena_release_adsb_transponder();
  // optional .aalyria.spacetime.api.common.Motion coordinates = 12 [json_name = "coordinates"];
  bool has_coordinates() const;
  void clear_coordinates() ;
  const ::aalyria::spacetime::api::common::Motion& coordinates() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Motion* release_coordinates();
  ::aalyria::spacetime::api::common::Motion* mutable_coordinates();
  void set_allocated_coordinates(::aalyria::spacetime::api::common::Motion* coordinates);
  private:
  const ::aalyria::spacetime::api::common::Motion& _internal_coordinates() const;
  ::aalyria::spacetime::api::common::Motion* _internal_mutable_coordinates();
  public:
  void unsafe_arena_set_allocated_coordinates(
      ::aalyria::spacetime::api::common::Motion* coordinates);
  ::aalyria::spacetime::api::common::Motion* unsafe_arena_release_coordinates();
  // optional double longitude = 3 [json_name = "longitude", deprecated = true];
  [[deprecated]]  bool has_longitude() const;
  [[deprecated]]  void clear_longitude() ;
  [[deprecated]] double longitude() const;
  [[deprecated]] void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // optional double latitude = 4 [json_name = "latitude", deprecated = true];
  [[deprecated]]  bool has_latitude() const;
  [[deprecated]]  void clear_latitude() ;
  [[deprecated]] double latitude() const;
  [[deprecated]] void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // optional double height = 5 [json_name = "height", deprecated = true];
  [[deprecated]]  bool has_height() const;
  [[deprecated]]  void clear_height() ;
  [[deprecated]] double height() const;
  [[deprecated]] void set_height(double value);

  private:
  double _internal_height() const;
  void _internal_set_height(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TargetAcquisitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_address_;
    ::aalyria::spacetime::api::common::AdsbTransponder* adsb_transponder_;
    ::aalyria::spacetime::api::common::Motion* coordinates_;
    double longitude_;
    double latitude_;
    double height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class BeamTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamTask) */ {
 public:
  inline BeamTask() : BeamTask(nullptr) {}
  ~BeamTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamTask(const BeamTask& from);
  BeamTask(BeamTask&& from) noexcept
    : BeamTask() {
    *this = ::std::move(from);
  }

  inline BeamTask& operator=(const BeamTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamTask& operator=(BeamTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeamTask* internal_default_instance() {
    return reinterpret_cast<const BeamTask*>(
               &_BeamTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BeamTask& a, BeamTask& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamTask& from) {
    BeamTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamTask";
  }
  protected:
  explicit BeamTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceIdFieldNumber = 1,
    kTargetInterfaceIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
  };
  // optional string interface_id = 1 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // optional string target_interface_id = 2 [json_name = "targetInterfaceId", deprecated = true];
  [[deprecated]]  bool has_target_interface_id() const;
  [[deprecated]]  void clear_target_interface_id() ;
  [[deprecated]] const std::string& target_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_target_interface_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_target_interface_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_target_interface_id();
  [[deprecated]] void set_allocated_target_interface_id(std::string* ptr);

  private:
  const std::string& _internal_target_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_interface_id(
      const std::string& value);
  std::string* _internal_mutable_target_interface_id();

  public:
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId target_id = 3 [json_name = "targetId"];
  bool has_target_id() const;
  void clear_target_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& target_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_target_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_target_id();
  void set_allocated_target_id(::aalyria::spacetime::api::common::NetworkInterfaceId* target_id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_target_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_target_id();
  public:
  void unsafe_arena_set_allocated_target_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_target_id();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_interface_id_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};// -------------------------------------------------------------------

class BeamStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamStates) */ {
 public:
  inline BeamStates() : BeamStates(nullptr) {}
  ~BeamStates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamStates(const BeamStates& from);
  BeamStates(BeamStates&& from) noexcept
    : BeamStates() {
    *this = ::std::move(from);
  }

  inline BeamStates& operator=(const BeamStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamStates& operator=(BeamStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeamStates* internal_default_instance() {
    return reinterpret_cast<const BeamStates*>(
               &_BeamStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BeamStates& a, BeamStates& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamStates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamStates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamStates& from) {
    BeamStates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamStates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamStates";
  }
  protected:
  explicit BeamStates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeamTaskIdsFieldNumber = 4,
    kTimestampFieldNumber = 3,
  };
  // repeated string beam_task_ids = 4 [json_name = "beamTaskIds"];
  int beam_task_ids_size() const;
  private:
  int _internal_beam_task_ids_size() const;

  public:
  void clear_beam_task_ids() ;
  const std::string& beam_task_ids(int index) const;
  std::string* mutable_beam_task_ids(int index);
  void set_beam_task_ids(int index, const std::string& value);
  void set_beam_task_ids(int index, std::string&& value);
  void set_beam_task_ids(int index, const char* value);
  void set_beam_task_ids(int index, const char* value, std::size_t size);
  void set_beam_task_ids(int index, absl::string_view value);
  std::string* add_beam_task_ids();
  void add_beam_task_ids(const std::string& value);
  void add_beam_task_ids(std::string&& value);
  void add_beam_task_ids(const char* value);
  void add_beam_task_ids(const char* value, std::size_t size);
  void add_beam_task_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& beam_task_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_beam_task_ids();

  private:
  const std::string& _internal_beam_task_ids(int index) const;
  std::string* _internal_add_beam_task_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_beam_task_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_beam_task_ids();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> beam_task_ids_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_5fbeam_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BeamUpdate

// optional string beam_task_id = 3 [json_name = "beamTaskId"];
inline bool BeamUpdate::has_beam_task_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BeamUpdate::clear_beam_task_id() {
  _impl_.beam_task_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BeamUpdate::beam_task_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.beam_task_id)
  return _internal_beam_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamUpdate::set_beam_task_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.beam_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamUpdate.beam_task_id)
}
inline std::string* BeamUpdate::mutable_beam_task_id() {
  std::string* _s = _internal_mutable_beam_task_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.beam_task_id)
  return _s;
}
inline const std::string& BeamUpdate::_internal_beam_task_id() const {
  return _impl_.beam_task_id_.Get();
}
inline void BeamUpdate::_internal_set_beam_task_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.beam_task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamUpdate::_internal_mutable_beam_task_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.beam_task_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamUpdate::release_beam_task_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.beam_task_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.beam_task_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.beam_task_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamUpdate::set_allocated_beam_task_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.beam_task_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.beam_task_id_.IsDefault()) {
          _impl_.beam_task_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.beam_task_id)
}

// optional .aalyria.spacetime.api.common.BeamUpdate.Operation operation = 4 [json_name = "operation"];
inline bool BeamUpdate::has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void BeamUpdate::clear_operation() {
  _impl_.operation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::aalyria::spacetime::api::common::BeamUpdate_Operation BeamUpdate::operation() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.operation)
  return _internal_operation();
}
inline void BeamUpdate::set_operation(::aalyria::spacetime::api::common::BeamUpdate_Operation value) {
   _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamUpdate.operation)
}
inline ::aalyria::spacetime::api::common::BeamUpdate_Operation BeamUpdate::_internal_operation() const {
  return static_cast<::aalyria::spacetime::api::common::BeamUpdate_Operation>(_impl_.operation_);
}
inline void BeamUpdate::_internal_set_operation(::aalyria::spacetime::api::common::BeamUpdate_Operation value) {
  assert(::aalyria::spacetime::api::common::BeamUpdate_Operation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.operation_ = value;
}

// optional string source_interface_id = 1 [json_name = "sourceInterfaceId", deprecated = true];
inline bool BeamUpdate::has_source_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BeamUpdate::clear_source_interface_id() {
  _impl_.source_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BeamUpdate::source_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.source_interface_id)
  return _internal_source_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamUpdate::set_source_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamUpdate.source_interface_id)
}
inline std::string* BeamUpdate::mutable_source_interface_id() {
  std::string* _s = _internal_mutable_source_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.source_interface_id)
  return _s;
}
inline const std::string& BeamUpdate::_internal_source_interface_id() const {
  return _impl_.source_interface_id_.Get();
}
inline void BeamUpdate::_internal_set_source_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.source_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamUpdate::_internal_mutable_source_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamUpdate::release_source_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.source_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.source_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamUpdate::set_allocated_source_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_interface_id_.IsDefault()) {
          _impl_.source_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.source_interface_id)
}

// optional .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 10 [json_name = "interfaceId"];
inline bool BeamUpdate::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interface_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamUpdate::_internal_interface_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.interface_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamUpdate::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.interface_id)
  return _internal_interface_id();
}
inline void BeamUpdate::unsafe_arena_set_allocated_interface_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_id_);
  }
  _impl_.interface_id_ = interface_id;
  if (interface_id) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.interface_id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::release_interface_id() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.interface_id_;
  _impl_.interface_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::unsafe_arena_release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.interface_id)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.interface_id_;
  _impl_.interface_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.interface_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.interface_id_ = p;
  }
  return _impl_.interface_id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::mutable_interface_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.interface_id)
  return _msg;
}
inline void BeamUpdate::set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_id_);
  }
  if (interface_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_id));
    if (message_arena != submessage_arena) {
      interface_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.interface_id_ = interface_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.interface_id)
}

// optional .aalyria.spacetime.api.common.RadioConfig radio_config = 11 [json_name = "radioConfig"];
inline bool BeamUpdate::has_radio_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radio_config_ != nullptr);
  return value;
}
inline void BeamUpdate::clear_radio_config() {
  if (_impl_.radio_config_ != nullptr) _impl_.radio_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::aalyria::spacetime::api::common::RadioConfig& BeamUpdate::_internal_radio_config() const {
  const ::aalyria::spacetime::api::common::RadioConfig* p = _impl_.radio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::RadioConfig&>(
      ::aalyria::spacetime::api::common::_RadioConfig_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioConfig& BeamUpdate::radio_config() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.radio_config)
  return _internal_radio_config();
}
inline void BeamUpdate::unsafe_arena_set_allocated_radio_config(
    ::aalyria::spacetime::api::common::RadioConfig* radio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.radio_config_);
  }
  _impl_.radio_config_ = radio_config;
  if (radio_config) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.radio_config)
}
inline ::aalyria::spacetime::api::common::RadioConfig* BeamUpdate::release_radio_config() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::aalyria::spacetime::api::common::RadioConfig* temp = _impl_.radio_config_;
  _impl_.radio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig* BeamUpdate::unsafe_arena_release_radio_config() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.radio_config)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::aalyria::spacetime::api::common::RadioConfig* temp = _impl_.radio_config_;
  _impl_.radio_config_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig* BeamUpdate::_internal_mutable_radio_config() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.radio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::RadioConfig>(GetArenaForAllocation());
    _impl_.radio_config_ = p;
  }
  return _impl_.radio_config_;
}
inline ::aalyria::spacetime::api::common::RadioConfig* BeamUpdate::mutable_radio_config() {
  ::aalyria::spacetime::api::common::RadioConfig* _msg = _internal_mutable_radio_config();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.radio_config)
  return _msg;
}
inline void BeamUpdate::set_allocated_radio_config(::aalyria::spacetime::api::common::RadioConfig* radio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.radio_config_;
  }
  if (radio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(radio_config);
    if (message_arena != submessage_arena) {
      radio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.radio_config_ = radio_config;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.radio_config)
}

// optional string target_interface_id = 2 [json_name = "targetInterfaceId", deprecated = true];
inline bool BeamUpdate::has_target_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BeamUpdate::clear_target_interface_id() {
  _impl_.target_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BeamUpdate::target_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.target_interface_id)
  return _internal_target_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamUpdate::set_target_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamUpdate.target_interface_id)
}
inline std::string* BeamUpdate::mutable_target_interface_id() {
  std::string* _s = _internal_mutable_target_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.target_interface_id)
  return _s;
}
inline const std::string& BeamUpdate::_internal_target_interface_id() const {
  return _impl_.target_interface_id_.Get();
}
inline void BeamUpdate::_internal_set_target_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.target_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamUpdate::_internal_mutable_target_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.target_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamUpdate::release_target_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.target_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.target_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamUpdate::set_allocated_target_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_interface_id_.IsDefault()) {
          _impl_.target_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.target_interface_id)
}

// optional .aalyria.spacetime.api.common.NetworkInterfaceId target_id = 8 [json_name = "targetId"];
inline bool BeamUpdate::has_target_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamUpdate::_internal_target_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.target_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamUpdate::target_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.target_id)
  return _internal_target_id();
}
inline void BeamUpdate::unsafe_arena_set_allocated_target_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_id_);
  }
  _impl_.target_id_ = target_id;
  if (target_id) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.target_id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::release_target_id() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.target_id_;
  _impl_.target_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::unsafe_arena_release_target_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.target_id)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.target_id_;
  _impl_.target_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::_internal_mutable_target_id() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.target_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.target_id_ = p;
  }
  return _impl_.target_id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamUpdate::mutable_target_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.target_id)
  return _msg;
}
inline void BeamUpdate::set_allocated_target_id(::aalyria::spacetime::api::common::NetworkInterfaceId* target_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_id_);
  }
  if (target_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_id));
    if (message_arena != submessage_arena) {
      target_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.target_id_ = target_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.target_id)
}

// optional .aalyria.spacetime.api.common.TargetAcquisitionInfo acquisition_info = 5 [json_name = "acquisitionInfo"];
inline bool BeamUpdate::has_acquisition_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acquisition_info_ != nullptr);
  return value;
}
inline void BeamUpdate::clear_acquisition_info() {
  if (_impl_.acquisition_info_ != nullptr) _impl_.acquisition_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::TargetAcquisitionInfo& BeamUpdate::_internal_acquisition_info() const {
  const ::aalyria::spacetime::api::common::TargetAcquisitionInfo* p = _impl_.acquisition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TargetAcquisitionInfo&>(
      ::aalyria::spacetime::api::common::_TargetAcquisitionInfo_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TargetAcquisitionInfo& BeamUpdate::acquisition_info() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.acquisition_info)
  return _internal_acquisition_info();
}
inline void BeamUpdate::unsafe_arena_set_allocated_acquisition_info(
    ::aalyria::spacetime::api::common::TargetAcquisitionInfo* acquisition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acquisition_info_);
  }
  _impl_.acquisition_info_ = acquisition_info;
  if (acquisition_info) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.acquisition_info)
}
inline ::aalyria::spacetime::api::common::TargetAcquisitionInfo* BeamUpdate::release_acquisition_info() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* temp = _impl_.acquisition_info_;
  _impl_.acquisition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TargetAcquisitionInfo* BeamUpdate::unsafe_arena_release_acquisition_info() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.acquisition_info)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* temp = _impl_.acquisition_info_;
  _impl_.acquisition_info_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TargetAcquisitionInfo* BeamUpdate::_internal_mutable_acquisition_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.acquisition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TargetAcquisitionInfo>(GetArenaForAllocation());
    _impl_.acquisition_info_ = p;
  }
  return _impl_.acquisition_info_;
}
inline ::aalyria::spacetime::api::common::TargetAcquisitionInfo* BeamUpdate::mutable_acquisition_info() {
  ::aalyria::spacetime::api::common::TargetAcquisitionInfo* _msg = _internal_mutable_acquisition_info();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.acquisition_info)
  return _msg;
}
inline void BeamUpdate::set_allocated_acquisition_info(::aalyria::spacetime::api::common::TargetAcquisitionInfo* acquisition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acquisition_info_;
  }
  if (acquisition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acquisition_info);
    if (message_arena != submessage_arena) {
      acquisition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.acquisition_info_ = acquisition_info;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.acquisition_info)
}

// optional .aalyria.spacetime.api.common.SignalAcquisitionInfo signal_info = 12 [json_name = "signalInfo"];
inline bool BeamUpdate::has_signal_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.signal_info_ != nullptr);
  return value;
}
inline void BeamUpdate::clear_signal_info() {
  if (_impl_.signal_info_ != nullptr) _impl_.signal_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::aalyria::spacetime::api::common::SignalAcquisitionInfo& BeamUpdate::_internal_signal_info() const {
  const ::aalyria::spacetime::api::common::SignalAcquisitionInfo* p = _impl_.signal_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::SignalAcquisitionInfo&>(
      ::aalyria::spacetime::api::common::_SignalAcquisitionInfo_default_instance_);
}
inline const ::aalyria::spacetime::api::common::SignalAcquisitionInfo& BeamUpdate::signal_info() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.signal_info)
  return _internal_signal_info();
}
inline void BeamUpdate::unsafe_arena_set_allocated_signal_info(
    ::aalyria::spacetime::api::common::SignalAcquisitionInfo* signal_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_info_);
  }
  _impl_.signal_info_ = signal_info;
  if (signal_info) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.signal_info)
}
inline ::aalyria::spacetime::api::common::SignalAcquisitionInfo* BeamUpdate::release_signal_info() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* temp = _impl_.signal_info_;
  _impl_.signal_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::SignalAcquisitionInfo* BeamUpdate::unsafe_arena_release_signal_info() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.signal_info)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* temp = _impl_.signal_info_;
  _impl_.signal_info_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::SignalAcquisitionInfo* BeamUpdate::_internal_mutable_signal_info() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.signal_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::SignalAcquisitionInfo>(GetArenaForAllocation());
    _impl_.signal_info_ = p;
  }
  return _impl_.signal_info_;
}
inline ::aalyria::spacetime::api::common::SignalAcquisitionInfo* BeamUpdate::mutable_signal_info() {
  ::aalyria::spacetime::api::common::SignalAcquisitionInfo* _msg = _internal_mutable_signal_info();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.signal_info)
  return _msg;
}
inline void BeamUpdate::set_allocated_signal_info(::aalyria::spacetime::api::common::SignalAcquisitionInfo* signal_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.signal_info_;
  }
  if (signal_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_info);
    if (message_arena != submessage_arena) {
      signal_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.signal_info_ = signal_info;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.signal_info)
}

// optional int64 per_interface_sequence_number = 7 [json_name = "perInterfaceSequenceNumber"];
inline bool BeamUpdate::has_per_interface_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void BeamUpdate::clear_per_interface_sequence_number() {
  _impl_.per_interface_sequence_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int64_t BeamUpdate::per_interface_sequence_number() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.per_interface_sequence_number)
  return _internal_per_interface_sequence_number();
}
inline void BeamUpdate::set_per_interface_sequence_number(::int64_t value) {
  _internal_set_per_interface_sequence_number(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamUpdate.per_interface_sequence_number)
}
inline ::int64_t BeamUpdate::_internal_per_interface_sequence_number() const {
  return _impl_.per_interface_sequence_number_;
}
inline void BeamUpdate::_internal_set_per_interface_sequence_number(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.per_interface_sequence_number_ = value;
}

// optional .google.protobuf.Duration establishment_timeout = 9 [json_name = "establishmentTimeout"];
inline bool BeamUpdate::has_establishment_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.establishment_timeout_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BeamUpdate::_internal_establishment_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.establishment_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BeamUpdate::establishment_timeout() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamUpdate.establishment_timeout)
  return _internal_establishment_timeout();
}
inline void BeamUpdate::unsafe_arena_set_allocated_establishment_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* establishment_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.establishment_timeout_);
  }
  _impl_.establishment_timeout_ = establishment_timeout;
  if (establishment_timeout) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamUpdate.establishment_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BeamUpdate::release_establishment_timeout() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.establishment_timeout_;
  _impl_.establishment_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BeamUpdate::unsafe_arena_release_establishment_timeout() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamUpdate.establishment_timeout)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.establishment_timeout_;
  _impl_.establishment_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BeamUpdate::_internal_mutable_establishment_timeout() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.establishment_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.establishment_timeout_ = p;
  }
  return _impl_.establishment_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BeamUpdate::mutable_establishment_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_establishment_timeout();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamUpdate.establishment_timeout)
  return _msg;
}
inline void BeamUpdate::set_allocated_establishment_timeout(::PROTOBUF_NAMESPACE_ID::Duration* establishment_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.establishment_timeout_);
  }
  if (establishment_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(establishment_timeout));
    if (message_arena != submessage_arena) {
      establishment_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, establishment_timeout, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.establishment_timeout_ = establishment_timeout;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamUpdate.establishment_timeout)
}

// -------------------------------------------------------------------

// RadioConfig_Channel

// optional uint64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
inline bool RadioConfig_Channel::has_center_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioConfig_Channel::clear_center_frequency_hz() {
  _impl_.center_frequency_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t RadioConfig_Channel::center_frequency_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioConfig.Channel.center_frequency_hz)
  return _internal_center_frequency_hz();
}
inline void RadioConfig_Channel::set_center_frequency_hz(::uint64_t value) {
  _internal_set_center_frequency_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioConfig.Channel.center_frequency_hz)
}
inline ::uint64_t RadioConfig_Channel::_internal_center_frequency_hz() const {
  return _impl_.center_frequency_hz_;
}
inline void RadioConfig_Channel::_internal_set_center_frequency_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.center_frequency_hz_ = value;
}

// optional uint64 channel_width_hz = 2 [json_name = "channelWidthHz"];
inline bool RadioConfig_Channel::has_channel_width_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RadioConfig_Channel::clear_channel_width_hz() {
  _impl_.channel_width_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RadioConfig_Channel::channel_width_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioConfig.Channel.channel_width_hz)
  return _internal_channel_width_hz();
}
inline void RadioConfig_Channel::set_channel_width_hz(::uint64_t value) {
  _internal_set_channel_width_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioConfig.Channel.channel_width_hz)
}
inline ::uint64_t RadioConfig_Channel::_internal_channel_width_hz() const {
  return _impl_.channel_width_hz_;
}
inline void RadioConfig_Channel::_internal_set_channel_width_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_width_hz_ = value;
}

// -------------------------------------------------------------------

// RadioConfig

// optional .aalyria.spacetime.api.common.RadioConfig.Channel tx_channel = 1 [json_name = "txChannel"];
inline bool RadioConfig::has_tx_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tx_channel_ != nullptr);
  return value;
}
inline void RadioConfig::clear_tx_channel() {
  if (_impl_.tx_channel_ != nullptr) _impl_.tx_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::RadioConfig_Channel& RadioConfig::_internal_tx_channel() const {
  const ::aalyria::spacetime::api::common::RadioConfig_Channel* p = _impl_.tx_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::RadioConfig_Channel&>(
      ::aalyria::spacetime::api::common::_RadioConfig_Channel_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioConfig_Channel& RadioConfig::tx_channel() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioConfig.tx_channel)
  return _internal_tx_channel();
}
inline void RadioConfig::unsafe_arena_set_allocated_tx_channel(
    ::aalyria::spacetime::api::common::RadioConfig_Channel* tx_channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_channel_);
  }
  _impl_.tx_channel_ = tx_channel;
  if (tx_channel) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioConfig.tx_channel)
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::release_tx_channel() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* temp = _impl_.tx_channel_;
  _impl_.tx_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::unsafe_arena_release_tx_channel() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioConfig.tx_channel)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* temp = _impl_.tx_channel_;
  _impl_.tx_channel_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::_internal_mutable_tx_channel() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tx_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::RadioConfig_Channel>(GetArenaForAllocation());
    _impl_.tx_channel_ = p;
  }
  return _impl_.tx_channel_;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::mutable_tx_channel() {
  ::aalyria::spacetime::api::common::RadioConfig_Channel* _msg = _internal_mutable_tx_channel();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioConfig.tx_channel)
  return _msg;
}
inline void RadioConfig::set_allocated_tx_channel(::aalyria::spacetime::api::common::RadioConfig_Channel* tx_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tx_channel_;
  }
  if (tx_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_channel);
    if (message_arena != submessage_arena) {
      tx_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_channel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tx_channel_ = tx_channel;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioConfig.tx_channel)
}

// optional .aalyria.spacetime.api.common.RadioConfig.Channel rx_channel = 2 [json_name = "rxChannel"];
inline bool RadioConfig::has_rx_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_channel_ != nullptr);
  return value;
}
inline void RadioConfig::clear_rx_channel() {
  if (_impl_.rx_channel_ != nullptr) _impl_.rx_channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::RadioConfig_Channel& RadioConfig::_internal_rx_channel() const {
  const ::aalyria::spacetime::api::common::RadioConfig_Channel* p = _impl_.rx_channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::RadioConfig_Channel&>(
      ::aalyria::spacetime::api::common::_RadioConfig_Channel_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioConfig_Channel& RadioConfig::rx_channel() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioConfig.rx_channel)
  return _internal_rx_channel();
}
inline void RadioConfig::unsafe_arena_set_allocated_rx_channel(
    ::aalyria::spacetime::api::common::RadioConfig_Channel* rx_channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_channel_);
  }
  _impl_.rx_channel_ = rx_channel;
  if (rx_channel) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.RadioConfig.rx_channel)
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::release_rx_channel() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* temp = _impl_.rx_channel_;
  _impl_.rx_channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::unsafe_arena_release_rx_channel() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioConfig.rx_channel)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::RadioConfig_Channel* temp = _impl_.rx_channel_;
  _impl_.rx_channel_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::_internal_mutable_rx_channel() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rx_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::RadioConfig_Channel>(GetArenaForAllocation());
    _impl_.rx_channel_ = p;
  }
  return _impl_.rx_channel_;
}
inline ::aalyria::spacetime::api::common::RadioConfig_Channel* RadioConfig::mutable_rx_channel() {
  ::aalyria::spacetime::api::common::RadioConfig_Channel* _msg = _internal_mutable_rx_channel();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioConfig.rx_channel)
  return _msg;
}
inline void RadioConfig::set_allocated_rx_channel(::aalyria::spacetime::api::common::RadioConfig_Channel* rx_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rx_channel_;
  }
  if (rx_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rx_channel);
    if (message_arena != submessage_arena) {
      rx_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_channel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rx_channel_ = rx_channel;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioConfig.rx_channel)
}

// optional string modem_config_id = 3 [json_name = "modemConfigId"];
inline bool RadioConfig::has_modem_config_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioConfig::clear_modem_config_id() {
  _impl_.modem_config_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RadioConfig::modem_config_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioConfig.modem_config_id)
  return _internal_modem_config_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioConfig::set_modem_config_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modem_config_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioConfig.modem_config_id)
}
inline std::string* RadioConfig::mutable_modem_config_id() {
  std::string* _s = _internal_mutable_modem_config_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioConfig.modem_config_id)
  return _s;
}
inline const std::string& RadioConfig::_internal_modem_config_id() const {
  return _impl_.modem_config_id_.Get();
}
inline void RadioConfig::_internal_set_modem_config_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.modem_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioConfig::_internal_mutable_modem_config_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modem_config_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioConfig::release_modem_config_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioConfig.modem_config_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modem_config_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.modem_config_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioConfig::set_allocated_modem_config_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modem_config_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modem_config_id_.IsDefault()) {
          _impl_.modem_config_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioConfig.modem_config_id)
}

// -------------------------------------------------------------------

// SignalAcquisitionInfo

// optional double modeled_power_at_receiver_output_dbw = 1 [json_name = "modeledPowerAtReceiverOutputDbw"];
inline bool SignalAcquisitionInfo::has_modeled_power_at_receiver_output_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SignalAcquisitionInfo::clear_modeled_power_at_receiver_output_dbw() {
  _impl_.modeled_power_at_receiver_output_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SignalAcquisitionInfo::modeled_power_at_receiver_output_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.SignalAcquisitionInfo.modeled_power_at_receiver_output_dbw)
  return _internal_modeled_power_at_receiver_output_dbw();
}
inline void SignalAcquisitionInfo::set_modeled_power_at_receiver_output_dbw(double value) {
  _internal_set_modeled_power_at_receiver_output_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.SignalAcquisitionInfo.modeled_power_at_receiver_output_dbw)
}
inline double SignalAcquisitionInfo::_internal_modeled_power_at_receiver_output_dbw() const {
  return _impl_.modeled_power_at_receiver_output_dbw_;
}
inline void SignalAcquisitionInfo::_internal_set_modeled_power_at_receiver_output_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modeled_power_at_receiver_output_dbw_ = value;
}

// -------------------------------------------------------------------

// TargetAcquisitionInfo

// optional double longitude = 3 [json_name = "longitude", deprecated = true];
inline bool TargetAcquisitionInfo::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TargetAcquisitionInfo::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double TargetAcquisitionInfo::longitude() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.longitude)
  return _internal_longitude();
}
inline void TargetAcquisitionInfo::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TargetAcquisitionInfo.longitude)
}
inline double TargetAcquisitionInfo::_internal_longitude() const {
  return _impl_.longitude_;
}
inline void TargetAcquisitionInfo::_internal_set_longitude(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.longitude_ = value;
}

// optional double latitude = 4 [json_name = "latitude", deprecated = true];
inline bool TargetAcquisitionInfo::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TargetAcquisitionInfo::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double TargetAcquisitionInfo::latitude() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.latitude)
  return _internal_latitude();
}
inline void TargetAcquisitionInfo::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TargetAcquisitionInfo.latitude)
}
inline double TargetAcquisitionInfo::_internal_latitude() const {
  return _impl_.latitude_;
}
inline void TargetAcquisitionInfo::_internal_set_latitude(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.latitude_ = value;
}

// optional double height = 5 [json_name = "height", deprecated = true];
inline bool TargetAcquisitionInfo::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TargetAcquisitionInfo::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double TargetAcquisitionInfo::height() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.height)
  return _internal_height();
}
inline void TargetAcquisitionInfo::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TargetAcquisitionInfo.height)
}
inline double TargetAcquisitionInfo::_internal_height() const {
  return _impl_.height_;
}
inline void TargetAcquisitionInfo::_internal_set_height(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.height_ = value;
}

// optional .aalyria.spacetime.api.common.Motion coordinates = 12 [json_name = "coordinates"];
inline bool TargetAcquisitionInfo::has_coordinates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.coordinates_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::Motion& TargetAcquisitionInfo::_internal_coordinates() const {
  const ::aalyria::spacetime::api::common::Motion* p = _impl_.coordinates_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Motion&>(
      ::aalyria::spacetime::api::common::_Motion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Motion& TargetAcquisitionInfo::coordinates() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.coordinates)
  return _internal_coordinates();
}
inline void TargetAcquisitionInfo::unsafe_arena_set_allocated_coordinates(
    ::aalyria::spacetime::api::common::Motion* coordinates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinates_);
  }
  _impl_.coordinates_ = coordinates;
  if (coordinates) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TargetAcquisitionInfo.coordinates)
}
inline ::aalyria::spacetime::api::common::Motion* TargetAcquisitionInfo::release_coordinates() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::Motion* temp = _impl_.coordinates_;
  _impl_.coordinates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Motion* TargetAcquisitionInfo::unsafe_arena_release_coordinates() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TargetAcquisitionInfo.coordinates)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::Motion* temp = _impl_.coordinates_;
  _impl_.coordinates_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Motion* TargetAcquisitionInfo::_internal_mutable_coordinates() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.coordinates_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Motion>(GetArenaForAllocation());
    _impl_.coordinates_ = p;
  }
  return _impl_.coordinates_;
}
inline ::aalyria::spacetime::api::common::Motion* TargetAcquisitionInfo::mutable_coordinates() {
  ::aalyria::spacetime::api::common::Motion* _msg = _internal_mutable_coordinates();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TargetAcquisitionInfo.coordinates)
  return _msg;
}
inline void TargetAcquisitionInfo::set_allocated_coordinates(::aalyria::spacetime::api::common::Motion* coordinates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinates_);
  }
  if (coordinates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coordinates));
    if (message_arena != submessage_arena) {
      coordinates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinates, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.coordinates_ = coordinates;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TargetAcquisitionInfo.coordinates)
}

// optional .aalyria.spacetime.api.common.AdsbTransponder adsb_transponder = 9 [json_name = "adsbTransponder"];
inline bool TargetAcquisitionInfo::has_adsb_transponder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adsb_transponder_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::AdsbTransponder& TargetAcquisitionInfo::_internal_adsb_transponder() const {
  const ::aalyria::spacetime::api::common::AdsbTransponder* p = _impl_.adsb_transponder_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AdsbTransponder&>(
      ::aalyria::spacetime::api::common::_AdsbTransponder_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AdsbTransponder& TargetAcquisitionInfo::adsb_transponder() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.adsb_transponder)
  return _internal_adsb_transponder();
}
inline void TargetAcquisitionInfo::unsafe_arena_set_allocated_adsb_transponder(
    ::aalyria::spacetime::api::common::AdsbTransponder* adsb_transponder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adsb_transponder_);
  }
  _impl_.adsb_transponder_ = adsb_transponder;
  if (adsb_transponder) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TargetAcquisitionInfo.adsb_transponder)
}
inline ::aalyria::spacetime::api::common::AdsbTransponder* TargetAcquisitionInfo::release_adsb_transponder() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::AdsbTransponder* temp = _impl_.adsb_transponder_;
  _impl_.adsb_transponder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AdsbTransponder* TargetAcquisitionInfo::unsafe_arena_release_adsb_transponder() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TargetAcquisitionInfo.adsb_transponder)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::AdsbTransponder* temp = _impl_.adsb_transponder_;
  _impl_.adsb_transponder_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AdsbTransponder* TargetAcquisitionInfo::_internal_mutable_adsb_transponder() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.adsb_transponder_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AdsbTransponder>(GetArenaForAllocation());
    _impl_.adsb_transponder_ = p;
  }
  return _impl_.adsb_transponder_;
}
inline ::aalyria::spacetime::api::common::AdsbTransponder* TargetAcquisitionInfo::mutable_adsb_transponder() {
  ::aalyria::spacetime::api::common::AdsbTransponder* _msg = _internal_mutable_adsb_transponder();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TargetAcquisitionInfo.adsb_transponder)
  return _msg;
}
inline void TargetAcquisitionInfo::set_allocated_adsb_transponder(::aalyria::spacetime::api::common::AdsbTransponder* adsb_transponder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adsb_transponder_);
  }
  if (adsb_transponder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adsb_transponder));
    if (message_arena != submessage_arena) {
      adsb_transponder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adsb_transponder, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.adsb_transponder_ = adsb_transponder;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TargetAcquisitionInfo.adsb_transponder)
}

// optional bytes physical_address = 10 [json_name = "physicalAddress"];
inline bool TargetAcquisitionInfo::has_physical_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TargetAcquisitionInfo::clear_physical_address() {
  _impl_.physical_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TargetAcquisitionInfo::physical_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TargetAcquisitionInfo.physical_address)
  return _internal_physical_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TargetAcquisitionInfo::set_physical_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.physical_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TargetAcquisitionInfo.physical_address)
}
inline std::string* TargetAcquisitionInfo::mutable_physical_address() {
  std::string* _s = _internal_mutable_physical_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TargetAcquisitionInfo.physical_address)
  return _s;
}
inline const std::string& TargetAcquisitionInfo::_internal_physical_address() const {
  return _impl_.physical_address_.Get();
}
inline void TargetAcquisitionInfo::_internal_set_physical_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.physical_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TargetAcquisitionInfo::_internal_mutable_physical_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.physical_address_.Mutable( GetArenaForAllocation());
}
inline std::string* TargetAcquisitionInfo::release_physical_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TargetAcquisitionInfo.physical_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.physical_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TargetAcquisitionInfo::set_allocated_physical_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.physical_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.physical_address_.IsDefault()) {
          _impl_.physical_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TargetAcquisitionInfo.physical_address)
}

// -------------------------------------------------------------------

// BeamTask

// optional string interface_id = 1 [json_name = "interfaceId"];
inline bool BeamTask::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BeamTask::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BeamTask::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamTask.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamTask::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamTask.interface_id)
}
inline std::string* BeamTask::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamTask.interface_id)
  return _s;
}
inline const std::string& BeamTask::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void BeamTask::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamTask::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamTask::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamTask.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamTask::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamTask.interface_id)
}

// optional string target_interface_id = 2 [json_name = "targetInterfaceId", deprecated = true];
inline bool BeamTask::has_target_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BeamTask::clear_target_interface_id() {
  _impl_.target_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BeamTask::target_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamTask.target_interface_id)
  return _internal_target_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamTask::set_target_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamTask.target_interface_id)
}
inline std::string* BeamTask::mutable_target_interface_id() {
  std::string* _s = _internal_mutable_target_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamTask.target_interface_id)
  return _s;
}
inline const std::string& BeamTask::_internal_target_interface_id() const {
  return _impl_.target_interface_id_.Get();
}
inline void BeamTask::_internal_set_target_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.target_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamTask::_internal_mutable_target_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.target_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamTask::release_target_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamTask.target_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.target_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamTask::set_allocated_target_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_interface_id_.IsDefault()) {
          _impl_.target_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamTask.target_interface_id)
}

// optional .aalyria.spacetime.api.common.NetworkInterfaceId target_id = 3 [json_name = "targetId"];
inline bool BeamTask::has_target_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamTask::_internal_target_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.target_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& BeamTask::target_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamTask.target_id)
  return _internal_target_id();
}
inline void BeamTask::unsafe_arena_set_allocated_target_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* target_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_id_);
  }
  _impl_.target_id_ = target_id;
  if (target_id) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamTask.target_id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamTask::release_target_id() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.target_id_;
  _impl_.target_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamTask::unsafe_arena_release_target_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamTask.target_id)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.target_id_;
  _impl_.target_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamTask::_internal_mutable_target_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.target_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.target_id_ = p;
  }
  return _impl_.target_id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* BeamTask::mutable_target_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamTask.target_id)
  return _msg;
}
inline void BeamTask::set_allocated_target_id(::aalyria::spacetime::api::common::NetworkInterfaceId* target_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_id_);
  }
  if (target_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_id));
    if (message_arena != submessage_arena) {
      target_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.target_id_ = target_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamTask.target_id)
}

// -------------------------------------------------------------------

// BeamStates

// optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
inline bool BeamStates::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& BeamStates::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& BeamStates::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStates.timestamp)
  return _internal_timestamp();
}
inline void BeamStates::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStates.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStates::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStates::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStates.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStates::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStates::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStates.timestamp)
  return _msg;
}
inline void BeamStates::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStates.timestamp)
}

// repeated string beam_task_ids = 4 [json_name = "beamTaskIds"];
inline int BeamStates::_internal_beam_task_ids_size() const {
  return _impl_.beam_task_ids_.size();
}
inline int BeamStates::beam_task_ids_size() const {
  return _internal_beam_task_ids_size();
}
inline void BeamStates::clear_beam_task_ids() {
  _internal_mutable_beam_task_ids()->Clear();
}
inline std::string* BeamStates::add_beam_task_ids() {
  std::string* _s = _internal_add_beam_task_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
  return _s;
}
inline const std::string& BeamStates::beam_task_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
  return _internal_beam_task_ids(index);
}
inline std::string* BeamStates::mutable_beam_task_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
  return _internal_mutable_beam_task_ids()->Mutable(index);
}
inline void BeamStates::set_beam_task_ids(int index, const std::string& value) {
  _internal_mutable_beam_task_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::set_beam_task_ids(int index, std::string&& value) {
  _internal_mutable_beam_task_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::set_beam_task_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_beam_task_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::set_beam_task_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_beam_task_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::set_beam_task_ids(int index, absl::string_view value) {
  _internal_mutable_beam_task_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::add_beam_task_ids(const std::string& value) {
  _internal_mutable_beam_task_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::add_beam_task_ids(std::string&& value) {
  _internal_mutable_beam_task_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::add_beam_task_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_beam_task_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::add_beam_task_ids(const char* value, std::size_t size) {
  _internal_mutable_beam_task_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline void BeamStates::add_beam_task_ids(absl::string_view value) {
  _internal_mutable_beam_task_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BeamStates::beam_task_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
  return _internal_beam_task_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BeamStates::mutable_beam_task_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.BeamStates.beam_task_ids)
  return _internal_mutable_beam_task_ids();
}
inline const std::string& BeamStates::_internal_beam_task_ids(int index) const {
  return _internal_beam_task_ids().Get(index);
}
inline std::string* BeamStates::_internal_add_beam_task_ids() {
  return _internal_mutable_beam_task_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BeamStates::_internal_beam_task_ids() const {
  return _impl_.beam_task_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BeamStates::_internal_mutable_beam_task_ids() {
  return &_impl_.beam_task_ids_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::BeamUpdate_Operation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::BeamUpdate_Operation>() {
  return ::aalyria::spacetime::api::common::BeamUpdate_Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_5fbeam_2eproto_2epb_2eh
