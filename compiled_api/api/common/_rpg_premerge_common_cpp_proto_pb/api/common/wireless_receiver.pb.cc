// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/wireless_receiver.proto

#include "api/common/wireless_receiver.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
template <typename>
PROTOBUF_CONSTEXPR RxChannels::RxChannels(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.center_frequency_hz_)*/ {}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RxChannelsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RxChannelsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RxChannelsDefaultTypeInternal() {}
  union {
    RxChannels _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RxChannelsDefaultTypeInternal _RxChannels_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReceiverDefinition_ChannelSetEntry_DoNotUse::ReceiverDefinition_ChannelSetEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ReceiverDefinition_ChannelSetEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiverDefinition_ChannelSetEntry_DoNotUseDefaultTypeInternal _ReceiverDefinition_ChannelSetEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReceiverDefinition::ReceiverDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.channel_set_)*/{}
  , /*decltype(_impl_.signal_processing_step_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.channel_selection_method_)*/ 0
} {}
struct ReceiverDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiverDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiverDefinitionDefaultTypeInternal() {}
  union {
    ReceiverDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiverDefinitionDefaultTypeInternal _ReceiverDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReceiveSignalProcessor::ReceiveSignalProcessor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ReceiveSignalProcessorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiveSignalProcessorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiveSignalProcessorDefaultTypeInternal() {}
  union {
    ReceiveSignalProcessor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiveSignalProcessorDefaultTypeInternal _ReceiveSignalProcessor_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Filter_RectangularFilterDefinition::Filter_RectangularFilterDefinition(
    ::_pbi::ConstantInitialized) {}
struct Filter_RectangularFilterDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Filter_RectangularFilterDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Filter_RectangularFilterDefinitionDefaultTypeInternal() {}
  union {
    Filter_RectangularFilterDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Filter_RectangularFilterDefinitionDefaultTypeInternal _Filter_RectangularFilterDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Filter_LinearFilterDefinition::Filter_LinearFilterDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rejection_db_per_hz_)*/ 0
} {}
struct Filter_LinearFilterDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Filter_LinearFilterDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Filter_LinearFilterDefinitionDefaultTypeInternal() {}
  union {
    Filter_LinearFilterDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Filter_LinearFilterDefinitionDefaultTypeInternal _Filter_LinearFilterDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Filter::Filter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frequency_hz_)*/ 0

  , /*decltype(_impl_.lower_bandwidth_limit_hz_)*/ 0

  , /*decltype(_impl_.upper_bandwidth_limit_hz_)*/ 0

  , /*decltype(_impl_.noise_temperature_k_)*/ 0

  , /*decltype(_impl_.filter_type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterDefaultTypeInternal() {}
  union {
    Filter _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterDefaultTypeInternal _Filter_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PhotodetectorDefinition_AvalanchePhotodiodeDefinition::PhotodetectorDefinition_AvalanchePhotodiodeDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.field_of_view_rad_)*/ 0

  , /*decltype(_impl_.bandwidth_hz_)*/ 0

  , /*decltype(_impl_.noise_temperature_k_)*/ 0

  , /*decltype(_impl_.efficiency_percent_)*/ 0

  , /*decltype(_impl_.dark_current_amp_)*/ 0

  , /*decltype(_impl_.load_impedance_ohm_)*/ 0

  , /*decltype(_impl_.noise_factor_)*/ 0

  , /*decltype(_impl_.gain_db_)*/ 0

  , /*decltype(_impl_.optical_bandpass_filter_bandwidth_hz_)*/ 0

  , /*decltype(_impl_.sky_spectral_radiance_)*/ 0

  , /*decltype(_impl_.sun_spectral_radiant_emittance_)*/ 0

  , /*decltype(_impl_.wavelength_m_)*/ 0
} {}
struct PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal() {}
  union {
    PhotodetectorDefinition_AvalanchePhotodiodeDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhotodetectorDefinition_AvalanchePhotodiodeDefinitionDefaultTypeInternal _PhotodetectorDefinition_AvalanchePhotodiodeDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PhotodetectorDefinition_PinPhotodiodeDefinition::PhotodetectorDefinition_PinPhotodiodeDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.field_of_view_rad_)*/ 0

  , /*decltype(_impl_.bandwidth_hz_)*/ 0

  , /*decltype(_impl_.noise_temperature_k_)*/ 0

  , /*decltype(_impl_.efficiency_percent_)*/ 0

  , /*decltype(_impl_.dark_current_amp_)*/ 0

  , /*decltype(_impl_.load_impedance_ohm_)*/ 0

  , /*decltype(_impl_.optical_bandpass_filter_bandwidth_hz_)*/ 0

  , /*decltype(_impl_.sky_spectral_radiance_)*/ 0

  , /*decltype(_impl_.sun_spectral_radiant_emittance_)*/ 0

  , /*decltype(_impl_.wavelength_m_)*/ 0
} {}
struct PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal() {}
  union {
    PhotodetectorDefinition_PinPhotodiodeDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhotodetectorDefinition_PinPhotodiodeDefinitionDefaultTypeInternal _PhotodetectorDefinition_PinPhotodiodeDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PhotodetectorDefinition::PhotodetectorDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.photodetector_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PhotodetectorDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhotodetectorDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhotodetectorDefinitionDefaultTypeInternal() {}
  union {
    PhotodetectorDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhotodetectorDefinitionDefaultTypeInternal _PhotodetectorDefinition_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[10];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_api_2fcommon_2fwireless_5freceiver_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fcommon_2fwireless_5freceiver_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RxChannels, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RxChannels, _impl_.center_frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _impl_.channel_set_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _impl_.channel_selection_method_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverDefinition, _impl_.signal_processing_step_),
    0,
    ~0u,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiveSignalProcessor, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiveSignalProcessor, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiveSignalProcessor, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition, _impl_.rejection_db_per_hz_),
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_.frequency_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_.lower_bandwidth_limit_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_.upper_bandwidth_limit_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_.noise_temperature_k_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_.filter_type_),
    0,
    1,
    2,
    3,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.field_of_view_rad_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.noise_temperature_k_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.efficiency_percent_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.dark_current_amp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.load_impedance_ohm_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.noise_factor_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.gain_db_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.optical_bandpass_filter_bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.sky_spectral_radiance_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.sun_spectral_radiant_emittance_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.wavelength_m_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.field_of_view_rad_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.noise_temperature_k_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.efficiency_percent_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.dark_current_amp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.load_impedance_ohm_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.optical_bandpass_filter_bandwidth_hz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.sky_spectral_radiance_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.sun_spectral_radiant_emittance_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.wavelength_m_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition, _impl_.photodetector_type_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::aalyria::spacetime::api::common::RxChannels)},
        { 9, 19, -1, sizeof(::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse)},
        { 21, 33, -1, sizeof(::aalyria::spacetime::api::common::ReceiverDefinition)},
        { 37, -1, -1, sizeof(::aalyria::spacetime::api::common::ReceiveSignalProcessor)},
        { 50, -1, -1, sizeof(::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition)},
        { 58, 67, -1, sizeof(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition)},
        { 68, 83, -1, sizeof(::aalyria::spacetime::api::common::Filter)},
        { 89, 109, -1, sizeof(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition)},
        { 121, 139, -1, sizeof(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition)},
        { 149, -1, -1, sizeof(::aalyria::spacetime::api::common::PhotodetectorDefinition)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::common::_RxChannels_default_instance_._instance,
    &::aalyria::spacetime::api::common::_ReceiverDefinition_ChannelSetEntry_DoNotUse_default_instance_._instance,
    &::aalyria::spacetime::api::common::_ReceiverDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_ReceiveSignalProcessor_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Filter_RectangularFilterDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Filter_LinearFilterDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Filter_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PhotodetectorDefinition_AvalanchePhotodiodeDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PhotodetectorDefinition_PinPhotodiodeDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PhotodetectorDefinition_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fcommon_2fwireless_5freceiver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\"api/common/wireless_receiver.proto\022\034aa"
    "lyria.spacetime.api.common\032\030api/common/c"
    "hannel.proto\032\031api/common/wireless.proto\""
    "<\n\nRxChannels\022.\n\023center_frequency_hz\030\001 \003"
    "(\003R\021centerFrequencyHz\"\354\003\n\022ReceiverDefini"
    "tion\022\022\n\004name\030\002 \001(\tR\004name\022a\n\013channel_set\030"
    "\n \003(\0132@.aalyria.spacetime.api.common.Rec"
    "eiverDefinition.ChannelSetEntryR\nchannel"
    "Set\022n\n\030channel_selection_method\030\t \001(\01624."
    "aalyria.spacetime.api.common.ChannelSele"
    "ctionMethodR\026channelSelectionMethod\022j\n\026s"
    "ignal_processing_step\030\013 \003(\01324.aalyria.sp"
    "acetime.api.common.ReceiveSignalProcesso"
    "rR\024signalProcessingStep\032g\n\017ChannelSetEnt"
    "ry\022\020\n\003key\030\001 \001(\tR\003key\022>\n\005value\030\002 \001(\0132(.aa"
    "lyria.spacetime.api.common.RxChannelsR\005v"
    "alue:\0028\001J\004\010\001\020\002J\004\010\003\020\tJ\004\010\014\020\rJ\010\010\r\020\200\200\200\200\002\"\344\002\n"
    "\026ReceiveSignalProcessor\022>\n\006filter\030\001 \001(\0132"
    "$.aalyria.spacetime.api.common.FilterH\000R"
    "\006filter\022]\n\rphotodetector\030\002 \001(\01325.aalyria"
    ".spacetime.api.common.PhotodetectorDefin"
    "itionH\000R\rphotodetector\022Q\n\tamplifier\030\003 \001("
    "\01321.aalyria.spacetime.api.common.Amplifi"
    "erDefinitionH\000R\tamplifier\022P\n\014gain_or_los"
    "s\030\004 \001(\0132,.aalyria.spacetime.api.common.M"
    "iscGainOrLossH\000R\ngainOrLossB\006\n\004type\"\201\004\n\006"
    "Filter\022!\n\014frequency_hz\030\001 \001(\001R\013frequencyH"
    "z\0227\n\030lower_bandwidth_limit_hz\030\002 \001(\001R\025low"
    "erBandwidthLimitHz\0227\n\030upper_bandwidth_li"
    "mit_hz\030\003 \001(\001R\025upperBandwidthLimitHz\022.\n\023n"
    "oise_temperature_k\030\004 \001(\001R\021noiseTemperatu"
    "reK\022d\n\013rectangular\030\005 \001(\0132@.aalyria.space"
    "time.api.common.Filter.RectangularFilter"
    "DefinitionH\000R\013rectangular\022U\n\006linear\030\006 \001("
    "\0132;.aalyria.spacetime.api.common.Filter."
    "LinearFilterDefinitionH\000R\006linear\032\035\n\033Rect"
    "angularFilterDefinition\032G\n\026LinearFilterD"
    "efinition\022-\n\023rejection_db_per_hz\030\001 \001(\001R\020"
    "rejectionDbPerHzB\r\n\013filter_type\"\216\013\n\027Phot"
    "odetectorDefinition\022\210\001\n\024avalanche_photod"
    "iode\030\001 \001(\0132S.aalyria.spacetime.api.commo"
    "n.PhotodetectorDefinition.AvalanchePhoto"
    "diodeDefinitionH\000R\023avalanchePhotodiode\022v"
    "\n\016pin_photodiode\030\002 \001(\0132M.aalyria.spaceti"
    "me.api.common.PhotodetectorDefinition.Pi"
    "nPhotodiodeDefinitionH\000R\rpinPhotodiode\032\314"
    "\004\n\035AvalanchePhotodiodeDefinition\022)\n\021fiel"
    "d_of_view_rad\030\001 \001(\001R\016fieldOfViewRad\022!\n\014b"
    "andwidth_hz\030\002 \001(\001R\013bandwidthHz\022.\n\023noise_"
    "temperature_k\030\003 \001(\001R\021noiseTemperatureK\022-"
    "\n\022efficiency_percent\030\004 \001(\001R\021efficiencyPe"
    "rcent\022(\n\020dark_current_amp\030\005 \001(\001R\016darkCur"
    "rentAmp\022,\n\022load_impedance_ohm\030\006 \001(\001R\020loa"
    "dImpedanceOhm\022!\n\014noise_factor\030\007 \001(\001R\013noi"
    "seFactor\022\027\n\007gain_db\030\010 \001(\001R\006gainDb\022N\n$opt"
    "ical_bandpass_filter_bandwidth_hz\030\t \001(\001R"
    " opticalBandpassFilterBandwidthHz\0222\n\025sky"
    "_spectral_radiance\030\n \001(\001R\023skySpectralRad"
    "iance\022C\n\036sun_spectral_radiant_emittance\030"
    "\013 \001(\001R\033sunSpectralRadiantEmittance\022!\n\014wa"
    "velength_m\030\014 \001(\001R\013wavelengthM\032\212\004\n\027PinPho"
    "todiodeDefinition\022)\n\021field_of_view_rad\030\001"
    " \001(\001R\016fieldOfViewRad\022!\n\014bandwidth_hz\030\002 \001"
    "(\001R\013bandwidthHz\022.\n\023noise_temperature_k\030\003"
    " \001(\001R\021noiseTemperatureK\022-\n\022efficiency_pe"
    "rcent\030\004 \001(\001R\021efficiencyPercent\022(\n\020dark_c"
    "urrent_amp\030\005 \001(\001R\016darkCurrentAmp\022,\n\022load"
    "_impedance_ohm\030\006 \001(\001R\020loadImpedanceOhm\022N"
    "\n$optical_bandpass_filter_bandwidth_hz\030\007"
    " \001(\001R opticalBandpassFilterBandwidthHz\0222"
    "\n\025sky_spectral_radiance\030\010 \001(\001R\023skySpectr"
    "alRadiance\022C\n\036sun_spectral_radiant_emitt"
    "ance\030\t \001(\001R\033sunSpectralRadiantEmittance\022"
    "!\n\014wavelength_m\030\n \001(\001R\013wavelengthMB\024\n\022ph"
    "otodetector_typeBD\n com.aalyria.spacetim"
    "e.api.commonZ aalyria.com/spacetime/api/"
    "common"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_deps[2] =
    {
        &::descriptor_table_api_2fcommon_2fchannel_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto = {
    false,
    false,
    3046,
    descriptor_table_protodef_api_2fcommon_2fwireless_5freceiver_2eproto,
    "api/common/wireless_receiver.proto",
    &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
    descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_deps,
    2,
    10,
    schemas,
    file_default_instances,
    TableStruct_api_2fcommon_2fwireless_5freceiver_2eproto::offsets,
    file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto,
    file_level_enum_descriptors_api_2fcommon_2fwireless_5freceiver_2eproto,
    file_level_service_descriptors_api_2fcommon_2fwireless_5freceiver_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter() {
  return &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fcommon_2fwireless_5freceiver_2eproto(&descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
// ===================================================================

class RxChannels::_Internal {
 public:
};

RxChannels::RxChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.RxChannels)
}
RxChannels::RxChannels(const RxChannels& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RxChannels* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.center_frequency_hz_) { from._impl_.center_frequency_hz_ }

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.RxChannels)
}

inline void RxChannels::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.center_frequency_hz_) { arena }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RxChannels::~RxChannels() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.RxChannels)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RxChannels::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.center_frequency_hz_.~RepeatedField();
}

void RxChannels::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RxChannels::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.RxChannels)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_center_frequency_hz()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RxChannels::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_center_frequency_hz(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_center_frequency_hz(), ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RxChannels::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.RxChannels)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
  for (int i = 0, n = this->_internal_center_frequency_hz_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_center_frequency_hz(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.RxChannels)
  return target;
}

::size_t RxChannels::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.RxChannels)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_center_frequency_hz())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_center_frequency_hz_size());
    ;
    total_size += tag_size + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RxChannels::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RxChannels::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RxChannels::GetClassData() const { return &_class_data_; }


void RxChannels::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RxChannels*>(&to_msg);
  auto& from = static_cast<const RxChannels&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.RxChannels)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.center_frequency_hz_.MergeFrom(from._impl_.center_frequency_hz_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RxChannels::CopyFrom(const RxChannels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.RxChannels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RxChannels::IsInitialized() const {
  return true;
}

void RxChannels::InternalSwap(RxChannels* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.center_frequency_hz_.InternalSwap(&other->_impl_.center_frequency_hz_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RxChannels::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[0]);
}
// ===================================================================

ReceiverDefinition_ChannelSetEntry_DoNotUse::ReceiverDefinition_ChannelSetEntry_DoNotUse() {}
ReceiverDefinition_ChannelSetEntry_DoNotUse::ReceiverDefinition_ChannelSetEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ReceiverDefinition_ChannelSetEntry_DoNotUse::MergeFrom(const ReceiverDefinition_ChannelSetEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ReceiverDefinition_ChannelSetEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[1]);
}
// ===================================================================

class ReceiverDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<ReceiverDefinition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ReceiverDefinition, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_channel_selection_method(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReceiverDefinition::ReceiverDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.ReceiverDefinition)
}
ReceiverDefinition::ReceiverDefinition(const ReceiverDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReceiverDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.channel_set_)*/{}
    , decltype(_impl_.signal_processing_step_){from._impl_.signal_processing_step_}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.channel_selection_method_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.channel_set_.MergeFrom(from._impl_.channel_set_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _this->_impl_.channel_selection_method_ = from._impl_.channel_selection_method_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.ReceiverDefinition)
}

inline void ReceiverDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.channel_set_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.signal_processing_step_){arena}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.channel_selection_method_) { 0 }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReceiverDefinition::~ReceiverDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.ReceiverDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReceiverDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.channel_set_.~MapField();
  _internal_mutable_signal_processing_step()->~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void ReceiverDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReceiverDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.ReceiverDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_set_.Clear();
  _internal_mutable_signal_processing_step()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.channel_selection_method_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReceiverDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 2 [json_name = "name"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.ReceiverDefinition.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.ChannelSelectionMethod channel_selection_method = 9 [json_name = "channelSelectionMethod"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::ChannelSelectionMethod_IsValid(static_cast<int>(val)))) {
            _internal_set_channel_selection_method(static_cast<::aalyria::spacetime::api::common::ChannelSelectionMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, .aalyria.spacetime.api.common.RxChannels> channel_set = 10 [json_name = "channelSet"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.channel_set_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor signal_processing_step = 11 [json_name = "signalProcessingStep"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_signal_processing_step(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReceiverDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.ReceiverDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 2 [json_name = "name"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.ReceiverDefinition.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .aalyria.spacetime.api.common.ChannelSelectionMethod channel_selection_method = 9 [json_name = "channelSelectionMethod"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        9, this->_internal_channel_selection_method(), target);
  }

  // map<string, .aalyria.spacetime.api.common.RxChannels> channel_set = 10 [json_name = "channelSet"];
  if (!this->_internal_channel_set().empty()) {
    using MapType = ::_pb::Map<std::string, ::aalyria::spacetime::api::common::RxChannels>;
    using WireHelper = ReceiverDefinition_ChannelSetEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_channel_set();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.ReceiverDefinition.channel_set");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor signal_processing_step = 11 [json_name = "signalProcessingStep"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_signal_processing_step_size()); i < n; i++) {
    const auto& repfield = this->_internal_signal_processing_step(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.ReceiverDefinition)
  return target;
}

::size_t ReceiverDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.ReceiverDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .aalyria.spacetime.api.common.RxChannels> channel_set = 10 [json_name = "channelSet"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_channel_set_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RxChannels >::const_iterator
      it = this->_internal_channel_set().begin();
      it != this->_internal_channel_set().end(); ++it) {
    total_size += ReceiverDefinition_ChannelSetEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .aalyria.spacetime.api.common.ReceiveSignalProcessor signal_processing_step = 11 [json_name = "signalProcessingStep"];
  total_size += 1UL * this->_internal_signal_processing_step_size();
  for (const auto& msg : this->_internal_signal_processing_step()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2 [json_name = "name"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional .aalyria.spacetime.api.common.ChannelSelectionMethod channel_selection_method = 9 [json_name = "channelSelectionMethod"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_selection_method());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReceiverDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReceiverDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReceiverDefinition::GetClassData() const { return &_class_data_; }


void ReceiverDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReceiverDefinition*>(&to_msg);
  auto& from = static_cast<const ReceiverDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.ReceiverDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.channel_set_.MergeFrom(from._impl_.channel_set_);
  _this->_internal_mutable_signal_processing_step()->MergeFrom(from._internal_signal_processing_step());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.channel_selection_method_ = from._impl_.channel_selection_method_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReceiverDefinition::CopyFrom(const ReceiverDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.ReceiverDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiverDefinition::IsInitialized() const {
  return true;
}

void ReceiverDefinition::InternalSwap(ReceiverDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channel_set_.InternalSwap(&other->_impl_.channel_set_);
  _internal_mutable_signal_processing_step()->InternalSwap(other->_internal_mutable_signal_processing_step());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  swap(_impl_.channel_selection_method_, other->_impl_.channel_selection_method_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReceiverDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[2]);
}
// ===================================================================

class ReceiveSignalProcessor::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiveSignalProcessor, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::Filter& filter(const ReceiveSignalProcessor* msg);
  static const ::aalyria::spacetime::api::common::PhotodetectorDefinition& photodetector(const ReceiveSignalProcessor* msg);
  static const ::aalyria::spacetime::api::common::AmplifierDefinition& amplifier(const ReceiveSignalProcessor* msg);
  static const ::aalyria::spacetime::api::common::MiscGainOrLoss& gain_or_loss(const ReceiveSignalProcessor* msg);
};

const ::aalyria::spacetime::api::common::Filter&
ReceiveSignalProcessor::_Internal::filter(const ReceiveSignalProcessor* msg) {
  return *msg->_impl_.type_.filter_;
}
const ::aalyria::spacetime::api::common::PhotodetectorDefinition&
ReceiveSignalProcessor::_Internal::photodetector(const ReceiveSignalProcessor* msg) {
  return *msg->_impl_.type_.photodetector_;
}
const ::aalyria::spacetime::api::common::AmplifierDefinition&
ReceiveSignalProcessor::_Internal::amplifier(const ReceiveSignalProcessor* msg) {
  return *msg->_impl_.type_.amplifier_;
}
const ::aalyria::spacetime::api::common::MiscGainOrLoss&
ReceiveSignalProcessor::_Internal::gain_or_loss(const ReceiveSignalProcessor* msg) {
  return *msg->_impl_.type_.gain_or_loss_;
}
void ReceiveSignalProcessor::set_allocated_filter(::aalyria::spacetime::api::common::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    set_has_filter();
    _impl_.type_.filter_ = filter;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.filter)
}
void ReceiveSignalProcessor::set_allocated_photodetector(::aalyria::spacetime::api::common::PhotodetectorDefinition* photodetector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (photodetector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(photodetector);
    if (message_arena != submessage_arena) {
      photodetector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, photodetector, submessage_arena);
    }
    set_has_photodetector();
    _impl_.type_.photodetector_ = photodetector;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.photodetector)
}
void ReceiveSignalProcessor::set_allocated_amplifier(::aalyria::spacetime::api::common::AmplifierDefinition* amplifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (amplifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplifier));
    if (message_arena != submessage_arena) {
      amplifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplifier, submessage_arena);
    }
    set_has_amplifier();
    _impl_.type_.amplifier_ = amplifier;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.amplifier)
}
void ReceiveSignalProcessor::clear_amplifier() {
  if (type_case() == kAmplifier) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.amplifier_;
    }
    clear_has_type();
  }
}
void ReceiveSignalProcessor::set_allocated_gain_or_loss(::aalyria::spacetime::api::common::MiscGainOrLoss* gain_or_loss) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (gain_or_loss) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gain_or_loss));
    if (message_arena != submessage_arena) {
      gain_or_loss = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gain_or_loss, submessage_arena);
    }
    set_has_gain_or_loss();
    _impl_.type_.gain_or_loss_ = gain_or_loss;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiveSignalProcessor.gain_or_loss)
}
void ReceiveSignalProcessor::clear_gain_or_loss() {
  if (type_case() == kGainOrLoss) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.gain_or_loss_;
    }
    clear_has_type();
  }
}
ReceiveSignalProcessor::ReceiveSignalProcessor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.ReceiveSignalProcessor)
}
ReceiveSignalProcessor::ReceiveSignalProcessor(const ReceiveSignalProcessor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReceiveSignalProcessor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kFilter: {
      _this->_internal_mutable_filter()->::aalyria::spacetime::api::common::Filter::MergeFrom(
          from._internal_filter());
      break;
    }
    case kPhotodetector: {
      _this->_internal_mutable_photodetector()->::aalyria::spacetime::api::common::PhotodetectorDefinition::MergeFrom(
          from._internal_photodetector());
      break;
    }
    case kAmplifier: {
      _this->_internal_mutable_amplifier()->::aalyria::spacetime::api::common::AmplifierDefinition::MergeFrom(
          from._internal_amplifier());
      break;
    }
    case kGainOrLoss: {
      _this->_internal_mutable_gain_or_loss()->::aalyria::spacetime::api::common::MiscGainOrLoss::MergeFrom(
          from._internal_gain_or_loss());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.ReceiveSignalProcessor)
}

inline void ReceiveSignalProcessor::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type();
}

ReceiveSignalProcessor::~ReceiveSignalProcessor() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReceiveSignalProcessor::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void ReceiveSignalProcessor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReceiveSignalProcessor::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  switch (type_case()) {
    case kFilter: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.filter_;
      }
      break;
    }
    case kPhotodetector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.photodetector_;
      }
      break;
    }
    case kAmplifier: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.amplifier_;
      }
      break;
    }
    case kGainOrLoss: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.gain_or_loss_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void ReceiveSignalProcessor::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReceiveSignalProcessor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.Filter filter = 1 [json_name = "filter"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PhotodetectorDefinition photodetector = 2 [json_name = "photodetector"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_photodetector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.AmplifierDefinition amplifier = 3 [json_name = "amplifier"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_amplifier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.MiscGainOrLoss gain_or_loss = 4 [json_name = "gainOrLoss"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_gain_or_loss(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReceiveSignalProcessor::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kFilter: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::filter(this),
          _Internal::filter(this).GetCachedSize(), target, stream);
      break;
    }
    case kPhotodetector: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::photodetector(this),
          _Internal::photodetector(this).GetCachedSize(), target, stream);
      break;
    }
    case kAmplifier: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::amplifier(this),
          _Internal::amplifier(this).GetCachedSize(), target, stream);
      break;
    }
    case kGainOrLoss: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::gain_or_loss(this),
          _Internal::gain_or_loss(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  return target;
}

::size_t ReceiveSignalProcessor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // .aalyria.spacetime.api.common.Filter filter = 1 [json_name = "filter"];
    case kFilter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.filter_);
      break;
    }
    // .aalyria.spacetime.api.common.PhotodetectorDefinition photodetector = 2 [json_name = "photodetector"];
    case kPhotodetector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.photodetector_);
      break;
    }
    // .aalyria.spacetime.api.common.AmplifierDefinition amplifier = 3 [json_name = "amplifier"];
    case kAmplifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.amplifier_);
      break;
    }
    // .aalyria.spacetime.api.common.MiscGainOrLoss gain_or_loss = 4 [json_name = "gainOrLoss"];
    case kGainOrLoss: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.gain_or_loss_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReceiveSignalProcessor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReceiveSignalProcessor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReceiveSignalProcessor::GetClassData() const { return &_class_data_; }


void ReceiveSignalProcessor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReceiveSignalProcessor*>(&to_msg);
  auto& from = static_cast<const ReceiveSignalProcessor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kFilter: {
      _this->_internal_mutable_filter()->::aalyria::spacetime::api::common::Filter::MergeFrom(
          from._internal_filter());
      break;
    }
    case kPhotodetector: {
      _this->_internal_mutable_photodetector()->::aalyria::spacetime::api::common::PhotodetectorDefinition::MergeFrom(
          from._internal_photodetector());
      break;
    }
    case kAmplifier: {
      _this->_internal_mutable_amplifier()->::aalyria::spacetime::api::common::AmplifierDefinition::MergeFrom(
          from._internal_amplifier());
      break;
    }
    case kGainOrLoss: {
      _this->_internal_mutable_gain_or_loss()->::aalyria::spacetime::api::common::MiscGainOrLoss::MergeFrom(
          from._internal_gain_or_loss());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReceiveSignalProcessor::CopyFrom(const ReceiveSignalProcessor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.ReceiveSignalProcessor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveSignalProcessor::IsInitialized() const {
  return true;
}

void ReceiveSignalProcessor::InternalSwap(ReceiveSignalProcessor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReceiveSignalProcessor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[3]);
}
// ===================================================================

class Filter_RectangularFilterDefinition::_Internal {
 public:
};

Filter_RectangularFilterDefinition::Filter_RectangularFilterDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Filter.RectangularFilterDefinition)
}
Filter_RectangularFilterDefinition::Filter_RectangularFilterDefinition(const Filter_RectangularFilterDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Filter_RectangularFilterDefinition* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Filter.RectangularFilterDefinition)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Filter_RectangularFilterDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Filter_RectangularFilterDefinition::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Filter_RectangularFilterDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[4]);
}
// ===================================================================

class Filter_LinearFilterDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<Filter_LinearFilterDefinition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Filter_LinearFilterDefinition, _impl_._has_bits_);
  static void set_has_rejection_db_per_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Filter_LinearFilterDefinition::Filter_LinearFilterDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
}
Filter_LinearFilterDefinition::Filter_LinearFilterDefinition(const Filter_LinearFilterDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
}

inline void Filter_LinearFilterDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rejection_db_per_hz_) { 0 }

  };
}

Filter_LinearFilterDefinition::~Filter_LinearFilterDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Filter_LinearFilterDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Filter_LinearFilterDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Filter_LinearFilterDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rejection_db_per_hz_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Filter_LinearFilterDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double rejection_db_per_hz = 1 [json_name = "rejectionDbPerHz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_rejection_db_per_hz(&has_bits);
          _impl_.rejection_db_per_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Filter_LinearFilterDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double rejection_db_per_hz = 1 [json_name = "rejectionDbPerHz"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_rejection_db_per_hz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  return target;
}

::size_t Filter_LinearFilterDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double rejection_db_per_hz = 1 [json_name = "rejectionDbPerHz"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Filter_LinearFilterDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Filter_LinearFilterDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Filter_LinearFilterDefinition::GetClassData() const { return &_class_data_; }


void Filter_LinearFilterDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Filter_LinearFilterDefinition*>(&to_msg);
  auto& from = static_cast<const Filter_LinearFilterDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_rejection_db_per_hz(from._internal_rejection_db_per_hz());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Filter_LinearFilterDefinition::CopyFrom(const Filter_LinearFilterDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Filter.LinearFilterDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter_LinearFilterDefinition::IsInitialized() const {
  return true;
}

void Filter_LinearFilterDefinition::InternalSwap(Filter_LinearFilterDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.rejection_db_per_hz_, other->_impl_.rejection_db_per_hz_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Filter_LinearFilterDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[5]);
}
// ===================================================================

class Filter::_Internal {
 public:
  using HasBits = decltype(std::declval<Filter>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Filter, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Filter, _impl_._oneof_case_);
  static void set_has_frequency_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lower_bandwidth_limit_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upper_bandwidth_limit_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_noise_temperature_k(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition& rectangular(const Filter* msg);
  static const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition& linear(const Filter* msg);
};

const ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition&
Filter::_Internal::rectangular(const Filter* msg) {
  return *msg->_impl_.filter_type_.rectangular_;
}
const ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition&
Filter::_Internal::linear(const Filter* msg) {
  return *msg->_impl_.filter_type_.linear_;
}
void Filter::set_allocated_rectangular(::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition* rectangular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter_type();
  if (rectangular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rectangular);
    if (message_arena != submessage_arena) {
      rectangular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangular, submessage_arena);
    }
    set_has_rectangular();
    _impl_.filter_type_.rectangular_ = rectangular;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Filter.rectangular)
}
void Filter::set_allocated_linear(::aalyria::spacetime::api::common::Filter_LinearFilterDefinition* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter_type();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    _impl_.filter_type_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Filter.linear)
}
Filter::Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Filter)
}
Filter::Filter(const Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Filter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frequency_hz_) {}

    , decltype(_impl_.lower_bandwidth_limit_hz_) {}

    , decltype(_impl_.upper_bandwidth_limit_hz_) {}

    , decltype(_impl_.noise_temperature_k_) {}

    , decltype(_impl_.filter_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.frequency_hz_, &from._impl_.frequency_hz_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.noise_temperature_k_) -
    reinterpret_cast<char*>(&_impl_.frequency_hz_)) + sizeof(_impl_.noise_temperature_k_));
  clear_has_filter_type();
  switch (from.filter_type_case()) {
    case kRectangular: {
      _this->_internal_mutable_rectangular()->::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition::MergeFrom(
          from._internal_rectangular());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::aalyria::spacetime::api::common::Filter_LinearFilterDefinition::MergeFrom(
          from._internal_linear());
      break;
    }
    case FILTER_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Filter)
}

inline void Filter::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frequency_hz_) { 0 }

    , decltype(_impl_.lower_bandwidth_limit_hz_) { 0 }

    , decltype(_impl_.upper_bandwidth_limit_hz_) { 0 }

    , decltype(_impl_.noise_temperature_k_) { 0 }

    , decltype(_impl_.filter_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_filter_type();
}

Filter::~Filter() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Filter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Filter::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_filter_type()) {
    clear_filter_type();
  }
}

void Filter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Filter::clear_filter_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.Filter)
  switch (filter_type_case()) {
    case kRectangular: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.filter_type_.rectangular_;
      }
      break;
    }
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.filter_type_.linear_;
      }
      break;
    }
    case FILTER_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = FILTER_TYPE_NOT_SET;
}


void Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Filter)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.frequency_hz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.noise_temperature_k_) -
        reinterpret_cast<char*>(&_impl_.frequency_hz_)) + sizeof(_impl_.noise_temperature_k_));
  }
  clear_filter_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double frequency_hz = 1 [json_name = "frequencyHz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_frequency_hz(&has_bits);
          _impl_.frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double lower_bandwidth_limit_hz = 2 [json_name = "lowerBandwidthLimitHz"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_lower_bandwidth_limit_hz(&has_bits);
          _impl_.lower_bandwidth_limit_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double upper_bandwidth_limit_hz = 3 [json_name = "upperBandwidthLimitHz"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_upper_bandwidth_limit_hz(&has_bits);
          _impl_.upper_bandwidth_limit_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double noise_temperature_k = 4 [json_name = "noiseTemperatureK"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_noise_temperature_k(&has_bits);
          _impl_.noise_temperature_k_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Filter.RectangularFilterDefinition rectangular = 5 [json_name = "rectangular"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rectangular(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Filter.LinearFilterDefinition linear = 6 [json_name = "linear"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Filter::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Filter)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double frequency_hz = 1 [json_name = "frequencyHz"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_frequency_hz(), target);
  }

  // optional double lower_bandwidth_limit_hz = 2 [json_name = "lowerBandwidthLimitHz"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_lower_bandwidth_limit_hz(), target);
  }

  // optional double upper_bandwidth_limit_hz = 3 [json_name = "upperBandwidthLimitHz"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_upper_bandwidth_limit_hz(), target);
  }

  // optional double noise_temperature_k = 4 [json_name = "noiseTemperatureK"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_noise_temperature_k(), target);
  }

  switch (filter_type_case()) {
    case kRectangular: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::rectangular(this),
          _Internal::rectangular(this).GetCachedSize(), target, stream);
      break;
    }
    case kLinear: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::linear(this),
          _Internal::linear(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Filter)
  return target;
}

::size_t Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Filter)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double frequency_hz = 1 [json_name = "frequencyHz"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double lower_bandwidth_limit_hz = 2 [json_name = "lowerBandwidthLimitHz"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double upper_bandwidth_limit_hz = 3 [json_name = "upperBandwidthLimitHz"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double noise_temperature_k = 4 [json_name = "noiseTemperatureK"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

  }
  switch (filter_type_case()) {
    // .aalyria.spacetime.api.common.Filter.RectangularFilterDefinition rectangular = 5 [json_name = "rectangular"];
    case kRectangular: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filter_type_.rectangular_);
      break;
    }
    // .aalyria.spacetime.api.common.Filter.LinearFilterDefinition linear = 6 [json_name = "linear"];
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filter_type_.linear_);
      break;
    }
    case FILTER_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Filter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Filter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Filter::GetClassData() const { return &_class_data_; }


void Filter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Filter*>(&to_msg);
  auto& from = static_cast<const Filter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Filter)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.frequency_hz_ = from._impl_.frequency_hz_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lower_bandwidth_limit_hz_ = from._impl_.lower_bandwidth_limit_hz_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.upper_bandwidth_limit_hz_ = from._impl_.upper_bandwidth_limit_hz_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.noise_temperature_k_ = from._impl_.noise_temperature_k_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.filter_type_case()) {
    case kRectangular: {
      _this->_internal_mutable_rectangular()->::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition::MergeFrom(
          from._internal_rectangular());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::aalyria::spacetime::api::common::Filter_LinearFilterDefinition::MergeFrom(
          from._internal_linear());
      break;
    }
    case FILTER_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Filter::CopyFrom(const Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filter::IsInitialized() const {
  return true;
}

void Filter::InternalSwap(Filter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Filter, _impl_.noise_temperature_k_)
      + sizeof(Filter::_impl_.noise_temperature_k_)
      - PROTOBUF_FIELD_OFFSET(Filter, _impl_.frequency_hz_)>(
          reinterpret_cast<char*>(&_impl_.frequency_hz_),
          reinterpret_cast<char*>(&other->_impl_.frequency_hz_));
  swap(_impl_.filter_type_, other->_impl_.filter_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Filter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[6]);
}
// ===================================================================

class PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<PhotodetectorDefinition_AvalanchePhotodiodeDefinition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_._has_bits_);
  static void set_has_field_of_view_rad(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bandwidth_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_noise_temperature_k(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_efficiency_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dark_current_amp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_load_impedance_ohm(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_noise_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gain_db(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_optical_bandpass_filter_bandwidth_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sky_spectral_radiance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_sun_spectral_radiant_emittance(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_wavelength_m(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

PhotodetectorDefinition_AvalanchePhotodiodeDefinition::PhotodetectorDefinition_AvalanchePhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
}
PhotodetectorDefinition_AvalanchePhotodiodeDefinition::PhotodetectorDefinition_AvalanchePhotodiodeDefinition(const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
}

inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.field_of_view_rad_) { 0 }

    , decltype(_impl_.bandwidth_hz_) { 0 }

    , decltype(_impl_.noise_temperature_k_) { 0 }

    , decltype(_impl_.efficiency_percent_) { 0 }

    , decltype(_impl_.dark_current_amp_) { 0 }

    , decltype(_impl_.load_impedance_ohm_) { 0 }

    , decltype(_impl_.noise_factor_) { 0 }

    , decltype(_impl_.gain_db_) { 0 }

    , decltype(_impl_.optical_bandpass_filter_bandwidth_hz_) { 0 }

    , decltype(_impl_.sky_spectral_radiance_) { 0 }

    , decltype(_impl_.sun_spectral_radiant_emittance_) { 0 }

    , decltype(_impl_.wavelength_m_) { 0 }

  };
}

PhotodetectorDefinition_AvalanchePhotodiodeDefinition::~PhotodetectorDefinition_AvalanchePhotodiodeDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.field_of_view_rad_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.gain_db_) -
        reinterpret_cast<char*>(&_impl_.field_of_view_rad_)) + sizeof(_impl_.gain_db_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.optical_bandpass_filter_bandwidth_hz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.wavelength_m_) -
        reinterpret_cast<char*>(&_impl_.optical_bandpass_filter_bandwidth_hz_)) + sizeof(_impl_.wavelength_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_field_of_view_rad(&has_bits);
          _impl_.field_of_view_rad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_bandwidth_hz(&has_bits);
          _impl_.bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_noise_temperature_k(&has_bits);
          _impl_.noise_temperature_k_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_efficiency_percent(&has_bits);
          _impl_.efficiency_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_dark_current_amp(&has_bits);
          _impl_.dark_current_amp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_load_impedance_ohm(&has_bits);
          _impl_.load_impedance_ohm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double noise_factor = 7 [json_name = "noiseFactor"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_noise_factor(&has_bits);
          _impl_.noise_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double gain_db = 8 [json_name = "gainDb"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _Internal::set_has_gain_db(&has_bits);
          _impl_.gain_db_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double optical_bandpass_filter_bandwidth_hz = 9 [json_name = "opticalBandpassFilterBandwidthHz"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _Internal::set_has_optical_bandpass_filter_bandwidth_hz(&has_bits);
          _impl_.optical_bandpass_filter_bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double sky_spectral_radiance = 10 [json_name = "skySpectralRadiance"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_sky_spectral_radiance(&has_bits);
          _impl_.sky_spectral_radiance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double sun_spectral_radiant_emittance = 11 [json_name = "sunSpectralRadiantEmittance"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 89)) {
          _Internal::set_has_sun_spectral_radiant_emittance(&has_bits);
          _impl_.sun_spectral_radiant_emittance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double wavelength_m = 12 [json_name = "wavelengthM"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 97)) {
          _Internal::set_has_wavelength_m(&has_bits);
          _impl_.wavelength_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_field_of_view_rad(), target);
  }

  // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_bandwidth_hz(), target);
  }

  // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_noise_temperature_k(), target);
  }

  // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_efficiency_percent(), target);
  }

  // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_dark_current_amp(), target);
  }

  // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_load_impedance_ohm(), target);
  }

  // optional double noise_factor = 7 [json_name = "noiseFactor"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_noise_factor(), target);
  }

  // optional double gain_db = 8 [json_name = "gainDb"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_gain_db(), target);
  }

  // optional double optical_bandpass_filter_bandwidth_hz = 9 [json_name = "opticalBandpassFilterBandwidthHz"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_optical_bandpass_filter_bandwidth_hz(), target);
  }

  // optional double sky_spectral_radiance = 10 [json_name = "skySpectralRadiance"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_sky_spectral_radiance(), target);
  }

  // optional double sun_spectral_radiant_emittance = 11 [json_name = "sunSpectralRadiantEmittance"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this->_internal_sun_spectral_radiant_emittance(), target);
  }

  // optional double wavelength_m = 12 [json_name = "wavelengthM"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this->_internal_wavelength_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  return target;
}

::size_t PhotodetectorDefinition_AvalanchePhotodiodeDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional double noise_factor = 7 [json_name = "noiseFactor"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }

    // optional double gain_db = 8 [json_name = "gainDb"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional double optical_bandpass_filter_bandwidth_hz = 9 [json_name = "opticalBandpassFilterBandwidthHz"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }

    // optional double sky_spectral_radiance = 10 [json_name = "skySpectralRadiance"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }

    // optional double sun_spectral_radiant_emittance = 11 [json_name = "sunSpectralRadiantEmittance"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 9;
    }

    // optional double wavelength_m = 12 [json_name = "wavelengthM"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhotodetectorDefinition_AvalanchePhotodiodeDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhotodetectorDefinition_AvalanchePhotodiodeDefinition::GetClassData() const { return &_class_data_; }


void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhotodetectorDefinition_AvalanchePhotodiodeDefinition*>(&to_msg);
  auto& from = static_cast<const PhotodetectorDefinition_AvalanchePhotodiodeDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.field_of_view_rad_ = from._impl_.field_of_view_rad_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bandwidth_hz_ = from._impl_.bandwidth_hz_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.noise_temperature_k_ = from._impl_.noise_temperature_k_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.efficiency_percent_ = from._impl_.efficiency_percent_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dark_current_amp_ = from._impl_.dark_current_amp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.load_impedance_ohm_ = from._impl_.load_impedance_ohm_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.noise_factor_ = from._impl_.noise_factor_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gain_db_ = from._impl_.gain_db_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.optical_bandpass_filter_bandwidth_hz_ = from._impl_.optical_bandpass_filter_bandwidth_hz_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.sky_spectral_radiance_ = from._impl_.sky_spectral_radiance_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sun_spectral_radiant_emittance_ = from._impl_.sun_spectral_radiant_emittance_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wavelength_m_ = from._impl_.wavelength_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::CopyFrom(const PhotodetectorDefinition_AvalanchePhotodiodeDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhotodetectorDefinition_AvalanchePhotodiodeDefinition::IsInitialized() const {
  return true;
}

void PhotodetectorDefinition_AvalanchePhotodiodeDefinition::InternalSwap(PhotodetectorDefinition_AvalanchePhotodiodeDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.wavelength_m_)
      + sizeof(PhotodetectorDefinition_AvalanchePhotodiodeDefinition::_impl_.wavelength_m_)
      - PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_AvalanchePhotodiodeDefinition, _impl_.field_of_view_rad_)>(
          reinterpret_cast<char*>(&_impl_.field_of_view_rad_),
          reinterpret_cast<char*>(&other->_impl_.field_of_view_rad_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhotodetectorDefinition_AvalanchePhotodiodeDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[7]);
}
// ===================================================================

class PhotodetectorDefinition_PinPhotodiodeDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<PhotodetectorDefinition_PinPhotodiodeDefinition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_._has_bits_);
  static void set_has_field_of_view_rad(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bandwidth_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_noise_temperature_k(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_efficiency_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dark_current_amp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_load_impedance_ohm(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_optical_bandpass_filter_bandwidth_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sky_spectral_radiance(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sun_spectral_radiant_emittance(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_wavelength_m(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

PhotodetectorDefinition_PinPhotodiodeDefinition::PhotodetectorDefinition_PinPhotodiodeDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
}
PhotodetectorDefinition_PinPhotodiodeDefinition::PhotodetectorDefinition_PinPhotodiodeDefinition(const PhotodetectorDefinition_PinPhotodiodeDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
}

inline void PhotodetectorDefinition_PinPhotodiodeDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.field_of_view_rad_) { 0 }

    , decltype(_impl_.bandwidth_hz_) { 0 }

    , decltype(_impl_.noise_temperature_k_) { 0 }

    , decltype(_impl_.efficiency_percent_) { 0 }

    , decltype(_impl_.dark_current_amp_) { 0 }

    , decltype(_impl_.load_impedance_ohm_) { 0 }

    , decltype(_impl_.optical_bandpass_filter_bandwidth_hz_) { 0 }

    , decltype(_impl_.sky_spectral_radiance_) { 0 }

    , decltype(_impl_.sun_spectral_radiant_emittance_) { 0 }

    , decltype(_impl_.wavelength_m_) { 0 }

  };
}

PhotodetectorDefinition_PinPhotodiodeDefinition::~PhotodetectorDefinition_PinPhotodiodeDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhotodetectorDefinition_PinPhotodiodeDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PhotodetectorDefinition_PinPhotodiodeDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhotodetectorDefinition_PinPhotodiodeDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.field_of_view_rad_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.sky_spectral_radiance_) -
        reinterpret_cast<char*>(&_impl_.field_of_view_rad_)) + sizeof(_impl_.sky_spectral_radiance_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.sun_spectral_radiant_emittance_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.wavelength_m_) -
        reinterpret_cast<char*>(&_impl_.sun_spectral_radiant_emittance_)) + sizeof(_impl_.wavelength_m_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhotodetectorDefinition_PinPhotodiodeDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_field_of_view_rad(&has_bits);
          _impl_.field_of_view_rad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_bandwidth_hz(&has_bits);
          _impl_.bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_noise_temperature_k(&has_bits);
          _impl_.noise_temperature_k_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_efficiency_percent(&has_bits);
          _impl_.efficiency_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_dark_current_amp(&has_bits);
          _impl_.dark_current_amp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_load_impedance_ohm(&has_bits);
          _impl_.load_impedance_ohm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double optical_bandpass_filter_bandwidth_hz = 7 [json_name = "opticalBandpassFilterBandwidthHz"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_optical_bandpass_filter_bandwidth_hz(&has_bits);
          _impl_.optical_bandpass_filter_bandwidth_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double sky_spectral_radiance = 8 [json_name = "skySpectralRadiance"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _Internal::set_has_sky_spectral_radiance(&has_bits);
          _impl_.sky_spectral_radiance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double sun_spectral_radiant_emittance = 9 [json_name = "sunSpectralRadiantEmittance"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _Internal::set_has_sun_spectral_radiant_emittance(&has_bits);
          _impl_.sun_spectral_radiant_emittance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double wavelength_m = 10 [json_name = "wavelengthM"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 81)) {
          _Internal::set_has_wavelength_m(&has_bits);
          _impl_.wavelength_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhotodetectorDefinition_PinPhotodiodeDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_field_of_view_rad(), target);
  }

  // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_bandwidth_hz(), target);
  }

  // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_noise_temperature_k(), target);
  }

  // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_efficiency_percent(), target);
  }

  // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_dark_current_amp(), target);
  }

  // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_load_impedance_ohm(), target);
  }

  // optional double optical_bandpass_filter_bandwidth_hz = 7 [json_name = "opticalBandpassFilterBandwidthHz"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_optical_bandpass_filter_bandwidth_hz(), target);
  }

  // optional double sky_spectral_radiance = 8 [json_name = "skySpectralRadiance"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_sky_spectral_radiance(), target);
  }

  // optional double sun_spectral_radiant_emittance = 9 [json_name = "sunSpectralRadiantEmittance"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_sun_spectral_radiant_emittance(), target);
  }

  // optional double wavelength_m = 10 [json_name = "wavelengthM"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this->_internal_wavelength_m(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  return target;
}

::size_t PhotodetectorDefinition_PinPhotodiodeDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double field_of_view_rad = 1 [json_name = "fieldOfViewRad"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double bandwidth_hz = 2 [json_name = "bandwidthHz"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double noise_temperature_k = 3 [json_name = "noiseTemperatureK"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double efficiency_percent = 4 [json_name = "efficiencyPercent"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double dark_current_amp = 5 [json_name = "darkCurrentAmp"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double load_impedance_ohm = 6 [json_name = "loadImpedanceOhm"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

    // optional double optical_bandpass_filter_bandwidth_hz = 7 [json_name = "opticalBandpassFilterBandwidthHz"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }

    // optional double sky_spectral_radiance = 8 [json_name = "skySpectralRadiance"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional double sun_spectral_radiant_emittance = 9 [json_name = "sunSpectralRadiantEmittance"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }

    // optional double wavelength_m = 10 [json_name = "wavelengthM"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhotodetectorDefinition_PinPhotodiodeDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhotodetectorDefinition_PinPhotodiodeDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhotodetectorDefinition_PinPhotodiodeDefinition::GetClassData() const { return &_class_data_; }


void PhotodetectorDefinition_PinPhotodiodeDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhotodetectorDefinition_PinPhotodiodeDefinition*>(&to_msg);
  auto& from = static_cast<const PhotodetectorDefinition_PinPhotodiodeDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.field_of_view_rad_ = from._impl_.field_of_view_rad_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bandwidth_hz_ = from._impl_.bandwidth_hz_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.noise_temperature_k_ = from._impl_.noise_temperature_k_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.efficiency_percent_ = from._impl_.efficiency_percent_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dark_current_amp_ = from._impl_.dark_current_amp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.load_impedance_ohm_ = from._impl_.load_impedance_ohm_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.optical_bandpass_filter_bandwidth_hz_ = from._impl_.optical_bandpass_filter_bandwidth_hz_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.sky_spectral_radiance_ = from._impl_.sky_spectral_radiance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sun_spectral_radiant_emittance_ = from._impl_.sun_spectral_radiant_emittance_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.wavelength_m_ = from._impl_.wavelength_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhotodetectorDefinition_PinPhotodiodeDefinition::CopyFrom(const PhotodetectorDefinition_PinPhotodiodeDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhotodetectorDefinition_PinPhotodiodeDefinition::IsInitialized() const {
  return true;
}

void PhotodetectorDefinition_PinPhotodiodeDefinition::InternalSwap(PhotodetectorDefinition_PinPhotodiodeDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.wavelength_m_)
      + sizeof(PhotodetectorDefinition_PinPhotodiodeDefinition::_impl_.wavelength_m_)
      - PROTOBUF_FIELD_OFFSET(PhotodetectorDefinition_PinPhotodiodeDefinition, _impl_.field_of_view_rad_)>(
          reinterpret_cast<char*>(&_impl_.field_of_view_rad_),
          reinterpret_cast<char*>(&other->_impl_.field_of_view_rad_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PhotodetectorDefinition_PinPhotodiodeDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[8]);
}
// ===================================================================

class PhotodetectorDefinition::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PhotodetectorDefinition, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition& avalanche_photodiode(const PhotodetectorDefinition* msg);
  static const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition& pin_photodiode(const PhotodetectorDefinition* msg);
};

const ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition&
PhotodetectorDefinition::_Internal::avalanche_photodiode(const PhotodetectorDefinition* msg) {
  return *msg->_impl_.photodetector_type_.avalanche_photodiode_;
}
const ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition&
PhotodetectorDefinition::_Internal::pin_photodiode(const PhotodetectorDefinition* msg) {
  return *msg->_impl_.photodetector_type_.pin_photodiode_;
}
void PhotodetectorDefinition::set_allocated_avalanche_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition* avalanche_photodiode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_photodetector_type();
  if (avalanche_photodiode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(avalanche_photodiode);
    if (message_arena != submessage_arena) {
      avalanche_photodiode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avalanche_photodiode, submessage_arena);
    }
    set_has_avalanche_photodiode();
    _impl_.photodetector_type_.avalanche_photodiode_ = avalanche_photodiode;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PhotodetectorDefinition.avalanche_photodiode)
}
void PhotodetectorDefinition::set_allocated_pin_photodiode(::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition* pin_photodiode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_photodetector_type();
  if (pin_photodiode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pin_photodiode);
    if (message_arena != submessage_arena) {
      pin_photodiode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pin_photodiode, submessage_arena);
    }
    set_has_pin_photodiode();
    _impl_.photodetector_type_.pin_photodiode_ = pin_photodiode;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PhotodetectorDefinition.pin_photodiode)
}
PhotodetectorDefinition::PhotodetectorDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition)
}
PhotodetectorDefinition::PhotodetectorDefinition(const PhotodetectorDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhotodetectorDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.photodetector_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_photodetector_type();
  switch (from.photodetector_type_case()) {
    case kAvalanchePhotodiode: {
      _this->_internal_mutable_avalanche_photodiode()->::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition::MergeFrom(
          from._internal_avalanche_photodiode());
      break;
    }
    case kPinPhotodiode: {
      _this->_internal_mutable_pin_photodiode()->::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition::MergeFrom(
          from._internal_pin_photodiode());
      break;
    }
    case PHOTODETECTOR_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PhotodetectorDefinition)
}

inline void PhotodetectorDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.photodetector_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_photodetector_type();
}

PhotodetectorDefinition::~PhotodetectorDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PhotodetectorDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhotodetectorDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_photodetector_type()) {
    clear_photodetector_type();
  }
}

void PhotodetectorDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhotodetectorDefinition::clear_photodetector_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  switch (photodetector_type_case()) {
    case kAvalanchePhotodiode: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.photodetector_type_.avalanche_photodiode_;
      }
      break;
    }
    case kPinPhotodiode: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.photodetector_type_.pin_photodiode_;
      }
      break;
    }
    case PHOTODETECTOR_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PHOTODETECTOR_TYPE_NOT_SET;
}


void PhotodetectorDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_photodetector_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhotodetectorDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition avalanche_photodiode = 1 [json_name = "avalanchePhotodiode"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_avalanche_photodiode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition pin_photodiode = 2 [json_name = "pinPhotodiode"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pin_photodiode(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PhotodetectorDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (photodetector_type_case()) {
    case kAvalanchePhotodiode: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::avalanche_photodiode(this),
          _Internal::avalanche_photodiode(this).GetCachedSize(), target, stream);
      break;
    }
    case kPinPhotodiode: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::pin_photodiode(this),
          _Internal::pin_photodiode(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PhotodetectorDefinition)
  return target;
}

::size_t PhotodetectorDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (photodetector_type_case()) {
    // .aalyria.spacetime.api.common.PhotodetectorDefinition.AvalanchePhotodiodeDefinition avalanche_photodiode = 1 [json_name = "avalanchePhotodiode"];
    case kAvalanchePhotodiode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.photodetector_type_.avalanche_photodiode_);
      break;
    }
    // .aalyria.spacetime.api.common.PhotodetectorDefinition.PinPhotodiodeDefinition pin_photodiode = 2 [json_name = "pinPhotodiode"];
    case kPinPhotodiode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.photodetector_type_.pin_photodiode_);
      break;
    }
    case PHOTODETECTOR_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhotodetectorDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhotodetectorDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhotodetectorDefinition::GetClassData() const { return &_class_data_; }


void PhotodetectorDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhotodetectorDefinition*>(&to_msg);
  auto& from = static_cast<const PhotodetectorDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.photodetector_type_case()) {
    case kAvalanchePhotodiode: {
      _this->_internal_mutable_avalanche_photodiode()->::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition::MergeFrom(
          from._internal_avalanche_photodiode());
      break;
    }
    case kPinPhotodiode: {
      _this->_internal_mutable_pin_photodiode()->::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition::MergeFrom(
          from._internal_pin_photodiode());
      break;
    }
    case PHOTODETECTOR_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhotodetectorDefinition::CopyFrom(const PhotodetectorDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PhotodetectorDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhotodetectorDefinition::IsInitialized() const {
  return true;
}

void PhotodetectorDefinition::InternalSwap(PhotodetectorDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.photodetector_type_, other->_impl_.photodetector_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PhotodetectorDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_getter, &descriptor_table_api_2fcommon_2fwireless_5freceiver_2eproto_once,
      file_level_metadata_api_2fcommon_2fwireless_5freceiver_2eproto[9]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::RxChannels*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::RxChannels >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::RxChannels >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::ReceiverDefinition_ChannelSetEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::ReceiverDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::ReceiverDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::ReceiverDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::ReceiveSignalProcessor*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::ReceiveSignalProcessor >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Filter_RectangularFilterDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Filter_LinearFilterDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Filter*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PhotodetectorDefinition_AvalanchePhotodiodeDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PhotodetectorDefinition_PinPhotodiodeDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PhotodetectorDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PhotodetectorDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PhotodetectorDefinition >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
