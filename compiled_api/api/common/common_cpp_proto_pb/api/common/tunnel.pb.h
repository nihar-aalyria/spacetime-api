// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/tunnel.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftunnel_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftunnel_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2ftunnel_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2ftunnel_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2ftunnel_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class EspParameters;
struct EspParametersDefaultTypeInternal;
extern EspParametersDefaultTypeInternal _EspParameters_default_instance_;
class EspParameters_EspAuth;
struct EspParameters_EspAuthDefaultTypeInternal;
extern EspParameters_EspAuthDefaultTypeInternal _EspParameters_EspAuth_default_instance_;
class EspParameters_EspEncrypt;
struct EspParameters_EspEncryptDefaultTypeInternal;
extern EspParameters_EspEncryptDefaultTypeInternal _EspParameters_EspEncrypt_default_instance_;
class EspProtocol;
struct EspProtocolDefaultTypeInternal;
extern EspProtocolDefaultTypeInternal _EspProtocol_default_instance_;
class EspProtocol_EspIntegrity;
struct EspProtocol_EspIntegrityDefaultTypeInternal;
extern EspProtocol_EspIntegrityDefaultTypeInternal _EspProtocol_EspIntegrity_default_instance_;
class EspProtocol_EspPrivacy;
struct EspProtocol_EspPrivacyDefaultTypeInternal;
extern EspProtocol_EspPrivacyDefaultTypeInternal _EspProtocol_EspPrivacy_default_instance_;
class TunnelMethod;
struct TunnelMethodDefaultTypeInternal;
extern TunnelMethodDefaultTypeInternal _TunnelMethod_default_instance_;
class WrappedKey;
struct WrappedKeyDefaultTypeInternal;
extern WrappedKeyDefaultTypeInternal _WrappedKey_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::EspParameters* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspParameters>(Arena*);
template <>
::aalyria::spacetime::api::common::EspParameters_EspAuth* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspParameters_EspAuth>(Arena*);
template <>
::aalyria::spacetime::api::common::EspParameters_EspEncrypt* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspParameters_EspEncrypt>(Arena*);
template <>
::aalyria::spacetime::api::common::EspProtocol* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspProtocol>(Arena*);
template <>
::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspProtocol_EspIntegrity>(Arena*);
template <>
::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::EspProtocol_EspPrivacy>(Arena*);
template <>
::aalyria::spacetime::api::common::TunnelMethod* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TunnelMethod>(Arena*);
template <>
::aalyria::spacetime::api::common::WrappedKey* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::WrappedKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum AuthenticationAlgorithm : int {
  AUTH_ALGO_UNSPECIFIED = 0,
  HMAC_SHA1_96 = 1,
};

bool AuthenticationAlgorithm_IsValid(int value);
constexpr AuthenticationAlgorithm AuthenticationAlgorithm_MIN = static_cast<AuthenticationAlgorithm>(0);
constexpr AuthenticationAlgorithm AuthenticationAlgorithm_MAX = static_cast<AuthenticationAlgorithm>(1);
constexpr int AuthenticationAlgorithm_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AuthenticationAlgorithm_descriptor();
template <typename T>
const std::string& AuthenticationAlgorithm_Name(T value) {
  static_assert(std::is_same<T, AuthenticationAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AuthenticationAlgorithm_Name().");
  return AuthenticationAlgorithm_Name(static_cast<AuthenticationAlgorithm>(value));
}
template <>
inline const std::string& AuthenticationAlgorithm_Name(AuthenticationAlgorithm value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AuthenticationAlgorithm_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AuthenticationAlgorithm_Parse(absl::string_view name, AuthenticationAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthenticationAlgorithm>(
      AuthenticationAlgorithm_descriptor(), name, value);
}
enum EncryptionAlgorithm : int {
  ENCRYPTION_ALGO_UNSPECIFIED = 0,
  AES_CBC_128 = 1,
};

bool EncryptionAlgorithm_IsValid(int value);
constexpr EncryptionAlgorithm EncryptionAlgorithm_MIN = static_cast<EncryptionAlgorithm>(0);
constexpr EncryptionAlgorithm EncryptionAlgorithm_MAX = static_cast<EncryptionAlgorithm>(1);
constexpr int EncryptionAlgorithm_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
EncryptionAlgorithm_descriptor();
template <typename T>
const std::string& EncryptionAlgorithm_Name(T value) {
  static_assert(std::is_same<T, EncryptionAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncryptionAlgorithm_Name().");
  return EncryptionAlgorithm_Name(static_cast<EncryptionAlgorithm>(value));
}
template <>
inline const std::string& EncryptionAlgorithm_Name(EncryptionAlgorithm value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<EncryptionAlgorithm_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool EncryptionAlgorithm_Parse(absl::string_view name, EncryptionAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionAlgorithm>(
      EncryptionAlgorithm_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class EspProtocol_EspIntegrity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspProtocol.EspIntegrity) */ {
 public:
  inline EspProtocol_EspIntegrity() : EspProtocol_EspIntegrity(nullptr) {}
  ~EspProtocol_EspIntegrity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspProtocol_EspIntegrity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspProtocol_EspIntegrity(const EspProtocol_EspIntegrity& from);
  EspProtocol_EspIntegrity(EspProtocol_EspIntegrity&& from) noexcept
    : EspProtocol_EspIntegrity() {
    *this = ::std::move(from);
  }

  inline EspProtocol_EspIntegrity& operator=(const EspProtocol_EspIntegrity& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspProtocol_EspIntegrity& operator=(EspProtocol_EspIntegrity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspProtocol_EspIntegrity& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspProtocol_EspIntegrity* internal_default_instance() {
    return reinterpret_cast<const EspProtocol_EspIntegrity*>(
               &_EspProtocol_EspIntegrity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EspProtocol_EspIntegrity& a, EspProtocol_EspIntegrity& b) {
    a.Swap(&b);
  }
  inline void Swap(EspProtocol_EspIntegrity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspProtocol_EspIntegrity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspProtocol_EspIntegrity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspProtocol_EspIntegrity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspProtocol_EspIntegrity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspProtocol_EspIntegrity& from) {
    EspProtocol_EspIntegrity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspProtocol_EspIntegrity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspProtocol.EspIntegrity";
  }
  protected:
  explicit EspProtocol_EspIntegrity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.common.AuthenticationAlgorithm algorithm = 1 [json_name = "algorithm"];
  bool has_algorithm() const;
  void clear_algorithm() ;
  ::aalyria::spacetime::api::common::AuthenticationAlgorithm algorithm() const;
  void set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value);

  private:
  ::aalyria::spacetime::api::common::AuthenticationAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspProtocol.EspIntegrity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int algorithm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class EspProtocol_EspPrivacy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspProtocol.EspPrivacy) */ {
 public:
  inline EspProtocol_EspPrivacy() : EspProtocol_EspPrivacy(nullptr) {}
  ~EspProtocol_EspPrivacy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspProtocol_EspPrivacy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspProtocol_EspPrivacy(const EspProtocol_EspPrivacy& from);
  EspProtocol_EspPrivacy(EspProtocol_EspPrivacy&& from) noexcept
    : EspProtocol_EspPrivacy() {
    *this = ::std::move(from);
  }

  inline EspProtocol_EspPrivacy& operator=(const EspProtocol_EspPrivacy& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspProtocol_EspPrivacy& operator=(EspProtocol_EspPrivacy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspProtocol_EspPrivacy& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspProtocol_EspPrivacy* internal_default_instance() {
    return reinterpret_cast<const EspProtocol_EspPrivacy*>(
               &_EspProtocol_EspPrivacy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EspProtocol_EspPrivacy& a, EspProtocol_EspPrivacy& b) {
    a.Swap(&b);
  }
  inline void Swap(EspProtocol_EspPrivacy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspProtocol_EspPrivacy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspProtocol_EspPrivacy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspProtocol_EspPrivacy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspProtocol_EspPrivacy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspProtocol_EspPrivacy& from) {
    EspProtocol_EspPrivacy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspProtocol_EspPrivacy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspProtocol.EspPrivacy";
  }
  protected:
  explicit EspProtocol_EspPrivacy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.common.EncryptionAlgorithm algorithm = 1 [json_name = "algorithm"];
  bool has_algorithm() const;
  void clear_algorithm() ;
  ::aalyria::spacetime::api::common::EncryptionAlgorithm algorithm() const;
  void set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value);

  private:
  ::aalyria::spacetime::api::common::EncryptionAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspProtocol.EspPrivacy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int algorithm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class EspProtocol final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspProtocol) */ {
 public:
  inline EspProtocol() : EspProtocol(nullptr) {}
  ~EspProtocol() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspProtocol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspProtocol(const EspProtocol& from);
  EspProtocol(EspProtocol&& from) noexcept
    : EspProtocol() {
    *this = ::std::move(from);
  }

  inline EspProtocol& operator=(const EspProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspProtocol& operator=(EspProtocol&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspProtocol& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspProtocol* internal_default_instance() {
    return reinterpret_cast<const EspProtocol*>(
               &_EspProtocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EspProtocol& a, EspProtocol& b) {
    a.Swap(&b);
  }
  inline void Swap(EspProtocol* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspProtocol* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspProtocol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspProtocol>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspProtocol& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspProtocol& from) {
    EspProtocol::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspProtocol* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspProtocol";
  }
  protected:
  explicit EspProtocol(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EspProtocol_EspIntegrity EspIntegrity;
  typedef EspProtocol_EspPrivacy EspPrivacy;

  // accessors -------------------------------------------------------

  enum : int {
    kAuthenticationFieldNumber = 1,
    kEncryptionFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.EspProtocol.EspIntegrity authentication = 1 [json_name = "authentication"];
  bool has_authentication() const;
  void clear_authentication() ;
  const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity& authentication() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* release_authentication();
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* mutable_authentication();
  void set_allocated_authentication(::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* authentication);
  private:
  const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity& _internal_authentication() const;
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* _internal_mutable_authentication();
  public:
  void unsafe_arena_set_allocated_authentication(
      ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* authentication);
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* unsafe_arena_release_authentication();
  // optional .aalyria.spacetime.api.common.EspProtocol.EspPrivacy encryption = 2 [json_name = "encryption"];
  bool has_encryption() const;
  void clear_encryption() ;
  const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy& encryption() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* release_encryption();
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* mutable_encryption();
  void set_allocated_encryption(::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* encryption);
  private:
  const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy& _internal_encryption() const;
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* _internal_mutable_encryption();
  public:
  void unsafe_arena_set_allocated_encryption(
      ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* encryption);
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* unsafe_arena_release_encryption();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspProtocol)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* authentication_;
    ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* encryption_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class EspParameters_EspAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspParameters.EspAuth) */ {
 public:
  inline EspParameters_EspAuth() : EspParameters_EspAuth(nullptr) {}
  ~EspParameters_EspAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspParameters_EspAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspParameters_EspAuth(const EspParameters_EspAuth& from);
  EspParameters_EspAuth(EspParameters_EspAuth&& from) noexcept
    : EspParameters_EspAuth() {
    *this = ::std::move(from);
  }

  inline EspParameters_EspAuth& operator=(const EspParameters_EspAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspParameters_EspAuth& operator=(EspParameters_EspAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspParameters_EspAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspParameters_EspAuth* internal_default_instance() {
    return reinterpret_cast<const EspParameters_EspAuth*>(
               &_EspParameters_EspAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EspParameters_EspAuth& a, EspParameters_EspAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(EspParameters_EspAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspParameters_EspAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspParameters_EspAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspParameters_EspAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspParameters_EspAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspParameters_EspAuth& from) {
    EspParameters_EspAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspParameters_EspAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspParameters.EspAuth";
  }
  protected:
  explicit EspParameters_EspAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kAlgorithmFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.common.WrappedKey key = 2 [json_name = "key"];
  bool has_key() const;
  void clear_key() ;
  const ::aalyria::spacetime::api::common::WrappedKey& key() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::WrappedKey* release_key();
  ::aalyria::spacetime::api::common::WrappedKey* mutable_key();
  void set_allocated_key(::aalyria::spacetime::api::common::WrappedKey* key);
  private:
  const ::aalyria::spacetime::api::common::WrappedKey& _internal_key() const;
  ::aalyria::spacetime::api::common::WrappedKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::aalyria::spacetime::api::common::WrappedKey* key);
  ::aalyria::spacetime::api::common::WrappedKey* unsafe_arena_release_key();
  // optional .aalyria.spacetime.api.common.AuthenticationAlgorithm algorithm = 1 [json_name = "algorithm"];
  bool has_algorithm() const;
  void clear_algorithm() ;
  ::aalyria::spacetime::api::common::AuthenticationAlgorithm algorithm() const;
  void set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value);

  private:
  ::aalyria::spacetime::api::common::AuthenticationAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspParameters.EspAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::WrappedKey* key_;
    int algorithm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class EspParameters_EspEncrypt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspParameters.EspEncrypt) */ {
 public:
  inline EspParameters_EspEncrypt() : EspParameters_EspEncrypt(nullptr) {}
  ~EspParameters_EspEncrypt() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspParameters_EspEncrypt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspParameters_EspEncrypt(const EspParameters_EspEncrypt& from);
  EspParameters_EspEncrypt(EspParameters_EspEncrypt&& from) noexcept
    : EspParameters_EspEncrypt() {
    *this = ::std::move(from);
  }

  inline EspParameters_EspEncrypt& operator=(const EspParameters_EspEncrypt& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspParameters_EspEncrypt& operator=(EspParameters_EspEncrypt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspParameters_EspEncrypt& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspParameters_EspEncrypt* internal_default_instance() {
    return reinterpret_cast<const EspParameters_EspEncrypt*>(
               &_EspParameters_EspEncrypt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EspParameters_EspEncrypt& a, EspParameters_EspEncrypt& b) {
    a.Swap(&b);
  }
  inline void Swap(EspParameters_EspEncrypt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspParameters_EspEncrypt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspParameters_EspEncrypt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspParameters_EspEncrypt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspParameters_EspEncrypt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspParameters_EspEncrypt& from) {
    EspParameters_EspEncrypt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspParameters_EspEncrypt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspParameters.EspEncrypt";
  }
  protected:
  explicit EspParameters_EspEncrypt(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kAlgorithmFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.common.WrappedKey key = 2 [json_name = "key"];
  bool has_key() const;
  void clear_key() ;
  const ::aalyria::spacetime::api::common::WrappedKey& key() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::WrappedKey* release_key();
  ::aalyria::spacetime::api::common::WrappedKey* mutable_key();
  void set_allocated_key(::aalyria::spacetime::api::common::WrappedKey* key);
  private:
  const ::aalyria::spacetime::api::common::WrappedKey& _internal_key() const;
  ::aalyria::spacetime::api::common::WrappedKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::aalyria::spacetime::api::common::WrappedKey* key);
  ::aalyria::spacetime::api::common::WrappedKey* unsafe_arena_release_key();
  // optional .aalyria.spacetime.api.common.EncryptionAlgorithm algorithm = 1 [json_name = "algorithm"];
  bool has_algorithm() const;
  void clear_algorithm() ;
  ::aalyria::spacetime::api::common::EncryptionAlgorithm algorithm() const;
  void set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value);

  private:
  ::aalyria::spacetime::api::common::EncryptionAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspParameters.EspEncrypt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::WrappedKey* key_;
    int algorithm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class EspParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.EspParameters) */ {
 public:
  inline EspParameters() : EspParameters(nullptr) {}
  ~EspParameters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EspParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EspParameters(const EspParameters& from);
  EspParameters(EspParameters&& from) noexcept
    : EspParameters() {
    *this = ::std::move(from);
  }

  inline EspParameters& operator=(const EspParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline EspParameters& operator=(EspParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EspParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const EspParameters* internal_default_instance() {
    return reinterpret_cast<const EspParameters*>(
               &_EspParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EspParameters& a, EspParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(EspParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EspParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EspParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EspParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EspParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EspParameters& from) {
    EspParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EspParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.EspParameters";
  }
  protected:
  explicit EspParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EspParameters_EspAuth EspAuth;
  typedef EspParameters_EspEncrypt EspEncrypt;

  // accessors -------------------------------------------------------

  enum : int {
    kAuthenticationFieldNumber = 1,
    kEncryptionFieldNumber = 2,
    kSecurityParametersIndexFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.EspParameters.EspAuth authentication = 1 [json_name = "authentication"];
  bool has_authentication() const;
  void clear_authentication() ;
  const ::aalyria::spacetime::api::common::EspParameters_EspAuth& authentication() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::EspParameters_EspAuth* release_authentication();
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* mutable_authentication();
  void set_allocated_authentication(::aalyria::spacetime::api::common::EspParameters_EspAuth* authentication);
  private:
  const ::aalyria::spacetime::api::common::EspParameters_EspAuth& _internal_authentication() const;
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* _internal_mutable_authentication();
  public:
  void unsafe_arena_set_allocated_authentication(
      ::aalyria::spacetime::api::common::EspParameters_EspAuth* authentication);
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* unsafe_arena_release_authentication();
  // optional .aalyria.spacetime.api.common.EspParameters.EspEncrypt encryption = 2 [json_name = "encryption"];
  bool has_encryption() const;
  void clear_encryption() ;
  const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt& encryption() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* release_encryption();
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* mutable_encryption();
  void set_allocated_encryption(::aalyria::spacetime::api::common::EspParameters_EspEncrypt* encryption);
  private:
  const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt& _internal_encryption() const;
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* _internal_mutable_encryption();
  public:
  void unsafe_arena_set_allocated_encryption(
      ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* encryption);
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* unsafe_arena_release_encryption();
  // optional uint32 security_parameters_index = 3 [json_name = "securityParametersIndex"];
  bool has_security_parameters_index() const;
  void clear_security_parameters_index() ;
  ::uint32_t security_parameters_index() const;
  void set_security_parameters_index(::uint32_t value);

  private:
  ::uint32_t _internal_security_parameters_index() const;
  void _internal_set_security_parameters_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.EspParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::EspParameters_EspAuth* authentication_;
    ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* encryption_;
    ::uint32_t security_parameters_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class WrappedKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.WrappedKey) */ {
 public:
  inline WrappedKey() : WrappedKey(nullptr) {}
  ~WrappedKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WrappedKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WrappedKey(const WrappedKey& from);
  WrappedKey(WrappedKey&& from) noexcept
    : WrappedKey() {
    *this = ::std::move(from);
  }

  inline WrappedKey& operator=(const WrappedKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline WrappedKey& operator=(WrappedKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WrappedKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const WrappedKey* internal_default_instance() {
    return reinterpret_cast<const WrappedKey*>(
               &_WrappedKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WrappedKey& a, WrappedKey& b) {
    a.Swap(&b);
  }
  inline void Swap(WrappedKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WrappedKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WrappedKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WrappedKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WrappedKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WrappedKey& from) {
    WrappedKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WrappedKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.WrappedKey";
  }
  protected:
  explicit WrappedKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnwrapperKeyNameFieldNumber = 1,
    kWrappedKeyFieldNumber = 2,
  };
  // optional string unwrapper_key_name = 1 [json_name = "unwrapperKeyName"];
  bool has_unwrapper_key_name() const;
  void clear_unwrapper_key_name() ;
  const std::string& unwrapper_key_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unwrapper_key_name(Arg_&& arg, Args_... args);
  std::string* mutable_unwrapper_key_name();
  PROTOBUF_NODISCARD std::string* release_unwrapper_key_name();
  void set_allocated_unwrapper_key_name(std::string* ptr);

  private:
  const std::string& _internal_unwrapper_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unwrapper_key_name(
      const std::string& value);
  std::string* _internal_mutable_unwrapper_key_name();

  public:
  // optional bytes wrapped_key = 2 [json_name = "wrappedKey"];
  bool has_wrapped_key() const;
  void clear_wrapped_key() ;
  const std::string& wrapped_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wrapped_key(Arg_&& arg, Args_... args);
  std::string* mutable_wrapped_key();
  PROTOBUF_NODISCARD std::string* release_wrapped_key();
  void set_allocated_wrapped_key(std::string* ptr);

  private:
  const std::string& _internal_wrapped_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapped_key(
      const std::string& value);
  std::string* _internal_mutable_wrapped_key();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.WrappedKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unwrapper_key_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapped_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};// -------------------------------------------------------------------

class TunnelMethod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TunnelMethod) */ {
 public:
  inline TunnelMethod() : TunnelMethod(nullptr) {}
  ~TunnelMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TunnelMethod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelMethod(const TunnelMethod& from);
  TunnelMethod(TunnelMethod&& from) noexcept
    : TunnelMethod() {
    *this = ::std::move(from);
  }

  inline TunnelMethod& operator=(const TunnelMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelMethod& operator=(TunnelMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelMethod& default_instance() {
    return *internal_default_instance();
  }
  enum ProtocolCase {
    kEsp = 1,
    kNone = 2,
    PROTOCOL_NOT_SET = 0,
  };

  static inline const TunnelMethod* internal_default_instance() {
    return reinterpret_cast<const TunnelMethod*>(
               &_TunnelMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TunnelMethod& a, TunnelMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelMethod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelMethod>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelMethod& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelMethod& from) {
    TunnelMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelMethod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TunnelMethod";
  }
  protected:
  explicit TunnelMethod(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEspFieldNumber = 1,
    kNoneFieldNumber = 2,
  };
  // .aalyria.spacetime.api.common.EspProtocol esp = 1 [json_name = "esp"];
  bool has_esp() const;
  private:
  bool _internal_has_esp() const;

  public:
  void clear_esp() ;
  const ::aalyria::spacetime::api::common::EspProtocol& esp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::EspProtocol* release_esp();
  ::aalyria::spacetime::api::common::EspProtocol* mutable_esp();
  void set_allocated_esp(::aalyria::spacetime::api::common::EspProtocol* esp);
  private:
  const ::aalyria::spacetime::api::common::EspProtocol& _internal_esp() const;
  ::aalyria::spacetime::api::common::EspProtocol* _internal_mutable_esp();
  public:
  void unsafe_arena_set_allocated_esp(
      ::aalyria::spacetime::api::common::EspProtocol* esp);
  ::aalyria::spacetime::api::common::EspProtocol* unsafe_arena_release_esp();
  // .google.protobuf.Empty none = 2 [json_name = "none"];
  bool has_none() const;
  private:
  bool _internal_has_none() const;

  public:
  void clear_none() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& none() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_none();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_none();
  void set_allocated_none(::PROTOBUF_NAMESPACE_ID::Empty* none);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_none() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_none();
  public:
  void unsafe_arena_set_allocated_none(
      ::PROTOBUF_NAMESPACE_ID::Empty* none);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_none();
  void clear_protocol();
  ProtocolCase protocol_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TunnelMethod)
 private:
  class _Internal;
  void set_has_esp();
  void set_has_none();

  inline bool has_protocol() const;
  inline void clear_has_protocol();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ProtocolUnion {
      constexpr ProtocolUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::EspProtocol* esp_;
      ::PROTOBUF_NAMESPACE_ID::Empty* none_;
    } protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftunnel_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EspProtocol_EspIntegrity

// optional .aalyria.spacetime.api.common.AuthenticationAlgorithm algorithm = 1 [json_name = "algorithm"];
inline bool EspProtocol_EspIntegrity::has_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EspProtocol_EspIntegrity::clear_algorithm() {
  _impl_.algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::aalyria::spacetime::api::common::AuthenticationAlgorithm EspProtocol_EspIntegrity::algorithm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspProtocol.EspIntegrity.algorithm)
  return _internal_algorithm();
}
inline void EspProtocol_EspIntegrity::set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value) {
   _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.EspProtocol.EspIntegrity.algorithm)
}
inline ::aalyria::spacetime::api::common::AuthenticationAlgorithm EspProtocol_EspIntegrity::_internal_algorithm() const {
  return static_cast<::aalyria::spacetime::api::common::AuthenticationAlgorithm>(_impl_.algorithm_);
}
inline void EspProtocol_EspIntegrity::_internal_set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value) {
  assert(::aalyria::spacetime::api::common::AuthenticationAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.algorithm_ = value;
}

// -------------------------------------------------------------------

// EspProtocol_EspPrivacy

// optional .aalyria.spacetime.api.common.EncryptionAlgorithm algorithm = 1 [json_name = "algorithm"];
inline bool EspProtocol_EspPrivacy::has_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EspProtocol_EspPrivacy::clear_algorithm() {
  _impl_.algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::aalyria::spacetime::api::common::EncryptionAlgorithm EspProtocol_EspPrivacy::algorithm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspProtocol.EspPrivacy.algorithm)
  return _internal_algorithm();
}
inline void EspProtocol_EspPrivacy::set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value) {
   _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.EspProtocol.EspPrivacy.algorithm)
}
inline ::aalyria::spacetime::api::common::EncryptionAlgorithm EspProtocol_EspPrivacy::_internal_algorithm() const {
  return static_cast<::aalyria::spacetime::api::common::EncryptionAlgorithm>(_impl_.algorithm_);
}
inline void EspProtocol_EspPrivacy::_internal_set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value) {
  assert(::aalyria::spacetime::api::common::EncryptionAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.algorithm_ = value;
}

// -------------------------------------------------------------------

// EspProtocol

// optional .aalyria.spacetime.api.common.EspProtocol.EspIntegrity authentication = 1 [json_name = "authentication"];
inline bool EspProtocol::has_authentication() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authentication_ != nullptr);
  return value;
}
inline void EspProtocol::clear_authentication() {
  if (_impl_.authentication_ != nullptr) _impl_.authentication_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity& EspProtocol::_internal_authentication() const {
  const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* p = _impl_.authentication_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity&>(
      ::aalyria::spacetime::api::common::_EspProtocol_EspIntegrity_default_instance_);
}
inline const ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity& EspProtocol::authentication() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspProtocol.authentication)
  return _internal_authentication();
}
inline void EspProtocol::unsafe_arena_set_allocated_authentication(
    ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* authentication) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authentication_);
  }
  _impl_.authentication_ = authentication;
  if (authentication) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspProtocol.authentication)
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* EspProtocol::release_authentication() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* temp = _impl_.authentication_;
  _impl_.authentication_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* EspProtocol::unsafe_arena_release_authentication() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspProtocol.authentication)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* temp = _impl_.authentication_;
  _impl_.authentication_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* EspProtocol::_internal_mutable_authentication() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.authentication_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::EspProtocol_EspIntegrity>(GetArenaForAllocation());
    _impl_.authentication_ = p;
  }
  return _impl_.authentication_;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* EspProtocol::mutable_authentication() {
  ::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* _msg = _internal_mutable_authentication();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspProtocol.authentication)
  return _msg;
}
inline void EspProtocol::set_allocated_authentication(::aalyria::spacetime::api::common::EspProtocol_EspIntegrity* authentication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authentication_;
  }
  if (authentication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authentication);
    if (message_arena != submessage_arena) {
      authentication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.authentication_ = authentication;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspProtocol.authentication)
}

// optional .aalyria.spacetime.api.common.EspProtocol.EspPrivacy encryption = 2 [json_name = "encryption"];
inline bool EspProtocol::has_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encryption_ != nullptr);
  return value;
}
inline void EspProtocol::clear_encryption() {
  if (_impl_.encryption_ != nullptr) _impl_.encryption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy& EspProtocol::_internal_encryption() const {
  const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* p = _impl_.encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy&>(
      ::aalyria::spacetime::api::common::_EspProtocol_EspPrivacy_default_instance_);
}
inline const ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy& EspProtocol::encryption() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspProtocol.encryption)
  return _internal_encryption();
}
inline void EspProtocol::unsafe_arena_set_allocated_encryption(
    ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_);
  }
  _impl_.encryption_ = encryption;
  if (encryption) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspProtocol.encryption)
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* EspProtocol::release_encryption() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* temp = _impl_.encryption_;
  _impl_.encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* EspProtocol::unsafe_arena_release_encryption() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspProtocol.encryption)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* temp = _impl_.encryption_;
  _impl_.encryption_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* EspProtocol::_internal_mutable_encryption() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::EspProtocol_EspPrivacy>(GetArenaForAllocation());
    _impl_.encryption_ = p;
  }
  return _impl_.encryption_;
}
inline ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* EspProtocol::mutable_encryption() {
  ::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* _msg = _internal_mutable_encryption();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspProtocol.encryption)
  return _msg;
}
inline void EspProtocol::set_allocated_encryption(::aalyria::spacetime::api::common::EspProtocol_EspPrivacy* encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryption_;
  }
  if (encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryption);
    if (message_arena != submessage_arena) {
      encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspProtocol.encryption)
}

// -------------------------------------------------------------------

// EspParameters_EspAuth

// optional .aalyria.spacetime.api.common.AuthenticationAlgorithm algorithm = 1 [json_name = "algorithm"];
inline bool EspParameters_EspAuth::has_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EspParameters_EspAuth::clear_algorithm() {
  _impl_.algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::AuthenticationAlgorithm EspParameters_EspAuth::algorithm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.EspAuth.algorithm)
  return _internal_algorithm();
}
inline void EspParameters_EspAuth::set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value) {
   _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.EspParameters.EspAuth.algorithm)
}
inline ::aalyria::spacetime::api::common::AuthenticationAlgorithm EspParameters_EspAuth::_internal_algorithm() const {
  return static_cast<::aalyria::spacetime::api::common::AuthenticationAlgorithm>(_impl_.algorithm_);
}
inline void EspParameters_EspAuth::_internal_set_algorithm(::aalyria::spacetime::api::common::AuthenticationAlgorithm value) {
  assert(::aalyria::spacetime::api::common::AuthenticationAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.algorithm_ = value;
}

// optional .aalyria.spacetime.api.common.WrappedKey key = 2 [json_name = "key"];
inline bool EspParameters_EspAuth::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void EspParameters_EspAuth::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::WrappedKey& EspParameters_EspAuth::_internal_key() const {
  const ::aalyria::spacetime::api::common::WrappedKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::WrappedKey&>(
      ::aalyria::spacetime::api::common::_WrappedKey_default_instance_);
}
inline const ::aalyria::spacetime::api::common::WrappedKey& EspParameters_EspAuth::key() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.EspAuth.key)
  return _internal_key();
}
inline void EspParameters_EspAuth::unsafe_arena_set_allocated_key(
    ::aalyria::spacetime::api::common::WrappedKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspParameters.EspAuth.key)
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspAuth::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WrappedKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspAuth::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspParameters.EspAuth.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WrappedKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspAuth::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::WrappedKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspAuth::mutable_key() {
  ::aalyria::spacetime::api::common::WrappedKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspParameters.EspAuth.key)
  return _msg;
}
inline void EspParameters_EspAuth::set_allocated_key(::aalyria::spacetime::api::common::WrappedKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspParameters.EspAuth.key)
}

// -------------------------------------------------------------------

// EspParameters_EspEncrypt

// optional .aalyria.spacetime.api.common.EncryptionAlgorithm algorithm = 1 [json_name = "algorithm"];
inline bool EspParameters_EspEncrypt::has_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EspParameters_EspEncrypt::clear_algorithm() {
  _impl_.algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::common::EncryptionAlgorithm EspParameters_EspEncrypt::algorithm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.EspEncrypt.algorithm)
  return _internal_algorithm();
}
inline void EspParameters_EspEncrypt::set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value) {
   _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.EspParameters.EspEncrypt.algorithm)
}
inline ::aalyria::spacetime::api::common::EncryptionAlgorithm EspParameters_EspEncrypt::_internal_algorithm() const {
  return static_cast<::aalyria::spacetime::api::common::EncryptionAlgorithm>(_impl_.algorithm_);
}
inline void EspParameters_EspEncrypt::_internal_set_algorithm(::aalyria::spacetime::api::common::EncryptionAlgorithm value) {
  assert(::aalyria::spacetime::api::common::EncryptionAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.algorithm_ = value;
}

// optional .aalyria.spacetime.api.common.WrappedKey key = 2 [json_name = "key"];
inline bool EspParameters_EspEncrypt::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void EspParameters_EspEncrypt::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::WrappedKey& EspParameters_EspEncrypt::_internal_key() const {
  const ::aalyria::spacetime::api::common::WrappedKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::WrappedKey&>(
      ::aalyria::spacetime::api::common::_WrappedKey_default_instance_);
}
inline const ::aalyria::spacetime::api::common::WrappedKey& EspParameters_EspEncrypt::key() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.EspEncrypt.key)
  return _internal_key();
}
inline void EspParameters_EspEncrypt::unsafe_arena_set_allocated_key(
    ::aalyria::spacetime::api::common::WrappedKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspParameters.EspEncrypt.key)
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspEncrypt::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WrappedKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspEncrypt::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspParameters.EspEncrypt.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WrappedKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspEncrypt::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::WrappedKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::aalyria::spacetime::api::common::WrappedKey* EspParameters_EspEncrypt::mutable_key() {
  ::aalyria::spacetime::api::common::WrappedKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspParameters.EspEncrypt.key)
  return _msg;
}
inline void EspParameters_EspEncrypt::set_allocated_key(::aalyria::spacetime::api::common::WrappedKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspParameters.EspEncrypt.key)
}

// -------------------------------------------------------------------

// EspParameters

// optional uint32 security_parameters_index = 3 [json_name = "securityParametersIndex"];
inline bool EspParameters::has_security_parameters_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EspParameters::clear_security_parameters_index() {
  _impl_.security_parameters_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t EspParameters::security_parameters_index() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.security_parameters_index)
  return _internal_security_parameters_index();
}
inline void EspParameters::set_security_parameters_index(::uint32_t value) {
  _internal_set_security_parameters_index(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.EspParameters.security_parameters_index)
}
inline ::uint32_t EspParameters::_internal_security_parameters_index() const {
  return _impl_.security_parameters_index_;
}
inline void EspParameters::_internal_set_security_parameters_index(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.security_parameters_index_ = value;
}

// optional .aalyria.spacetime.api.common.EspParameters.EspAuth authentication = 1 [json_name = "authentication"];
inline bool EspParameters::has_authentication() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authentication_ != nullptr);
  return value;
}
inline void EspParameters::clear_authentication() {
  if (_impl_.authentication_ != nullptr) _impl_.authentication_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::EspParameters_EspAuth& EspParameters::_internal_authentication() const {
  const ::aalyria::spacetime::api::common::EspParameters_EspAuth* p = _impl_.authentication_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::EspParameters_EspAuth&>(
      ::aalyria::spacetime::api::common::_EspParameters_EspAuth_default_instance_);
}
inline const ::aalyria::spacetime::api::common::EspParameters_EspAuth& EspParameters::authentication() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.authentication)
  return _internal_authentication();
}
inline void EspParameters::unsafe_arena_set_allocated_authentication(
    ::aalyria::spacetime::api::common::EspParameters_EspAuth* authentication) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authentication_);
  }
  _impl_.authentication_ = authentication;
  if (authentication) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspParameters.authentication)
}
inline ::aalyria::spacetime::api::common::EspParameters_EspAuth* EspParameters::release_authentication() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* temp = _impl_.authentication_;
  _impl_.authentication_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspAuth* EspParameters::unsafe_arena_release_authentication() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspParameters.authentication)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* temp = _impl_.authentication_;
  _impl_.authentication_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspAuth* EspParameters::_internal_mutable_authentication() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.authentication_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::EspParameters_EspAuth>(GetArenaForAllocation());
    _impl_.authentication_ = p;
  }
  return _impl_.authentication_;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspAuth* EspParameters::mutable_authentication() {
  ::aalyria::spacetime::api::common::EspParameters_EspAuth* _msg = _internal_mutable_authentication();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspParameters.authentication)
  return _msg;
}
inline void EspParameters::set_allocated_authentication(::aalyria::spacetime::api::common::EspParameters_EspAuth* authentication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authentication_;
  }
  if (authentication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authentication);
    if (message_arena != submessage_arena) {
      authentication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.authentication_ = authentication;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspParameters.authentication)
}

// optional .aalyria.spacetime.api.common.EspParameters.EspEncrypt encryption = 2 [json_name = "encryption"];
inline bool EspParameters::has_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.encryption_ != nullptr);
  return value;
}
inline void EspParameters::clear_encryption() {
  if (_impl_.encryption_ != nullptr) _impl_.encryption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt& EspParameters::_internal_encryption() const {
  const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* p = _impl_.encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt&>(
      ::aalyria::spacetime::api::common::_EspParameters_EspEncrypt_default_instance_);
}
inline const ::aalyria::spacetime::api::common::EspParameters_EspEncrypt& EspParameters::encryption() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.EspParameters.encryption)
  return _internal_encryption();
}
inline void EspParameters::unsafe_arena_set_allocated_encryption(
    ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_);
  }
  _impl_.encryption_ = encryption;
  if (encryption) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.EspParameters.encryption)
}
inline ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* EspParameters::release_encryption() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* temp = _impl_.encryption_;
  _impl_.encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* EspParameters::unsafe_arena_release_encryption() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.EspParameters.encryption)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* temp = _impl_.encryption_;
  _impl_.encryption_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* EspParameters::_internal_mutable_encryption() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::EspParameters_EspEncrypt>(GetArenaForAllocation());
    _impl_.encryption_ = p;
  }
  return _impl_.encryption_;
}
inline ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* EspParameters::mutable_encryption() {
  ::aalyria::spacetime::api::common::EspParameters_EspEncrypt* _msg = _internal_mutable_encryption();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.EspParameters.encryption)
  return _msg;
}
inline void EspParameters::set_allocated_encryption(::aalyria::spacetime::api::common::EspParameters_EspEncrypt* encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryption_;
  }
  if (encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryption);
    if (message_arena != submessage_arena) {
      encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encryption_ = encryption;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.EspParameters.encryption)
}

// -------------------------------------------------------------------

// WrappedKey

// optional string unwrapper_key_name = 1 [json_name = "unwrapperKeyName"];
inline bool WrappedKey::has_unwrapper_key_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WrappedKey::clear_unwrapper_key_name() {
  _impl_.unwrapper_key_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WrappedKey::unwrapper_key_name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.WrappedKey.unwrapper_key_name)
  return _internal_unwrapper_key_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WrappedKey::set_unwrapper_key_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unwrapper_key_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.WrappedKey.unwrapper_key_name)
}
inline std::string* WrappedKey::mutable_unwrapper_key_name() {
  std::string* _s = _internal_mutable_unwrapper_key_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.WrappedKey.unwrapper_key_name)
  return _s;
}
inline const std::string& WrappedKey::_internal_unwrapper_key_name() const {
  return _impl_.unwrapper_key_name_.Get();
}
inline void WrappedKey::_internal_set_unwrapper_key_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.unwrapper_key_name_.Set(value, GetArenaForAllocation());
}
inline std::string* WrappedKey::_internal_mutable_unwrapper_key_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.unwrapper_key_name_.Mutable( GetArenaForAllocation());
}
inline std::string* WrappedKey::release_unwrapper_key_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.WrappedKey.unwrapper_key_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.unwrapper_key_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unwrapper_key_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WrappedKey::set_allocated_unwrapper_key_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unwrapper_key_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unwrapper_key_name_.IsDefault()) {
          _impl_.unwrapper_key_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.WrappedKey.unwrapper_key_name)
}

// optional bytes wrapped_key = 2 [json_name = "wrappedKey"];
inline bool WrappedKey::has_wrapped_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WrappedKey::clear_wrapped_key() {
  _impl_.wrapped_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WrappedKey::wrapped_key() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.WrappedKey.wrapped_key)
  return _internal_wrapped_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WrappedKey::set_wrapped_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wrapped_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.WrappedKey.wrapped_key)
}
inline std::string* WrappedKey::mutable_wrapped_key() {
  std::string* _s = _internal_mutable_wrapped_key();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.WrappedKey.wrapped_key)
  return _s;
}
inline const std::string& WrappedKey::_internal_wrapped_key() const {
  return _impl_.wrapped_key_.Get();
}
inline void WrappedKey::_internal_set_wrapped_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.wrapped_key_.Set(value, GetArenaForAllocation());
}
inline std::string* WrappedKey::_internal_mutable_wrapped_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wrapped_key_.Mutable( GetArenaForAllocation());
}
inline std::string* WrappedKey::release_wrapped_key() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.WrappedKey.wrapped_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.wrapped_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wrapped_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WrappedKey::set_allocated_wrapped_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wrapped_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wrapped_key_.IsDefault()) {
          _impl_.wrapped_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.WrappedKey.wrapped_key)
}

// -------------------------------------------------------------------

// TunnelMethod

// .aalyria.spacetime.api.common.EspProtocol esp = 1 [json_name = "esp"];
inline bool TunnelMethod::has_esp() const {
  return protocol_case() == kEsp;
}
inline bool TunnelMethod::_internal_has_esp() const {
  return protocol_case() == kEsp;
}
inline void TunnelMethod::set_has_esp() {
  _impl_._oneof_case_[0] = kEsp;
}
inline void TunnelMethod::clear_esp() {
  if (protocol_case() == kEsp) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.protocol_.esp_;
    }
    clear_has_protocol();
  }
}
inline ::aalyria::spacetime::api::common::EspProtocol* TunnelMethod::release_esp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TunnelMethod.esp)
  if (protocol_case() == kEsp) {
    clear_has_protocol();
    ::aalyria::spacetime::api::common::EspProtocol* temp = _impl_.protocol_.esp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.protocol_.esp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::EspProtocol& TunnelMethod::_internal_esp() const {
  return protocol_case() == kEsp
      ? *_impl_.protocol_.esp_
      : reinterpret_cast<::aalyria::spacetime::api::common::EspProtocol&>(::aalyria::spacetime::api::common::_EspProtocol_default_instance_);
}
inline const ::aalyria::spacetime::api::common::EspProtocol& TunnelMethod::esp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TunnelMethod.esp)
  return _internal_esp();
}
inline ::aalyria::spacetime::api::common::EspProtocol* TunnelMethod::unsafe_arena_release_esp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.TunnelMethod.esp)
  if (protocol_case() == kEsp) {
    clear_has_protocol();
    ::aalyria::spacetime::api::common::EspProtocol* temp = _impl_.protocol_.esp_;
    _impl_.protocol_.esp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TunnelMethod::unsafe_arena_set_allocated_esp(::aalyria::spacetime::api::common::EspProtocol* esp) {
  clear_protocol();
  if (esp) {
    set_has_esp();
    _impl_.protocol_.esp_ = esp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TunnelMethod.esp)
}
inline ::aalyria::spacetime::api::common::EspProtocol* TunnelMethod::_internal_mutable_esp() {
  if (protocol_case() != kEsp) {
    clear_protocol();
    set_has_esp();
    _impl_.protocol_.esp_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::EspProtocol >(GetArenaForAllocation());
  }
  return _impl_.protocol_.esp_;
}
inline ::aalyria::spacetime::api::common::EspProtocol* TunnelMethod::mutable_esp() {
  ::aalyria::spacetime::api::common::EspProtocol* _msg = _internal_mutable_esp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TunnelMethod.esp)
  return _msg;
}

// .google.protobuf.Empty none = 2 [json_name = "none"];
inline bool TunnelMethod::has_none() const {
  return protocol_case() == kNone;
}
inline bool TunnelMethod::_internal_has_none() const {
  return protocol_case() == kNone;
}
inline void TunnelMethod::set_has_none() {
  _impl_._oneof_case_[0] = kNone;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TunnelMethod::release_none() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TunnelMethod.none)
  if (protocol_case() == kNone) {
    clear_has_protocol();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.protocol_.none_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.protocol_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& TunnelMethod::_internal_none() const {
  return protocol_case() == kNone
      ? *_impl_.protocol_.none_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& TunnelMethod::none() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TunnelMethod.none)
  return _internal_none();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TunnelMethod::unsafe_arena_release_none() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.TunnelMethod.none)
  if (protocol_case() == kNone) {
    clear_has_protocol();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.protocol_.none_;
    _impl_.protocol_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TunnelMethod::unsafe_arena_set_allocated_none(::PROTOBUF_NAMESPACE_ID::Empty* none) {
  clear_protocol();
  if (none) {
    set_has_none();
    _impl_.protocol_.none_ = none;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TunnelMethod.none)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TunnelMethod::_internal_mutable_none() {
  if (protocol_case() != kNone) {
    clear_protocol();
    set_has_none();
    _impl_.protocol_.none_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.protocol_.none_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TunnelMethod::mutable_none() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_none();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TunnelMethod.none)
  return _msg;
}

inline bool TunnelMethod::has_protocol() const {
  return protocol_case() != PROTOCOL_NOT_SET;
}
inline void TunnelMethod::clear_has_protocol() {
  _impl_._oneof_case_[0] = PROTOCOL_NOT_SET;
}
inline TunnelMethod::ProtocolCase TunnelMethod::protocol_case() const {
  return TunnelMethod::ProtocolCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::AuthenticationAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::AuthenticationAlgorithm>() {
  return ::aalyria::spacetime::api::common::AuthenticationAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::EncryptionAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::EncryptionAlgorithm>() {
  return ::aalyria::spacetime::api::common::EncryptionAlgorithm_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftunnel_2eproto_2epb_2eh
