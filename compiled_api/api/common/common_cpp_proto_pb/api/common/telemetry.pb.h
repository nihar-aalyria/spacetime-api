// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/telemetry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftelemetry_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftelemetry_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/coordinates.pb.h"
#include "api/common/time.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2ftelemetry_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2ftelemetry_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2ftelemetry_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class BeamStats;
struct BeamStatsDefaultTypeInternal;
extern BeamStatsDefaultTypeInternal _BeamStats_default_instance_;
class BeamStats_GimbalStats;
struct BeamStats_GimbalStatsDefaultTypeInternal;
extern BeamStats_GimbalStatsDefaultTypeInternal _BeamStats_GimbalStats_default_instance_;
class BeamStats_TargetingStats;
struct BeamStats_TargetingStatsDefaultTypeInternal;
extern BeamStats_TargetingStatsDefaultTypeInternal _BeamStats_TargetingStats_default_instance_;
class FlowStats;
struct FlowStatsDefaultTypeInternal;
extern FlowStatsDefaultTypeInternal _FlowStats_default_instance_;
class InterfaceEvent;
struct InterfaceEventDefaultTypeInternal;
extern InterfaceEventDefaultTypeInternal _InterfaceEvent_default_instance_;
class InterfaceStats;
struct InterfaceStatsDefaultTypeInternal;
extern InterfaceStatsDefaultTypeInternal _InterfaceStats_default_instance_;
class NetworkEventReport;
struct NetworkEventReportDefaultTypeInternal;
extern NetworkEventReportDefaultTypeInternal _NetworkEventReport_default_instance_;
class NetworkStatsReport;
struct NetworkStatsReportDefaultTypeInternal;
extern NetworkStatsReportDefaultTypeInternal _NetworkStatsReport_default_instance_;
class NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse;
struct NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal;
extern NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse_default_instance_;
class NetworkStatsReport_FlowStatsByIdEntry_DoNotUse;
struct NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal;
extern NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_FlowStatsByIdEntry_DoNotUse_default_instance_;
class NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse;
struct NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal;
extern NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse_default_instance_;
class NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse;
struct NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal;
extern NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse_default_instance_;
class PortEvent;
struct PortEventDefaultTypeInternal;
extern PortEventDefaultTypeInternal _PortEvent_default_instance_;
class RadioEvent;
struct RadioEventDefaultTypeInternal;
extern RadioEventDefaultTypeInternal _RadioEvent_default_instance_;
class RadioStats;
struct RadioStatsDefaultTypeInternal;
extern RadioStatsDefaultTypeInternal _RadioStats_default_instance_;
class ReceiverStats;
struct ReceiverStatsDefaultTypeInternal;
extern ReceiverStatsDefaultTypeInternal _ReceiverStats_default_instance_;
class TransmitterStats;
struct TransmitterStatsDefaultTypeInternal;
extern TransmitterStatsDefaultTypeInternal _TransmitterStats_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::BeamStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStats>(Arena*);
template <>
::aalyria::spacetime::api::common::BeamStats_GimbalStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStats_GimbalStats>(Arena*);
template <>
::aalyria::spacetime::api::common::BeamStats_TargetingStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStats_TargetingStats>(Arena*);
template <>
::aalyria::spacetime::api::common::FlowStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowStats>(Arena*);
template <>
::aalyria::spacetime::api::common::InterfaceEvent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::InterfaceEvent>(Arena*);
template <>
::aalyria::spacetime::api::common::InterfaceStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::InterfaceStats>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkEventReport* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkEventReport>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkStatsReport* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkStatsReport>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::PortEvent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PortEvent>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioEvent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioEvent>(Arena*);
template <>
::aalyria::spacetime::api::common::RadioStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::RadioStats>(Arena*);
template <>
::aalyria::spacetime::api::common::ReceiverStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverStats>(Arena*);
template <>
::aalyria::spacetime::api::common::TransmitterStats* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TransmitterStats>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum BeamStats_TargetingStats_ConnectionStatus : int {
  BeamStats_TargetingStats_ConnectionStatus_UNKNOWN = 0,
  BeamStats_TargetingStats_ConnectionStatus_SEEKING = 1,
  BeamStats_TargetingStats_ConnectionStatus_LOCKED = 2,
};

bool BeamStats_TargetingStats_ConnectionStatus_IsValid(int value);
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_MIN = static_cast<BeamStats_TargetingStats_ConnectionStatus>(0);
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_MAX = static_cast<BeamStats_TargetingStats_ConnectionStatus>(2);
constexpr int BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
BeamStats_TargetingStats_ConnectionStatus_descriptor();
template <typename T>
const std::string& BeamStats_TargetingStats_ConnectionStatus_Name(T value) {
  static_assert(std::is_same<T, BeamStats_TargetingStats_ConnectionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConnectionStatus_Name().");
  return BeamStats_TargetingStats_ConnectionStatus_Name(static_cast<BeamStats_TargetingStats_ConnectionStatus>(value));
}
template <>
inline const std::string& BeamStats_TargetingStats_ConnectionStatus_Name(BeamStats_TargetingStats_ConnectionStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<BeamStats_TargetingStats_ConnectionStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool BeamStats_TargetingStats_ConnectionStatus_Parse(absl::string_view name, BeamStats_TargetingStats_ConnectionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BeamStats_TargetingStats_ConnectionStatus>(
      BeamStats_TargetingStats_ConnectionStatus_descriptor(), name, value);
}
enum RadioEvent_LinkStatus : int {
  RadioEvent_LinkStatus_UNKNOWN = 0,
  RadioEvent_LinkStatus_DOWN = 1,
  RadioEvent_LinkStatus_UP = 2,
};

bool RadioEvent_LinkStatus_IsValid(int value);
constexpr RadioEvent_LinkStatus RadioEvent_LinkStatus_LinkStatus_MIN = static_cast<RadioEvent_LinkStatus>(0);
constexpr RadioEvent_LinkStatus RadioEvent_LinkStatus_LinkStatus_MAX = static_cast<RadioEvent_LinkStatus>(2);
constexpr int RadioEvent_LinkStatus_LinkStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RadioEvent_LinkStatus_descriptor();
template <typename T>
const std::string& RadioEvent_LinkStatus_Name(T value) {
  static_assert(std::is_same<T, RadioEvent_LinkStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LinkStatus_Name().");
  return RadioEvent_LinkStatus_Name(static_cast<RadioEvent_LinkStatus>(value));
}
template <>
inline const std::string& RadioEvent_LinkStatus_Name(RadioEvent_LinkStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RadioEvent_LinkStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RadioEvent_LinkStatus_Parse(absl::string_view name, RadioEvent_LinkStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadioEvent_LinkStatus>(
      RadioEvent_LinkStatus_descriptor(), name, value);
}
enum PortEvent_PortStatus : int {
  PortEvent_PortStatus_UNKNOWN = 0,
  PortEvent_PortStatus_DOWN = 1,
  PortEvent_PortStatus_UP = 2,
};

bool PortEvent_PortStatus_IsValid(int value);
constexpr PortEvent_PortStatus PortEvent_PortStatus_PortStatus_MIN = static_cast<PortEvent_PortStatus>(0);
constexpr PortEvent_PortStatus PortEvent_PortStatus_PortStatus_MAX = static_cast<PortEvent_PortStatus>(2);
constexpr int PortEvent_PortStatus_PortStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PortEvent_PortStatus_descriptor();
template <typename T>
const std::string& PortEvent_PortStatus_Name(T value) {
  static_assert(std::is_same<T, PortEvent_PortStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PortStatus_Name().");
  return PortEvent_PortStatus_Name(static_cast<PortEvent_PortStatus>(value));
}
template <>
inline const std::string& PortEvent_PortStatus_Name(PortEvent_PortStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PortEvent_PortStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PortEvent_PortStatus_Parse(absl::string_view name, PortEvent_PortStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortEvent_PortStatus>(
      PortEvent_PortStatus_descriptor(), name, value);
}
enum InterfaceEvent_InterfaceStatus : int {
  InterfaceEvent_InterfaceStatus_UNKNOWN = 0,
  InterfaceEvent_InterfaceStatus_DISABLED = 1,
  InterfaceEvent_InterfaceStatus_ENABLED = 2,
};

bool InterfaceEvent_InterfaceStatus_IsValid(int value);
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent_InterfaceStatus_InterfaceStatus_MIN = static_cast<InterfaceEvent_InterfaceStatus>(0);
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent_InterfaceStatus_InterfaceStatus_MAX = static_cast<InterfaceEvent_InterfaceStatus>(2);
constexpr int InterfaceEvent_InterfaceStatus_InterfaceStatus_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
InterfaceEvent_InterfaceStatus_descriptor();
template <typename T>
const std::string& InterfaceEvent_InterfaceStatus_Name(T value) {
  static_assert(std::is_same<T, InterfaceEvent_InterfaceStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InterfaceStatus_Name().");
  return InterfaceEvent_InterfaceStatus_Name(static_cast<InterfaceEvent_InterfaceStatus>(value));
}
template <>
inline const std::string& InterfaceEvent_InterfaceStatus_Name(InterfaceEvent_InterfaceStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<InterfaceEvent_InterfaceStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool InterfaceEvent_InterfaceStatus_Parse(absl::string_view name, InterfaceEvent_InterfaceStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InterfaceEvent_InterfaceStatus>(
      InterfaceEvent_InterfaceStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::RadioStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::RadioStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse& other);
  static const NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse*>(&_NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.NetworkStatsReport.RadioStatsByInterfaceIdEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::InterfaceStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::InterfaceStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse& other);
  static const NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse*>(&_NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.NetworkStatsReport.InterfaceStatsByIdEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::BeamStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::BeamStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse& other);
  static const NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse*>(&_NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.NetworkStatsReport.BeamStatsByAntennaIdEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class NetworkStatsReport_FlowStatsByIdEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::FlowStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::FlowStats,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NetworkStatsReport_FlowStatsByIdEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStatsReport_FlowStatsByIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NetworkStatsReport_FlowStatsByIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NetworkStatsReport_FlowStatsByIdEntry_DoNotUse& other);
  static const NetworkStatsReport_FlowStatsByIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NetworkStatsReport_FlowStatsByIdEntry_DoNotUse*>(&_NetworkStatsReport_FlowStatsByIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.NetworkStatsReport.FlowStatsByIdEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};
// -------------------------------------------------------------------

class NetworkStatsReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.NetworkStatsReport) */ {
 public:
  inline NetworkStatsReport() : NetworkStatsReport(nullptr) {}
  ~NetworkStatsReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkStatsReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkStatsReport(const NetworkStatsReport& from);
  NetworkStatsReport(NetworkStatsReport&& from) noexcept
    : NetworkStatsReport() {
    *this = ::std::move(from);
  }

  inline NetworkStatsReport& operator=(const NetworkStatsReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkStatsReport& operator=(NetworkStatsReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkStatsReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkStatsReport* internal_default_instance() {
    return reinterpret_cast<const NetworkStatsReport*>(
               &_NetworkStatsReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetworkStatsReport& a, NetworkStatsReport& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkStatsReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkStatsReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkStatsReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkStatsReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkStatsReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkStatsReport& from) {
    NetworkStatsReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkStatsReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.NetworkStatsReport";
  }
  protected:
  explicit NetworkStatsReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceStatsByIdFieldNumber = 3,
    kRadioStatsByInterfaceIdFieldNumber = 4,
    kBeamStatsByAntennaIdFieldNumber = 5,
    kFlowStatsByIdFieldNumber = 6,
    kNodeIdFieldNumber = 7,
    kTimestampFieldNumber = 1,
  };
  // map<string, .aalyria.spacetime.api.common.InterfaceStats> interface_stats_by_id = 3 [json_name = "interfaceStatsById"];
  int interface_stats_by_id_size() const;
  private:
  int _internal_interface_stats_by_id_size() const;

  public:
  void clear_interface_stats_by_id() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >&
      _internal_interface_stats_by_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >*
      _internal_mutable_interface_stats_by_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >&
      interface_stats_by_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >*
      mutable_interface_stats_by_id();
  // map<string, .aalyria.spacetime.api.common.RadioStats> radio_stats_by_interface_id = 4 [json_name = "radioStatsByInterfaceId"];
  int radio_stats_by_interface_id_size() const;
  private:
  int _internal_radio_stats_by_interface_id_size() const;

  public:
  void clear_radio_stats_by_interface_id() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >&
      _internal_radio_stats_by_interface_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >*
      _internal_mutable_radio_stats_by_interface_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >&
      radio_stats_by_interface_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >*
      mutable_radio_stats_by_interface_id();
  // map<string, .aalyria.spacetime.api.common.BeamStats> beam_stats_by_antenna_id = 5 [json_name = "beamStatsByAntennaId"];
  int beam_stats_by_antenna_id_size() const;
  private:
  int _internal_beam_stats_by_antenna_id_size() const;

  public:
  void clear_beam_stats_by_antenna_id() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >&
      _internal_beam_stats_by_antenna_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >*
      _internal_mutable_beam_stats_by_antenna_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >&
      beam_stats_by_antenna_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >*
      mutable_beam_stats_by_antenna_id();
  // map<string, .aalyria.spacetime.api.common.FlowStats> flow_stats_by_id = 6 [json_name = "flowStatsById"];
  int flow_stats_by_id_size() const;
  private:
  int _internal_flow_stats_by_id_size() const;

  public:
  void clear_flow_stats_by_id() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >&
      _internal_flow_stats_by_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >*
      _internal_mutable_flow_stats_by_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >&
      flow_stats_by_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >*
      mutable_flow_stats_by_id();
  // optional string node_id = 7 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.NetworkStatsReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::InterfaceStats,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> interface_stats_by_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::RadioStats,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> radio_stats_by_interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::BeamStats,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> beam_stats_by_antenna_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NetworkStatsReport_FlowStatsByIdEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::FlowStats,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> flow_stats_by_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class BeamStats_TargetingStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamStats.TargetingStats) */ {
 public:
  inline BeamStats_TargetingStats() : BeamStats_TargetingStats(nullptr) {}
  ~BeamStats_TargetingStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamStats_TargetingStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamStats_TargetingStats(const BeamStats_TargetingStats& from);
  BeamStats_TargetingStats(BeamStats_TargetingStats&& from) noexcept
    : BeamStats_TargetingStats() {
    *this = ::std::move(from);
  }

  inline BeamStats_TargetingStats& operator=(const BeamStats_TargetingStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamStats_TargetingStats& operator=(BeamStats_TargetingStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamStats_TargetingStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeamStats_TargetingStats* internal_default_instance() {
    return reinterpret_cast<const BeamStats_TargetingStats*>(
               &_BeamStats_TargetingStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BeamStats_TargetingStats& a, BeamStats_TargetingStats& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamStats_TargetingStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamStats_TargetingStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamStats_TargetingStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamStats_TargetingStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamStats_TargetingStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamStats_TargetingStats& from) {
    BeamStats_TargetingStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamStats_TargetingStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamStats.TargetingStats";
  }
  protected:
  explicit BeamStats_TargetingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ConnectionStatus = BeamStats_TargetingStats_ConnectionStatus;
  static constexpr ConnectionStatus UNKNOWN = BeamStats_TargetingStats_ConnectionStatus_UNKNOWN;
  static constexpr ConnectionStatus SEEKING = BeamStats_TargetingStats_ConnectionStatus_SEEKING;
  static constexpr ConnectionStatus LOCKED = BeamStats_TargetingStats_ConnectionStatus_LOCKED;
  static inline bool ConnectionStatus_IsValid(int value) {
    return BeamStats_TargetingStats_ConnectionStatus_IsValid(value);
  }
  static constexpr ConnectionStatus ConnectionStatus_MIN = BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_MIN;
  static constexpr ConnectionStatus ConnectionStatus_MAX = BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_MAX;
  static constexpr int ConnectionStatus_ARRAYSIZE = BeamStats_TargetingStats_ConnectionStatus_ConnectionStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionStatus_descriptor() {
    return BeamStats_TargetingStats_ConnectionStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& ConnectionStatus_Name(T value) {
    return BeamStats_TargetingStats_ConnectionStatus_Name(value);
  }
  static inline bool ConnectionStatus_Parse(absl::string_view name, ConnectionStatus* value) {
    return BeamStats_TargetingStats_ConnectionStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBeamTaskIdFieldNumber = 3,
    kTargetIdentifierFieldNumber = 4,
    kTargetLocationFieldNumber = 1,
    kConnectionStatusFieldNumber = 2,
  };
  // optional string beam_task_id = 3 [json_name = "beamTaskId"];
  bool has_beam_task_id() const;
  void clear_beam_task_id() ;
  const std::string& beam_task_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_beam_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_beam_task_id();
  PROTOBUF_NODISCARD std::string* release_beam_task_id();
  void set_allocated_beam_task_id(std::string* ptr);

  private:
  const std::string& _internal_beam_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beam_task_id(
      const std::string& value);
  std::string* _internal_mutable_beam_task_id();

  public:
  // optional string target_identifier = 4 [json_name = "targetIdentifier"];
  bool has_target_identifier() const;
  void clear_target_identifier() ;
  const std::string& target_identifier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_identifier(Arg_&& arg, Args_... args);
  std::string* mutable_target_identifier();
  PROTOBUF_NODISCARD std::string* release_target_identifier();
  void set_allocated_target_identifier(std::string* ptr);

  private:
  const std::string& _internal_target_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_identifier(
      const std::string& value);
  std::string* _internal_mutable_target_identifier();

  public:
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 target_location = 1 [json_name = "targetLocation"];
  bool has_target_location() const;
  void clear_target_location() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84& target_location() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84* release_target_location();
  ::aalyria::spacetime::api::common::GeodeticWgs84* mutable_target_location();
  void set_allocated_target_location(::aalyria::spacetime::api::common::GeodeticWgs84* target_location);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84& _internal_target_location() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84* _internal_mutable_target_location();
  public:
  void unsafe_arena_set_allocated_target_location(
      ::aalyria::spacetime::api::common::GeodeticWgs84* target_location);
  ::aalyria::spacetime::api::common::GeodeticWgs84* unsafe_arena_release_target_location();
  // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus connection_status = 2 [json_name = "connectionStatus"];
  bool has_connection_status() const;
  void clear_connection_status() ;
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus connection_status() const;
  void set_connection_status(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus value);

  private:
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus _internal_connection_status() const;
  void _internal_set_connection_status(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamStats.TargetingStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beam_task_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_identifier_;
    ::aalyria::spacetime::api::common::GeodeticWgs84* target_location_;
    int connection_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class BeamStats_GimbalStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamStats.GimbalStats) */ {
 public:
  inline BeamStats_GimbalStats() : BeamStats_GimbalStats(nullptr) {}
  ~BeamStats_GimbalStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamStats_GimbalStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamStats_GimbalStats(const BeamStats_GimbalStats& from);
  BeamStats_GimbalStats(BeamStats_GimbalStats&& from) noexcept
    : BeamStats_GimbalStats() {
    *this = ::std::move(from);
  }

  inline BeamStats_GimbalStats& operator=(const BeamStats_GimbalStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamStats_GimbalStats& operator=(BeamStats_GimbalStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamStats_GimbalStats& default_instance() {
    return *internal_default_instance();
  }
  enum SiteOrientationCase {
    kOrientationQuaternion = 2,
    kOrientationYpr = 3,
    SITE_ORIENTATION_NOT_SET = 0,
  };

  static inline const BeamStats_GimbalStats* internal_default_instance() {
    return reinterpret_cast<const BeamStats_GimbalStats*>(
               &_BeamStats_GimbalStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BeamStats_GimbalStats& a, BeamStats_GimbalStats& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamStats_GimbalStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamStats_GimbalStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamStats_GimbalStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamStats_GimbalStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamStats_GimbalStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamStats_GimbalStats& from) {
    BeamStats_GimbalStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamStats_GimbalStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamStats.GimbalStats";
  }
  protected:
  explicit BeamStats_GimbalStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kPointingVectorFieldNumber = 4,
    kInitializedFieldNumber = 5,
    kOrientationQuaternionFieldNumber = 2,
    kOrientationYprFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 1 [json_name = "location"];
  bool has_location() const;
  void clear_location() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84& location() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84* release_location();
  ::aalyria::spacetime::api::common::GeodeticWgs84* mutable_location();
  void set_allocated_location(::aalyria::spacetime::api::common::GeodeticWgs84* location);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84& _internal_location() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::aalyria::spacetime::api::common::GeodeticWgs84* location);
  ::aalyria::spacetime::api::common::GeodeticWgs84* unsafe_arena_release_location();
  // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 4 [json_name = "pointingVector"];
  bool has_pointing_vector() const;
  void clear_pointing_vector() ;
  const ::aalyria::spacetime::api::common::PointingVector& pointing_vector() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PointingVector* release_pointing_vector();
  ::aalyria::spacetime::api::common::PointingVector* mutable_pointing_vector();
  void set_allocated_pointing_vector(::aalyria::spacetime::api::common::PointingVector* pointing_vector);
  private:
  const ::aalyria::spacetime::api::common::PointingVector& _internal_pointing_vector() const;
  ::aalyria::spacetime::api::common::PointingVector* _internal_mutable_pointing_vector();
  public:
  void unsafe_arena_set_allocated_pointing_vector(
      ::aalyria::spacetime::api::common::PointingVector* pointing_vector);
  ::aalyria::spacetime::api::common::PointingVector* unsafe_arena_release_pointing_vector();
  // optional bool initialized = 5 [json_name = "initialized"];
  bool has_initialized() const;
  void clear_initialized() ;
  bool initialized() const;
  void set_initialized(bool value);

  private:
  bool _internal_initialized() const;
  void _internal_set_initialized(bool value);

  public:
  // .aalyria.spacetime.api.common.Quaternion orientation_quaternion = 2 [json_name = "orientationQuaternion"];
  bool has_orientation_quaternion() const;
  private:
  bool _internal_has_orientation_quaternion() const;

  public:
  void clear_orientation_quaternion() ;
  const ::aalyria::spacetime::api::common::Quaternion& orientation_quaternion() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Quaternion* release_orientation_quaternion();
  ::aalyria::spacetime::api::common::Quaternion* mutable_orientation_quaternion();
  void set_allocated_orientation_quaternion(::aalyria::spacetime::api::common::Quaternion* orientation_quaternion);
  private:
  const ::aalyria::spacetime::api::common::Quaternion& _internal_orientation_quaternion() const;
  ::aalyria::spacetime::api::common::Quaternion* _internal_mutable_orientation_quaternion();
  public:
  void unsafe_arena_set_allocated_orientation_quaternion(
      ::aalyria::spacetime::api::common::Quaternion* orientation_quaternion);
  ::aalyria::spacetime::api::common::Quaternion* unsafe_arena_release_orientation_quaternion();
  // .aalyria.spacetime.api.common.YawPitchRoll orientation_ypr = 3 [json_name = "orientationYpr"];
  bool has_orientation_ypr() const;
  private:
  bool _internal_has_orientation_ypr() const;

  public:
  void clear_orientation_ypr() ;
  const ::aalyria::spacetime::api::common::YawPitchRoll& orientation_ypr() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::YawPitchRoll* release_orientation_ypr();
  ::aalyria::spacetime::api::common::YawPitchRoll* mutable_orientation_ypr();
  void set_allocated_orientation_ypr(::aalyria::spacetime::api::common::YawPitchRoll* orientation_ypr);
  private:
  const ::aalyria::spacetime::api::common::YawPitchRoll& _internal_orientation_ypr() const;
  ::aalyria::spacetime::api::common::YawPitchRoll* _internal_mutable_orientation_ypr();
  public:
  void unsafe_arena_set_allocated_orientation_ypr(
      ::aalyria::spacetime::api::common::YawPitchRoll* orientation_ypr);
  ::aalyria::spacetime::api::common::YawPitchRoll* unsafe_arena_release_orientation_ypr();
  void clear_site_orientation();
  SiteOrientationCase site_orientation_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamStats.GimbalStats)
 private:
  class _Internal;
  void set_has_orientation_quaternion();
  void set_has_orientation_ypr();

  inline bool has_site_orientation() const;
  inline void clear_has_site_orientation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::GeodeticWgs84* location_;
    ::aalyria::spacetime::api::common::PointingVector* pointing_vector_;
    bool initialized_;
    union SiteOrientationUnion {
      constexpr SiteOrientationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::Quaternion* orientation_quaternion_;
      ::aalyria::spacetime::api::common::YawPitchRoll* orientation_ypr_;
    } site_orientation_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class BeamStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.BeamStats) */ {
 public:
  inline BeamStats() : BeamStats(nullptr) {}
  ~BeamStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamStats(const BeamStats& from);
  BeamStats(BeamStats&& from) noexcept
    : BeamStats() {
    *this = ::std::move(from);
  }

  inline BeamStats& operator=(const BeamStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamStats& operator=(BeamStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeamStats* internal_default_instance() {
    return reinterpret_cast<const BeamStats*>(
               &_BeamStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BeamStats& a, BeamStats& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamStats& from) {
    BeamStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.BeamStats";
  }
  protected:
  explicit BeamStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BeamStats_TargetingStats TargetingStats;
  typedef BeamStats_GimbalStats GimbalStats;

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kTargetingFieldNumber = 2,
    kGimbalFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats targeting = 2 [json_name = "targeting"];
  bool has_targeting() const;
  void clear_targeting() ;
  const ::aalyria::spacetime::api::common::BeamStats_TargetingStats& targeting() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::BeamStats_TargetingStats* release_targeting();
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* mutable_targeting();
  void set_allocated_targeting(::aalyria::spacetime::api::common::BeamStats_TargetingStats* targeting);
  private:
  const ::aalyria::spacetime::api::common::BeamStats_TargetingStats& _internal_targeting() const;
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* _internal_mutable_targeting();
  public:
  void unsafe_arena_set_allocated_targeting(
      ::aalyria::spacetime::api::common::BeamStats_TargetingStats* targeting);
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* unsafe_arena_release_targeting();
  // optional .aalyria.spacetime.api.common.BeamStats.GimbalStats gimbal = 3 [json_name = "gimbal"];
  bool has_gimbal() const;
  void clear_gimbal() ;
  const ::aalyria::spacetime::api::common::BeamStats_GimbalStats& gimbal() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::BeamStats_GimbalStats* release_gimbal();
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* mutable_gimbal();
  void set_allocated_gimbal(::aalyria::spacetime::api::common::BeamStats_GimbalStats* gimbal);
  private:
  const ::aalyria::spacetime::api::common::BeamStats_GimbalStats& _internal_gimbal() const;
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* _internal_mutable_gimbal();
  public:
  void unsafe_arena_set_allocated_gimbal(
      ::aalyria::spacetime::api::common::BeamStats_GimbalStats* gimbal);
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* unsafe_arena_release_gimbal();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.BeamStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    ::aalyria::spacetime::api::common::BeamStats_TargetingStats* targeting_;
    ::aalyria::spacetime::api::common::BeamStats_GimbalStats* gimbal_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class TransmitterStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TransmitterStats) */ {
 public:
  inline TransmitterStats() : TransmitterStats(nullptr) {}
  ~TransmitterStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransmitterStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransmitterStats(const TransmitterStats& from);
  TransmitterStats(TransmitterStats&& from) noexcept
    : TransmitterStats() {
    *this = ::std::move(from);
  }

  inline TransmitterStats& operator=(const TransmitterStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransmitterStats& operator=(TransmitterStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransmitterStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransmitterStats* internal_default_instance() {
    return reinterpret_cast<const TransmitterStats*>(
               &_TransmitterStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TransmitterStats& a, TransmitterStats& b) {
    a.Swap(&b);
  }
  inline void Swap(TransmitterStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransmitterStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransmitterStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransmitterStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransmitterStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransmitterStats& from) {
    TransmitterStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransmitterStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TransmitterStats";
  }
  protected:
  explicit TransmitterStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverPhysicalAddressFieldNumber = 5,
    kTimestampFieldNumber = 4,
    kDataRateBpsFieldNumber = 2,
    kTxPacketErrorRateFieldNumber = 3,
  };
  // optional string receiver_physical_address = 5 [json_name = "receiverPhysicalAddress"];
  bool has_receiver_physical_address() const;
  void clear_receiver_physical_address() ;
  const std::string& receiver_physical_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver_physical_address(Arg_&& arg, Args_... args);
  std::string* mutable_receiver_physical_address();
  PROTOBUF_NODISCARD std::string* release_receiver_physical_address();
  void set_allocated_receiver_physical_address(std::string* ptr);

  private:
  const std::string& _internal_receiver_physical_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_physical_address(
      const std::string& value);
  std::string* _internal_mutable_receiver_physical_address();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 4 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional double data_rate_bps = 2 [json_name = "dataRateBps"];
  bool has_data_rate_bps() const;
  void clear_data_rate_bps() ;
  double data_rate_bps() const;
  void set_data_rate_bps(double value);

  private:
  double _internal_data_rate_bps() const;
  void _internal_set_data_rate_bps(double value);

  public:
  // optional double tx_packet_error_rate = 3 [json_name = "txPacketErrorRate"];
  bool has_tx_packet_error_rate() const;
  void clear_tx_packet_error_rate() ;
  double tx_packet_error_rate() const;
  void set_tx_packet_error_rate(double value);

  private:
  double _internal_tx_packet_error_rate() const;
  void _internal_set_tx_packet_error_rate(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TransmitterStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_physical_address_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    double data_rate_bps_;
    double tx_packet_error_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class ReceiverStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ReceiverStats) */ {
 public:
  inline ReceiverStats() : ReceiverStats(nullptr) {}
  ~ReceiverStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiverStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiverStats(const ReceiverStats& from);
  ReceiverStats(ReceiverStats&& from) noexcept
    : ReceiverStats() {
    *this = ::std::move(from);
  }

  inline ReceiverStats& operator=(const ReceiverStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiverStats& operator=(ReceiverStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiverStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiverStats* internal_default_instance() {
    return reinterpret_cast<const ReceiverStats*>(
               &_ReceiverStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReceiverStats& a, ReceiverStats& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiverStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiverStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiverStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiverStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiverStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiverStats& from) {
    ReceiverStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiverStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ReceiverStats";
  }
  protected:
  explicit ReceiverStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerAtReceiverOutputByChainDbwFieldNumber = 5,
    kTransmitterPhysicalAddressFieldNumber = 4,
    kTimestampFieldNumber = 3,
    kPowerAtReceiverOutputDbwFieldNumber = 2,
    kMseDbFieldNumber = 6,
    kCarrierToNoisePlusInterferenceDbFieldNumber = 7,
  };
  // repeated double power_at_receiver_output_by_chain_dbw = 5 [json_name = "powerAtReceiverOutputByChainDbw"];
  int power_at_receiver_output_by_chain_dbw_size() const;
  private:
  int _internal_power_at_receiver_output_by_chain_dbw_size() const;

  public:
  void clear_power_at_receiver_output_by_chain_dbw() ;
  double power_at_receiver_output_by_chain_dbw(int index) const;
  void set_power_at_receiver_output_by_chain_dbw(int index, double value);
  void add_power_at_receiver_output_by_chain_dbw(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& power_at_receiver_output_by_chain_dbw() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* mutable_power_at_receiver_output_by_chain_dbw();

  private:
  double _internal_power_at_receiver_output_by_chain_dbw(int index) const;
  void _internal_add_power_at_receiver_output_by_chain_dbw(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& _internal_power_at_receiver_output_by_chain_dbw() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* _internal_mutable_power_at_receiver_output_by_chain_dbw();

  public:
  // optional string transmitter_physical_address = 4 [json_name = "transmitterPhysicalAddress"];
  bool has_transmitter_physical_address() const;
  void clear_transmitter_physical_address() ;
  const std::string& transmitter_physical_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter_physical_address(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter_physical_address();
  PROTOBUF_NODISCARD std::string* release_transmitter_physical_address();
  void set_allocated_transmitter_physical_address(std::string* ptr);

  private:
  const std::string& _internal_transmitter_physical_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter_physical_address(
      const std::string& value);
  std::string* _internal_mutable_transmitter_physical_address();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional double power_at_receiver_output_dbw = 2 [json_name = "powerAtReceiverOutputDbw"];
  bool has_power_at_receiver_output_dbw() const;
  void clear_power_at_receiver_output_dbw() ;
  double power_at_receiver_output_dbw() const;
  void set_power_at_receiver_output_dbw(double value);

  private:
  double _internal_power_at_receiver_output_dbw() const;
  void _internal_set_power_at_receiver_output_dbw(double value);

  public:
  // optional double mse_db = 6 [json_name = "mseDb"];
  bool has_mse_db() const;
  void clear_mse_db() ;
  double mse_db() const;
  void set_mse_db(double value);

  private:
  double _internal_mse_db() const;
  void _internal_set_mse_db(double value);

  public:
  // optional double carrier_to_noise_plus_interference_db = 7 [json_name = "carrierToNoisePlusInterferenceDb"];
  bool has_carrier_to_noise_plus_interference_db() const;
  void clear_carrier_to_noise_plus_interference_db() ;
  double carrier_to_noise_plus_interference_db() const;
  void set_carrier_to_noise_plus_interference_db(double value);

  private:
  double _internal_carrier_to_noise_plus_interference_db() const;
  void _internal_set_carrier_to_noise_plus_interference_db(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ReceiverStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<double> power_at_receiver_output_by_chain_dbw_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_physical_address_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    double power_at_receiver_output_dbw_;
    double mse_db_;
    double carrier_to_noise_plus_interference_db_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class RadioStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioStats) */ {
 public:
  inline RadioStats() : RadioStats(nullptr) {}
  ~RadioStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioStats(const RadioStats& from);
  RadioStats(RadioStats&& from) noexcept
    : RadioStats() {
    *this = ::std::move(from);
  }

  inline RadioStats& operator=(const RadioStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioStats& operator=(RadioStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioStats* internal_default_instance() {
    return reinterpret_cast<const RadioStats*>(
               &_RadioStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RadioStats& a, RadioStats& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioStats& from) {
    RadioStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioStats";
  }
  protected:
  explicit RadioStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmitterStatsFieldNumber = 3,
    kReceiverStatsFieldNumber = 4,
    kInterfaceIdFieldNumber = 5,
  };
  // repeated .aalyria.spacetime.api.common.TransmitterStats transmitter_stats = 3 [json_name = "transmitterStats"];
  int transmitter_stats_size() const;
  private:
  int _internal_transmitter_stats_size() const;

  public:
  void clear_transmitter_stats() ;
  ::aalyria::spacetime::api::common::TransmitterStats* mutable_transmitter_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransmitterStats >*
      mutable_transmitter_stats();
  private:
  const ::aalyria::spacetime::api::common::TransmitterStats& _internal_transmitter_stats(int index) const;
  ::aalyria::spacetime::api::common::TransmitterStats* _internal_add_transmitter_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransmitterStats>& _internal_transmitter_stats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransmitterStats>* _internal_mutable_transmitter_stats();
  public:
  const ::aalyria::spacetime::api::common::TransmitterStats& transmitter_stats(int index) const;
  ::aalyria::spacetime::api::common::TransmitterStats* add_transmitter_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransmitterStats >&
      transmitter_stats() const;
  // repeated .aalyria.spacetime.api.common.ReceiverStats receiver_stats = 4 [json_name = "receiverStats"];
  int receiver_stats_size() const;
  private:
  int _internal_receiver_stats_size() const;

  public:
  void clear_receiver_stats() ;
  ::aalyria::spacetime::api::common::ReceiverStats* mutable_receiver_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiverStats >*
      mutable_receiver_stats();
  private:
  const ::aalyria::spacetime::api::common::ReceiverStats& _internal_receiver_stats(int index) const;
  ::aalyria::spacetime::api::common::ReceiverStats* _internal_add_receiver_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiverStats>& _internal_receiver_stats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiverStats>* _internal_mutable_receiver_stats();
  public:
  const ::aalyria::spacetime::api::common::ReceiverStats& receiver_stats(int index) const;
  ::aalyria::spacetime::api::common::ReceiverStats* add_receiver_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiverStats >&
      receiver_stats() const;
  // optional string interface_id = 5 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransmitterStats > transmitter_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiverStats > receiver_stats_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class InterfaceStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.InterfaceStats) */ {
 public:
  inline InterfaceStats() : InterfaceStats(nullptr) {}
  ~InterfaceStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterfaceStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceStats(const InterfaceStats& from);
  InterfaceStats(InterfaceStats&& from) noexcept
    : InterfaceStats() {
    *this = ::std::move(from);
  }

  inline InterfaceStats& operator=(const InterfaceStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceStats& operator=(InterfaceStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterfaceStats* internal_default_instance() {
    return reinterpret_cast<const InterfaceStats*>(
               &_InterfaceStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InterfaceStats& a, InterfaceStats& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterfaceStats& from) {
    InterfaceStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.InterfaceStats";
  }
  protected:
  explicit InterfaceStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 9,
    kTxPacketsFieldNumber = 1,
    kRxPacketsFieldNumber = 2,
    kTxBytesFieldNumber = 3,
    kRxBytesFieldNumber = 4,
    kTxDroppedFieldNumber = 5,
    kRxDroppedFieldNumber = 6,
    kRxErrorsFieldNumber = 7,
    kTxErrorsFieldNumber = 8,
  };
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 9 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional int64 tx_packets = 1 [json_name = "txPackets"];
  bool has_tx_packets() const;
  void clear_tx_packets() ;
  ::int64_t tx_packets() const;
  void set_tx_packets(::int64_t value);

  private:
  ::int64_t _internal_tx_packets() const;
  void _internal_set_tx_packets(::int64_t value);

  public:
  // optional int64 rx_packets = 2 [json_name = "rxPackets"];
  bool has_rx_packets() const;
  void clear_rx_packets() ;
  ::int64_t rx_packets() const;
  void set_rx_packets(::int64_t value);

  private:
  ::int64_t _internal_rx_packets() const;
  void _internal_set_rx_packets(::int64_t value);

  public:
  // optional int64 tx_bytes = 3 [json_name = "txBytes"];
  bool has_tx_bytes() const;
  void clear_tx_bytes() ;
  ::int64_t tx_bytes() const;
  void set_tx_bytes(::int64_t value);

  private:
  ::int64_t _internal_tx_bytes() const;
  void _internal_set_tx_bytes(::int64_t value);

  public:
  // optional int64 rx_bytes = 4 [json_name = "rxBytes"];
  bool has_rx_bytes() const;
  void clear_rx_bytes() ;
  ::int64_t rx_bytes() const;
  void set_rx_bytes(::int64_t value);

  private:
  ::int64_t _internal_rx_bytes() const;
  void _internal_set_rx_bytes(::int64_t value);

  public:
  // optional int64 tx_dropped = 5 [json_name = "txDropped"];
  bool has_tx_dropped() const;
  void clear_tx_dropped() ;
  ::int64_t tx_dropped() const;
  void set_tx_dropped(::int64_t value);

  private:
  ::int64_t _internal_tx_dropped() const;
  void _internal_set_tx_dropped(::int64_t value);

  public:
  // optional int64 rx_dropped = 6 [json_name = "rxDropped"];
  bool has_rx_dropped() const;
  void clear_rx_dropped() ;
  ::int64_t rx_dropped() const;
  void set_rx_dropped(::int64_t value);

  private:
  ::int64_t _internal_rx_dropped() const;
  void _internal_set_rx_dropped(::int64_t value);

  public:
  // optional int64 rx_errors = 7 [json_name = "rxErrors"];
  bool has_rx_errors() const;
  void clear_rx_errors() ;
  ::int64_t rx_errors() const;
  void set_rx_errors(::int64_t value);

  private:
  ::int64_t _internal_rx_errors() const;
  void _internal_set_rx_errors(::int64_t value);

  public:
  // optional int64 tx_errors = 8 [json_name = "txErrors"];
  bool has_tx_errors() const;
  void clear_tx_errors() ;
  ::int64_t tx_errors() const;
  void set_tx_errors(::int64_t value);

  private:
  ::int64_t _internal_tx_errors() const;
  void _internal_set_tx_errors(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.InterfaceStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    ::int64_t tx_packets_;
    ::int64_t rx_packets_;
    ::int64_t tx_bytes_;
    ::int64_t rx_bytes_;
    ::int64_t tx_dropped_;
    ::int64_t rx_dropped_;
    ::int64_t rx_errors_;
    ::int64_t tx_errors_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class FlowStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowStats) */ {
 public:
  inline FlowStats() : FlowStats(nullptr) {}
  ~FlowStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowStats(const FlowStats& from);
  FlowStats(FlowStats&& from) noexcept
    : FlowStats() {
    *this = ::std::move(from);
  }

  inline FlowStats& operator=(const FlowStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowStats& operator=(FlowStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowStats* internal_default_instance() {
    return reinterpret_cast<const FlowStats*>(
               &_FlowStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FlowStats& a, FlowStats& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowStats& from) {
    FlowStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowStats";
  }
  protected:
  explicit FlowStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kTxPacketsFieldNumber = 2,
    kRxPacketsFieldNumber = 3,
    kTxBytesFieldNumber = 4,
    kRxBytesFieldNumber = 5,
  };
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional int64 tx_packets = 2 [json_name = "txPackets"];
  bool has_tx_packets() const;
  void clear_tx_packets() ;
  ::int64_t tx_packets() const;
  void set_tx_packets(::int64_t value);

  private:
  ::int64_t _internal_tx_packets() const;
  void _internal_set_tx_packets(::int64_t value);

  public:
  // optional int64 rx_packets = 3 [json_name = "rxPackets"];
  bool has_rx_packets() const;
  void clear_rx_packets() ;
  ::int64_t rx_packets() const;
  void set_rx_packets(::int64_t value);

  private:
  ::int64_t _internal_rx_packets() const;
  void _internal_set_rx_packets(::int64_t value);

  public:
  // optional int64 tx_bytes = 4 [json_name = "txBytes"];
  bool has_tx_bytes() const;
  void clear_tx_bytes() ;
  ::int64_t tx_bytes() const;
  void set_tx_bytes(::int64_t value);

  private:
  ::int64_t _internal_tx_bytes() const;
  void _internal_set_tx_bytes(::int64_t value);

  public:
  // optional int64 rx_bytes = 5 [json_name = "rxBytes"];
  bool has_rx_bytes() const;
  void clear_rx_bytes() ;
  ::int64_t rx_bytes() const;
  void set_rx_bytes(::int64_t value);

  private:
  ::int64_t _internal_rx_bytes() const;
  void _internal_set_rx_bytes(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    ::int64_t tx_packets_;
    ::int64_t rx_packets_;
    ::int64_t tx_bytes_;
    ::int64_t rx_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class NetworkEventReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.NetworkEventReport) */ {
 public:
  inline NetworkEventReport() : NetworkEventReport(nullptr) {}
  ~NetworkEventReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkEventReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkEventReport(const NetworkEventReport& from);
  NetworkEventReport(NetworkEventReport&& from) noexcept
    : NetworkEventReport() {
    *this = ::std::move(from);
  }

  inline NetworkEventReport& operator=(const NetworkEventReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkEventReport& operator=(NetworkEventReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkEventReport& default_instance() {
    return *internal_default_instance();
  }
  enum SourceTypeCase {
    kRadioEvent = 2,
    kPortEvent = 3,
    kInterfaceEvent = 4,
    SOURCE_TYPE_NOT_SET = 0,
  };

  static inline const NetworkEventReport* internal_default_instance() {
    return reinterpret_cast<const NetworkEventReport*>(
               &_NetworkEventReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NetworkEventReport& a, NetworkEventReport& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkEventReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkEventReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkEventReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkEventReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkEventReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkEventReport& from) {
    NetworkEventReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkEventReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.NetworkEventReport";
  }
  protected:
  explicit NetworkEventReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 5,
    kTimestampFieldNumber = 1,
    kRadioEventFieldNumber = 2,
    kPortEventFieldNumber = 3,
    kInterfaceEventFieldNumber = 4,
  };
  // optional string node_id = 5 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // .aalyria.spacetime.api.common.RadioEvent radio_event = 2 [json_name = "radioEvent"];
  bool has_radio_event() const;
  private:
  bool _internal_has_radio_event() const;

  public:
  void clear_radio_event() ;
  const ::aalyria::spacetime::api::common::RadioEvent& radio_event() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioEvent* release_radio_event();
  ::aalyria::spacetime::api::common::RadioEvent* mutable_radio_event();
  void set_allocated_radio_event(::aalyria::spacetime::api::common::RadioEvent* radio_event);
  private:
  const ::aalyria::spacetime::api::common::RadioEvent& _internal_radio_event() const;
  ::aalyria::spacetime::api::common::RadioEvent* _internal_mutable_radio_event();
  public:
  void unsafe_arena_set_allocated_radio_event(
      ::aalyria::spacetime::api::common::RadioEvent* radio_event);
  ::aalyria::spacetime::api::common::RadioEvent* unsafe_arena_release_radio_event();
  // .aalyria.spacetime.api.common.PortEvent port_event = 3 [json_name = "portEvent"];
  bool has_port_event() const;
  private:
  bool _internal_has_port_event() const;

  public:
  void clear_port_event() ;
  const ::aalyria::spacetime::api::common::PortEvent& port_event() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PortEvent* release_port_event();
  ::aalyria::spacetime::api::common::PortEvent* mutable_port_event();
  void set_allocated_port_event(::aalyria::spacetime::api::common::PortEvent* port_event);
  private:
  const ::aalyria::spacetime::api::common::PortEvent& _internal_port_event() const;
  ::aalyria::spacetime::api::common::PortEvent* _internal_mutable_port_event();
  public:
  void unsafe_arena_set_allocated_port_event(
      ::aalyria::spacetime::api::common::PortEvent* port_event);
  ::aalyria::spacetime::api::common::PortEvent* unsafe_arena_release_port_event();
  // .aalyria.spacetime.api.common.InterfaceEvent interface_event = 4 [json_name = "interfaceEvent"];
  bool has_interface_event() const;
  private:
  bool _internal_has_interface_event() const;

  public:
  void clear_interface_event() ;
  const ::aalyria::spacetime::api::common::InterfaceEvent& interface_event() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::InterfaceEvent* release_interface_event();
  ::aalyria::spacetime::api::common::InterfaceEvent* mutable_interface_event();
  void set_allocated_interface_event(::aalyria::spacetime::api::common::InterfaceEvent* interface_event);
  private:
  const ::aalyria::spacetime::api::common::InterfaceEvent& _internal_interface_event() const;
  ::aalyria::spacetime::api::common::InterfaceEvent* _internal_mutable_interface_event();
  public:
  void unsafe_arena_set_allocated_interface_event(
      ::aalyria::spacetime::api::common::InterfaceEvent* interface_event);
  ::aalyria::spacetime::api::common::InterfaceEvent* unsafe_arena_release_interface_event();
  void clear_source_type();
  SourceTypeCase source_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.NetworkEventReport)
 private:
  class _Internal;
  void set_has_radio_event();
  void set_has_port_event();
  void set_has_interface_event();

  inline bool has_source_type() const;
  inline void clear_has_source_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    union SourceTypeUnion {
      constexpr SourceTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::RadioEvent* radio_event_;
      ::aalyria::spacetime::api::common::PortEvent* port_event_;
      ::aalyria::spacetime::api::common::InterfaceEvent* interface_event_;
    } source_type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class RadioEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.RadioEvent) */ {
 public:
  inline RadioEvent() : RadioEvent(nullptr) {}
  ~RadioEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioEvent(const RadioEvent& from);
  RadioEvent(RadioEvent&& from) noexcept
    : RadioEvent() {
    *this = ::std::move(from);
  }

  inline RadioEvent& operator=(const RadioEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioEvent& operator=(RadioEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioEvent& default_instance() {
    return *internal_default_instance();
  }
  enum RadioIdCase {
    kTransmitterId = 1,
    kReceiverId = 2,
    RADIO_ID_NOT_SET = 0,
  };

  enum EventCase {
    kLinkStatus = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const RadioEvent* internal_default_instance() {
    return reinterpret_cast<const RadioEvent*>(
               &_RadioEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RadioEvent& a, RadioEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioEvent& from) {
    RadioEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.RadioEvent";
  }
  protected:
  explicit RadioEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LinkStatus = RadioEvent_LinkStatus;
  static constexpr LinkStatus UNKNOWN = RadioEvent_LinkStatus_UNKNOWN;
  static constexpr LinkStatus DOWN = RadioEvent_LinkStatus_DOWN;
  static constexpr LinkStatus UP = RadioEvent_LinkStatus_UP;
  static inline bool LinkStatus_IsValid(int value) {
    return RadioEvent_LinkStatus_IsValid(value);
  }
  static constexpr LinkStatus LinkStatus_MIN = RadioEvent_LinkStatus_LinkStatus_MIN;
  static constexpr LinkStatus LinkStatus_MAX = RadioEvent_LinkStatus_LinkStatus_MAX;
  static constexpr int LinkStatus_ARRAYSIZE = RadioEvent_LinkStatus_LinkStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LinkStatus_descriptor() {
    return RadioEvent_LinkStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& LinkStatus_Name(T value) {
    return RadioEvent_LinkStatus_Name(value);
  }
  static inline bool LinkStatus_Parse(absl::string_view name, LinkStatus* value) {
    return RadioEvent_LinkStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTransmitterIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kLinkStatusFieldNumber = 3,
  };
  // string transmitter_id = 1 [json_name = "transmitterId"];
  bool has_transmitter_id() const;
  void clear_transmitter_id() ;
  const std::string& transmitter_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmitter_id(Arg_&& arg, Args_... args);
  std::string* mutable_transmitter_id();
  PROTOBUF_NODISCARD std::string* release_transmitter_id();
  void set_allocated_transmitter_id(std::string* ptr);

  private:
  const std::string& _internal_transmitter_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmitter_id(
      const std::string& value);
  std::string* _internal_mutable_transmitter_id();

  public:
  // string receiver_id = 2 [json_name = "receiverId"];
  bool has_receiver_id() const;
  void clear_receiver_id() ;
  const std::string& receiver_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver_id(Arg_&& arg, Args_... args);
  std::string* mutable_receiver_id();
  PROTOBUF_NODISCARD std::string* release_receiver_id();
  void set_allocated_receiver_id(std::string* ptr);

  private:
  const std::string& _internal_receiver_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_id(
      const std::string& value);
  std::string* _internal_mutable_receiver_id();

  public:
  // .aalyria.spacetime.api.common.RadioEvent.LinkStatus link_status = 3 [json_name = "linkStatus"];
  bool has_link_status() const;
  void clear_link_status() ;
  ::aalyria::spacetime::api::common::RadioEvent_LinkStatus link_status() const;
  void set_link_status(::aalyria::spacetime::api::common::RadioEvent_LinkStatus value);

  private:
  ::aalyria::spacetime::api::common::RadioEvent_LinkStatus _internal_link_status() const;
  void _internal_set_link_status(::aalyria::spacetime::api::common::RadioEvent_LinkStatus value);

  public:
  void clear_radio_id();
  RadioIdCase radio_id_case() const;
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.RadioEvent)
 private:
  class _Internal;
  void set_has_transmitter_id();
  void set_has_receiver_id();
  void set_has_link_status();

  inline bool has_radio_id() const;
  inline void clear_has_radio_id();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RadioIdUnion {
      constexpr RadioIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transmitter_id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_id_;
    } radio_id_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int link_status_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class PortEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PortEvent) */ {
 public:
  inline PortEvent() : PortEvent(nullptr) {}
  ~PortEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortEvent(const PortEvent& from);
  PortEvent(PortEvent&& from) noexcept
    : PortEvent() {
    *this = ::std::move(from);
  }

  inline PortEvent& operator=(const PortEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortEvent& operator=(PortEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kPortStatus = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const PortEvent* internal_default_instance() {
    return reinterpret_cast<const PortEvent*>(
               &_PortEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PortEvent& a, PortEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PortEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortEvent& from) {
    PortEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PortEvent";
  }
  protected:
  explicit PortEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PortStatus = PortEvent_PortStatus;
  static constexpr PortStatus UNKNOWN = PortEvent_PortStatus_UNKNOWN;
  static constexpr PortStatus DOWN = PortEvent_PortStatus_DOWN;
  static constexpr PortStatus UP = PortEvent_PortStatus_UP;
  static inline bool PortStatus_IsValid(int value) {
    return PortEvent_PortStatus_IsValid(value);
  }
  static constexpr PortStatus PortStatus_MIN = PortEvent_PortStatus_PortStatus_MIN;
  static constexpr PortStatus PortStatus_MAX = PortEvent_PortStatus_PortStatus_MAX;
  static constexpr int PortStatus_ARRAYSIZE = PortEvent_PortStatus_PortStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortStatus_descriptor() {
    return PortEvent_PortStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& PortStatus_Name(T value) {
    return PortEvent_PortStatus_Name(value);
  }
  static inline bool PortStatus_Parse(absl::string_view name, PortStatus* value) {
    return PortEvent_PortStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPortStatusFieldNumber = 2,
  };
  // optional string port_id = 1 [json_name = "portId"];
  bool has_port_id() const;
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // .aalyria.spacetime.api.common.PortEvent.PortStatus port_status = 2 [json_name = "portStatus"];
  bool has_port_status() const;
  void clear_port_status() ;
  ::aalyria::spacetime::api::common::PortEvent_PortStatus port_status() const;
  void set_port_status(::aalyria::spacetime::api::common::PortEvent_PortStatus value);

  private:
  ::aalyria::spacetime::api::common::PortEvent_PortStatus _internal_port_status() const;
  void _internal_set_port_status(::aalyria::spacetime::api::common::PortEvent_PortStatus value);

  public:
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PortEvent)
 private:
  class _Internal;
  void set_has_port_status();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int port_status_;
    } event_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};// -------------------------------------------------------------------

class InterfaceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.InterfaceEvent) */ {
 public:
  inline InterfaceEvent() : InterfaceEvent(nullptr) {}
  ~InterfaceEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterfaceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceEvent(const InterfaceEvent& from);
  InterfaceEvent(InterfaceEvent&& from) noexcept
    : InterfaceEvent() {
    *this = ::std::move(from);
  }

  inline InterfaceEvent& operator=(const InterfaceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceEvent& operator=(InterfaceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kInterfaceStatus = 2,
    kIpAddress = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const InterfaceEvent* internal_default_instance() {
    return reinterpret_cast<const InterfaceEvent*>(
               &_InterfaceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(InterfaceEvent& a, InterfaceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterfaceEvent& from) {
    InterfaceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.InterfaceEvent";
  }
  protected:
  explicit InterfaceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using InterfaceStatus = InterfaceEvent_InterfaceStatus;
  static constexpr InterfaceStatus UNKNOWN = InterfaceEvent_InterfaceStatus_UNKNOWN;
  static constexpr InterfaceStatus DISABLED = InterfaceEvent_InterfaceStatus_DISABLED;
  static constexpr InterfaceStatus ENABLED = InterfaceEvent_InterfaceStatus_ENABLED;
  static inline bool InterfaceStatus_IsValid(int value) {
    return InterfaceEvent_InterfaceStatus_IsValid(value);
  }
  static constexpr InterfaceStatus InterfaceStatus_MIN = InterfaceEvent_InterfaceStatus_InterfaceStatus_MIN;
  static constexpr InterfaceStatus InterfaceStatus_MAX = InterfaceEvent_InterfaceStatus_InterfaceStatus_MAX;
  static constexpr int InterfaceStatus_ARRAYSIZE = InterfaceEvent_InterfaceStatus_InterfaceStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterfaceStatus_descriptor() {
    return InterfaceEvent_InterfaceStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& InterfaceStatus_Name(T value) {
    return InterfaceEvent_InterfaceStatus_Name(value);
  }
  static inline bool InterfaceStatus_Parse(absl::string_view name, InterfaceStatus* value) {
    return InterfaceEvent_InterfaceStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceIdFieldNumber = 1,
    kInterfaceStatusFieldNumber = 2,
    kIpAddressFieldNumber = 3,
  };
  // optional string interface_id = 1 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // .aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus interface_status = 2 [json_name = "interfaceStatus"];
  bool has_interface_status() const;
  void clear_interface_status() ;
  ::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus interface_status() const;
  void set_interface_status(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus value);

  private:
  ::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus _internal_interface_status() const;
  void _internal_set_interface_status(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus value);

  public:
  // string ip_address = 3 [json_name = "ipAddress"];
  bool has_ip_address() const;
  void clear_ip_address() ;
  const std::string& ip_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ptr);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.InterfaceEvent)
 private:
  class _Internal;
  void set_has_interface_status();
  void set_has_ip_address();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int interface_status_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    } event_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2ftelemetry_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NetworkStatsReport

// optional string node_id = 7 [json_name = "nodeId"];
inline bool NetworkStatsReport::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkStatsReport::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkStatsReport::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkStatsReport.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkStatsReport::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.NetworkStatsReport.node_id)
}
inline std::string* NetworkStatsReport::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkStatsReport.node_id)
  return _s;
}
inline const std::string& NetworkStatsReport::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void NetworkStatsReport::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkStatsReport::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkStatsReport::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkStatsReport.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkStatsReport::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkStatsReport.node_id)
}

// optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
inline bool NetworkStatsReport::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& NetworkStatsReport::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& NetworkStatsReport::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkStatsReport.timestamp)
  return _internal_timestamp();
}
inline void NetworkStatsReport::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.NetworkStatsReport.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkStatsReport::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkStatsReport::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkStatsReport.timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkStatsReport::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkStatsReport::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkStatsReport.timestamp)
  return _msg;
}
inline void NetworkStatsReport::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkStatsReport.timestamp)
}

// map<string, .aalyria.spacetime.api.common.RadioStats> radio_stats_by_interface_id = 4 [json_name = "radioStatsByInterfaceId"];
inline int NetworkStatsReport::_internal_radio_stats_by_interface_id_size() const {
  return _impl_.radio_stats_by_interface_id_.size();
}
inline int NetworkStatsReport::radio_stats_by_interface_id_size() const {
  return _internal_radio_stats_by_interface_id_size();
}
inline void NetworkStatsReport::clear_radio_stats_by_interface_id() {
  _impl_.radio_stats_by_interface_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >&
NetworkStatsReport::_internal_radio_stats_by_interface_id() const {
  return _impl_.radio_stats_by_interface_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >&
NetworkStatsReport::radio_stats_by_interface_id() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.NetworkStatsReport.radio_stats_by_interface_id)
  return _internal_radio_stats_by_interface_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >*
NetworkStatsReport::_internal_mutable_radio_stats_by_interface_id() {
  return _impl_.radio_stats_by_interface_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >*
NetworkStatsReport::mutable_radio_stats_by_interface_id() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.NetworkStatsReport.radio_stats_by_interface_id)
  return _internal_mutable_radio_stats_by_interface_id();
}

// map<string, .aalyria.spacetime.api.common.InterfaceStats> interface_stats_by_id = 3 [json_name = "interfaceStatsById"];
inline int NetworkStatsReport::_internal_interface_stats_by_id_size() const {
  return _impl_.interface_stats_by_id_.size();
}
inline int NetworkStatsReport::interface_stats_by_id_size() const {
  return _internal_interface_stats_by_id_size();
}
inline void NetworkStatsReport::clear_interface_stats_by_id() {
  _impl_.interface_stats_by_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >&
NetworkStatsReport::_internal_interface_stats_by_id() const {
  return _impl_.interface_stats_by_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >&
NetworkStatsReport::interface_stats_by_id() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.NetworkStatsReport.interface_stats_by_id)
  return _internal_interface_stats_by_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >*
NetworkStatsReport::_internal_mutable_interface_stats_by_id() {
  return _impl_.interface_stats_by_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >*
NetworkStatsReport::mutable_interface_stats_by_id() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.NetworkStatsReport.interface_stats_by_id)
  return _internal_mutable_interface_stats_by_id();
}

// map<string, .aalyria.spacetime.api.common.BeamStats> beam_stats_by_antenna_id = 5 [json_name = "beamStatsByAntennaId"];
inline int NetworkStatsReport::_internal_beam_stats_by_antenna_id_size() const {
  return _impl_.beam_stats_by_antenna_id_.size();
}
inline int NetworkStatsReport::beam_stats_by_antenna_id_size() const {
  return _internal_beam_stats_by_antenna_id_size();
}
inline void NetworkStatsReport::clear_beam_stats_by_antenna_id() {
  _impl_.beam_stats_by_antenna_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >&
NetworkStatsReport::_internal_beam_stats_by_antenna_id() const {
  return _impl_.beam_stats_by_antenna_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >&
NetworkStatsReport::beam_stats_by_antenna_id() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.NetworkStatsReport.beam_stats_by_antenna_id)
  return _internal_beam_stats_by_antenna_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >*
NetworkStatsReport::_internal_mutable_beam_stats_by_antenna_id() {
  return _impl_.beam_stats_by_antenna_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >*
NetworkStatsReport::mutable_beam_stats_by_antenna_id() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.NetworkStatsReport.beam_stats_by_antenna_id)
  return _internal_mutable_beam_stats_by_antenna_id();
}

// map<string, .aalyria.spacetime.api.common.FlowStats> flow_stats_by_id = 6 [json_name = "flowStatsById"];
inline int NetworkStatsReport::_internal_flow_stats_by_id_size() const {
  return _impl_.flow_stats_by_id_.size();
}
inline int NetworkStatsReport::flow_stats_by_id_size() const {
  return _internal_flow_stats_by_id_size();
}
inline void NetworkStatsReport::clear_flow_stats_by_id() {
  _impl_.flow_stats_by_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >&
NetworkStatsReport::_internal_flow_stats_by_id() const {
  return _impl_.flow_stats_by_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >&
NetworkStatsReport::flow_stats_by_id() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.NetworkStatsReport.flow_stats_by_id)
  return _internal_flow_stats_by_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >*
NetworkStatsReport::_internal_mutable_flow_stats_by_id() {
  return _impl_.flow_stats_by_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >*
NetworkStatsReport::mutable_flow_stats_by_id() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.NetworkStatsReport.flow_stats_by_id)
  return _internal_mutable_flow_stats_by_id();
}

// -------------------------------------------------------------------

// BeamStats_TargetingStats

// optional .aalyria.spacetime.api.common.GeodeticWgs84 target_location = 1 [json_name = "targetLocation"];
inline bool BeamStats_TargetingStats::has_target_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_location_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& BeamStats_TargetingStats::_internal_target_location() const {
  const ::aalyria::spacetime::api::common::GeodeticWgs84* p = _impl_.target_location_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::GeodeticWgs84&>(
      ::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& BeamStats_TargetingStats::target_location() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location)
  return _internal_target_location();
}
inline void BeamStats_TargetingStats::unsafe_arena_set_allocated_target_location(
    ::aalyria::spacetime::api::common::GeodeticWgs84* target_location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_location_);
  }
  _impl_.target_location_ = target_location;
  if (target_location) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_TargetingStats::release_target_location() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.target_location_;
  _impl_.target_location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_TargetingStats::unsafe_arena_release_target_location() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.target_location_;
  _impl_.target_location_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_TargetingStats::_internal_mutable_target_location() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.target_location_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84>(GetArenaForAllocation());
    _impl_.target_location_ = p;
  }
  return _impl_.target_location_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_TargetingStats::mutable_target_location() {
  ::aalyria::spacetime::api::common::GeodeticWgs84* _msg = _internal_mutable_target_location();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location)
  return _msg;
}
inline void BeamStats_TargetingStats::set_allocated_target_location(::aalyria::spacetime::api::common::GeodeticWgs84* target_location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_location_);
  }
  if (target_location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_location));
    if (message_arena != submessage_arena) {
      target_location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.target_location_ = target_location;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location)
}

// optional .aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus connection_status = 2 [json_name = "connectionStatus"];
inline bool BeamStats_TargetingStats::has_connection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BeamStats_TargetingStats::clear_connection_status() {
  _impl_.connection_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::connection_status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.TargetingStats.connection_status)
  return _internal_connection_status();
}
inline void BeamStats_TargetingStats::set_connection_status(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus value) {
   _internal_set_connection_status(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStats.TargetingStats.connection_status)
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::_internal_connection_status() const {
  return static_cast<::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus>(_impl_.connection_status_);
}
inline void BeamStats_TargetingStats::_internal_set_connection_status(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus value) {
  assert(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.connection_status_ = value;
}

// optional string beam_task_id = 3 [json_name = "beamTaskId"];
inline bool BeamStats_TargetingStats::has_beam_task_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BeamStats_TargetingStats::clear_beam_task_id() {
  _impl_.beam_task_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BeamStats_TargetingStats::beam_task_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id)
  return _internal_beam_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamStats_TargetingStats::set_beam_task_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.beam_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id)
}
inline std::string* BeamStats_TargetingStats::mutable_beam_task_id() {
  std::string* _s = _internal_mutable_beam_task_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id)
  return _s;
}
inline const std::string& BeamStats_TargetingStats::_internal_beam_task_id() const {
  return _impl_.beam_task_id_.Get();
}
inline void BeamStats_TargetingStats::_internal_set_beam_task_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.beam_task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamStats_TargetingStats::_internal_mutable_beam_task_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.beam_task_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamStats_TargetingStats::release_beam_task_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.beam_task_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.beam_task_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamStats_TargetingStats::set_allocated_beam_task_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.beam_task_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.beam_task_id_.IsDefault()) {
          _impl_.beam_task_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id)
}

// optional string target_identifier = 4 [json_name = "targetIdentifier"];
inline bool BeamStats_TargetingStats::has_target_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BeamStats_TargetingStats::clear_target_identifier() {
  _impl_.target_identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BeamStats_TargetingStats::target_identifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier)
  return _internal_target_identifier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeamStats_TargetingStats::set_target_identifier(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_identifier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier)
}
inline std::string* BeamStats_TargetingStats::mutable_target_identifier() {
  std::string* _s = _internal_mutable_target_identifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier)
  return _s;
}
inline const std::string& BeamStats_TargetingStats::_internal_target_identifier() const {
  return _impl_.target_identifier_.Get();
}
inline void BeamStats_TargetingStats::_internal_set_target_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.target_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* BeamStats_TargetingStats::_internal_mutable_target_identifier() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.target_identifier_.Mutable( GetArenaForAllocation());
}
inline std::string* BeamStats_TargetingStats::release_target_identifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.target_identifier_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_identifier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BeamStats_TargetingStats::set_allocated_target_identifier(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_identifier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_identifier_.IsDefault()) {
          _impl_.target_identifier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier)
}

// -------------------------------------------------------------------

// BeamStats_GimbalStats

// optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 1 [json_name = "location"];
inline bool BeamStats_GimbalStats::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& BeamStats_GimbalStats::_internal_location() const {
  const ::aalyria::spacetime::api::common::GeodeticWgs84* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::GeodeticWgs84&>(
      ::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& BeamStats_GimbalStats::location() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.GimbalStats.location)
  return _internal_location();
}
inline void BeamStats_GimbalStats::unsafe_arena_set_allocated_location(
    ::aalyria::spacetime::api::common::GeodeticWgs84* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.location)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_GimbalStats::release_location() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_GimbalStats::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.location)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_GimbalStats::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* BeamStats_GimbalStats::mutable_location() {
  ::aalyria::spacetime::api::common::GeodeticWgs84* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.GimbalStats.location)
  return _msg;
}
inline void BeamStats_GimbalStats::set_allocated_location(::aalyria::spacetime::api::common::GeodeticWgs84* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.location)
}

// .aalyria.spacetime.api.common.Quaternion orientation_quaternion = 2 [json_name = "orientationQuaternion"];
inline bool BeamStats_GimbalStats::has_orientation_quaternion() const {
  return site_orientation_case() == kOrientationQuaternion;
}
inline bool BeamStats_GimbalStats::_internal_has_orientation_quaternion() const {
  return site_orientation_case() == kOrientationQuaternion;
}
inline void BeamStats_GimbalStats::set_has_orientation_quaternion() {
  _impl_._oneof_case_[0] = kOrientationQuaternion;
}
inline ::aalyria::spacetime::api::common::Quaternion* BeamStats_GimbalStats::release_orientation_quaternion() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
  if (site_orientation_case() == kOrientationQuaternion) {
    clear_has_site_orientation();
    ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.site_orientation_.orientation_quaternion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.site_orientation_.orientation_quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Quaternion& BeamStats_GimbalStats::_internal_orientation_quaternion() const {
  return site_orientation_case() == kOrientationQuaternion
      ? *_impl_.site_orientation_.orientation_quaternion_
      : reinterpret_cast<::aalyria::spacetime::api::common::Quaternion&>(::aalyria::spacetime::api::common::_Quaternion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Quaternion& BeamStats_GimbalStats::orientation_quaternion() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
  return _internal_orientation_quaternion();
}
inline ::aalyria::spacetime::api::common::Quaternion* BeamStats_GimbalStats::unsafe_arena_release_orientation_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
  if (site_orientation_case() == kOrientationQuaternion) {
    clear_has_site_orientation();
    ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.site_orientation_.orientation_quaternion_;
    _impl_.site_orientation_.orientation_quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BeamStats_GimbalStats::unsafe_arena_set_allocated_orientation_quaternion(::aalyria::spacetime::api::common::Quaternion* orientation_quaternion) {
  clear_site_orientation();
  if (orientation_quaternion) {
    set_has_orientation_quaternion();
    _impl_.site_orientation_.orientation_quaternion_ = orientation_quaternion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
}
inline ::aalyria::spacetime::api::common::Quaternion* BeamStats_GimbalStats::_internal_mutable_orientation_quaternion() {
  if (site_orientation_case() != kOrientationQuaternion) {
    clear_site_orientation();
    set_has_orientation_quaternion();
    _impl_.site_orientation_.orientation_quaternion_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Quaternion >(GetArenaForAllocation());
  }
  return _impl_.site_orientation_.orientation_quaternion_;
}
inline ::aalyria::spacetime::api::common::Quaternion* BeamStats_GimbalStats::mutable_orientation_quaternion() {
  ::aalyria::spacetime::api::common::Quaternion* _msg = _internal_mutable_orientation_quaternion();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
  return _msg;
}

// .aalyria.spacetime.api.common.YawPitchRoll orientation_ypr = 3 [json_name = "orientationYpr"];
inline bool BeamStats_GimbalStats::has_orientation_ypr() const {
  return site_orientation_case() == kOrientationYpr;
}
inline bool BeamStats_GimbalStats::_internal_has_orientation_ypr() const {
  return site_orientation_case() == kOrientationYpr;
}
inline void BeamStats_GimbalStats::set_has_orientation_ypr() {
  _impl_._oneof_case_[0] = kOrientationYpr;
}
inline ::aalyria::spacetime::api::common::YawPitchRoll* BeamStats_GimbalStats::release_orientation_ypr() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
  if (site_orientation_case() == kOrientationYpr) {
    clear_has_site_orientation();
    ::aalyria::spacetime::api::common::YawPitchRoll* temp = _impl_.site_orientation_.orientation_ypr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.site_orientation_.orientation_ypr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::YawPitchRoll& BeamStats_GimbalStats::_internal_orientation_ypr() const {
  return site_orientation_case() == kOrientationYpr
      ? *_impl_.site_orientation_.orientation_ypr_
      : reinterpret_cast<::aalyria::spacetime::api::common::YawPitchRoll&>(::aalyria::spacetime::api::common::_YawPitchRoll_default_instance_);
}
inline const ::aalyria::spacetime::api::common::YawPitchRoll& BeamStats_GimbalStats::orientation_ypr() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
  return _internal_orientation_ypr();
}
inline ::aalyria::spacetime::api::common::YawPitchRoll* BeamStats_GimbalStats::unsafe_arena_release_orientation_ypr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
  if (site_orientation_case() == kOrientationYpr) {
    clear_has_site_orientation();
    ::aalyria::spacetime::api::common::YawPitchRoll* temp = _impl_.site_orientation_.orientation_ypr_;
    _impl_.site_orientation_.orientation_ypr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BeamStats_GimbalStats::unsafe_arena_set_allocated_orientation_ypr(::aalyria::spacetime::api::common::YawPitchRoll* orientation_ypr) {
  clear_site_orientation();
  if (orientation_ypr) {
    set_has_orientation_ypr();
    _impl_.site_orientation_.orientation_ypr_ = orientation_ypr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
}
inline ::aalyria::spacetime::api::common::YawPitchRoll* BeamStats_GimbalStats::_internal_mutable_orientation_ypr() {
  if (site_orientation_case() != kOrientationYpr) {
    clear_site_orientation();
    set_has_orientation_ypr();
    _impl_.site_orientation_.orientation_ypr_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::YawPitchRoll >(GetArenaForAllocation());
  }
  return _impl_.site_orientation_.orientation_ypr_;
}
inline ::aalyria::spacetime::api::common::YawPitchRoll* BeamStats_GimbalStats::mutable_orientation_ypr() {
  ::aalyria::spacetime::api::common::YawPitchRoll* _msg = _internal_mutable_orientation_ypr();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
  return _msg;
}

// optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 4 [json_name = "pointingVector"];
inline bool BeamStats_GimbalStats::has_pointing_vector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pointing_vector_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::PointingVector& BeamStats_GimbalStats::_internal_pointing_vector() const {
  const ::aalyria::spacetime::api::common::PointingVector* p = _impl_.pointing_vector_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PointingVector&>(
      ::aalyria::spacetime::api::common::_PointingVector_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PointingVector& BeamStats_GimbalStats::pointing_vector() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector)
  return _internal_pointing_vector();
}
inline void BeamStats_GimbalStats::unsafe_arena_set_allocated_pointing_vector(
    ::aalyria::spacetime::api::common::PointingVector* pointing_vector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointing_vector_);
  }
  _impl_.pointing_vector_ = pointing_vector;
  if (pointing_vector) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector)
}
inline ::aalyria::spacetime::api::common::PointingVector* BeamStats_GimbalStats::release_pointing_vector() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PointingVector* temp = _impl_.pointing_vector_;
  _impl_.pointing_vector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PointingVector* BeamStats_GimbalStats::unsafe_arena_release_pointing_vector() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PointingVector* temp = _impl_.pointing_vector_;
  _impl_.pointing_vector_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PointingVector* BeamStats_GimbalStats::_internal_mutable_pointing_vector() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pointing_vector_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PointingVector>(GetArenaForAllocation());
    _impl_.pointing_vector_ = p;
  }
  return _impl_.pointing_vector_;
}
inline ::aalyria::spacetime::api::common::PointingVector* BeamStats_GimbalStats::mutable_pointing_vector() {
  ::aalyria::spacetime::api::common::PointingVector* _msg = _internal_mutable_pointing_vector();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector)
  return _msg;
}
inline void BeamStats_GimbalStats::set_allocated_pointing_vector(::aalyria::spacetime::api::common::PointingVector* pointing_vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointing_vector_);
  }
  if (pointing_vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pointing_vector));
    if (message_arena != submessage_arena) {
      pointing_vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointing_vector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pointing_vector_ = pointing_vector;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector)
}

// optional bool initialized = 5 [json_name = "initialized"];
inline bool BeamStats_GimbalStats::has_initialized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BeamStats_GimbalStats::clear_initialized() {
  _impl_.initialized_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool BeamStats_GimbalStats::initialized() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.GimbalStats.initialized)
  return _internal_initialized();
}
inline void BeamStats_GimbalStats::set_initialized(bool value) {
  _internal_set_initialized(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.BeamStats.GimbalStats.initialized)
}
inline bool BeamStats_GimbalStats::_internal_initialized() const {
  return _impl_.initialized_;
}
inline void BeamStats_GimbalStats::_internal_set_initialized(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.initialized_ = value;
}

inline bool BeamStats_GimbalStats::has_site_orientation() const {
  return site_orientation_case() != SITE_ORIENTATION_NOT_SET;
}
inline void BeamStats_GimbalStats::clear_has_site_orientation() {
  _impl_._oneof_case_[0] = SITE_ORIENTATION_NOT_SET;
}
inline BeamStats_GimbalStats::SiteOrientationCase BeamStats_GimbalStats::site_orientation_case() const {
  return BeamStats_GimbalStats::SiteOrientationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BeamStats

// optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
inline bool BeamStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& BeamStats::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& BeamStats::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.timestamp)
  return _internal_timestamp();
}
inline void BeamStats::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStats::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStats::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* BeamStats::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.timestamp)
  return _msg;
}
inline void BeamStats::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.timestamp)
}

// optional .aalyria.spacetime.api.common.BeamStats.TargetingStats targeting = 2 [json_name = "targeting"];
inline bool BeamStats::has_targeting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targeting_ != nullptr);
  return value;
}
inline void BeamStats::clear_targeting() {
  if (_impl_.targeting_ != nullptr) _impl_.targeting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::BeamStats_TargetingStats& BeamStats::_internal_targeting() const {
  const ::aalyria::spacetime::api::common::BeamStats_TargetingStats* p = _impl_.targeting_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::BeamStats_TargetingStats&>(
      ::aalyria::spacetime::api::common::_BeamStats_TargetingStats_default_instance_);
}
inline const ::aalyria::spacetime::api::common::BeamStats_TargetingStats& BeamStats::targeting() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.targeting)
  return _internal_targeting();
}
inline void BeamStats::unsafe_arena_set_allocated_targeting(
    ::aalyria::spacetime::api::common::BeamStats_TargetingStats* targeting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.targeting_);
  }
  _impl_.targeting_ = targeting;
  if (targeting) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.targeting)
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats* BeamStats::release_targeting() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* temp = _impl_.targeting_;
  _impl_.targeting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats* BeamStats::unsafe_arena_release_targeting() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.targeting)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* temp = _impl_.targeting_;
  _impl_.targeting_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats* BeamStats::_internal_mutable_targeting() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.targeting_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStats_TargetingStats>(GetArenaForAllocation());
    _impl_.targeting_ = p;
  }
  return _impl_.targeting_;
}
inline ::aalyria::spacetime::api::common::BeamStats_TargetingStats* BeamStats::mutable_targeting() {
  ::aalyria::spacetime::api::common::BeamStats_TargetingStats* _msg = _internal_mutable_targeting();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.targeting)
  return _msg;
}
inline void BeamStats::set_allocated_targeting(::aalyria::spacetime::api::common::BeamStats_TargetingStats* targeting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.targeting_;
  }
  if (targeting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(targeting);
    if (message_arena != submessage_arena) {
      targeting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targeting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.targeting_ = targeting;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.targeting)
}

// optional .aalyria.spacetime.api.common.BeamStats.GimbalStats gimbal = 3 [json_name = "gimbal"];
inline bool BeamStats::has_gimbal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gimbal_ != nullptr);
  return value;
}
inline void BeamStats::clear_gimbal() {
  if (_impl_.gimbal_ != nullptr) _impl_.gimbal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::BeamStats_GimbalStats& BeamStats::_internal_gimbal() const {
  const ::aalyria::spacetime::api::common::BeamStats_GimbalStats* p = _impl_.gimbal_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::BeamStats_GimbalStats&>(
      ::aalyria::spacetime::api::common::_BeamStats_GimbalStats_default_instance_);
}
inline const ::aalyria::spacetime::api::common::BeamStats_GimbalStats& BeamStats::gimbal() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.BeamStats.gimbal)
  return _internal_gimbal();
}
inline void BeamStats::unsafe_arena_set_allocated_gimbal(
    ::aalyria::spacetime::api::common::BeamStats_GimbalStats* gimbal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gimbal_);
  }
  _impl_.gimbal_ = gimbal;
  if (gimbal) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.BeamStats.gimbal)
}
inline ::aalyria::spacetime::api::common::BeamStats_GimbalStats* BeamStats::release_gimbal() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* temp = _impl_.gimbal_;
  _impl_.gimbal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStats_GimbalStats* BeamStats::unsafe_arena_release_gimbal() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.BeamStats.gimbal)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* temp = _impl_.gimbal_;
  _impl_.gimbal_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStats_GimbalStats* BeamStats::_internal_mutable_gimbal() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.gimbal_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStats_GimbalStats>(GetArenaForAllocation());
    _impl_.gimbal_ = p;
  }
  return _impl_.gimbal_;
}
inline ::aalyria::spacetime::api::common::BeamStats_GimbalStats* BeamStats::mutable_gimbal() {
  ::aalyria::spacetime::api::common::BeamStats_GimbalStats* _msg = _internal_mutable_gimbal();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.BeamStats.gimbal)
  return _msg;
}
inline void BeamStats::set_allocated_gimbal(::aalyria::spacetime::api::common::BeamStats_GimbalStats* gimbal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gimbal_;
  }
  if (gimbal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gimbal);
    if (message_arena != submessage_arena) {
      gimbal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gimbal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gimbal_ = gimbal;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.gimbal)
}

// -------------------------------------------------------------------

// TransmitterStats

// optional .aalyria.spacetime.api.common.DateTime timestamp = 4 [json_name = "timestamp"];
inline bool TransmitterStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& TransmitterStats::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& TransmitterStats::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterStats.timestamp)
  return _internal_timestamp();
}
inline void TransmitterStats::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.TransmitterStats.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* TransmitterStats::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* TransmitterStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TransmitterStats.timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* TransmitterStats::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* TransmitterStats::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TransmitterStats.timestamp)
  return _msg;
}
inline void TransmitterStats::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TransmitterStats.timestamp)
}

// optional string receiver_physical_address = 5 [json_name = "receiverPhysicalAddress"];
inline bool TransmitterStats::has_receiver_physical_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TransmitterStats::clear_receiver_physical_address() {
  _impl_.receiver_physical_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransmitterStats::receiver_physical_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address)
  return _internal_receiver_physical_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransmitterStats::set_receiver_physical_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.receiver_physical_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address)
}
inline std::string* TransmitterStats::mutable_receiver_physical_address() {
  std::string* _s = _internal_mutable_receiver_physical_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address)
  return _s;
}
inline const std::string& TransmitterStats::_internal_receiver_physical_address() const {
  return _impl_.receiver_physical_address_.Get();
}
inline void TransmitterStats::_internal_set_receiver_physical_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.receiver_physical_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TransmitterStats::_internal_mutable_receiver_physical_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.receiver_physical_address_.Mutable( GetArenaForAllocation());
}
inline std::string* TransmitterStats::release_receiver_physical_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.receiver_physical_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.receiver_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TransmitterStats::set_allocated_receiver_physical_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.receiver_physical_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_physical_address_.IsDefault()) {
          _impl_.receiver_physical_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address)
}

// optional double data_rate_bps = 2 [json_name = "dataRateBps"];
inline bool TransmitterStats::has_data_rate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TransmitterStats::clear_data_rate_bps() {
  _impl_.data_rate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double TransmitterStats::data_rate_bps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterStats.data_rate_bps)
  return _internal_data_rate_bps();
}
inline void TransmitterStats::set_data_rate_bps(double value) {
  _internal_set_data_rate_bps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterStats.data_rate_bps)
}
inline double TransmitterStats::_internal_data_rate_bps() const {
  return _impl_.data_rate_bps_;
}
inline void TransmitterStats::_internal_set_data_rate_bps(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_rate_bps_ = value;
}

// optional double tx_packet_error_rate = 3 [json_name = "txPacketErrorRate"];
inline bool TransmitterStats::has_tx_packet_error_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TransmitterStats::clear_tx_packet_error_rate() {
  _impl_.tx_packet_error_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double TransmitterStats::tx_packet_error_rate() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TransmitterStats.tx_packet_error_rate)
  return _internal_tx_packet_error_rate();
}
inline void TransmitterStats::set_tx_packet_error_rate(double value) {
  _internal_set_tx_packet_error_rate(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TransmitterStats.tx_packet_error_rate)
}
inline double TransmitterStats::_internal_tx_packet_error_rate() const {
  return _impl_.tx_packet_error_rate_;
}
inline void TransmitterStats::_internal_set_tx_packet_error_rate(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tx_packet_error_rate_ = value;
}

// -------------------------------------------------------------------

// ReceiverStats

// optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
inline bool ReceiverStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& ReceiverStats::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& ReceiverStats::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.timestamp)
  return _internal_timestamp();
}
inline void ReceiverStats::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ReceiverStats.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* ReceiverStats::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* ReceiverStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiverStats.timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* ReceiverStats::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* ReceiverStats::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiverStats.timestamp)
  return _msg;
}
inline void ReceiverStats::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiverStats.timestamp)
}

// optional string transmitter_physical_address = 4 [json_name = "transmitterPhysicalAddress"];
inline bool ReceiverStats::has_transmitter_physical_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReceiverStats::clear_transmitter_physical_address() {
  _impl_.transmitter_physical_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReceiverStats::transmitter_physical_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address)
  return _internal_transmitter_physical_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReceiverStats::set_transmitter_physical_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transmitter_physical_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address)
}
inline std::string* ReceiverStats::mutable_transmitter_physical_address() {
  std::string* _s = _internal_mutable_transmitter_physical_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address)
  return _s;
}
inline const std::string& ReceiverStats::_internal_transmitter_physical_address() const {
  return _impl_.transmitter_physical_address_.Get();
}
inline void ReceiverStats::_internal_set_transmitter_physical_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.transmitter_physical_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiverStats::_internal_mutable_transmitter_physical_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transmitter_physical_address_.Mutable( GetArenaForAllocation());
}
inline std::string* ReceiverStats::release_transmitter_physical_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transmitter_physical_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transmitter_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ReceiverStats::set_allocated_transmitter_physical_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transmitter_physical_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmitter_physical_address_.IsDefault()) {
          _impl_.transmitter_physical_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address)
}

// optional double power_at_receiver_output_dbw = 2 [json_name = "powerAtReceiverOutputDbw"];
inline bool ReceiverStats::has_power_at_receiver_output_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReceiverStats::clear_power_at_receiver_output_dbw() {
  _impl_.power_at_receiver_output_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ReceiverStats::power_at_receiver_output_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_dbw)
  return _internal_power_at_receiver_output_dbw();
}
inline void ReceiverStats::set_power_at_receiver_output_dbw(double value) {
  _internal_set_power_at_receiver_output_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_dbw)
}
inline double ReceiverStats::_internal_power_at_receiver_output_dbw() const {
  return _impl_.power_at_receiver_output_dbw_;
}
inline void ReceiverStats::_internal_set_power_at_receiver_output_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.power_at_receiver_output_dbw_ = value;
}

// repeated double power_at_receiver_output_by_chain_dbw = 5 [json_name = "powerAtReceiverOutputByChainDbw"];
inline int ReceiverStats::_internal_power_at_receiver_output_by_chain_dbw_size() const {
  return _impl_.power_at_receiver_output_by_chain_dbw_.size();
}
inline int ReceiverStats::power_at_receiver_output_by_chain_dbw_size() const {
  return _internal_power_at_receiver_output_by_chain_dbw_size();
}
inline void ReceiverStats::clear_power_at_receiver_output_by_chain_dbw() {
  _internal_mutable_power_at_receiver_output_by_chain_dbw()->Clear();
}
inline double ReceiverStats::power_at_receiver_output_by_chain_dbw(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_by_chain_dbw)
  return _internal_power_at_receiver_output_by_chain_dbw(index);
}
inline void ReceiverStats::set_power_at_receiver_output_by_chain_dbw(int index, double value) {
  _internal_mutable_power_at_receiver_output_by_chain_dbw()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_by_chain_dbw)
}
inline void ReceiverStats::add_power_at_receiver_output_by_chain_dbw(double value) {
  _internal_add_power_at_receiver_output_by_chain_dbw(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_by_chain_dbw)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& ReceiverStats::power_at_receiver_output_by_chain_dbw() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_by_chain_dbw)
  return _internal_power_at_receiver_output_by_chain_dbw();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* ReceiverStats::mutable_power_at_receiver_output_by_chain_dbw() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.ReceiverStats.power_at_receiver_output_by_chain_dbw)
  return _internal_mutable_power_at_receiver_output_by_chain_dbw();
}

inline double ReceiverStats::_internal_power_at_receiver_output_by_chain_dbw(int index) const {
  return _internal_power_at_receiver_output_by_chain_dbw().Get(index);
}
inline void ReceiverStats::_internal_add_power_at_receiver_output_by_chain_dbw(double value) {
  _internal_mutable_power_at_receiver_output_by_chain_dbw()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& ReceiverStats::_internal_power_at_receiver_output_by_chain_dbw() const {
  return _impl_.power_at_receiver_output_by_chain_dbw_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* ReceiverStats::_internal_mutable_power_at_receiver_output_by_chain_dbw() {
  return &_impl_.power_at_receiver_output_by_chain_dbw_;
}

// optional double mse_db = 6 [json_name = "mseDb"];
inline bool ReceiverStats::has_mse_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ReceiverStats::clear_mse_db() {
  _impl_.mse_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ReceiverStats::mse_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.mse_db)
  return _internal_mse_db();
}
inline void ReceiverStats::set_mse_db(double value) {
  _internal_set_mse_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverStats.mse_db)
}
inline double ReceiverStats::_internal_mse_db() const {
  return _impl_.mse_db_;
}
inline void ReceiverStats::_internal_set_mse_db(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mse_db_ = value;
}

// optional double carrier_to_noise_plus_interference_db = 7 [json_name = "carrierToNoisePlusInterferenceDb"];
inline bool ReceiverStats::has_carrier_to_noise_plus_interference_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ReceiverStats::clear_carrier_to_noise_plus_interference_db() {
  _impl_.carrier_to_noise_plus_interference_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double ReceiverStats::carrier_to_noise_plus_interference_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ReceiverStats.carrier_to_noise_plus_interference_db)
  return _internal_carrier_to_noise_plus_interference_db();
}
inline void ReceiverStats::set_carrier_to_noise_plus_interference_db(double value) {
  _internal_set_carrier_to_noise_plus_interference_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ReceiverStats.carrier_to_noise_plus_interference_db)
}
inline double ReceiverStats::_internal_carrier_to_noise_plus_interference_db() const {
  return _impl_.carrier_to_noise_plus_interference_db_;
}
inline void ReceiverStats::_internal_set_carrier_to_noise_plus_interference_db(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.carrier_to_noise_plus_interference_db_ = value;
}

// -------------------------------------------------------------------

// RadioStats

// optional string interface_id = 5 [json_name = "interfaceId"];
inline bool RadioStats::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioStats::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RadioStats::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStats.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioStats::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioStats.interface_id)
}
inline std::string* RadioStats::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStats.interface_id)
  return _s;
}
inline const std::string& RadioStats::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void RadioStats::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioStats::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioStats::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioStats.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioStats::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioStats.interface_id)
}

// repeated .aalyria.spacetime.api.common.TransmitterStats transmitter_stats = 3 [json_name = "transmitterStats"];
inline int RadioStats::_internal_transmitter_stats_size() const {
  return _impl_.transmitter_stats_.size();
}
inline int RadioStats::transmitter_stats_size() const {
  return _internal_transmitter_stats_size();
}
inline void RadioStats::clear_transmitter_stats() {
  _internal_mutable_transmitter_stats()->Clear();
}
inline ::aalyria::spacetime::api::common::TransmitterStats* RadioStats::mutable_transmitter_stats(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStats.transmitter_stats)
  return _internal_mutable_transmitter_stats()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransmitterStats >*
RadioStats::mutable_transmitter_stats() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.RadioStats.transmitter_stats)
  return _internal_mutable_transmitter_stats();
}
inline const ::aalyria::spacetime::api::common::TransmitterStats& RadioStats::_internal_transmitter_stats(int index) const {
  return _internal_transmitter_stats().Get(index);
}
inline const ::aalyria::spacetime::api::common::TransmitterStats& RadioStats::transmitter_stats(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStats.transmitter_stats)
  return _internal_transmitter_stats(index);
}
inline ::aalyria::spacetime::api::common::TransmitterStats* RadioStats::_internal_add_transmitter_stats() {
  return _internal_mutable_transmitter_stats()->Add();
}
inline ::aalyria::spacetime::api::common::TransmitterStats* RadioStats::add_transmitter_stats() {
  ::aalyria::spacetime::api::common::TransmitterStats* _add = _internal_add_transmitter_stats();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.RadioStats.transmitter_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransmitterStats >&
RadioStats::transmitter_stats() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.RadioStats.transmitter_stats)
  return _internal_transmitter_stats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransmitterStats>&
RadioStats::_internal_transmitter_stats() const {
  return _impl_.transmitter_stats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransmitterStats>*
RadioStats::_internal_mutable_transmitter_stats() {
  return &_impl_.transmitter_stats_;
}

// repeated .aalyria.spacetime.api.common.ReceiverStats receiver_stats = 4 [json_name = "receiverStats"];
inline int RadioStats::_internal_receiver_stats_size() const {
  return _impl_.receiver_stats_.size();
}
inline int RadioStats::receiver_stats_size() const {
  return _internal_receiver_stats_size();
}
inline void RadioStats::clear_receiver_stats() {
  _internal_mutable_receiver_stats()->Clear();
}
inline ::aalyria::spacetime::api::common::ReceiverStats* RadioStats::mutable_receiver_stats(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioStats.receiver_stats)
  return _internal_mutable_receiver_stats()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiverStats >*
RadioStats::mutable_receiver_stats() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.RadioStats.receiver_stats)
  return _internal_mutable_receiver_stats();
}
inline const ::aalyria::spacetime::api::common::ReceiverStats& RadioStats::_internal_receiver_stats(int index) const {
  return _internal_receiver_stats().Get(index);
}
inline const ::aalyria::spacetime::api::common::ReceiverStats& RadioStats::receiver_stats(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioStats.receiver_stats)
  return _internal_receiver_stats(index);
}
inline ::aalyria::spacetime::api::common::ReceiverStats* RadioStats::_internal_add_receiver_stats() {
  return _internal_mutable_receiver_stats()->Add();
}
inline ::aalyria::spacetime::api::common::ReceiverStats* RadioStats::add_receiver_stats() {
  ::aalyria::spacetime::api::common::ReceiverStats* _add = _internal_add_receiver_stats();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.RadioStats.receiver_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ReceiverStats >&
RadioStats::receiver_stats() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.RadioStats.receiver_stats)
  return _internal_receiver_stats();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiverStats>&
RadioStats::_internal_receiver_stats() const {
  return _impl_.receiver_stats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ReceiverStats>*
RadioStats::_internal_mutable_receiver_stats() {
  return &_impl_.receiver_stats_;
}

// -------------------------------------------------------------------

// InterfaceStats

// optional .aalyria.spacetime.api.common.DateTime timestamp = 9 [json_name = "timestamp"];
inline bool InterfaceStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& InterfaceStats::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& InterfaceStats::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.timestamp)
  return _internal_timestamp();
}
inline void InterfaceStats::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.InterfaceStats.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* InterfaceStats::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* InterfaceStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.InterfaceStats.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* InterfaceStats::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* InterfaceStats::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.InterfaceStats.timestamp)
  return _msg;
}
inline void InterfaceStats::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.InterfaceStats.timestamp)
}

// optional int64 tx_packets = 1 [json_name = "txPackets"];
inline bool InterfaceStats::has_tx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InterfaceStats::clear_tx_packets() {
  _impl_.tx_packets_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t InterfaceStats::tx_packets() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.tx_packets)
  return _internal_tx_packets();
}
inline void InterfaceStats::set_tx_packets(::int64_t value) {
  _internal_set_tx_packets(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.tx_packets)
}
inline ::int64_t InterfaceStats::_internal_tx_packets() const {
  return _impl_.tx_packets_;
}
inline void InterfaceStats::_internal_set_tx_packets(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_packets_ = value;
}

// optional int64 rx_packets = 2 [json_name = "rxPackets"];
inline bool InterfaceStats::has_rx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InterfaceStats::clear_rx_packets() {
  _impl_.rx_packets_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t InterfaceStats::rx_packets() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.rx_packets)
  return _internal_rx_packets();
}
inline void InterfaceStats::set_rx_packets(::int64_t value) {
  _internal_set_rx_packets(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.rx_packets)
}
inline ::int64_t InterfaceStats::_internal_rx_packets() const {
  return _impl_.rx_packets_;
}
inline void InterfaceStats::_internal_set_rx_packets(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rx_packets_ = value;
}

// optional int64 tx_bytes = 3 [json_name = "txBytes"];
inline bool InterfaceStats::has_tx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InterfaceStats::clear_tx_bytes() {
  _impl_.tx_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t InterfaceStats::tx_bytes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.tx_bytes)
  return _internal_tx_bytes();
}
inline void InterfaceStats::set_tx_bytes(::int64_t value) {
  _internal_set_tx_bytes(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.tx_bytes)
}
inline ::int64_t InterfaceStats::_internal_tx_bytes() const {
  return _impl_.tx_bytes_;
}
inline void InterfaceStats::_internal_set_tx_bytes(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tx_bytes_ = value;
}

// optional int64 rx_bytes = 4 [json_name = "rxBytes"];
inline bool InterfaceStats::has_rx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InterfaceStats::clear_rx_bytes() {
  _impl_.rx_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t InterfaceStats::rx_bytes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.rx_bytes)
  return _internal_rx_bytes();
}
inline void InterfaceStats::set_rx_bytes(::int64_t value) {
  _internal_set_rx_bytes(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.rx_bytes)
}
inline ::int64_t InterfaceStats::_internal_rx_bytes() const {
  return _impl_.rx_bytes_;
}
inline void InterfaceStats::_internal_set_rx_bytes(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rx_bytes_ = value;
}

// optional int64 tx_dropped = 5 [json_name = "txDropped"];
inline bool InterfaceStats::has_tx_dropped() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InterfaceStats::clear_tx_dropped() {
  _impl_.tx_dropped_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t InterfaceStats::tx_dropped() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.tx_dropped)
  return _internal_tx_dropped();
}
inline void InterfaceStats::set_tx_dropped(::int64_t value) {
  _internal_set_tx_dropped(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.tx_dropped)
}
inline ::int64_t InterfaceStats::_internal_tx_dropped() const {
  return _impl_.tx_dropped_;
}
inline void InterfaceStats::_internal_set_tx_dropped(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tx_dropped_ = value;
}

// optional int64 rx_dropped = 6 [json_name = "rxDropped"];
inline bool InterfaceStats::has_rx_dropped() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void InterfaceStats::clear_rx_dropped() {
  _impl_.rx_dropped_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t InterfaceStats::rx_dropped() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.rx_dropped)
  return _internal_rx_dropped();
}
inline void InterfaceStats::set_rx_dropped(::int64_t value) {
  _internal_set_rx_dropped(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.rx_dropped)
}
inline ::int64_t InterfaceStats::_internal_rx_dropped() const {
  return _impl_.rx_dropped_;
}
inline void InterfaceStats::_internal_set_rx_dropped(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.rx_dropped_ = value;
}

// optional int64 rx_errors = 7 [json_name = "rxErrors"];
inline bool InterfaceStats::has_rx_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void InterfaceStats::clear_rx_errors() {
  _impl_.rx_errors_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t InterfaceStats::rx_errors() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.rx_errors)
  return _internal_rx_errors();
}
inline void InterfaceStats::set_rx_errors(::int64_t value) {
  _internal_set_rx_errors(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.rx_errors)
}
inline ::int64_t InterfaceStats::_internal_rx_errors() const {
  return _impl_.rx_errors_;
}
inline void InterfaceStats::_internal_set_rx_errors(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.rx_errors_ = value;
}

// optional int64 tx_errors = 8 [json_name = "txErrors"];
inline bool InterfaceStats::has_tx_errors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void InterfaceStats::clear_tx_errors() {
  _impl_.tx_errors_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t InterfaceStats::tx_errors() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceStats.tx_errors)
  return _internal_tx_errors();
}
inline void InterfaceStats::set_tx_errors(::int64_t value) {
  _internal_set_tx_errors(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceStats.tx_errors)
}
inline ::int64_t InterfaceStats::_internal_tx_errors() const {
  return _impl_.tx_errors_;
}
inline void InterfaceStats::_internal_set_tx_errors(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.tx_errors_ = value;
}

// -------------------------------------------------------------------

// FlowStats

// optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
inline bool FlowStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& FlowStats::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& FlowStats::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowStats.timestamp)
  return _internal_timestamp();
}
inline void FlowStats::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowStats.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* FlowStats::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowStats.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowStats::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* FlowStats::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowStats.timestamp)
  return _msg;
}
inline void FlowStats::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowStats.timestamp)
}

// optional int64 tx_packets = 2 [json_name = "txPackets"];
inline bool FlowStats::has_tx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FlowStats::clear_tx_packets() {
  _impl_.tx_packets_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t FlowStats::tx_packets() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowStats.tx_packets)
  return _internal_tx_packets();
}
inline void FlowStats::set_tx_packets(::int64_t value) {
  _internal_set_tx_packets(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowStats.tx_packets)
}
inline ::int64_t FlowStats::_internal_tx_packets() const {
  return _impl_.tx_packets_;
}
inline void FlowStats::_internal_set_tx_packets(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_packets_ = value;
}

// optional int64 rx_packets = 3 [json_name = "rxPackets"];
inline bool FlowStats::has_rx_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FlowStats::clear_rx_packets() {
  _impl_.rx_packets_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t FlowStats::rx_packets() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowStats.rx_packets)
  return _internal_rx_packets();
}
inline void FlowStats::set_rx_packets(::int64_t value) {
  _internal_set_rx_packets(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowStats.rx_packets)
}
inline ::int64_t FlowStats::_internal_rx_packets() const {
  return _impl_.rx_packets_;
}
inline void FlowStats::_internal_set_rx_packets(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rx_packets_ = value;
}

// optional int64 tx_bytes = 4 [json_name = "txBytes"];
inline bool FlowStats::has_tx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FlowStats::clear_tx_bytes() {
  _impl_.tx_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t FlowStats::tx_bytes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowStats.tx_bytes)
  return _internal_tx_bytes();
}
inline void FlowStats::set_tx_bytes(::int64_t value) {
  _internal_set_tx_bytes(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowStats.tx_bytes)
}
inline ::int64_t FlowStats::_internal_tx_bytes() const {
  return _impl_.tx_bytes_;
}
inline void FlowStats::_internal_set_tx_bytes(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tx_bytes_ = value;
}

// optional int64 rx_bytes = 5 [json_name = "rxBytes"];
inline bool FlowStats::has_rx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FlowStats::clear_rx_bytes() {
  _impl_.rx_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t FlowStats::rx_bytes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowStats.rx_bytes)
  return _internal_rx_bytes();
}
inline void FlowStats::set_rx_bytes(::int64_t value) {
  _internal_set_rx_bytes(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.FlowStats.rx_bytes)
}
inline ::int64_t FlowStats::_internal_rx_bytes() const {
  return _impl_.rx_bytes_;
}
inline void FlowStats::_internal_set_rx_bytes(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rx_bytes_ = value;
}

// -------------------------------------------------------------------

// NetworkEventReport

// optional string node_id = 5 [json_name = "nodeId"];
inline bool NetworkEventReport::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkEventReport::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkEventReport::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkEventReport.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkEventReport::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.NetworkEventReport.node_id)
}
inline std::string* NetworkEventReport::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkEventReport.node_id)
  return _s;
}
inline const std::string& NetworkEventReport::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void NetworkEventReport::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkEventReport::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkEventReport::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkEventReport.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkEventReport::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.node_id)
}

// optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
inline bool NetworkEventReport::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& NetworkEventReport::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& NetworkEventReport::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkEventReport.timestamp)
  return _internal_timestamp();
}
inline void NetworkEventReport::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkEventReport::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkEventReport::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkEventReport.timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkEventReport::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* NetworkEventReport::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkEventReport.timestamp)
  return _msg;
}
inline void NetworkEventReport::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.timestamp)
}

// .aalyria.spacetime.api.common.RadioEvent radio_event = 2 [json_name = "radioEvent"];
inline bool NetworkEventReport::has_radio_event() const {
  return source_type_case() == kRadioEvent;
}
inline bool NetworkEventReport::_internal_has_radio_event() const {
  return source_type_case() == kRadioEvent;
}
inline void NetworkEventReport::set_has_radio_event() {
  _impl_._oneof_case_[0] = kRadioEvent;
}
inline void NetworkEventReport::clear_radio_event() {
  if (source_type_case() == kRadioEvent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_type_.radio_event_;
    }
    clear_has_source_type();
  }
}
inline ::aalyria::spacetime::api::common::RadioEvent* NetworkEventReport::release_radio_event() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
  if (source_type_case() == kRadioEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::RadioEvent* temp = _impl_.source_type_.radio_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_type_.radio_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::RadioEvent& NetworkEventReport::_internal_radio_event() const {
  return source_type_case() == kRadioEvent
      ? *_impl_.source_type_.radio_event_
      : reinterpret_cast<::aalyria::spacetime::api::common::RadioEvent&>(::aalyria::spacetime::api::common::_RadioEvent_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioEvent& NetworkEventReport::radio_event() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
  return _internal_radio_event();
}
inline ::aalyria::spacetime::api::common::RadioEvent* NetworkEventReport::unsafe_arena_release_radio_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
  if (source_type_case() == kRadioEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::RadioEvent* temp = _impl_.source_type_.radio_event_;
    _impl_.source_type_.radio_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkEventReport::unsafe_arena_set_allocated_radio_event(::aalyria::spacetime::api::common::RadioEvent* radio_event) {
  clear_source_type();
  if (radio_event) {
    set_has_radio_event();
    _impl_.source_type_.radio_event_ = radio_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
}
inline ::aalyria::spacetime::api::common::RadioEvent* NetworkEventReport::_internal_mutable_radio_event() {
  if (source_type_case() != kRadioEvent) {
    clear_source_type();
    set_has_radio_event();
    _impl_.source_type_.radio_event_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::RadioEvent >(GetArenaForAllocation());
  }
  return _impl_.source_type_.radio_event_;
}
inline ::aalyria::spacetime::api::common::RadioEvent* NetworkEventReport::mutable_radio_event() {
  ::aalyria::spacetime::api::common::RadioEvent* _msg = _internal_mutable_radio_event();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
  return _msg;
}

// .aalyria.spacetime.api.common.PortEvent port_event = 3 [json_name = "portEvent"];
inline bool NetworkEventReport::has_port_event() const {
  return source_type_case() == kPortEvent;
}
inline bool NetworkEventReport::_internal_has_port_event() const {
  return source_type_case() == kPortEvent;
}
inline void NetworkEventReport::set_has_port_event() {
  _impl_._oneof_case_[0] = kPortEvent;
}
inline void NetworkEventReport::clear_port_event() {
  if (source_type_case() == kPortEvent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_type_.port_event_;
    }
    clear_has_source_type();
  }
}
inline ::aalyria::spacetime::api::common::PortEvent* NetworkEventReport::release_port_event() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkEventReport.port_event)
  if (source_type_case() == kPortEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::PortEvent* temp = _impl_.source_type_.port_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_type_.port_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PortEvent& NetworkEventReport::_internal_port_event() const {
  return source_type_case() == kPortEvent
      ? *_impl_.source_type_.port_event_
      : reinterpret_cast<::aalyria::spacetime::api::common::PortEvent&>(::aalyria::spacetime::api::common::_PortEvent_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PortEvent& NetworkEventReport::port_event() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkEventReport.port_event)
  return _internal_port_event();
}
inline ::aalyria::spacetime::api::common::PortEvent* NetworkEventReport::unsafe_arena_release_port_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.NetworkEventReport.port_event)
  if (source_type_case() == kPortEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::PortEvent* temp = _impl_.source_type_.port_event_;
    _impl_.source_type_.port_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkEventReport::unsafe_arena_set_allocated_port_event(::aalyria::spacetime::api::common::PortEvent* port_event) {
  clear_source_type();
  if (port_event) {
    set_has_port_event();
    _impl_.source_type_.port_event_ = port_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.port_event)
}
inline ::aalyria::spacetime::api::common::PortEvent* NetworkEventReport::_internal_mutable_port_event() {
  if (source_type_case() != kPortEvent) {
    clear_source_type();
    set_has_port_event();
    _impl_.source_type_.port_event_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PortEvent >(GetArenaForAllocation());
  }
  return _impl_.source_type_.port_event_;
}
inline ::aalyria::spacetime::api::common::PortEvent* NetworkEventReport::mutable_port_event() {
  ::aalyria::spacetime::api::common::PortEvent* _msg = _internal_mutable_port_event();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkEventReport.port_event)
  return _msg;
}

// .aalyria.spacetime.api.common.InterfaceEvent interface_event = 4 [json_name = "interfaceEvent"];
inline bool NetworkEventReport::has_interface_event() const {
  return source_type_case() == kInterfaceEvent;
}
inline bool NetworkEventReport::_internal_has_interface_event() const {
  return source_type_case() == kInterfaceEvent;
}
inline void NetworkEventReport::set_has_interface_event() {
  _impl_._oneof_case_[0] = kInterfaceEvent;
}
inline void NetworkEventReport::clear_interface_event() {
  if (source_type_case() == kInterfaceEvent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_type_.interface_event_;
    }
    clear_has_source_type();
  }
}
inline ::aalyria::spacetime::api::common::InterfaceEvent* NetworkEventReport::release_interface_event() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
  if (source_type_case() == kInterfaceEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::InterfaceEvent* temp = _impl_.source_type_.interface_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_type_.interface_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::InterfaceEvent& NetworkEventReport::_internal_interface_event() const {
  return source_type_case() == kInterfaceEvent
      ? *_impl_.source_type_.interface_event_
      : reinterpret_cast<::aalyria::spacetime::api::common::InterfaceEvent&>(::aalyria::spacetime::api::common::_InterfaceEvent_default_instance_);
}
inline const ::aalyria::spacetime::api::common::InterfaceEvent& NetworkEventReport::interface_event() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
  return _internal_interface_event();
}
inline ::aalyria::spacetime::api::common::InterfaceEvent* NetworkEventReport::unsafe_arena_release_interface_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
  if (source_type_case() == kInterfaceEvent) {
    clear_has_source_type();
    ::aalyria::spacetime::api::common::InterfaceEvent* temp = _impl_.source_type_.interface_event_;
    _impl_.source_type_.interface_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkEventReport::unsafe_arena_set_allocated_interface_event(::aalyria::spacetime::api::common::InterfaceEvent* interface_event) {
  clear_source_type();
  if (interface_event) {
    set_has_interface_event();
    _impl_.source_type_.interface_event_ = interface_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
}
inline ::aalyria::spacetime::api::common::InterfaceEvent* NetworkEventReport::_internal_mutable_interface_event() {
  if (source_type_case() != kInterfaceEvent) {
    clear_source_type();
    set_has_interface_event();
    _impl_.source_type_.interface_event_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::InterfaceEvent >(GetArenaForAllocation());
  }
  return _impl_.source_type_.interface_event_;
}
inline ::aalyria::spacetime::api::common::InterfaceEvent* NetworkEventReport::mutable_interface_event() {
  ::aalyria::spacetime::api::common::InterfaceEvent* _msg = _internal_mutable_interface_event();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
  return _msg;
}

inline bool NetworkEventReport::has_source_type() const {
  return source_type_case() != SOURCE_TYPE_NOT_SET;
}
inline void NetworkEventReport::clear_has_source_type() {
  _impl_._oneof_case_[0] = SOURCE_TYPE_NOT_SET;
}
inline NetworkEventReport::SourceTypeCase NetworkEventReport::source_type_case() const {
  return NetworkEventReport::SourceTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RadioEvent

// string transmitter_id = 1 [json_name = "transmitterId"];
inline bool RadioEvent::has_transmitter_id() const {
  return radio_id_case() == kTransmitterId;
}
inline void RadioEvent::set_has_transmitter_id() {
  _impl_._oneof_case_[0] = kTransmitterId;
}
inline void RadioEvent::clear_transmitter_id() {
  if (radio_id_case() == kTransmitterId) {
    _impl_.radio_id_.transmitter_id_.Destroy();
    clear_has_radio_id();
  }
}
inline const std::string& RadioEvent::transmitter_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioEvent.transmitter_id)
  return _internal_transmitter_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioEvent::set_transmitter_id(Arg_&& arg,
                                                     Args_... args) {
  if (radio_id_case() != kTransmitterId) {
    clear_radio_id();

    set_has_transmitter_id();
    _impl_.radio_id_.transmitter_id_.InitDefault();
  }
  _impl_.radio_id_.transmitter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioEvent.transmitter_id)
}
inline std::string* RadioEvent::mutable_transmitter_id() {
  std::string* _s = _internal_mutable_transmitter_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioEvent.transmitter_id)
  return _s;
}
inline const std::string& RadioEvent::_internal_transmitter_id() const {
  if (radio_id_case() != kTransmitterId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.radio_id_.transmitter_id_.Get();
}
inline void RadioEvent::_internal_set_transmitter_id(const std::string& value) {
  if (radio_id_case() != kTransmitterId) {
    clear_radio_id();

    set_has_transmitter_id();
    _impl_.radio_id_.transmitter_id_.InitDefault();
  }


  _impl_.radio_id_.transmitter_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioEvent::_internal_mutable_transmitter_id() {
  if (radio_id_case() != kTransmitterId) {
    clear_radio_id();

    set_has_transmitter_id();
    _impl_.radio_id_.transmitter_id_.InitDefault();
  }
  return _impl_.radio_id_.transmitter_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioEvent::release_transmitter_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioEvent.transmitter_id)
  if (radio_id_case() != kTransmitterId) {
    return nullptr;
  }
  clear_has_radio_id();
  return _impl_.radio_id_.transmitter_id_.Release();
}
inline void RadioEvent::set_allocated_transmitter_id(std::string* value) {
  if (has_radio_id()) {
    clear_radio_id();
  }
  if (value != nullptr) {
    set_has_transmitter_id();
    _impl_.radio_id_.transmitter_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioEvent.transmitter_id)
}

// string receiver_id = 2 [json_name = "receiverId"];
inline bool RadioEvent::has_receiver_id() const {
  return radio_id_case() == kReceiverId;
}
inline void RadioEvent::set_has_receiver_id() {
  _impl_._oneof_case_[0] = kReceiverId;
}
inline void RadioEvent::clear_receiver_id() {
  if (radio_id_case() == kReceiverId) {
    _impl_.radio_id_.receiver_id_.Destroy();
    clear_has_radio_id();
  }
}
inline const std::string& RadioEvent::receiver_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioEvent.receiver_id)
  return _internal_receiver_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioEvent::set_receiver_id(Arg_&& arg,
                                                     Args_... args) {
  if (radio_id_case() != kReceiverId) {
    clear_radio_id();

    set_has_receiver_id();
    _impl_.radio_id_.receiver_id_.InitDefault();
  }
  _impl_.radio_id_.receiver_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioEvent.receiver_id)
}
inline std::string* RadioEvent::mutable_receiver_id() {
  std::string* _s = _internal_mutable_receiver_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.RadioEvent.receiver_id)
  return _s;
}
inline const std::string& RadioEvent::_internal_receiver_id() const {
  if (radio_id_case() != kReceiverId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.radio_id_.receiver_id_.Get();
}
inline void RadioEvent::_internal_set_receiver_id(const std::string& value) {
  if (radio_id_case() != kReceiverId) {
    clear_radio_id();

    set_has_receiver_id();
    _impl_.radio_id_.receiver_id_.InitDefault();
  }


  _impl_.radio_id_.receiver_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioEvent::_internal_mutable_receiver_id() {
  if (radio_id_case() != kReceiverId) {
    clear_radio_id();

    set_has_receiver_id();
    _impl_.radio_id_.receiver_id_.InitDefault();
  }
  return _impl_.radio_id_.receiver_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioEvent::release_receiver_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.RadioEvent.receiver_id)
  if (radio_id_case() != kReceiverId) {
    return nullptr;
  }
  clear_has_radio_id();
  return _impl_.radio_id_.receiver_id_.Release();
}
inline void RadioEvent::set_allocated_receiver_id(std::string* value) {
  if (has_radio_id()) {
    clear_radio_id();
  }
  if (value != nullptr) {
    set_has_receiver_id();
    _impl_.radio_id_.receiver_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.RadioEvent.receiver_id)
}

// .aalyria.spacetime.api.common.RadioEvent.LinkStatus link_status = 3 [json_name = "linkStatus"];
inline bool RadioEvent::has_link_status() const {
  return event_case() == kLinkStatus;
}
inline void RadioEvent::set_has_link_status() {
  _impl_._oneof_case_[1] = kLinkStatus;
}
inline void RadioEvent::clear_link_status() {
  if (event_case() == kLinkStatus) {
    _impl_.event_.link_status_ = 0;
    clear_has_event();
  }
}
inline ::aalyria::spacetime::api::common::RadioEvent_LinkStatus RadioEvent::link_status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.RadioEvent.link_status)
  return _internal_link_status();
}
inline void RadioEvent::set_link_status(::aalyria::spacetime::api::common::RadioEvent_LinkStatus value) {
   _internal_set_link_status(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.RadioEvent.link_status)
}
inline ::aalyria::spacetime::api::common::RadioEvent_LinkStatus RadioEvent::_internal_link_status() const {
  if (event_case() == kLinkStatus) {
    return static_cast<::aalyria::spacetime::api::common::RadioEvent_LinkStatus>(_impl_.event_.link_status_);
  }
  return static_cast<::aalyria::spacetime::api::common::RadioEvent_LinkStatus>(0);
}
inline void RadioEvent::_internal_set_link_status(::aalyria::spacetime::api::common::RadioEvent_LinkStatus value) {
  assert(::aalyria::spacetime::api::common::RadioEvent_LinkStatus_IsValid(value));
  if (event_case() != kLinkStatus) {
    clear_event();
    set_has_link_status();
  }
  _impl_.event_.link_status_ = value;
}

inline bool RadioEvent::has_radio_id() const {
  return radio_id_case() != RADIO_ID_NOT_SET;
}
inline void RadioEvent::clear_has_radio_id() {
  _impl_._oneof_case_[0] = RADIO_ID_NOT_SET;
}
inline bool RadioEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void RadioEvent::clear_has_event() {
  _impl_._oneof_case_[1] = EVENT_NOT_SET;
}
inline RadioEvent::RadioIdCase RadioEvent::radio_id_case() const {
  return RadioEvent::RadioIdCase(_impl_._oneof_case_[0]);
}
inline RadioEvent::EventCase RadioEvent::event_case() const {
  return RadioEvent::EventCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// PortEvent

// optional string port_id = 1 [json_name = "portId"];
inline bool PortEvent::has_port_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PortEvent::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PortEvent::port_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PortEvent.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortEvent::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PortEvent.port_id)
}
inline std::string* PortEvent::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PortEvent.port_id)
  return _s;
}
inline const std::string& PortEvent::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void PortEvent::_internal_set_port_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PortEvent::_internal_mutable_port_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PortEvent::release_port_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PortEvent.port_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.port_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.port_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PortEvent::set_allocated_port_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PortEvent.port_id)
}

// .aalyria.spacetime.api.common.PortEvent.PortStatus port_status = 2 [json_name = "portStatus"];
inline bool PortEvent::has_port_status() const {
  return event_case() == kPortStatus;
}
inline void PortEvent::set_has_port_status() {
  _impl_._oneof_case_[0] = kPortStatus;
}
inline void PortEvent::clear_port_status() {
  if (event_case() == kPortStatus) {
    _impl_.event_.port_status_ = 0;
    clear_has_event();
  }
}
inline ::aalyria::spacetime::api::common::PortEvent_PortStatus PortEvent::port_status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PortEvent.port_status)
  return _internal_port_status();
}
inline void PortEvent::set_port_status(::aalyria::spacetime::api::common::PortEvent_PortStatus value) {
   _internal_set_port_status(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PortEvent.port_status)
}
inline ::aalyria::spacetime::api::common::PortEvent_PortStatus PortEvent::_internal_port_status() const {
  if (event_case() == kPortStatus) {
    return static_cast<::aalyria::spacetime::api::common::PortEvent_PortStatus>(_impl_.event_.port_status_);
  }
  return static_cast<::aalyria::spacetime::api::common::PortEvent_PortStatus>(0);
}
inline void PortEvent::_internal_set_port_status(::aalyria::spacetime::api::common::PortEvent_PortStatus value) {
  assert(::aalyria::spacetime::api::common::PortEvent_PortStatus_IsValid(value));
  if (event_case() != kPortStatus) {
    clear_event();
    set_has_port_status();
  }
  _impl_.event_.port_status_ = value;
}

inline bool PortEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void PortEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline PortEvent::EventCase PortEvent::event_case() const {
  return PortEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InterfaceEvent

// optional string interface_id = 1 [json_name = "interfaceId"];
inline bool InterfaceEvent::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InterfaceEvent::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InterfaceEvent::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceEvent.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InterfaceEvent::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceEvent.interface_id)
}
inline std::string* InterfaceEvent::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.InterfaceEvent.interface_id)
  return _s;
}
inline const std::string& InterfaceEvent::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void InterfaceEvent::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InterfaceEvent::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* InterfaceEvent::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.InterfaceEvent.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InterfaceEvent::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.InterfaceEvent.interface_id)
}

// .aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus interface_status = 2 [json_name = "interfaceStatus"];
inline bool InterfaceEvent::has_interface_status() const {
  return event_case() == kInterfaceStatus;
}
inline void InterfaceEvent::set_has_interface_status() {
  _impl_._oneof_case_[0] = kInterfaceStatus;
}
inline void InterfaceEvent::clear_interface_status() {
  if (event_case() == kInterfaceStatus) {
    _impl_.event_.interface_status_ = 0;
    clear_has_event();
  }
}
inline ::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus InterfaceEvent::interface_status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceEvent.interface_status)
  return _internal_interface_status();
}
inline void InterfaceEvent::set_interface_status(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus value) {
   _internal_set_interface_status(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceEvent.interface_status)
}
inline ::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus InterfaceEvent::_internal_interface_status() const {
  if (event_case() == kInterfaceStatus) {
    return static_cast<::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus>(_impl_.event_.interface_status_);
  }
  return static_cast<::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus>(0);
}
inline void InterfaceEvent::_internal_set_interface_status(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus value) {
  assert(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus_IsValid(value));
  if (event_case() != kInterfaceStatus) {
    clear_event();
    set_has_interface_status();
  }
  _impl_.event_.interface_status_ = value;
}

// string ip_address = 3 [json_name = "ipAddress"];
inline bool InterfaceEvent::has_ip_address() const {
  return event_case() == kIpAddress;
}
inline void InterfaceEvent::set_has_ip_address() {
  _impl_._oneof_case_[0] = kIpAddress;
}
inline void InterfaceEvent::clear_ip_address() {
  if (event_case() == kIpAddress) {
    _impl_.event_.ip_address_.Destroy();
    clear_has_event();
  }
}
inline const std::string& InterfaceEvent::ip_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.InterfaceEvent.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InterfaceEvent::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  if (event_case() != kIpAddress) {
    clear_event();

    set_has_ip_address();
    _impl_.event_.ip_address_.InitDefault();
  }
  _impl_.event_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.InterfaceEvent.ip_address)
}
inline std::string* InterfaceEvent::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.InterfaceEvent.ip_address)
  return _s;
}
inline const std::string& InterfaceEvent::_internal_ip_address() const {
  if (event_case() != kIpAddress) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.event_.ip_address_.Get();
}
inline void InterfaceEvent::_internal_set_ip_address(const std::string& value) {
  if (event_case() != kIpAddress) {
    clear_event();

    set_has_ip_address();
    _impl_.event_.ip_address_.InitDefault();
  }


  _impl_.event_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* InterfaceEvent::_internal_mutable_ip_address() {
  if (event_case() != kIpAddress) {
    clear_event();

    set_has_ip_address();
    _impl_.event_.ip_address_.InitDefault();
  }
  return _impl_.event_.ip_address_.Mutable( GetArenaForAllocation());
}
inline std::string* InterfaceEvent::release_ip_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.InterfaceEvent.ip_address)
  if (event_case() != kIpAddress) {
    return nullptr;
  }
  clear_has_event();
  return _impl_.event_.ip_address_.Release();
}
inline void InterfaceEvent::set_allocated_ip_address(std::string* value) {
  if (has_event()) {
    clear_event();
  }
  if (value != nullptr) {
    set_has_ip_address();
    _impl_.event_.ip_address_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.InterfaceEvent.ip_address)
}

inline bool InterfaceEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void InterfaceEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline InterfaceEvent::EventCase InterfaceEvent::event_case() const {
  return InterfaceEvent::EventCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus>() {
  return ::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::RadioEvent_LinkStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::RadioEvent_LinkStatus>() {
  return ::aalyria::spacetime::api::common::RadioEvent_LinkStatus_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::PortEvent_PortStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::PortEvent_PortStatus>() {
  return ::aalyria::spacetime::api::common::PortEvent_PortStatus_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus>() {
  return ::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2ftelemetry_2eproto_2epb_2eh
