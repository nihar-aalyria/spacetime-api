// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/telemetry.proto

#include "api/common/telemetry.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
template <typename>
PROTOBUF_CONSTEXPR NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NetworkStatsReport_FlowStatsByIdEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStatsReport_FlowStatsByIdEntry_DoNotUseDefaultTypeInternal _NetworkStatsReport_FlowStatsByIdEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NetworkStatsReport::NetworkStatsReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interface_stats_by_id_)*/{}
  , /*decltype(_impl_.radio_stats_by_interface_id_)*/{}
  , /*decltype(_impl_.beam_stats_by_antenna_id_)*/{}
  , /*decltype(_impl_.flow_stats_by_id_)*/{}
  , /*decltype(_impl_.node_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/nullptr} {}
struct NetworkStatsReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStatsReportDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStatsReportDefaultTypeInternal() {}
  union {
    NetworkStatsReport _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStatsReportDefaultTypeInternal _NetworkStatsReport_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BeamStats_TargetingStats::BeamStats_TargetingStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.beam_task_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.target_identifier_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.target_location_)*/nullptr
  , /*decltype(_impl_.connection_status_)*/ 0
} {}
struct BeamStats_TargetingStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeamStats_TargetingStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeamStats_TargetingStatsDefaultTypeInternal() {}
  union {
    BeamStats_TargetingStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeamStats_TargetingStatsDefaultTypeInternal _BeamStats_TargetingStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BeamStats_GimbalStats::BeamStats_GimbalStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.pointing_vector_)*/nullptr
  , /*decltype(_impl_.initialized_)*/ false

  , /*decltype(_impl_.site_orientation_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BeamStats_GimbalStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeamStats_GimbalStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeamStats_GimbalStatsDefaultTypeInternal() {}
  union {
    BeamStats_GimbalStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeamStats_GimbalStatsDefaultTypeInternal _BeamStats_GimbalStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR BeamStats::BeamStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.targeting_)*/nullptr
  , /*decltype(_impl_.gimbal_)*/nullptr} {}
struct BeamStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeamStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeamStatsDefaultTypeInternal() {}
  union {
    BeamStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeamStatsDefaultTypeInternal _BeamStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TransmitterStats::TransmitterStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.receiver_physical_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.data_rate_bps_)*/ 0

  , /*decltype(_impl_.tx_packet_error_rate_)*/ 0
} {}
struct TransmitterStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransmitterStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransmitterStatsDefaultTypeInternal() {}
  union {
    TransmitterStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransmitterStatsDefaultTypeInternal _TransmitterStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReceiverStats::ReceiverStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.power_at_receiver_output_by_chain_dbw_)*/ {}

  , /*decltype(_impl_.transmitter_physical_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.power_at_receiver_output_dbw_)*/ 0

  , /*decltype(_impl_.mse_db_)*/ 0

  , /*decltype(_impl_.carrier_to_noise_plus_interference_db_)*/ 0
} {}
struct ReceiverStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiverStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiverStatsDefaultTypeInternal() {}
  union {
    ReceiverStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiverStatsDefaultTypeInternal _ReceiverStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RadioStats::RadioStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transmitter_stats_)*/{}
  , /*decltype(_impl_.receiver_stats_)*/{}
  , /*decltype(_impl_.interface_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct RadioStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadioStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadioStatsDefaultTypeInternal() {}
  union {
    RadioStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadioStatsDefaultTypeInternal _RadioStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterfaceStats::InterfaceStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.tx_packets_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_packets_)*/ ::int64_t{0}

  , /*decltype(_impl_.tx_bytes_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_bytes_)*/ ::int64_t{0}

  , /*decltype(_impl_.tx_dropped_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_dropped_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_errors_)*/ ::int64_t{0}

  , /*decltype(_impl_.tx_errors_)*/ ::int64_t{0}
} {}
struct InterfaceStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterfaceStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterfaceStatsDefaultTypeInternal() {}
  union {
    InterfaceStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterfaceStatsDefaultTypeInternal _InterfaceStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FlowStats::FlowStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.tx_packets_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_packets_)*/ ::int64_t{0}

  , /*decltype(_impl_.tx_bytes_)*/ ::int64_t{0}

  , /*decltype(_impl_.rx_bytes_)*/ ::int64_t{0}
} {}
struct FlowStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowStatsDefaultTypeInternal() {}
  union {
    FlowStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowStatsDefaultTypeInternal _FlowStats_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NetworkEventReport::NetworkEventReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.source_type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct NetworkEventReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkEventReportDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkEventReportDefaultTypeInternal() {}
  union {
    NetworkEventReport _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkEventReportDefaultTypeInternal _NetworkEventReport_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RadioEvent::RadioEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.radio_id_)*/{}
  , /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RadioEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadioEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadioEventDefaultTypeInternal() {}
  union {
    RadioEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadioEventDefaultTypeInternal _RadioEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PortEvent::PortEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.port_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PortEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortEventDefaultTypeInternal() {}
  union {
    PortEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortEventDefaultTypeInternal _PortEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InterfaceEvent::InterfaceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interface_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.event_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct InterfaceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterfaceEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterfaceEventDefaultTypeInternal() {}
  union {
    InterfaceEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterfaceEventDefaultTypeInternal _InterfaceEvent_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fcommon_2ftelemetry_2eproto[17];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto[4];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fcommon_2ftelemetry_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fcommon_2ftelemetry_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.radio_stats_by_interface_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.interface_stats_by_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.beam_stats_by_antenna_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkStatsReport, _impl_.flow_stats_by_id_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _impl_.target_location_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _impl_.connection_status_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _impl_.beam_task_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_TargetingStats, _impl_.target_identifier_),
    2,
    3,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_.location_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_.pointing_vector_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_.initialized_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_.site_orientation_),
    0,
    ~0u,
    ~0u,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats, _impl_.targeting_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats, _impl_.gimbal_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _impl_.receiver_physical_address_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _impl_.data_rate_bps_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::TransmitterStats, _impl_.tx_packet_error_rate_),
    1,
    0,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.transmitter_physical_address_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.power_at_receiver_output_dbw_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.power_at_receiver_output_by_chain_dbw_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.mse_db_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::ReceiverStats, _impl_.carrier_to_noise_plus_interference_db_),
    1,
    0,
    2,
    ~0u,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioStats, _impl_.interface_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioStats, _impl_.transmitter_stats_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioStats, _impl_.receiver_stats_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.tx_packets_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.rx_packets_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.tx_bytes_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.rx_bytes_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.tx_dropped_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.rx_dropped_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.rx_errors_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceStats, _impl_.tx_errors_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_.tx_packets_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_.rx_packets_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_.tx_bytes_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::FlowStats, _impl_.rx_bytes_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_.timestamp_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_.source_type_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioEvent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioEvent, _impl_.radio_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioEvent, _impl_.event_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _impl_.port_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _impl_.event_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _impl_.interface_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _impl_.event_),
    0,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse)},
        { 12, 22, -1, sizeof(::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse)},
        { 24, 34, -1, sizeof(::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse)},
        { 36, 46, -1, sizeof(::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse)},
        { 48, 62, -1, sizeof(::aalyria::spacetime::api::common::NetworkStatsReport)},
        { 68, 80, -1, sizeof(::aalyria::spacetime::api::common::BeamStats_TargetingStats)},
        { 84, 98, -1, sizeof(::aalyria::spacetime::api::common::BeamStats_GimbalStats)},
        { 103, 114, -1, sizeof(::aalyria::spacetime::api::common::BeamStats)},
        { 117, 129, -1, sizeof(::aalyria::spacetime::api::common::TransmitterStats)},
        { 133, 147, -1, sizeof(::aalyria::spacetime::api::common::ReceiverStats)},
        { 153, 164, -1, sizeof(::aalyria::spacetime::api::common::RadioStats)},
        { 167, 184, -1, sizeof(::aalyria::spacetime::api::common::InterfaceStats)},
        { 193, 206, -1, sizeof(::aalyria::spacetime::api::common::FlowStats)},
        { 211, 225, -1, sizeof(::aalyria::spacetime::api::common::NetworkEventReport)},
        { 230, -1, -1, sizeof(::aalyria::spacetime::api::common::RadioEvent)},
        { 243, 254, -1, sizeof(::aalyria::spacetime::api::common::PortEvent)},
        { 256, 268, -1, sizeof(::aalyria::spacetime::api::common::InterfaceEvent)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::common::_NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse_default_instance_._instance,
    &::aalyria::spacetime::api::common::_NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse_default_instance_._instance,
    &::aalyria::spacetime::api::common::_NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse_default_instance_._instance,
    &::aalyria::spacetime::api::common::_NetworkStatsReport_FlowStatsByIdEntry_DoNotUse_default_instance_._instance,
    &::aalyria::spacetime::api::common::_NetworkStatsReport_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BeamStats_TargetingStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BeamStats_GimbalStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_BeamStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_TransmitterStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_ReceiverStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_RadioStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_InterfaceStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_FlowStats_default_instance_._instance,
    &::aalyria::spacetime::api::common::_NetworkEventReport_default_instance_._instance,
    &::aalyria::spacetime::api::common::_RadioEvent_default_instance_._instance,
    &::aalyria::spacetime::api::common::_PortEvent_default_instance_._instance,
    &::aalyria::spacetime::api::common::_InterfaceEvent_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fcommon_2ftelemetry_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\032api/common/telemetry.proto\022\034aalyria.sp"
    "acetime.api.common\032\034api/common/coordinat"
    "es.proto\032\025api/common/time.proto\"\277\010\n\022Netw"
    "orkStatsReport\022\027\n\007node_id\030\007 \001(\tR\006nodeId\022"
    "D\n\ttimestamp\030\001 \001(\0132&.aalyria.spacetime.a"
    "pi.common.DateTimeR\ttimestamp\022\213\001\n\033radio_"
    "stats_by_interface_id\030\004 \003(\0132M.aalyria.sp"
    "acetime.api.common.NetworkStatsReport.Ra"
    "dioStatsByInterfaceIdEntryR\027radioStatsBy"
    "InterfaceId\022{\n\025interface_stats_by_id\030\003 \003"
    "(\0132H.aalyria.spacetime.api.common.Networ"
    "kStatsReport.InterfaceStatsByIdEntryR\022in"
    "terfaceStatsById\022\202\001\n\030beam_stats_by_anten"
    "na_id\030\005 \003(\0132J.aalyria.spacetime.api.comm"
    "on.NetworkStatsReport.BeamStatsByAntenna"
    "IdEntryR\024beamStatsByAntennaId\022l\n\020flow_st"
    "ats_by_id\030\006 \003(\0132C.aalyria.spacetime.api."
    "common.NetworkStatsReport.FlowStatsByIdE"
    "ntryR\rflowStatsById\032t\n\034RadioStatsByInter"
    "faceIdEntry\022\020\n\003key\030\001 \001(\tR\003key\022>\n\005value\030\002"
    " \001(\0132(.aalyria.spacetime.api.common.Radi"
    "oStatsR\005value:\0028\001\032s\n\027InterfaceStatsByIdE"
    "ntry\022\020\n\003key\030\001 \001(\tR\003key\022B\n\005value\030\002 \001(\0132,."
    "aalyria.spacetime.api.common.InterfaceSt"
    "atsR\005value:\0028\001\032p\n\031BeamStatsByAntennaIdEn"
    "try\022\020\n\003key\030\001 \001(\tR\003key\022=\n\005value\030\002 \001(\0132\'.a"
    "alyria.spacetime.api.common.BeamStatsR\005v"
    "alue:\0028\001\032i\n\022FlowStatsByIdEntry\022\020\n\003key\030\001 "
    "\001(\tR\003key\022=\n\005value\030\002 \001(\0132\'.aalyria.spacet"
    "ime.api.common.FlowStatsR\005value:\0028\001J\004\010\002\020"
    "\003\"\374\007\n\tBeamStats\022D\n\ttimestamp\030\001 \001(\0132&.aal"
    "yria.spacetime.api.common.DateTimeR\ttime"
    "stamp\022T\n\ttargeting\030\002 \001(\01326.aalyria.space"
    "time.api.common.BeamStats.TargetingStats"
    "R\ttargeting\022K\n\006gimbal\030\003 \001(\01323.aalyria.sp"
    "acetime.api.common.BeamStats.GimbalStats"
    "R\006gimbal\032\345\002\n\016TargetingStats\022T\n\017target_lo"
    "cation\030\001 \001(\0132+.aalyria.spacetime.api.com"
    "mon.GeodeticWgs84R\016targetLocation\022t\n\021con"
    "nection_status\030\002 \001(\0162G.aalyria.spacetime"
    ".api.common.BeamStats.TargetingStats.Con"
    "nectionStatusR\020connectionStatus\022 \n\014beam_"
    "task_id\030\003 \001(\tR\nbeamTaskId\022+\n\021target_iden"
    "tifier\030\004 \001(\tR\020targetIdentifier\"8\n\020Connec"
    "tionStatus\022\013\n\007UNKNOWN\020\000\022\013\n\007SEEKING\020\001\022\n\n\006"
    "LOCKED\020\002\032\235\003\n\013GimbalStats\022G\n\010location\030\001 \001"
    "(\0132+.aalyria.spacetime.api.common.Geodet"
    "icWgs84R\010location\022a\n\026orientation_quatern"
    "ion\030\002 \001(\0132(.aalyria.spacetime.api.common"
    ".QuaternionH\000R\025orientationQuaternion\022U\n\017"
    "orientation_ypr\030\003 \001(\0132*.aalyria.spacetim"
    "e.api.common.YawPitchRollH\000R\016orientation"
    "Ypr\022U\n\017pointing_vector\030\004 \001(\0132,.aalyria.s"
    "pacetime.api.common.PointingVectorR\016poin"
    "tingVector\022 \n\013initialized\030\005 \001(\010R\013initial"
    "izedB\022\n\020site_orientation\"\357\001\n\020Transmitter"
    "Stats\022D\n\ttimestamp\030\004 \001(\0132&.aalyria.space"
    "time.api.common.DateTimeR\ttimestamp\022:\n\031r"
    "eceiver_physical_address\030\005 \001(\tR\027receiver"
    "PhysicalAddress\022\"\n\rdata_rate_bps\030\002 \001(\001R\013"
    "dataRateBps\022/\n\024tx_packet_error_rate\030\003 \001("
    "\001R\021txPacketErrorRateJ\004\010\001\020\002\"\225\003\n\rReceiverS"
    "tats\022D\n\ttimestamp\030\003 \001(\0132&.aalyria.spacet"
    "ime.api.common.DateTimeR\ttimestamp\022@\n\034tr"
    "ansmitter_physical_address\030\004 \001(\tR\032transm"
    "itterPhysicalAddress\022>\n\034power_at_receive"
    "r_output_dbw\030\002 \001(\001R\030powerAtReceiverOutpu"
    "tDbw\022N\n%power_at_receiver_output_by_chai"
    "n_dbw\030\005 \003(\001R\037powerAtReceiverOutputByChai"
    "nDbw\022\025\n\006mse_db\030\006 \001(\001R\005mseDb\022O\n%carrier_t"
    "o_noise_plus_interference_db\030\007 \001(\001R carr"
    "ierToNoisePlusInterferenceDbJ\004\010\001\020\002\"\354\001\n\nR"
    "adioStats\022!\n\014interface_id\030\005 \001(\tR\013interfa"
    "ceId\022[\n\021transmitter_stats\030\003 \003(\0132..aalyri"
    "a.spacetime.api.common.TransmitterStatsR"
    "\020transmitterStats\022R\n\016receiver_stats\030\004 \003("
    "\0132+.aalyria.spacetime.api.common.Receive"
    "rStatsR\rreceiverStatsJ\004\010\001\020\002J\004\010\002\020\003\"\302\002\n\016In"
    "terfaceStats\022D\n\ttimestamp\030\t \001(\0132&.aalyri"
    "a.spacetime.api.common.DateTimeR\ttimesta"
    "mp\022\035\n\ntx_packets\030\001 \001(\003R\ttxPackets\022\035\n\nrx_"
    "packets\030\002 \001(\003R\trxPackets\022\031\n\010tx_bytes\030\003 \001"
    "(\003R\007txBytes\022\031\n\010rx_bytes\030\004 \001(\003R\007rxBytes\022\035"
    "\n\ntx_dropped\030\005 \001(\003R\ttxDropped\022\035\n\nrx_drop"
    "ped\030\006 \001(\003R\trxDropped\022\033\n\trx_errors\030\007 \001(\003R"
    "\010rxErrors\022\033\n\ttx_errors\030\010 \001(\003R\010txErrors\"\305"
    "\001\n\tFlowStats\022D\n\ttimestamp\030\001 \001(\0132&.aalyri"
    "a.spacetime.api.common.DateTimeR\ttimesta"
    "mp\022\035\n\ntx_packets\030\002 \001(\003R\ttxPackets\022\035\n\nrx_"
    "packets\030\003 \001(\003R\trxPackets\022\031\n\010tx_bytes\030\004 \001"
    "(\003R\007txBytes\022\031\n\010rx_bytes\030\005 \001(\003R\007rxBytes\"\362"
    "\002\n\022NetworkEventReport\022\027\n\007node_id\030\005 \001(\tR\006"
    "nodeId\022D\n\ttimestamp\030\001 \001(\0132&.aalyria.spac"
    "etime.api.common.DateTimeR\ttimestamp\022K\n\013"
    "radio_event\030\002 \001(\0132(.aalyria.spacetime.ap"
    "i.common.RadioEventH\000R\nradioEvent\022H\n\npor"
    "t_event\030\003 \001(\0132\'.aalyria.spacetime.api.co"
    "mmon.PortEventH\000R\tportEvent\022W\n\017interface"
    "_event\030\004 \001(\0132,.aalyria.spacetime.api.com"
    "mon.InterfaceEventH\000R\016interfaceEventB\r\n\013"
    "source_type\"\362\001\n\nRadioEvent\022\'\n\016transmitte"
    "r_id\030\001 \001(\tH\000R\rtransmitterId\022!\n\013receiver_"
    "id\030\002 \001(\tH\000R\nreceiverId\022V\n\013link_status\030\003 "
    "\001(\01623.aalyria.spacetime.api.common.Radio"
    "Event.LinkStatusH\001R\nlinkStatus\"+\n\nLinkSt"
    "atus\022\013\n\007UNKNOWN\020\000\022\010\n\004DOWN\020\001\022\006\n\002UP\020\002B\n\n\010r"
    "adio_idB\007\n\005event\"\261\001\n\tPortEvent\022\027\n\007port_i"
    "d\030\001 \001(\tR\006portId\022U\n\013port_status\030\002 \001(\01622.a"
    "alyria.spacetime.api.common.PortEvent.Po"
    "rtStatusH\000R\nportStatus\"+\n\nPortStatus\022\013\n\007"
    "UNKNOWN\020\000\022\010\n\004DOWN\020\001\022\006\n\002UP\020\002B\007\n\005event\"\203\002\n"
    "\016InterfaceEvent\022!\n\014interface_id\030\001 \001(\tR\013i"
    "nterfaceId\022i\n\020interface_status\030\002 \001(\0162<.a"
    "alyria.spacetime.api.common.InterfaceEve"
    "nt.InterfaceStatusH\000R\017interfaceStatus\022\037\n"
    "\nip_address\030\003 \001(\tH\000R\tipAddress\"9\n\017Interf"
    "aceStatus\022\013\n\007UNKNOWN\020\000\022\014\n\010DISABLED\020\001\022\013\n\007"
    "ENABLED\020\002B\007\n\005eventBD\n com.aalyria.spacet"
    "ime.api.commonZ aalyria.com/spacetime/ap"
    "i/common"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fcommon_2ftelemetry_2eproto_deps[2] =
    {
        &::descriptor_table_api_2fcommon_2fcoordinates_2eproto,
        &::descriptor_table_api_2fcommon_2ftime_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fcommon_2ftelemetry_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fcommon_2ftelemetry_2eproto = {
    false,
    false,
    4768,
    descriptor_table_protodef_api_2fcommon_2ftelemetry_2eproto,
    "api/common/telemetry.proto",
    &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
    descriptor_table_api_2fcommon_2ftelemetry_2eproto_deps,
    2,
    17,
    schemas,
    file_default_instances,
    TableStruct_api_2fcommon_2ftelemetry_2eproto::offsets,
    file_level_metadata_api_2fcommon_2ftelemetry_2eproto,
    file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto,
    file_level_service_descriptors_api_2fcommon_2ftelemetry_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter() {
  return &descriptor_table_api_2fcommon_2ftelemetry_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fcommon_2ftelemetry_2eproto(&descriptor_table_api_2fcommon_2ftelemetry_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BeamStats_TargetingStats_ConnectionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2ftelemetry_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto[0];
}
bool BeamStats_TargetingStats_ConnectionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::UNKNOWN;
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::SEEKING;
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::LOCKED;
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::ConnectionStatus_MIN;
constexpr BeamStats_TargetingStats_ConnectionStatus BeamStats_TargetingStats::ConnectionStatus_MAX;
constexpr int BeamStats_TargetingStats::ConnectionStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadioEvent_LinkStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2ftelemetry_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto[1];
}
bool RadioEvent_LinkStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr RadioEvent_LinkStatus RadioEvent::UNKNOWN;
constexpr RadioEvent_LinkStatus RadioEvent::DOWN;
constexpr RadioEvent_LinkStatus RadioEvent::UP;
constexpr RadioEvent_LinkStatus RadioEvent::LinkStatus_MIN;
constexpr RadioEvent_LinkStatus RadioEvent::LinkStatus_MAX;
constexpr int RadioEvent::LinkStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortEvent_PortStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2ftelemetry_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto[2];
}
bool PortEvent_PortStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr PortEvent_PortStatus PortEvent::UNKNOWN;
constexpr PortEvent_PortStatus PortEvent::DOWN;
constexpr PortEvent_PortStatus PortEvent::UP;
constexpr PortEvent_PortStatus PortEvent::PortStatus_MIN;
constexpr PortEvent_PortStatus PortEvent::PortStatus_MAX;
constexpr int PortEvent::PortStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InterfaceEvent_InterfaceStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fcommon_2ftelemetry_2eproto);
  return file_level_enum_descriptors_api_2fcommon_2ftelemetry_2eproto[3];
}
bool InterfaceEvent_InterfaceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr InterfaceEvent_InterfaceStatus InterfaceEvent::UNKNOWN;
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent::DISABLED;
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent::ENABLED;
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent::InterfaceStatus_MIN;
constexpr InterfaceEvent_InterfaceStatus InterfaceEvent::InterfaceStatus_MAX;
constexpr int InterfaceEvent::InterfaceStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse() {}
NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::MergeFrom(const NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[0]);
}
// ===================================================================

NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse() {}
NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::MergeFrom(const NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[1]);
}
// ===================================================================

NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse() {}
NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::MergeFrom(const NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[2]);
}
// ===================================================================

NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse() {}
NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::MergeFrom(const NetworkStatsReport_FlowStatsByIdEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[3]);
}
// ===================================================================

class NetworkStatsReport::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkStatsReport>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NetworkStatsReport, _impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const NetworkStatsReport* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
NetworkStatsReport::_Internal::timestamp(const NetworkStatsReport* msg) {
  return *msg->_impl_.timestamp_;
}
void NetworkStatsReport::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
NetworkStatsReport::NetworkStatsReport(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.NetworkStatsReport)
}
NetworkStatsReport::NetworkStatsReport(const NetworkStatsReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetworkStatsReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.interface_stats_by_id_)*/{}
    , /*decltype(_impl_.radio_stats_by_interface_id_)*/{}
    , /*decltype(_impl_.beam_stats_by_antenna_id_)*/{}
    , /*decltype(_impl_.flow_stats_by_id_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.timestamp_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.interface_stats_by_id_.MergeFrom(from._impl_.interface_stats_by_id_);
  _this->_impl_.radio_stats_by_interface_id_.MergeFrom(from._impl_.radio_stats_by_interface_id_);
  _this->_impl_.beam_stats_by_antenna_id_.MergeFrom(from._impl_.beam_stats_by_antenna_id_);
  _this->_impl_.flow_stats_by_id_.MergeFrom(from._impl_.flow_stats_by_id_);
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.node_id_.Set(from._internal_node_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.NetworkStatsReport)
}

inline void NetworkStatsReport::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.interface_stats_by_id_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.radio_stats_by_interface_id_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.beam_stats_by_antenna_id_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.flow_stats_by_id_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.timestamp_){nullptr}
  };
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkStatsReport::~NetworkStatsReport() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.NetworkStatsReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkStatsReport::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.interface_stats_by_id_.~MapField();
  _impl_.radio_stats_by_interface_id_.~MapField();
  _impl_.beam_stats_by_antenna_id_.~MapField();
  _impl_.flow_stats_by_id_.~MapField();
  _impl_.node_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void NetworkStatsReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkStatsReport::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.NetworkStatsReport)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.interface_stats_by_id_.Clear();
  _impl_.radio_stats_by_interface_id_.Clear();
  _impl_.beam_stats_by_antenna_id_.Clear();
  _impl_.flow_stats_by_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.node_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetworkStatsReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, .aalyria.spacetime.api.common.InterfaceStats> interface_stats_by_id = 3 [json_name = "interfaceStatsById"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.interface_stats_by_id_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, .aalyria.spacetime.api.common.RadioStats> radio_stats_by_interface_id = 4 [json_name = "radioStatsByInterfaceId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.radio_stats_by_interface_id_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, .aalyria.spacetime.api.common.BeamStats> beam_stats_by_antenna_id = 5 [json_name = "beamStatsByAntennaId"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.beam_stats_by_antenna_id_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<string, .aalyria.spacetime.api.common.FlowStats> flow_stats_by_id = 6 [json_name = "flowStatsById"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.flow_stats_by_id_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string node_id = 7 [json_name = "nodeId"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.NetworkStatsReport.node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NetworkStatsReport::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.NetworkStatsReport)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // map<string, .aalyria.spacetime.api.common.InterfaceStats> interface_stats_by_id = 3 [json_name = "interfaceStatsById"];
  if (!this->_internal_interface_stats_by_id().empty()) {
    using MapType = ::_pb::Map<std::string, ::aalyria::spacetime::api::common::InterfaceStats>;
    using WireHelper = NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_interface_stats_by_id();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.NetworkStatsReport.interface_stats_by_id");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .aalyria.spacetime.api.common.RadioStats> radio_stats_by_interface_id = 4 [json_name = "radioStatsByInterfaceId"];
  if (!this->_internal_radio_stats_by_interface_id().empty()) {
    using MapType = ::_pb::Map<std::string, ::aalyria::spacetime::api::common::RadioStats>;
    using WireHelper = NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_radio_stats_by_interface_id();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.NetworkStatsReport.radio_stats_by_interface_id");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .aalyria.spacetime.api.common.BeamStats> beam_stats_by_antenna_id = 5 [json_name = "beamStatsByAntennaId"];
  if (!this->_internal_beam_stats_by_antenna_id().empty()) {
    using MapType = ::_pb::Map<std::string, ::aalyria::spacetime::api::common::BeamStats>;
    using WireHelper = NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_beam_stats_by_antenna_id();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.NetworkStatsReport.beam_stats_by_antenna_id");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .aalyria.spacetime.api.common.FlowStats> flow_stats_by_id = 6 [json_name = "flowStatsById"];
  if (!this->_internal_flow_stats_by_id().empty()) {
    using MapType = ::_pb::Map<std::string, ::aalyria::spacetime::api::common::FlowStats>;
    using WireHelper = NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_flow_stats_by_id();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(entry.first.data(), static_cast<int>(entry.first.length()),
 ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.NetworkStatsReport.flow_stats_by_id");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional string node_id = 7 [json_name = "nodeId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_node_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.NetworkStatsReport.node_id");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.NetworkStatsReport)
  return target;
}

::size_t NetworkStatsReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.NetworkStatsReport)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .aalyria.spacetime.api.common.InterfaceStats> interface_stats_by_id = 3 [json_name = "interfaceStatsById"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_interface_stats_by_id_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::InterfaceStats >::const_iterator
      it = this->_internal_interface_stats_by_id().begin();
      it != this->_internal_interface_stats_by_id().end(); ++it) {
    total_size += NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .aalyria.spacetime.api.common.RadioStats> radio_stats_by_interface_id = 4 [json_name = "radioStatsByInterfaceId"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_radio_stats_by_interface_id_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::RadioStats >::const_iterator
      it = this->_internal_radio_stats_by_interface_id().begin();
      it != this->_internal_radio_stats_by_interface_id().end(); ++it) {
    total_size += NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .aalyria.spacetime.api.common.BeamStats> beam_stats_by_antenna_id = 5 [json_name = "beamStatsByAntennaId"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_beam_stats_by_antenna_id_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::BeamStats >::const_iterator
      it = this->_internal_beam_stats_by_antenna_id().begin();
      it != this->_internal_beam_stats_by_antenna_id().end(); ++it) {
    total_size += NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .aalyria.spacetime.api.common.FlowStats> flow_stats_by_id = 6 [json_name = "flowStatsById"];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_flow_stats_by_id_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::FlowStats >::const_iterator
      it = this->_internal_flow_stats_by_id().begin();
      it != this->_internal_flow_stats_by_id().end(); ++it) {
    total_size += NetworkStatsReport_FlowStatsByIdEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string node_id = 7 [json_name = "nodeId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_node_id());
    }

    // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetworkStatsReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetworkStatsReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetworkStatsReport::GetClassData() const { return &_class_data_; }


void NetworkStatsReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetworkStatsReport*>(&to_msg);
  auto& from = static_cast<const NetworkStatsReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.NetworkStatsReport)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.interface_stats_by_id_.MergeFrom(from._impl_.interface_stats_by_id_);
  _this->_impl_.radio_stats_by_interface_id_.MergeFrom(from._impl_.radio_stats_by_interface_id_);
  _this->_impl_.beam_stats_by_antenna_id_.MergeFrom(from._impl_.beam_stats_by_antenna_id_);
  _this->_impl_.flow_stats_by_id_.MergeFrom(from._impl_.flow_stats_by_id_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_node_id(from._internal_node_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetworkStatsReport::CopyFrom(const NetworkStatsReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.NetworkStatsReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkStatsReport::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.beam_stats_by_antenna_id_)) return false;
  return true;
}

void NetworkStatsReport::InternalSwap(NetworkStatsReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.interface_stats_by_id_.InternalSwap(&other->_impl_.interface_stats_by_id_);
  _impl_.radio_stats_by_interface_id_.InternalSwap(&other->_impl_.radio_stats_by_interface_id_);
  _impl_.beam_stats_by_antenna_id_.InternalSwap(&other->_impl_.beam_stats_by_antenna_id_);
  _impl_.flow_stats_by_id_.InternalSwap(&other->_impl_.flow_stats_by_id_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.node_id_, lhs_arena,
                                       &other->_impl_.node_id_, rhs_arena);
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NetworkStatsReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[4]);
}
// ===================================================================

class BeamStats_TargetingStats::_Internal {
 public:
  using HasBits = decltype(std::declval<BeamStats_TargetingStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BeamStats_TargetingStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::GeodeticWgs84& target_location(const BeamStats_TargetingStats* msg);
  static void set_has_target_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_connection_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_beam_task_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::GeodeticWgs84&
BeamStats_TargetingStats::_Internal::target_location(const BeamStats_TargetingStats* msg) {
  return *msg->_impl_.target_location_;
}
void BeamStats_TargetingStats::clear_target_location() {
  if (_impl_.target_location_ != nullptr) _impl_.target_location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
BeamStats_TargetingStats::BeamStats_TargetingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BeamStats.TargetingStats)
}
BeamStats_TargetingStats::BeamStats_TargetingStats(const BeamStats_TargetingStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BeamStats_TargetingStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.beam_task_id_) {}

    , decltype(_impl_.target_identifier_) {}

    , decltype(_impl_.target_location_){nullptr}
    , decltype(_impl_.connection_status_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.beam_task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.beam_task_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.beam_task_id_.Set(from._internal_beam_task_id(), _this->GetArenaForAllocation());
  }
  _impl_.target_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.target_identifier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.target_identifier_.Set(from._internal_target_identifier(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.target_location_ = new ::aalyria::spacetime::api::common::GeodeticWgs84(*from._impl_.target_location_);
  }
  _this->_impl_.connection_status_ = from._impl_.connection_status_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BeamStats.TargetingStats)
}

inline void BeamStats_TargetingStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.beam_task_id_) {}

    , decltype(_impl_.target_identifier_) {}

    , decltype(_impl_.target_location_){nullptr}
    , decltype(_impl_.connection_status_) { 0 }

  };
  _impl_.beam_task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.beam_task_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.target_identifier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BeamStats_TargetingStats::~BeamStats_TargetingStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeamStats_TargetingStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.beam_task_id_.Destroy();
  _impl_.target_identifier_.Destroy();
  if (this != internal_default_instance()) delete _impl_.target_location_;
}

void BeamStats_TargetingStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BeamStats_TargetingStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.beam_task_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.target_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.target_location_ != nullptr);
      _impl_.target_location_->Clear();
    }
  }
  _impl_.connection_status_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BeamStats_TargetingStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.GeodeticWgs84 target_location = 1 [json_name = "targetLocation"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_location(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus connection_status = 2 [json_name = "connectionStatus"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_connection_status(static_cast<::aalyria::spacetime::api::common::BeamStats_TargetingStats_ConnectionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string beam_task_id = 3 [json_name = "beamTaskId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_beam_task_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string target_identifier = 4 [json_name = "targetIdentifier"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_target_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BeamStats_TargetingStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 target_location = 1 [json_name = "targetLocation"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target_location(this),
        _Internal::target_location(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus connection_status = 2 [json_name = "connectionStatus"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_connection_status(), target);
  }

  // optional string beam_task_id = 3 [json_name = "beamTaskId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_beam_task_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.BeamStats.TargetingStats.beam_task_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string target_identifier = 4 [json_name = "targetIdentifier"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_target_identifier();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.BeamStats.TargetingStats.target_identifier");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  return target;
}

::size_t BeamStats_TargetingStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string beam_task_id = 3 [json_name = "beamTaskId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_beam_task_id());
    }

    // optional string target_identifier = 4 [json_name = "targetIdentifier"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_target_identifier());
    }

    // optional .aalyria.spacetime.api.common.GeodeticWgs84 target_location = 1 [json_name = "targetLocation"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_location_);
    }

    // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus connection_status = 2 [json_name = "connectionStatus"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BeamStats_TargetingStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BeamStats_TargetingStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BeamStats_TargetingStats::GetClassData() const { return &_class_data_; }


void BeamStats_TargetingStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BeamStats_TargetingStats*>(&to_msg);
  auto& from = static_cast<const BeamStats_TargetingStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_beam_task_id(from._internal_beam_task_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_target_identifier(from._internal_target_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_target_location()->::aalyria::spacetime::api::common::GeodeticWgs84::MergeFrom(
          from._internal_target_location());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.connection_status_ = from._impl_.connection_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BeamStats_TargetingStats::CopyFrom(const BeamStats_TargetingStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BeamStats.TargetingStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeamStats_TargetingStats::IsInitialized() const {
  return true;
}

void BeamStats_TargetingStats::InternalSwap(BeamStats_TargetingStats* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.beam_task_id_, lhs_arena,
                                       &other->_impl_.beam_task_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_identifier_, lhs_arena,
                                       &other->_impl_.target_identifier_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeamStats_TargetingStats, _impl_.connection_status_)
      + sizeof(BeamStats_TargetingStats::_impl_.connection_status_)
      - PROTOBUF_FIELD_OFFSET(BeamStats_TargetingStats, _impl_.target_location_)>(
          reinterpret_cast<char*>(&_impl_.target_location_),
          reinterpret_cast<char*>(&other->_impl_.target_location_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BeamStats_TargetingStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[5]);
}
// ===================================================================

class BeamStats_GimbalStats::_Internal {
 public:
  using HasBits = decltype(std::declval<BeamStats_GimbalStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BeamStats_GimbalStats, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::BeamStats_GimbalStats, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::GeodeticWgs84& location(const BeamStats_GimbalStats* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::Quaternion& orientation_quaternion(const BeamStats_GimbalStats* msg);
  static const ::aalyria::spacetime::api::common::YawPitchRoll& orientation_ypr(const BeamStats_GimbalStats* msg);
  static const ::aalyria::spacetime::api::common::PointingVector& pointing_vector(const BeamStats_GimbalStats* msg);
  static void set_has_pointing_vector(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_initialized(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::aalyria::spacetime::api::common::GeodeticWgs84&
BeamStats_GimbalStats::_Internal::location(const BeamStats_GimbalStats* msg) {
  return *msg->_impl_.location_;
}
const ::aalyria::spacetime::api::common::Quaternion&
BeamStats_GimbalStats::_Internal::orientation_quaternion(const BeamStats_GimbalStats* msg) {
  return *msg->_impl_.site_orientation_.orientation_quaternion_;
}
const ::aalyria::spacetime::api::common::YawPitchRoll&
BeamStats_GimbalStats::_Internal::orientation_ypr(const BeamStats_GimbalStats* msg) {
  return *msg->_impl_.site_orientation_.orientation_ypr_;
}
const ::aalyria::spacetime::api::common::PointingVector&
BeamStats_GimbalStats::_Internal::pointing_vector(const BeamStats_GimbalStats* msg) {
  return *msg->_impl_.pointing_vector_;
}
void BeamStats_GimbalStats::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void BeamStats_GimbalStats::set_allocated_orientation_quaternion(::aalyria::spacetime::api::common::Quaternion* orientation_quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_site_orientation();
  if (orientation_quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_quaternion));
    if (message_arena != submessage_arena) {
      orientation_quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation_quaternion, submessage_arena);
    }
    set_has_orientation_quaternion();
    _impl_.site_orientation_.orientation_quaternion_ = orientation_quaternion;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion)
}
void BeamStats_GimbalStats::clear_orientation_quaternion() {
  if (site_orientation_case() == kOrientationQuaternion) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.site_orientation_.orientation_quaternion_;
    }
    clear_has_site_orientation();
  }
}
void BeamStats_GimbalStats::set_allocated_orientation_ypr(::aalyria::spacetime::api::common::YawPitchRoll* orientation_ypr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_site_orientation();
  if (orientation_ypr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_ypr));
    if (message_arena != submessage_arena) {
      orientation_ypr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation_ypr, submessage_arena);
    }
    set_has_orientation_ypr();
    _impl_.site_orientation_.orientation_ypr_ = orientation_ypr;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr)
}
void BeamStats_GimbalStats::clear_orientation_ypr() {
  if (site_orientation_case() == kOrientationYpr) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.site_orientation_.orientation_ypr_;
    }
    clear_has_site_orientation();
  }
}
void BeamStats_GimbalStats::clear_pointing_vector() {
  if (_impl_.pointing_vector_ != nullptr) _impl_.pointing_vector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
BeamStats_GimbalStats::BeamStats_GimbalStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BeamStats.GimbalStats)
}
BeamStats_GimbalStats::BeamStats_GimbalStats(const BeamStats_GimbalStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BeamStats_GimbalStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.pointing_vector_){nullptr}
    , decltype(_impl_.initialized_) {}

    , decltype(_impl_.site_orientation_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.location_ = new ::aalyria::spacetime::api::common::GeodeticWgs84(*from._impl_.location_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.pointing_vector_ = new ::aalyria::spacetime::api::common::PointingVector(*from._impl_.pointing_vector_);
  }
  _this->_impl_.initialized_ = from._impl_.initialized_;
  clear_has_site_orientation();
  switch (from.site_orientation_case()) {
    case kOrientationQuaternion: {
      _this->_internal_mutable_orientation_quaternion()->::aalyria::spacetime::api::common::Quaternion::MergeFrom(
          from._internal_orientation_quaternion());
      break;
    }
    case kOrientationYpr: {
      _this->_internal_mutable_orientation_ypr()->::aalyria::spacetime::api::common::YawPitchRoll::MergeFrom(
          from._internal_orientation_ypr());
      break;
    }
    case SITE_ORIENTATION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BeamStats.GimbalStats)
}

inline void BeamStats_GimbalStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.pointing_vector_){nullptr}
    , decltype(_impl_.initialized_) { false }

    , decltype(_impl_.site_orientation_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_site_orientation();
}

BeamStats_GimbalStats::~BeamStats_GimbalStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeamStats_GimbalStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.pointing_vector_;
  if (has_site_orientation()) {
    clear_site_orientation();
  }
}

void BeamStats_GimbalStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BeamStats_GimbalStats::clear_site_orientation() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  switch (site_orientation_case()) {
    case kOrientationQuaternion: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.site_orientation_.orientation_quaternion_;
      }
      break;
    }
    case kOrientationYpr: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.site_orientation_.orientation_ypr_;
      }
      break;
    }
    case SITE_ORIENTATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SITE_ORIENTATION_NOT_SET;
}


void BeamStats_GimbalStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pointing_vector_ != nullptr);
      _impl_.pointing_vector_->Clear();
    }
  }
  _impl_.initialized_ = false;
  clear_site_orientation();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BeamStats_GimbalStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 1 [json_name = "location"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Quaternion orientation_quaternion = 2 [json_name = "orientationQuaternion"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation_quaternion(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.YawPitchRoll orientation_ypr = 3 [json_name = "orientationYpr"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_orientation_ypr(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 4 [json_name = "pointingVector"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pointing_vector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool initialized = 5 [json_name = "initialized"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_initialized(&has_bits);
          _impl_.initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BeamStats_GimbalStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 1 [json_name = "location"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  switch (site_orientation_case()) {
    case kOrientationQuaternion: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::orientation_quaternion(this),
          _Internal::orientation_quaternion(this).GetCachedSize(), target, stream);
      break;
    }
    case kOrientationYpr: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::orientation_ypr(this),
          _Internal::orientation_ypr(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 4 [json_name = "pointingVector"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::pointing_vector(this),
        _Internal::pointing_vector(this).GetCachedSize(), target, stream);
  }

  // optional bool initialized = 5 [json_name = "initialized"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_initialized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  return target;
}

::size_t BeamStats_GimbalStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 1 [json_name = "location"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 4 [json_name = "pointingVector"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pointing_vector_);
    }

    // optional bool initialized = 5 [json_name = "initialized"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

  }
  switch (site_orientation_case()) {
    // .aalyria.spacetime.api.common.Quaternion orientation_quaternion = 2 [json_name = "orientationQuaternion"];
    case kOrientationQuaternion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.site_orientation_.orientation_quaternion_);
      break;
    }
    // .aalyria.spacetime.api.common.YawPitchRoll orientation_ypr = 3 [json_name = "orientationYpr"];
    case kOrientationYpr: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.site_orientation_.orientation_ypr_);
      break;
    }
    case SITE_ORIENTATION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BeamStats_GimbalStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BeamStats_GimbalStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BeamStats_GimbalStats::GetClassData() const { return &_class_data_; }


void BeamStats_GimbalStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BeamStats_GimbalStats*>(&to_msg);
  auto& from = static_cast<const BeamStats_GimbalStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_location()->::aalyria::spacetime::api::common::GeodeticWgs84::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pointing_vector()->::aalyria::spacetime::api::common::PointingVector::MergeFrom(
          from._internal_pointing_vector());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.initialized_ = from._impl_.initialized_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.site_orientation_case()) {
    case kOrientationQuaternion: {
      _this->_internal_mutable_orientation_quaternion()->::aalyria::spacetime::api::common::Quaternion::MergeFrom(
          from._internal_orientation_quaternion());
      break;
    }
    case kOrientationYpr: {
      _this->_internal_mutable_orientation_ypr()->::aalyria::spacetime::api::common::YawPitchRoll::MergeFrom(
          from._internal_orientation_ypr());
      break;
    }
    case SITE_ORIENTATION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BeamStats_GimbalStats::CopyFrom(const BeamStats_GimbalStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BeamStats.GimbalStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeamStats_GimbalStats::IsInitialized() const {
  switch (site_orientation_case()) {
    case kOrientationQuaternion: {
      if (site_orientation_case() == kOrientationQuaternion) {
        if (!_impl_.site_orientation_.orientation_quaternion_->IsInitialized()) return false;
      }
      break;
    }
    case kOrientationYpr: {
      if (site_orientation_case() == kOrientationYpr) {
        if (!_impl_.site_orientation_.orientation_ypr_->IsInitialized()) return false;
      }
      break;
    }
    case SITE_ORIENTATION_NOT_SET: {
      break;
    }
  }
  return true;
}

void BeamStats_GimbalStats::InternalSwap(BeamStats_GimbalStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeamStats_GimbalStats, _impl_.initialized_)
      + sizeof(BeamStats_GimbalStats::_impl_.initialized_)
      - PROTOBUF_FIELD_OFFSET(BeamStats_GimbalStats, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
  swap(_impl_.site_orientation_, other->_impl_.site_orientation_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BeamStats_GimbalStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[6]);
}
// ===================================================================

class BeamStats::_Internal {
 public:
  using HasBits = decltype(std::declval<BeamStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BeamStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const BeamStats* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::BeamStats_TargetingStats& targeting(const BeamStats* msg);
  static void set_has_targeting(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::BeamStats_GimbalStats& gimbal(const BeamStats* msg);
  static void set_has_gimbal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
BeamStats::_Internal::timestamp(const BeamStats* msg) {
  return *msg->_impl_.timestamp_;
}
const ::aalyria::spacetime::api::common::BeamStats_TargetingStats&
BeamStats::_Internal::targeting(const BeamStats* msg) {
  return *msg->_impl_.targeting_;
}
const ::aalyria::spacetime::api::common::BeamStats_GimbalStats&
BeamStats::_Internal::gimbal(const BeamStats* msg) {
  return *msg->_impl_.gimbal_;
}
void BeamStats::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
BeamStats::BeamStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.BeamStats)
}
BeamStats::BeamStats(const BeamStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BeamStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.targeting_){nullptr}
    , decltype(_impl_.gimbal_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.targeting_ = new ::aalyria::spacetime::api::common::BeamStats_TargetingStats(*from._impl_.targeting_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.gimbal_ = new ::aalyria::spacetime::api::common::BeamStats_GimbalStats(*from._impl_.gimbal_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.BeamStats)
}

inline void BeamStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.targeting_){nullptr}
    , decltype(_impl_.gimbal_){nullptr}
  };
}

BeamStats::~BeamStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.BeamStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeamStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.targeting_;
  if (this != internal_default_instance()) delete _impl_.gimbal_;
}

void BeamStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BeamStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.BeamStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.targeting_ != nullptr);
      _impl_.targeting_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.gimbal_ != nullptr);
      _impl_.gimbal_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BeamStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats targeting = 2 [json_name = "targeting"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_targeting(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.BeamStats.GimbalStats gimbal = 3 [json_name = "gimbal"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gimbal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BeamStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.BeamStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats targeting = 2 [json_name = "targeting"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::targeting(this),
        _Internal::targeting(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.BeamStats.GimbalStats gimbal = 3 [json_name = "gimbal"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::gimbal(this),
        _Internal::gimbal(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.BeamStats)
  return target;
}

::size_t BeamStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.BeamStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional .aalyria.spacetime.api.common.BeamStats.TargetingStats targeting = 2 [json_name = "targeting"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targeting_);
    }

    // optional .aalyria.spacetime.api.common.BeamStats.GimbalStats gimbal = 3 [json_name = "gimbal"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gimbal_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BeamStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BeamStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BeamStats::GetClassData() const { return &_class_data_; }


void BeamStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BeamStats*>(&to_msg);
  auto& from = static_cast<const BeamStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.BeamStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_targeting()->::aalyria::spacetime::api::common::BeamStats_TargetingStats::MergeFrom(
          from._internal_targeting());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_gimbal()->::aalyria::spacetime::api::common::BeamStats_GimbalStats::MergeFrom(
          from._internal_gimbal());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BeamStats::CopyFrom(const BeamStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.BeamStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeamStats::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.gimbal_->IsInitialized()) return false;
  }
  return true;
}

void BeamStats::InternalSwap(BeamStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeamStats, _impl_.gimbal_)
      + sizeof(BeamStats::_impl_.gimbal_)
      - PROTOBUF_FIELD_OFFSET(BeamStats, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BeamStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[7]);
}
// ===================================================================

class TransmitterStats::_Internal {
 public:
  using HasBits = decltype(std::declval<TransmitterStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TransmitterStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const TransmitterStats* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_receiver_physical_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_rate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tx_packet_error_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
TransmitterStats::_Internal::timestamp(const TransmitterStats* msg) {
  return *msg->_impl_.timestamp_;
}
void TransmitterStats::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TransmitterStats::TransmitterStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.TransmitterStats)
}
TransmitterStats::TransmitterStats(const TransmitterStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransmitterStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_physical_address_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.data_rate_bps_) {}

    , decltype(_impl_.tx_packet_error_rate_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.receiver_physical_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.receiver_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.receiver_physical_address_.Set(from._internal_receiver_physical_address(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.data_rate_bps_, &from._impl_.data_rate_bps_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.tx_packet_error_rate_) -
    reinterpret_cast<char*>(&_impl_.data_rate_bps_)) + sizeof(_impl_.tx_packet_error_rate_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.TransmitterStats)
}

inline void TransmitterStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiver_physical_address_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.data_rate_bps_) { 0 }

    , decltype(_impl_.tx_packet_error_rate_) { 0 }

  };
  _impl_.receiver_physical_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.receiver_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TransmitterStats::~TransmitterStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.TransmitterStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransmitterStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.receiver_physical_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void TransmitterStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransmitterStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.TransmitterStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.receiver_physical_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.data_rate_bps_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tx_packet_error_rate_) -
        reinterpret_cast<char*>(&_impl_.data_rate_bps_)) + sizeof(_impl_.tx_packet_error_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransmitterStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double data_rate_bps = 2 [json_name = "dataRateBps"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_data_rate_bps(&has_bits);
          _impl_.data_rate_bps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double tx_packet_error_rate = 3 [json_name = "txPacketErrorRate"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_tx_packet_error_rate(&has_bits);
          _impl_.tx_packet_error_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 4 [json_name = "timestamp"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string receiver_physical_address = 5 [json_name = "receiverPhysicalAddress"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_receiver_physical_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransmitterStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.TransmitterStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double data_rate_bps = 2 [json_name = "dataRateBps"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_data_rate_bps(), target);
  }

  // optional double tx_packet_error_rate = 3 [json_name = "txPacketErrorRate"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_tx_packet_error_rate(), target);
  }

  // optional .aalyria.spacetime.api.common.DateTime timestamp = 4 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional string receiver_physical_address = 5 [json_name = "receiverPhysicalAddress"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_receiver_physical_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.TransmitterStats.receiver_physical_address");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.TransmitterStats)
  return target;
}

::size_t TransmitterStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.TransmitterStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string receiver_physical_address = 5 [json_name = "receiverPhysicalAddress"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_receiver_physical_address());
    }

    // optional .aalyria.spacetime.api.common.DateTime timestamp = 4 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional double data_rate_bps = 2 [json_name = "dataRateBps"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double tx_packet_error_rate = 3 [json_name = "txPacketErrorRate"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransmitterStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransmitterStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransmitterStats::GetClassData() const { return &_class_data_; }


void TransmitterStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransmitterStats*>(&to_msg);
  auto& from = static_cast<const TransmitterStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.TransmitterStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_receiver_physical_address(from._internal_receiver_physical_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.data_rate_bps_ = from._impl_.data_rate_bps_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tx_packet_error_rate_ = from._impl_.tx_packet_error_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransmitterStats::CopyFrom(const TransmitterStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.TransmitterStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransmitterStats::IsInitialized() const {
  return true;
}

void TransmitterStats::InternalSwap(TransmitterStats* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.receiver_physical_address_, lhs_arena,
                                       &other->_impl_.receiver_physical_address_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransmitterStats, _impl_.tx_packet_error_rate_)
      + sizeof(TransmitterStats::_impl_.tx_packet_error_rate_)
      - PROTOBUF_FIELD_OFFSET(TransmitterStats, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransmitterStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[8]);
}
// ===================================================================

class ReceiverStats::_Internal {
 public:
  using HasBits = decltype(std::declval<ReceiverStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ReceiverStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const ReceiverStats* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transmitter_physical_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_power_at_receiver_output_dbw(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mse_db(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_carrier_to_noise_plus_interference_db(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
ReceiverStats::_Internal::timestamp(const ReceiverStats* msg) {
  return *msg->_impl_.timestamp_;
}
void ReceiverStats::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ReceiverStats::ReceiverStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.ReceiverStats)
}
ReceiverStats::ReceiverStats(const ReceiverStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReceiverStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.power_at_receiver_output_by_chain_dbw_) { from._impl_.power_at_receiver_output_by_chain_dbw_ }

    , decltype(_impl_.transmitter_physical_address_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.power_at_receiver_output_dbw_) {}

    , decltype(_impl_.mse_db_) {}

    , decltype(_impl_.carrier_to_noise_plus_interference_db_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transmitter_physical_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.transmitter_physical_address_.Set(from._internal_transmitter_physical_address(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.power_at_receiver_output_dbw_, &from._impl_.power_at_receiver_output_dbw_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.carrier_to_noise_plus_interference_db_) -
    reinterpret_cast<char*>(&_impl_.power_at_receiver_output_dbw_)) + sizeof(_impl_.carrier_to_noise_plus_interference_db_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.ReceiverStats)
}

inline void ReceiverStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.power_at_receiver_output_by_chain_dbw_) { arena }

    , decltype(_impl_.transmitter_physical_address_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.power_at_receiver_output_dbw_) { 0 }

    , decltype(_impl_.mse_db_) { 0 }

    , decltype(_impl_.carrier_to_noise_plus_interference_db_) { 0 }

  };
  _impl_.transmitter_physical_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transmitter_physical_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReceiverStats::~ReceiverStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.ReceiverStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReceiverStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.power_at_receiver_output_by_chain_dbw_.~RepeatedField();
  _impl_.transmitter_physical_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void ReceiverStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReceiverStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.ReceiverStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_power_at_receiver_output_by_chain_dbw()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.transmitter_physical_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.power_at_receiver_output_dbw_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.carrier_to_noise_plus_interference_db_) -
        reinterpret_cast<char*>(&_impl_.power_at_receiver_output_dbw_)) + sizeof(_impl_.carrier_to_noise_plus_interference_db_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReceiverStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double power_at_receiver_output_dbw = 2 [json_name = "powerAtReceiverOutputDbw"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_power_at_receiver_output_dbw(&has_bits);
          _impl_.power_at_receiver_output_dbw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string transmitter_physical_address = 4 [json_name = "transmitterPhysicalAddress"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_transmitter_physical_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated double power_at_receiver_output_by_chain_dbw = 5 [json_name = "powerAtReceiverOutputByChainDbw"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_power_at_receiver_output_by_chain_dbw(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<41>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_power_at_receiver_output_by_chain_dbw(), ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double mse_db = 6 [json_name = "mseDb"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_mse_db(&has_bits);
          _impl_.mse_db_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double carrier_to_noise_plus_interference_db = 7 [json_name = "carrierToNoisePlusInterferenceDb"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_carrier_to_noise_plus_interference_db(&has_bits);
          _impl_.carrier_to_noise_plus_interference_db_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReceiverStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.ReceiverStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double power_at_receiver_output_dbw = 2 [json_name = "powerAtReceiverOutputDbw"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_power_at_receiver_output_dbw(), target);
  }

  // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional string transmitter_physical_address = 4 [json_name = "transmitterPhysicalAddress"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_transmitter_physical_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.ReceiverStats.transmitter_physical_address");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // repeated double power_at_receiver_output_by_chain_dbw = 5 [json_name = "powerAtReceiverOutputByChainDbw"];
  for (int i = 0, n = this->_internal_power_at_receiver_output_by_chain_dbw_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_power_at_receiver_output_by_chain_dbw(i), target);
  }

  // optional double mse_db = 6 [json_name = "mseDb"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_mse_db(), target);
  }

  // optional double carrier_to_noise_plus_interference_db = 7 [json_name = "carrierToNoisePlusInterferenceDb"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_carrier_to_noise_plus_interference_db(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.ReceiverStats)
  return target;
}

::size_t ReceiverStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.ReceiverStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double power_at_receiver_output_by_chain_dbw = 5 [json_name = "powerAtReceiverOutputByChainDbw"];
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_power_at_receiver_output_by_chain_dbw_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_power_at_receiver_output_by_chain_dbw_size());
    ;
    total_size += tag_size + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string transmitter_physical_address = 4 [json_name = "transmitterPhysicalAddress"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_transmitter_physical_address());
    }

    // optional .aalyria.spacetime.api.common.DateTime timestamp = 3 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional double power_at_receiver_output_dbw = 2 [json_name = "powerAtReceiverOutputDbw"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double mse_db = 6 [json_name = "mseDb"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional double carrier_to_noise_plus_interference_db = 7 [json_name = "carrierToNoisePlusInterferenceDb"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReceiverStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReceiverStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReceiverStats::GetClassData() const { return &_class_data_; }


void ReceiverStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReceiverStats*>(&to_msg);
  auto& from = static_cast<const ReceiverStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.ReceiverStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.power_at_receiver_output_by_chain_dbw_.MergeFrom(from._impl_.power_at_receiver_output_by_chain_dbw_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_transmitter_physical_address(from._internal_transmitter_physical_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.power_at_receiver_output_dbw_ = from._impl_.power_at_receiver_output_dbw_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mse_db_ = from._impl_.mse_db_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.carrier_to_noise_plus_interference_db_ = from._impl_.carrier_to_noise_plus_interference_db_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReceiverStats::CopyFrom(const ReceiverStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.ReceiverStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiverStats::IsInitialized() const {
  return true;
}

void ReceiverStats::InternalSwap(ReceiverStats* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.power_at_receiver_output_by_chain_dbw_.InternalSwap(&other->_impl_.power_at_receiver_output_by_chain_dbw_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmitter_physical_address_, lhs_arena,
                                       &other->_impl_.transmitter_physical_address_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReceiverStats, _impl_.carrier_to_noise_plus_interference_db_)
      + sizeof(ReceiverStats::_impl_.carrier_to_noise_plus_interference_db_)
      - PROTOBUF_FIELD_OFFSET(ReceiverStats, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReceiverStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[9]);
}
// ===================================================================

class RadioStats::_Internal {
 public:
  using HasBits = decltype(std::declval<RadioStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RadioStats, _impl_._has_bits_);
  static void set_has_interface_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RadioStats::RadioStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.RadioStats)
}
RadioStats::RadioStats(const RadioStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadioStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmitter_stats_){from._impl_.transmitter_stats_}
    , decltype(_impl_.receiver_stats_){from._impl_.receiver_stats_}
    , decltype(_impl_.interface_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.interface_id_.Set(from._internal_interface_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.RadioStats)
}

inline void RadioStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transmitter_stats_){arena}
    , decltype(_impl_.receiver_stats_){arena}
    , decltype(_impl_.interface_id_) {}

  };
  _impl_.interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RadioStats::~RadioStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.RadioStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadioStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_transmitter_stats()->~RepeatedPtrField();
  _internal_mutable_receiver_stats()->~RepeatedPtrField();
  _impl_.interface_id_.Destroy();
}

void RadioStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadioStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.RadioStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_transmitter_stats()->Clear();
  _internal_mutable_receiver_stats()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.interface_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadioStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.TransmitterStats transmitter_stats = 3 [json_name = "transmitterStats"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transmitter_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.ReceiverStats receiver_stats = 4 [json_name = "receiverStats"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_receiver_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string interface_id = 5 [json_name = "interfaceId"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_interface_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.RadioStats.interface_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RadioStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.RadioStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.TransmitterStats transmitter_stats = 3 [json_name = "transmitterStats"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transmitter_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_transmitter_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.ReceiverStats receiver_stats = 4 [json_name = "receiverStats"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_receiver_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_receiver_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string interface_id = 5 [json_name = "interfaceId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_interface_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.RadioStats.interface_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.RadioStats)
  return target;
}

::size_t RadioStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.RadioStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.TransmitterStats transmitter_stats = 3 [json_name = "transmitterStats"];
  total_size += 1UL * this->_internal_transmitter_stats_size();
  for (const auto& msg : this->_internal_transmitter_stats()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.common.ReceiverStats receiver_stats = 4 [json_name = "receiverStats"];
  total_size += 1UL * this->_internal_receiver_stats_size();
  for (const auto& msg : this->_internal_receiver_stats()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string interface_id = 5 [json_name = "interfaceId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_interface_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadioStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadioStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadioStats::GetClassData() const { return &_class_data_; }


void RadioStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadioStats*>(&to_msg);
  auto& from = static_cast<const RadioStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.RadioStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transmitter_stats()->MergeFrom(from._internal_transmitter_stats());
  _this->_internal_mutable_receiver_stats()->MergeFrom(from._internal_receiver_stats());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_interface_id(from._internal_interface_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadioStats::CopyFrom(const RadioStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.RadioStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadioStats::IsInitialized() const {
  return true;
}

void RadioStats::InternalSwap(RadioStats* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_transmitter_stats()->InternalSwap(other->_internal_mutable_transmitter_stats());
  _internal_mutable_receiver_stats()->InternalSwap(other->_internal_mutable_receiver_stats());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.interface_id_, lhs_arena,
                                       &other->_impl_.interface_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata RadioStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[10]);
}
// ===================================================================

class InterfaceStats::_Internal {
 public:
  using HasBits = decltype(std::declval<InterfaceStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterfaceStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const InterfaceStats* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tx_dropped(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_rx_dropped(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_rx_errors(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_tx_errors(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
InterfaceStats::_Internal::timestamp(const InterfaceStats* msg) {
  return *msg->_impl_.timestamp_;
}
void InterfaceStats::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
InterfaceStats::InterfaceStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.InterfaceStats)
}
InterfaceStats::InterfaceStats(const InterfaceStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterfaceStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.tx_packets_) {}

    , decltype(_impl_.rx_packets_) {}

    , decltype(_impl_.tx_bytes_) {}

    , decltype(_impl_.rx_bytes_) {}

    , decltype(_impl_.tx_dropped_) {}

    , decltype(_impl_.rx_dropped_) {}

    , decltype(_impl_.rx_errors_) {}

    , decltype(_impl_.tx_errors_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.tx_packets_, &from._impl_.tx_packets_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.tx_errors_) -
    reinterpret_cast<char*>(&_impl_.tx_packets_)) + sizeof(_impl_.tx_errors_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.InterfaceStats)
}

inline void InterfaceStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.tx_packets_) { ::int64_t{0} }

    , decltype(_impl_.rx_packets_) { ::int64_t{0} }

    , decltype(_impl_.tx_bytes_) { ::int64_t{0} }

    , decltype(_impl_.rx_bytes_) { ::int64_t{0} }

    , decltype(_impl_.tx_dropped_) { ::int64_t{0} }

    , decltype(_impl_.rx_dropped_) { ::int64_t{0} }

    , decltype(_impl_.rx_errors_) { ::int64_t{0} }

    , decltype(_impl_.tx_errors_) { ::int64_t{0} }

  };
}

InterfaceStats::~InterfaceStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.InterfaceStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterfaceStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void InterfaceStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterfaceStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.InterfaceStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.timestamp_ != nullptr);
    _impl_.timestamp_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.tx_packets_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rx_errors_) -
        reinterpret_cast<char*>(&_impl_.tx_packets_)) + sizeof(_impl_.rx_errors_));
  }
  _impl_.tx_errors_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterfaceStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 tx_packets = 1 [json_name = "txPackets"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_tx_packets(&has_bits);
          _impl_.tx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_packets = 2 [json_name = "rxPackets"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_rx_packets(&has_bits);
          _impl_.rx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 tx_bytes = 3 [json_name = "txBytes"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_tx_bytes(&has_bits);
          _impl_.tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_bytes = 4 [json_name = "rxBytes"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_rx_bytes(&has_bits);
          _impl_.rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 tx_dropped = 5 [json_name = "txDropped"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_tx_dropped(&has_bits);
          _impl_.tx_dropped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_dropped = 6 [json_name = "rxDropped"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_rx_dropped(&has_bits);
          _impl_.rx_dropped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_errors = 7 [json_name = "rxErrors"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_rx_errors(&has_bits);
          _impl_.rx_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 tx_errors = 8 [json_name = "txErrors"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_tx_errors(&has_bits);
          _impl_.tx_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 9 [json_name = "timestamp"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterfaceStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.InterfaceStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 tx_packets = 1 [json_name = "txPackets"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_tx_packets(), target);
  }

  // optional int64 rx_packets = 2 [json_name = "rxPackets"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_rx_packets(), target);
  }

  // optional int64 tx_bytes = 3 [json_name = "txBytes"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_tx_bytes(), target);
  }

  // optional int64 rx_bytes = 4 [json_name = "rxBytes"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_rx_bytes(), target);
  }

  // optional int64 tx_dropped = 5 [json_name = "txDropped"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_tx_dropped(), target);
  }

  // optional int64 rx_dropped = 6 [json_name = "rxDropped"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_rx_dropped(), target);
  }

  // optional int64 rx_errors = 7 [json_name = "rxErrors"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this->_internal_rx_errors(), target);
  }

  // optional int64 tx_errors = 8 [json_name = "txErrors"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        8, this->_internal_tx_errors(), target);
  }

  // optional .aalyria.spacetime.api.common.DateTime timestamp = 9 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.InterfaceStats)
  return target;
}

::size_t InterfaceStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.InterfaceStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .aalyria.spacetime.api.common.DateTime timestamp = 9 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional int64 tx_packets = 1 [json_name = "txPackets"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_tx_packets());
    }

    // optional int64 rx_packets = 2 [json_name = "rxPackets"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_packets());
    }

    // optional int64 tx_bytes = 3 [json_name = "txBytes"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_tx_bytes());
    }

    // optional int64 rx_bytes = 4 [json_name = "rxBytes"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_bytes());
    }

    // optional int64 tx_dropped = 5 [json_name = "txDropped"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_tx_dropped());
    }

    // optional int64 rx_dropped = 6 [json_name = "rxDropped"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_dropped());
    }

    // optional int64 rx_errors = 7 [json_name = "rxErrors"];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_errors());
    }

  }
  // optional int64 tx_errors = 8 [json_name = "txErrors"];
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_tx_errors());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterfaceStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterfaceStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterfaceStats::GetClassData() const { return &_class_data_; }


void InterfaceStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterfaceStats*>(&to_msg);
  auto& from = static_cast<const InterfaceStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.InterfaceStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tx_packets_ = from._impl_.tx_packets_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rx_packets_ = from._impl_.rx_packets_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tx_bytes_ = from._impl_.tx_bytes_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rx_bytes_ = from._impl_.rx_bytes_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tx_dropped_ = from._impl_.tx_dropped_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.rx_dropped_ = from._impl_.rx_dropped_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.rx_errors_ = from._impl_.rx_errors_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_tx_errors(from._internal_tx_errors());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterfaceStats::CopyFrom(const InterfaceStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.InterfaceStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterfaceStats::IsInitialized() const {
  return true;
}

void InterfaceStats::InternalSwap(InterfaceStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterfaceStats, _impl_.tx_errors_)
      + sizeof(InterfaceStats::_impl_.tx_errors_)
      - PROTOBUF_FIELD_OFFSET(InterfaceStats, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InterfaceStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[11]);
}
// ===================================================================

class FlowStats::_Internal {
 public:
  using HasBits = decltype(std::declval<FlowStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FlowStats, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const FlowStats* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rx_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::aalyria::spacetime::api::common::DateTime&
FlowStats::_Internal::timestamp(const FlowStats* msg) {
  return *msg->_impl_.timestamp_;
}
void FlowStats::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FlowStats::FlowStats(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.FlowStats)
}
FlowStats::FlowStats(const FlowStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.tx_packets_) {}

    , decltype(_impl_.rx_packets_) {}

    , decltype(_impl_.tx_bytes_) {}

    , decltype(_impl_.rx_bytes_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.tx_packets_, &from._impl_.tx_packets_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.rx_bytes_) -
    reinterpret_cast<char*>(&_impl_.tx_packets_)) + sizeof(_impl_.rx_bytes_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.FlowStats)
}

inline void FlowStats::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.tx_packets_) { ::int64_t{0} }

    , decltype(_impl_.rx_packets_) { ::int64_t{0} }

    , decltype(_impl_.tx_bytes_) { ::int64_t{0} }

    , decltype(_impl_.rx_bytes_) { ::int64_t{0} }

  };
}

FlowStats::~FlowStats() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.FlowStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowStats::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void FlowStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowStats::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.FlowStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.timestamp_ != nullptr);
    _impl_.timestamp_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.tx_packets_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rx_bytes_) -
        reinterpret_cast<char*>(&_impl_.tx_packets_)) + sizeof(_impl_.rx_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 tx_packets = 2 [json_name = "txPackets"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_tx_packets(&has_bits);
          _impl_.tx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_packets = 3 [json_name = "rxPackets"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_rx_packets(&has_bits);
          _impl_.rx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 tx_bytes = 4 [json_name = "txBytes"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_tx_bytes(&has_bits);
          _impl_.tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 rx_bytes = 5 [json_name = "rxBytes"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_rx_bytes(&has_bits);
          _impl_.rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FlowStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.FlowStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional int64 tx_packets = 2 [json_name = "txPackets"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_tx_packets(), target);
  }

  // optional int64 rx_packets = 3 [json_name = "rxPackets"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_rx_packets(), target);
  }

  // optional int64 tx_bytes = 4 [json_name = "txBytes"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_tx_bytes(), target);
  }

  // optional int64 rx_bytes = 5 [json_name = "rxBytes"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_rx_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.FlowStats)
  return target;
}

::size_t FlowStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.FlowStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional int64 tx_packets = 2 [json_name = "txPackets"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_tx_packets());
    }

    // optional int64 rx_packets = 3 [json_name = "rxPackets"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_packets());
    }

    // optional int64 tx_bytes = 4 [json_name = "txBytes"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_tx_bytes());
    }

    // optional int64 rx_bytes = 5 [json_name = "rxBytes"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_rx_bytes());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowStats::GetClassData() const { return &_class_data_; }


void FlowStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowStats*>(&to_msg);
  auto& from = static_cast<const FlowStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.FlowStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tx_packets_ = from._impl_.tx_packets_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rx_packets_ = from._impl_.rx_packets_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tx_bytes_ = from._impl_.tx_bytes_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rx_bytes_ = from._impl_.rx_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowStats::CopyFrom(const FlowStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.FlowStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowStats::IsInitialized() const {
  return true;
}

void FlowStats::InternalSwap(FlowStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowStats, _impl_.rx_bytes_)
      + sizeof(FlowStats::_impl_.rx_bytes_)
      - PROTOBUF_FIELD_OFFSET(FlowStats, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[12]);
}
// ===================================================================

class NetworkEventReport::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkEventReport>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NetworkEventReport, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::NetworkEventReport, _impl_._oneof_case_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::DateTime& timestamp(const NetworkEventReport* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::RadioEvent& radio_event(const NetworkEventReport* msg);
  static const ::aalyria::spacetime::api::common::PortEvent& port_event(const NetworkEventReport* msg);
  static const ::aalyria::spacetime::api::common::InterfaceEvent& interface_event(const NetworkEventReport* msg);
};

const ::aalyria::spacetime::api::common::DateTime&
NetworkEventReport::_Internal::timestamp(const NetworkEventReport* msg) {
  return *msg->_impl_.timestamp_;
}
const ::aalyria::spacetime::api::common::RadioEvent&
NetworkEventReport::_Internal::radio_event(const NetworkEventReport* msg) {
  return *msg->_impl_.source_type_.radio_event_;
}
const ::aalyria::spacetime::api::common::PortEvent&
NetworkEventReport::_Internal::port_event(const NetworkEventReport* msg) {
  return *msg->_impl_.source_type_.port_event_;
}
const ::aalyria::spacetime::api::common::InterfaceEvent&
NetworkEventReport::_Internal::interface_event(const NetworkEventReport* msg) {
  return *msg->_impl_.source_type_.interface_event_;
}
void NetworkEventReport::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void NetworkEventReport::set_allocated_radio_event(::aalyria::spacetime::api::common::RadioEvent* radio_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source_type();
  if (radio_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(radio_event);
    if (message_arena != submessage_arena) {
      radio_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio_event, submessage_arena);
    }
    set_has_radio_event();
    _impl_.source_type_.radio_event_ = radio_event;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.radio_event)
}
void NetworkEventReport::set_allocated_port_event(::aalyria::spacetime::api::common::PortEvent* port_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source_type();
  if (port_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(port_event);
    if (message_arena != submessage_arena) {
      port_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_event, submessage_arena);
    }
    set_has_port_event();
    _impl_.source_type_.port_event_ = port_event;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.port_event)
}
void NetworkEventReport::set_allocated_interface_event(::aalyria::spacetime::api::common::InterfaceEvent* interface_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source_type();
  if (interface_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interface_event);
    if (message_arena != submessage_arena) {
      interface_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface_event, submessage_arena);
    }
    set_has_interface_event();
    _impl_.source_type_.interface_event_ = interface_event;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkEventReport.interface_event)
}
NetworkEventReport::NetworkEventReport(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.NetworkEventReport)
}
NetworkEventReport::NetworkEventReport(const NetworkEventReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetworkEventReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.source_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.node_id_.Set(from._internal_node_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.timestamp_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.timestamp_);
  }
  clear_has_source_type();
  switch (from.source_type_case()) {
    case kRadioEvent: {
      _this->_internal_mutable_radio_event()->::aalyria::spacetime::api::common::RadioEvent::MergeFrom(
          from._internal_radio_event());
      break;
    }
    case kPortEvent: {
      _this->_internal_mutable_port_event()->::aalyria::spacetime::api::common::PortEvent::MergeFrom(
          from._internal_port_event());
      break;
    }
    case kInterfaceEvent: {
      _this->_internal_mutable_interface_event()->::aalyria::spacetime::api::common::InterfaceEvent::MergeFrom(
          from._internal_interface_event());
      break;
    }
    case SOURCE_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.NetworkEventReport)
}

inline void NetworkEventReport::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.source_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_source_type();
}

NetworkEventReport::~NetworkEventReport() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.NetworkEventReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkEventReport::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (has_source_type()) {
    clear_source_type();
  }
}

void NetworkEventReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkEventReport::clear_source_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.NetworkEventReport)
  switch (source_type_case()) {
    case kRadioEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_type_.radio_event_;
      }
      break;
    }
    case kPortEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_type_.port_event_;
      }
      break;
    }
    case kInterfaceEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_type_.interface_event_;
      }
      break;
    }
    case SOURCE_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SOURCE_TYPE_NOT_SET;
}


void NetworkEventReport::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.NetworkEventReport)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.node_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
  }
  clear_source_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetworkEventReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.RadioEvent radio_event = 2 [json_name = "radioEvent"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_radio_event(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PortEvent port_event = 3 [json_name = "portEvent"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_port_event(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.InterfaceEvent interface_event = 4 [json_name = "interfaceEvent"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_interface_event(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string node_id = 5 [json_name = "nodeId"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.NetworkEventReport.node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NetworkEventReport::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.NetworkEventReport)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  switch (source_type_case()) {
    case kRadioEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::radio_event(this),
          _Internal::radio_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kPortEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::port_event(this),
          _Internal::port_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kInterfaceEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::interface_event(this),
          _Internal::interface_event(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional string node_id = 5 [json_name = "nodeId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_node_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.NetworkEventReport.node_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.NetworkEventReport)
  return target;
}

::size_t NetworkEventReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.NetworkEventReport)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string node_id = 5 [json_name = "nodeId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_node_id());
    }

    // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

  }
  switch (source_type_case()) {
    // .aalyria.spacetime.api.common.RadioEvent radio_event = 2 [json_name = "radioEvent"];
    case kRadioEvent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_type_.radio_event_);
      break;
    }
    // .aalyria.spacetime.api.common.PortEvent port_event = 3 [json_name = "portEvent"];
    case kPortEvent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_type_.port_event_);
      break;
    }
    // .aalyria.spacetime.api.common.InterfaceEvent interface_event = 4 [json_name = "interfaceEvent"];
    case kInterfaceEvent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_type_.interface_event_);
      break;
    }
    case SOURCE_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetworkEventReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetworkEventReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetworkEventReport::GetClassData() const { return &_class_data_; }


void NetworkEventReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetworkEventReport*>(&to_msg);
  auto& from = static_cast<const NetworkEventReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.NetworkEventReport)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_node_id(from._internal_node_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_timestamp()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_timestamp());
    }
  }
  switch (from.source_type_case()) {
    case kRadioEvent: {
      _this->_internal_mutable_radio_event()->::aalyria::spacetime::api::common::RadioEvent::MergeFrom(
          from._internal_radio_event());
      break;
    }
    case kPortEvent: {
      _this->_internal_mutable_port_event()->::aalyria::spacetime::api::common::PortEvent::MergeFrom(
          from._internal_port_event());
      break;
    }
    case kInterfaceEvent: {
      _this->_internal_mutable_interface_event()->::aalyria::spacetime::api::common::InterfaceEvent::MergeFrom(
          from._internal_interface_event());
      break;
    }
    case SOURCE_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetworkEventReport::CopyFrom(const NetworkEventReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.NetworkEventReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkEventReport::IsInitialized() const {
  return true;
}

void NetworkEventReport::InternalSwap(NetworkEventReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.node_id_, lhs_arena,
                                       &other->_impl_.node_id_, rhs_arena);
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
  swap(_impl_.source_type_, other->_impl_.source_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata NetworkEventReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[13]);
}
// ===================================================================

class RadioEvent::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::RadioEvent, _impl_._oneof_case_);
};

RadioEvent::RadioEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.RadioEvent)
}
RadioEvent::RadioEvent(const RadioEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadioEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.radio_id_){}
    , decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_radio_id();
  switch (from.radio_id_case()) {
    case kTransmitterId: {
      _this->_internal_set_transmitter_id(from._internal_transmitter_id());
      break;
    }
    case kReceiverId: {
      _this->_internal_set_receiver_id(from._internal_receiver_id());
      break;
    }
    case RADIO_ID_NOT_SET: {
      break;
    }
  }
  clear_has_event();
  switch (from.event_case()) {
    case kLinkStatus: {
      _this->_internal_set_link_status(from._internal_link_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.RadioEvent)
}

inline void RadioEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.radio_id_){}
    , decltype(_impl_.event_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_radio_id();
  clear_has_event();
}

RadioEvent::~RadioEvent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.RadioEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadioEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_radio_id()) {
    clear_radio_id();
  }
  if (has_event()) {
    clear_event();
  }
}

void RadioEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadioEvent::clear_radio_id() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.RadioEvent)
  switch (radio_id_case()) {
    case kTransmitterId: {
      _impl_.radio_id_.transmitter_id_.Destroy();
      break;
    }
    case kReceiverId: {
      _impl_.radio_id_.receiver_id_.Destroy();
      break;
    }
    case RADIO_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RADIO_ID_NOT_SET;
}

void RadioEvent::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.RadioEvent)
  switch (event_case()) {
    case kLinkStatus: {
      // No need to clear
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = EVENT_NOT_SET;
}


void RadioEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.RadioEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_radio_id();
  clear_event();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadioEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transmitter_id = 1 [json_name = "transmitterId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transmitter_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.RadioEvent.transmitter_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // string receiver_id = 2 [json_name = "receiverId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_receiver_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.RadioEvent.receiver_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.RadioEvent.LinkStatus link_status = 3 [json_name = "linkStatus"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::RadioEvent_LinkStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_link_status(static_cast<::aalyria::spacetime::api::common::RadioEvent_LinkStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RadioEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.RadioEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (radio_id_case()) {
    case kTransmitterId: {
      const std::string& _s = this->_internal_transmitter_id();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.RadioEvent.transmitter_id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
      break;
    }
    case kReceiverId: {
      const std::string& _s = this->_internal_receiver_id();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.RadioEvent.receiver_id");
      target = stream->WriteStringMaybeAliased(2, _s, target);
      break;
    }
    default: ;
  }
  // .aalyria.spacetime.api.common.RadioEvent.LinkStatus link_status = 3 [json_name = "linkStatus"];
  if (event_case() == kLinkStatus) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_link_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.RadioEvent)
  return target;
}

::size_t RadioEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.RadioEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (radio_id_case()) {
    // string transmitter_id = 1 [json_name = "transmitterId"];
    case kTransmitterId: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_transmitter_id());
      break;
    }
    // string receiver_id = 2 [json_name = "receiverId"];
    case kReceiverId: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_receiver_id());
      break;
    }
    case RADIO_ID_NOT_SET: {
      break;
    }
  }
  switch (event_case()) {
    // .aalyria.spacetime.api.common.RadioEvent.LinkStatus link_status = 3 [json_name = "linkStatus"];
    case kLinkStatus: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_link_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadioEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadioEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadioEvent::GetClassData() const { return &_class_data_; }


void RadioEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadioEvent*>(&to_msg);
  auto& from = static_cast<const RadioEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.RadioEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.radio_id_case()) {
    case kTransmitterId: {
      _this->_internal_set_transmitter_id(from._internal_transmitter_id());
      break;
    }
    case kReceiverId: {
      _this->_internal_set_receiver_id(from._internal_receiver_id());
      break;
    }
    case RADIO_ID_NOT_SET: {
      break;
    }
  }
  switch (from.event_case()) {
    case kLinkStatus: {
      _this->_internal_set_link_status(from._internal_link_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadioEvent::CopyFrom(const RadioEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.RadioEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadioEvent::IsInitialized() const {
  return true;
}

void RadioEvent::InternalSwap(RadioEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.radio_id_, other->_impl_.radio_id_);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RadioEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[14]);
}
// ===================================================================

class PortEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<PortEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PortEvent, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::PortEvent, _impl_._oneof_case_);
  static void set_has_port_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PortEvent::PortEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.PortEvent)
}
PortEvent::PortEvent(const PortEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.port_id_) {}

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.port_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.port_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.port_id_.Set(from._internal_port_id(), _this->GetArenaForAllocation());
  }
  clear_has_event();
  switch (from.event_case()) {
    case kPortStatus: {
      _this->_internal_set_port_status(from._internal_port_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.PortEvent)
}

inline void PortEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.port_id_) {}

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.port_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.port_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_event();
}

PortEvent::~PortEvent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.PortEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.port_id_.Destroy();
  if (has_event()) {
    clear_event();
  }
}

void PortEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortEvent::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.PortEvent)
  switch (event_case()) {
    case kPortStatus: {
      // No need to clear
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}


void PortEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.PortEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.port_id_.ClearNonDefaultToEmpty();
  }
  clear_event();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string port_id = 1 [json_name = "portId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_port_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.PortEvent.port_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.PortEvent.PortStatus port_status = 2 [json_name = "portStatus"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::PortEvent_PortStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_port_status(static_cast<::aalyria::spacetime::api::common::PortEvent_PortStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PortEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.PortEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string port_id = 1 [json_name = "portId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_port_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.PortEvent.port_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .aalyria.spacetime.api.common.PortEvent.PortStatus port_status = 2 [json_name = "portStatus"];
  if (event_case() == kPortStatus) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_port_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.PortEvent)
  return target;
}

::size_t PortEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.PortEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string port_id = 1 [json_name = "portId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_port_id());
  }

  switch (event_case()) {
    // .aalyria.spacetime.api.common.PortEvent.PortStatus port_status = 2 [json_name = "portStatus"];
    case kPortStatus: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_port_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortEvent::GetClassData() const { return &_class_data_; }


void PortEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortEvent*>(&to_msg);
  auto& from = static_cast<const PortEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.PortEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_port_id(from._internal_port_id());
  }
  switch (from.event_case()) {
    case kPortStatus: {
      _this->_internal_set_port_status(from._internal_port_status());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortEvent::CopyFrom(const PortEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.PortEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortEvent::IsInitialized() const {
  return true;
}

void PortEvent::InternalSwap(PortEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.port_id_, lhs_arena,
                                       &other->_impl_.port_id_, rhs_arena);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[15]);
}
// ===================================================================

class InterfaceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<InterfaceEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterfaceEvent, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::InterfaceEvent, _impl_._oneof_case_);
  static void set_has_interface_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

InterfaceEvent::InterfaceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.InterfaceEvent)
}
InterfaceEvent::InterfaceEvent(const InterfaceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterfaceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interface_id_) {}

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.interface_id_.Set(from._internal_interface_id(), _this->GetArenaForAllocation());
  }
  clear_has_event();
  switch (from.event_case()) {
    case kInterfaceStatus: {
      _this->_internal_set_interface_status(from._internal_interface_status());
      break;
    }
    case kIpAddress: {
      _this->_internal_set_ip_address(from._internal_ip_address());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.InterfaceEvent)
}

inline void InterfaceEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interface_id_) {}

    , decltype(_impl_.event_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_event();
}

InterfaceEvent::~InterfaceEvent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.InterfaceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterfaceEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.interface_id_.Destroy();
  if (has_event()) {
    clear_event();
  }
}

void InterfaceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterfaceEvent::clear_event() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.InterfaceEvent)
  switch (event_case()) {
    case kInterfaceStatus: {
      // No need to clear
      break;
    }
    case kIpAddress: {
      _impl_.event_.ip_address_.Destroy();
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}


void InterfaceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.InterfaceEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.interface_id_.ClearNonDefaultToEmpty();
  }
  clear_event();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterfaceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string interface_id = 1 [json_name = "interfaceId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_interface_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.InterfaceEvent.interface_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus interface_status = 2 [json_name = "interfaceStatus"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_interface_status(static_cast<::aalyria::spacetime::api::common::InterfaceEvent_InterfaceStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // string ip_address = 3 [json_name = "ipAddress"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.InterfaceEvent.ip_address");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterfaceEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.InterfaceEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string interface_id = 1 [json_name = "interfaceId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_interface_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.InterfaceEvent.interface_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  switch (event_case()) {
    case kInterfaceStatus: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this->_internal_interface_status(), target);
      break;
    }
    case kIpAddress: {
      const std::string& _s = this->_internal_ip_address();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.common.InterfaceEvent.ip_address");
      target = stream->WriteStringMaybeAliased(3, _s, target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.InterfaceEvent)
  return target;
}

::size_t InterfaceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.InterfaceEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string interface_id = 1 [json_name = "interfaceId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_interface_id());
  }

  switch (event_case()) {
    // .aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus interface_status = 2 [json_name = "interfaceStatus"];
    case kInterfaceStatus: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_interface_status());
      break;
    }
    // string ip_address = 3 [json_name = "ipAddress"];
    case kIpAddress: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_ip_address());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterfaceEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterfaceEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterfaceEvent::GetClassData() const { return &_class_data_; }


void InterfaceEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterfaceEvent*>(&to_msg);
  auto& from = static_cast<const InterfaceEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.InterfaceEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_interface_id(from._internal_interface_id());
  }
  switch (from.event_case()) {
    case kInterfaceStatus: {
      _this->_internal_set_interface_status(from._internal_interface_status());
      break;
    }
    case kIpAddress: {
      _this->_internal_set_ip_address(from._internal_ip_address());
      break;
    }
    case EVENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterfaceEvent::CopyFrom(const InterfaceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.InterfaceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterfaceEvent::IsInitialized() const {
  return true;
}

void InterfaceEvent::InternalSwap(InterfaceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.interface_id_, lhs_arena,
                                       &other->_impl_.interface_id_, rhs_arena);
  swap(_impl_.event_, other->_impl_.event_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata InterfaceEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2ftelemetry_2eproto_getter, &descriptor_table_api_2fcommon_2ftelemetry_2eproto_once,
      file_level_metadata_api_2fcommon_2ftelemetry_2eproto[16]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkStatsReport_RadioStatsByInterfaceIdEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkStatsReport_InterfaceStatsByIdEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkStatsReport_BeamStatsByAntennaIdEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkStatsReport_FlowStatsByIdEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkStatsReport*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkStatsReport >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BeamStats_TargetingStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BeamStats_TargetingStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BeamStats_TargetingStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BeamStats_GimbalStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BeamStats_GimbalStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BeamStats_GimbalStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::BeamStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::BeamStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::BeamStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::TransmitterStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::TransmitterStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::TransmitterStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::ReceiverStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::ReceiverStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::ReceiverStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::RadioStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::RadioStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::RadioStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::InterfaceStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::InterfaceStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::InterfaceStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::FlowStats*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::FlowStats >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::NetworkEventReport*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkEventReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::NetworkEventReport >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::RadioEvent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::RadioEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::RadioEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::PortEvent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::PortEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::PortEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::InterfaceEvent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::InterfaceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::InterfaceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
