// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/platform_antenna.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fplatform_5fantenna_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fplatform_5fantenna_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "api/common/coordinates.pb.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fplatform_5fantenna_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class AntennaConstraints;
struct AntennaConstraintsDefaultTypeInternal;
extern AntennaConstraintsDefaultTypeInternal _AntennaConstraints_default_instance_;
class AntennaConstraints_AzimuthAngleRateConstraint;
struct AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal;
extern AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal _AntennaConstraints_AzimuthAngleRateConstraint_default_instance_;
class AntennaConstraints_ElevationAngleRateConstraint;
struct AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal;
extern AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal _AntennaConstraints_ElevationAngleRateConstraint_default_instance_;
class AntennaConstraints_LinkRangeConstraint;
struct AntennaConstraints_LinkRangeConstraintDefaultTypeInternal;
extern AntennaConstraints_LinkRangeConstraintDefaultTypeInternal _AntennaConstraints_LinkRangeConstraint_default_instance_;
class AntennaConstraints_TotalAngularRateConstraint;
struct AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal;
extern AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal _AntennaConstraints_TotalAngularRateConstraint_default_instance_;
class AntennaDefinition;
struct AntennaDefinitionDefaultTypeInternal;
extern AntennaDefinitionDefaultTypeInternal _AntennaDefinition_default_instance_;
class AntennaDefinition_ElevationMask;
struct AntennaDefinition_ElevationMaskDefaultTypeInternal;
extern AntennaDefinition_ElevationMaskDefaultTypeInternal _AntennaDefinition_ElevationMask_default_instance_;
class AntennaDefinition_ElevationMask_ElevationRise;
struct AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal;
extern AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal _AntennaDefinition_ElevationMask_ElevationRise_default_instance_;
class Polarization;
struct PolarizationDefaultTypeInternal;
extern PolarizationDefaultTypeInternal _Polarization_default_instance_;
class Polarization_Constant;
struct Polarization_ConstantDefaultTypeInternal;
extern Polarization_ConstantDefaultTypeInternal _Polarization_Constant_default_instance_;
class Polarization_Constant_Linear;
struct Polarization_Constant_LinearDefaultTypeInternal;
extern Polarization_Constant_LinearDefaultTypeInternal _Polarization_Constant_Linear_default_instance_;
class Projection;
struct ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Projection_Conic;
struct Projection_ConicDefaultTypeInternal;
extern Projection_ConicDefaultTypeInternal _Projection_Conic_default_instance_;
class Projection_Custom;
struct Projection_CustomDefaultTypeInternal;
extern Projection_CustomDefaultTypeInternal _Projection_Custom_default_instance_;
class Projection_Rectangular;
struct Projection_RectangularDefaultTypeInternal;
extern Projection_RectangularDefaultTypeInternal _Projection_Rectangular_default_instance_;
class Targeting;
struct TargetingDefaultTypeInternal;
extern TargetingDefaultTypeInternal _Targeting_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::AntennaConstraints* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask>(Arena*);
template <>
::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise>(Arena*);
template <>
::aalyria::spacetime::api::common::Polarization* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Polarization>(Arena*);
template <>
::aalyria::spacetime::api::common::Polarization_Constant* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Polarization_Constant>(Arena*);
template <>
::aalyria::spacetime::api::common::Polarization_Constant_Linear* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Polarization_Constant_Linear>(Arena*);
template <>
::aalyria::spacetime::api::common::Projection* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Projection>(Arena*);
template <>
::aalyria::spacetime::api::common::Projection_Conic* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Projection_Conic>(Arena*);
template <>
::aalyria::spacetime::api::common::Projection_Custom* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Projection_Custom>(Arena*);
template <>
::aalyria::spacetime::api::common::Projection_Rectangular* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Projection_Rectangular>(Arena*);
template <>
::aalyria::spacetime::api::common::Targeting* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Targeting>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class AntennaDefinition_ElevationMask_ElevationRise final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise) */ {
 public:
  inline AntennaDefinition_ElevationMask_ElevationRise() : AntennaDefinition_ElevationMask_ElevationRise(nullptr) {}
  ~AntennaDefinition_ElevationMask_ElevationRise() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMask_ElevationRise(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaDefinition_ElevationMask_ElevationRise(const AntennaDefinition_ElevationMask_ElevationRise& from);
  AntennaDefinition_ElevationMask_ElevationRise(AntennaDefinition_ElevationMask_ElevationRise&& from) noexcept
    : AntennaDefinition_ElevationMask_ElevationRise() {
    *this = ::std::move(from);
  }

  inline AntennaDefinition_ElevationMask_ElevationRise& operator=(const AntennaDefinition_ElevationMask_ElevationRise& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaDefinition_ElevationMask_ElevationRise& operator=(AntennaDefinition_ElevationMask_ElevationRise&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaDefinition_ElevationMask_ElevationRise& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaDefinition_ElevationMask_ElevationRise* internal_default_instance() {
    return reinterpret_cast<const AntennaDefinition_ElevationMask_ElevationRise*>(
               &_AntennaDefinition_ElevationMask_ElevationRise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AntennaDefinition_ElevationMask_ElevationRise& a, AntennaDefinition_ElevationMask_ElevationRise& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaDefinition_ElevationMask_ElevationRise* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaDefinition_ElevationMask_ElevationRise* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaDefinition_ElevationMask_ElevationRise* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaDefinition_ElevationMask_ElevationRise>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaDefinition_ElevationMask_ElevationRise& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaDefinition_ElevationMask_ElevationRise& from) {
    AntennaDefinition_ElevationMask_ElevationRise::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaDefinition_ElevationMask_ElevationRise* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise";
  }
  protected:
  explicit AntennaDefinition_ElevationMask_ElevationRise(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
    kObscuredElevationDegFieldNumber = 2,
  };
  // optional double distance = 1 [json_name = "distance"];
  bool has_distance() const;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // optional double obscured_elevation_deg = 2 [json_name = "obscuredElevationDeg"];
  bool has_obscured_elevation_deg() const;
  void clear_obscured_elevation_deg() ;
  double obscured_elevation_deg() const;
  void set_obscured_elevation_deg(double value);

  private:
  double _internal_obscured_elevation_deg() const;
  void _internal_set_obscured_elevation_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double distance_;
    double obscured_elevation_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaDefinition_ElevationMask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask) */ {
 public:
  inline AntennaDefinition_ElevationMask() : AntennaDefinition_ElevationMask(nullptr) {}
  ~AntennaDefinition_ElevationMask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaDefinition_ElevationMask(const AntennaDefinition_ElevationMask& from);
  AntennaDefinition_ElevationMask(AntennaDefinition_ElevationMask&& from) noexcept
    : AntennaDefinition_ElevationMask() {
    *this = ::std::move(from);
  }

  inline AntennaDefinition_ElevationMask& operator=(const AntennaDefinition_ElevationMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaDefinition_ElevationMask& operator=(AntennaDefinition_ElevationMask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaDefinition_ElevationMask& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaDefinition_ElevationMask* internal_default_instance() {
    return reinterpret_cast<const AntennaDefinition_ElevationMask*>(
               &_AntennaDefinition_ElevationMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AntennaDefinition_ElevationMask& a, AntennaDefinition_ElevationMask& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaDefinition_ElevationMask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaDefinition_ElevationMask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaDefinition_ElevationMask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaDefinition_ElevationMask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaDefinition_ElevationMask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaDefinition_ElevationMask& from) {
    AntennaDefinition_ElevationMask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaDefinition_ElevationMask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaDefinition.ElevationMask";
  }
  protected:
  explicit AntennaDefinition_ElevationMask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AntennaDefinition_ElevationMask_ElevationRise ElevationRise;

  // accessors -------------------------------------------------------

  enum : int {
    kElevationRiseFieldNumber = 3,
    kAzimuthDegFieldNumber = 1,
    kMaximumObscuredElevationDegFieldNumber = 2,
  };
  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise elevation_rise = 3 [json_name = "elevationRise"];
  int elevation_rise_size() const;
  private:
  int _internal_elevation_rise_size() const;

  public:
  void clear_elevation_rise() ;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* mutable_elevation_rise(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >*
      mutable_elevation_rise();
  private:
  const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise& _internal_elevation_rise(int index) const;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* _internal_add_elevation_rise();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise>& _internal_elevation_rise() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise>* _internal_mutable_elevation_rise();
  public:
  const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise& elevation_rise(int index) const;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* add_elevation_rise();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >&
      elevation_rise() const;
  // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
  bool has_azimuth_deg() const;
  void clear_azimuth_deg() ;
  double azimuth_deg() const;
  void set_azimuth_deg(double value);

  private:
  double _internal_azimuth_deg() const;
  void _internal_set_azimuth_deg(double value);

  public:
  // optional double maximum_obscured_elevation_deg = 2 [json_name = "maximumObscuredElevationDeg"];
  bool has_maximum_obscured_elevation_deg() const;
  void clear_maximum_obscured_elevation_deg() ;
  double maximum_obscured_elevation_deg() const;
  void set_maximum_obscured_elevation_deg(double value);

  private:
  double _internal_maximum_obscured_elevation_deg() const;
  void _internal_set_maximum_obscured_elevation_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise > elevation_rise_;
    double azimuth_deg_;
    double maximum_obscured_elevation_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaDefinition) */ {
 public:
  inline AntennaDefinition() : AntennaDefinition(nullptr) {}
  ~AntennaDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaDefinition(const AntennaDefinition& from);
  AntennaDefinition(AntennaDefinition&& from) noexcept
    : AntennaDefinition() {
    *this = ::std::move(from);
  }

  inline AntennaDefinition& operator=(const AntennaDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaDefinition& operator=(AntennaDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaDefinition* internal_default_instance() {
    return reinterpret_cast<const AntennaDefinition*>(
               &_AntennaDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AntennaDefinition& a, AntennaDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaDefinition& from) {
    AntennaDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaDefinition";
  }
  protected:
  explicit AntennaDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AntennaDefinition_ElevationMask ElevationMask;

  // accessors -------------------------------------------------------

  enum : int {
    kAzimuthElevationMaskFieldNumber = 9,
    kObstructionsFieldNumber = 12,
    kNameFieldNumber = 2,
    kAntennaPatternIdFieldNumber = 10,
    kFixedCoordinateOffsetFieldNumber = 3,
    kConstraintsFieldNumber = 6,
    kFieldOfRegardFieldNumber = 11,
    kPolarizationFieldNumber = 17,
    kTargetingFieldNumber = 18,
  };
  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask azimuth_elevation_mask = 9 [json_name = "azimuthElevationMask"];
  int azimuth_elevation_mask_size() const;
  private:
  int _internal_azimuth_elevation_mask_size() const;

  public:
  void clear_azimuth_elevation_mask() ;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* mutable_azimuth_elevation_mask(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >*
      mutable_azimuth_elevation_mask();
  private:
  const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask& _internal_azimuth_elevation_mask(int index) const;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* _internal_add_azimuth_elevation_mask();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask>& _internal_azimuth_elevation_mask() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask>* _internal_mutable_azimuth_elevation_mask();
  public:
  const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask& azimuth_elevation_mask(int index) const;
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* add_azimuth_elevation_mask();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >&
      azimuth_elevation_mask() const;
  // repeated .aalyria.spacetime.api.common.Projection obstructions = 12 [json_name = "obstructions"];
  int obstructions_size() const;
  private:
  int _internal_obstructions_size() const;

  public:
  void clear_obstructions() ;
  ::aalyria::spacetime::api::common::Projection* mutable_obstructions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Projection >*
      mutable_obstructions();
  private:
  const ::aalyria::spacetime::api::common::Projection& _internal_obstructions(int index) const;
  ::aalyria::spacetime::api::common::Projection* _internal_add_obstructions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Projection>& _internal_obstructions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Projection>* _internal_mutable_obstructions();
  public:
  const ::aalyria::spacetime::api::common::Projection& obstructions(int index) const;
  ::aalyria::spacetime::api::common::Projection* add_obstructions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Projection >&
      obstructions() const;
  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string antenna_pattern_id = 10 [json_name = "antennaPatternId"];
  bool has_antenna_pattern_id() const;
  void clear_antenna_pattern_id() ;
  const std::string& antenna_pattern_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_antenna_pattern_id(Arg_&& arg, Args_... args);
  std::string* mutable_antenna_pattern_id();
  PROTOBUF_NODISCARD std::string* release_antenna_pattern_id();
  void set_allocated_antenna_pattern_id(std::string* ptr);

  private:
  const std::string& _internal_antenna_pattern_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_antenna_pattern_id(
      const std::string& value);
  std::string* _internal_mutable_antenna_pattern_id();

  public:
  // optional .aalyria.spacetime.api.common.PointAxes fixed_coordinate_offset = 3 [json_name = "fixedCoordinateOffset"];
  bool has_fixed_coordinate_offset() const;
  void clear_fixed_coordinate_offset() ;
  const ::aalyria::spacetime::api::common::PointAxes& fixed_coordinate_offset() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PointAxes* release_fixed_coordinate_offset();
  ::aalyria::spacetime::api::common::PointAxes* mutable_fixed_coordinate_offset();
  void set_allocated_fixed_coordinate_offset(::aalyria::spacetime::api::common::PointAxes* fixed_coordinate_offset);
  private:
  const ::aalyria::spacetime::api::common::PointAxes& _internal_fixed_coordinate_offset() const;
  ::aalyria::spacetime::api::common::PointAxes* _internal_mutable_fixed_coordinate_offset();
  public:
  void unsafe_arena_set_allocated_fixed_coordinate_offset(
      ::aalyria::spacetime::api::common::PointAxes* fixed_coordinate_offset);
  ::aalyria::spacetime::api::common::PointAxes* unsafe_arena_release_fixed_coordinate_offset();
  // optional .aalyria.spacetime.api.common.AntennaConstraints constraints = 6 [json_name = "constraints"];
  bool has_constraints() const;
  void clear_constraints() ;
  const ::aalyria::spacetime::api::common::AntennaConstraints& constraints() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AntennaConstraints* release_constraints();
  ::aalyria::spacetime::api::common::AntennaConstraints* mutable_constraints();
  void set_allocated_constraints(::aalyria::spacetime::api::common::AntennaConstraints* constraints);
  private:
  const ::aalyria::spacetime::api::common::AntennaConstraints& _internal_constraints() const;
  ::aalyria::spacetime::api::common::AntennaConstraints* _internal_mutable_constraints();
  public:
  void unsafe_arena_set_allocated_constraints(
      ::aalyria::spacetime::api::common::AntennaConstraints* constraints);
  ::aalyria::spacetime::api::common::AntennaConstraints* unsafe_arena_release_constraints();
  // optional .aalyria.spacetime.api.common.Projection field_of_regard = 11 [json_name = "fieldOfRegard"];
  bool has_field_of_regard() const;
  void clear_field_of_regard() ;
  const ::aalyria::spacetime::api::common::Projection& field_of_regard() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Projection* release_field_of_regard();
  ::aalyria::spacetime::api::common::Projection* mutable_field_of_regard();
  void set_allocated_field_of_regard(::aalyria::spacetime::api::common::Projection* field_of_regard);
  private:
  const ::aalyria::spacetime::api::common::Projection& _internal_field_of_regard() const;
  ::aalyria::spacetime::api::common::Projection* _internal_mutable_field_of_regard();
  public:
  void unsafe_arena_set_allocated_field_of_regard(
      ::aalyria::spacetime::api::common::Projection* field_of_regard);
  ::aalyria::spacetime::api::common::Projection* unsafe_arena_release_field_of_regard();
  // optional .aalyria.spacetime.api.common.Polarization polarization = 17 [json_name = "polarization"];
  bool has_polarization() const;
  void clear_polarization() ;
  const ::aalyria::spacetime::api::common::Polarization& polarization() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Polarization* release_polarization();
  ::aalyria::spacetime::api::common::Polarization* mutable_polarization();
  void set_allocated_polarization(::aalyria::spacetime::api::common::Polarization* polarization);
  private:
  const ::aalyria::spacetime::api::common::Polarization& _internal_polarization() const;
  ::aalyria::spacetime::api::common::Polarization* _internal_mutable_polarization();
  public:
  void unsafe_arena_set_allocated_polarization(
      ::aalyria::spacetime::api::common::Polarization* polarization);
  ::aalyria::spacetime::api::common::Polarization* unsafe_arena_release_polarization();
  // optional .aalyria.spacetime.api.common.Targeting targeting = 18 [json_name = "targeting"];
  bool has_targeting() const;
  void clear_targeting() ;
  const ::aalyria::spacetime::api::common::Targeting& targeting() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Targeting* release_targeting();
  ::aalyria::spacetime::api::common::Targeting* mutable_targeting();
  void set_allocated_targeting(::aalyria::spacetime::api::common::Targeting* targeting);
  private:
  const ::aalyria::spacetime::api::common::Targeting& _internal_targeting() const;
  ::aalyria::spacetime::api::common::Targeting* _internal_mutable_targeting();
  public:
  void unsafe_arena_set_allocated_targeting(
      ::aalyria::spacetime::api::common::Targeting* targeting);
  ::aalyria::spacetime::api::common::Targeting* unsafe_arena_release_targeting();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask > azimuth_elevation_mask_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Projection > obstructions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr antenna_pattern_id_;
    ::aalyria::spacetime::api::common::PointAxes* fixed_coordinate_offset_;
    ::aalyria::spacetime::api::common::AntennaConstraints* constraints_;
    ::aalyria::spacetime::api::common::Projection* field_of_regard_;
    ::aalyria::spacetime::api::common::Polarization* polarization_;
    ::aalyria::spacetime::api::common::Targeting* targeting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaConstraints_LinkRangeConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint) */ {
 public:
  inline AntennaConstraints_LinkRangeConstraint() : AntennaConstraints_LinkRangeConstraint(nullptr) {}
  ~AntennaConstraints_LinkRangeConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaConstraints_LinkRangeConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaConstraints_LinkRangeConstraint(const AntennaConstraints_LinkRangeConstraint& from);
  AntennaConstraints_LinkRangeConstraint(AntennaConstraints_LinkRangeConstraint&& from) noexcept
    : AntennaConstraints_LinkRangeConstraint() {
    *this = ::std::move(from);
  }

  inline AntennaConstraints_LinkRangeConstraint& operator=(const AntennaConstraints_LinkRangeConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaConstraints_LinkRangeConstraint& operator=(AntennaConstraints_LinkRangeConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaConstraints_LinkRangeConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaConstraints_LinkRangeConstraint* internal_default_instance() {
    return reinterpret_cast<const AntennaConstraints_LinkRangeConstraint*>(
               &_AntennaConstraints_LinkRangeConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AntennaConstraints_LinkRangeConstraint& a, AntennaConstraints_LinkRangeConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaConstraints_LinkRangeConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaConstraints_LinkRangeConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaConstraints_LinkRangeConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaConstraints_LinkRangeConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaConstraints_LinkRangeConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaConstraints_LinkRangeConstraint& from) {
    AntennaConstraints_LinkRangeConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaConstraints_LinkRangeConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint";
  }
  protected:
  explicit AntennaConstraints_LinkRangeConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumRangeFieldNumber = 1,
    kMaximumRangeFieldNumber = 2,
  };
  // optional double minimum_range = 1 [json_name = "minimumRange"];
  bool has_minimum_range() const;
  void clear_minimum_range() ;
  double minimum_range() const;
  void set_minimum_range(double value);

  private:
  double _internal_minimum_range() const;
  void _internal_set_minimum_range(double value);

  public:
  // optional double maximum_range = 2 [json_name = "maximumRange"];
  bool has_maximum_range() const;
  void clear_maximum_range() ;
  double maximum_range() const;
  void set_maximum_range(double value);

  private:
  double _internal_maximum_range() const;
  void _internal_set_maximum_range(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double minimum_range_;
    double maximum_range_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaConstraints_AzimuthAngleRateConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint) */ {
 public:
  inline AntennaConstraints_AzimuthAngleRateConstraint() : AntennaConstraints_AzimuthAngleRateConstraint(nullptr) {}
  ~AntennaConstraints_AzimuthAngleRateConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaConstraints_AzimuthAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaConstraints_AzimuthAngleRateConstraint(const AntennaConstraints_AzimuthAngleRateConstraint& from);
  AntennaConstraints_AzimuthAngleRateConstraint(AntennaConstraints_AzimuthAngleRateConstraint&& from) noexcept
    : AntennaConstraints_AzimuthAngleRateConstraint() {
    *this = ::std::move(from);
  }

  inline AntennaConstraints_AzimuthAngleRateConstraint& operator=(const AntennaConstraints_AzimuthAngleRateConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaConstraints_AzimuthAngleRateConstraint& operator=(AntennaConstraints_AzimuthAngleRateConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaConstraints_AzimuthAngleRateConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaConstraints_AzimuthAngleRateConstraint* internal_default_instance() {
    return reinterpret_cast<const AntennaConstraints_AzimuthAngleRateConstraint*>(
               &_AntennaConstraints_AzimuthAngleRateConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AntennaConstraints_AzimuthAngleRateConstraint& a, AntennaConstraints_AzimuthAngleRateConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaConstraints_AzimuthAngleRateConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaConstraints_AzimuthAngleRateConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaConstraints_AzimuthAngleRateConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaConstraints_AzimuthAngleRateConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaConstraints_AzimuthAngleRateConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaConstraints_AzimuthAngleRateConstraint& from) {
    AntennaConstraints_AzimuthAngleRateConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaConstraints_AzimuthAngleRateConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint";
  }
  protected:
  explicit AntennaConstraints_AzimuthAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumRateDegPerSecFieldNumber = 1,
    kMaximumRateDegPerSecFieldNumber = 2,
  };
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  bool has_minimum_rate_deg_per_sec() const;
  void clear_minimum_rate_deg_per_sec() ;
  double minimum_rate_deg_per_sec() const;
  void set_minimum_rate_deg_per_sec(double value);

  private:
  double _internal_minimum_rate_deg_per_sec() const;
  void _internal_set_minimum_rate_deg_per_sec(double value);

  public:
  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  bool has_maximum_rate_deg_per_sec() const;
  void clear_maximum_rate_deg_per_sec() ;
  double maximum_rate_deg_per_sec() const;
  void set_maximum_rate_deg_per_sec(double value);

  private:
  double _internal_maximum_rate_deg_per_sec() const;
  void _internal_set_maximum_rate_deg_per_sec(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double minimum_rate_deg_per_sec_;
    double maximum_rate_deg_per_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaConstraints_ElevationAngleRateConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint) */ {
 public:
  inline AntennaConstraints_ElevationAngleRateConstraint() : AntennaConstraints_ElevationAngleRateConstraint(nullptr) {}
  ~AntennaConstraints_ElevationAngleRateConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaConstraints_ElevationAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaConstraints_ElevationAngleRateConstraint(const AntennaConstraints_ElevationAngleRateConstraint& from);
  AntennaConstraints_ElevationAngleRateConstraint(AntennaConstraints_ElevationAngleRateConstraint&& from) noexcept
    : AntennaConstraints_ElevationAngleRateConstraint() {
    *this = ::std::move(from);
  }

  inline AntennaConstraints_ElevationAngleRateConstraint& operator=(const AntennaConstraints_ElevationAngleRateConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaConstraints_ElevationAngleRateConstraint& operator=(AntennaConstraints_ElevationAngleRateConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaConstraints_ElevationAngleRateConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaConstraints_ElevationAngleRateConstraint* internal_default_instance() {
    return reinterpret_cast<const AntennaConstraints_ElevationAngleRateConstraint*>(
               &_AntennaConstraints_ElevationAngleRateConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AntennaConstraints_ElevationAngleRateConstraint& a, AntennaConstraints_ElevationAngleRateConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaConstraints_ElevationAngleRateConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaConstraints_ElevationAngleRateConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaConstraints_ElevationAngleRateConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaConstraints_ElevationAngleRateConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaConstraints_ElevationAngleRateConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaConstraints_ElevationAngleRateConstraint& from) {
    AntennaConstraints_ElevationAngleRateConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaConstraints_ElevationAngleRateConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint";
  }
  protected:
  explicit AntennaConstraints_ElevationAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumRateDegPerSecFieldNumber = 1,
    kMaximumRateDegPerSecFieldNumber = 2,
  };
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  bool has_minimum_rate_deg_per_sec() const;
  void clear_minimum_rate_deg_per_sec() ;
  double minimum_rate_deg_per_sec() const;
  void set_minimum_rate_deg_per_sec(double value);

  private:
  double _internal_minimum_rate_deg_per_sec() const;
  void _internal_set_minimum_rate_deg_per_sec(double value);

  public:
  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  bool has_maximum_rate_deg_per_sec() const;
  void clear_maximum_rate_deg_per_sec() ;
  double maximum_rate_deg_per_sec() const;
  void set_maximum_rate_deg_per_sec(double value);

  private:
  double _internal_maximum_rate_deg_per_sec() const;
  void _internal_set_maximum_rate_deg_per_sec(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double minimum_rate_deg_per_sec_;
    double maximum_rate_deg_per_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaConstraints_TotalAngularRateConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint) */ {
 public:
  inline AntennaConstraints_TotalAngularRateConstraint() : AntennaConstraints_TotalAngularRateConstraint(nullptr) {}
  ~AntennaConstraints_TotalAngularRateConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaConstraints_TotalAngularRateConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaConstraints_TotalAngularRateConstraint(const AntennaConstraints_TotalAngularRateConstraint& from);
  AntennaConstraints_TotalAngularRateConstraint(AntennaConstraints_TotalAngularRateConstraint&& from) noexcept
    : AntennaConstraints_TotalAngularRateConstraint() {
    *this = ::std::move(from);
  }

  inline AntennaConstraints_TotalAngularRateConstraint& operator=(const AntennaConstraints_TotalAngularRateConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaConstraints_TotalAngularRateConstraint& operator=(AntennaConstraints_TotalAngularRateConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaConstraints_TotalAngularRateConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaConstraints_TotalAngularRateConstraint* internal_default_instance() {
    return reinterpret_cast<const AntennaConstraints_TotalAngularRateConstraint*>(
               &_AntennaConstraints_TotalAngularRateConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AntennaConstraints_TotalAngularRateConstraint& a, AntennaConstraints_TotalAngularRateConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaConstraints_TotalAngularRateConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaConstraints_TotalAngularRateConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaConstraints_TotalAngularRateConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaConstraints_TotalAngularRateConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaConstraints_TotalAngularRateConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaConstraints_TotalAngularRateConstraint& from) {
    AntennaConstraints_TotalAngularRateConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaConstraints_TotalAngularRateConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint";
  }
  protected:
  explicit AntennaConstraints_TotalAngularRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumRateDegPerSecFieldNumber = 1,
    kMaximumRateDegPerSecFieldNumber = 2,
  };
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  bool has_minimum_rate_deg_per_sec() const;
  void clear_minimum_rate_deg_per_sec() ;
  double minimum_rate_deg_per_sec() const;
  void set_minimum_rate_deg_per_sec(double value);

  private:
  double _internal_minimum_rate_deg_per_sec() const;
  void _internal_set_minimum_rate_deg_per_sec(double value);

  public:
  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  bool has_maximum_rate_deg_per_sec() const;
  void clear_maximum_rate_deg_per_sec() ;
  double maximum_rate_deg_per_sec() const;
  void set_maximum_rate_deg_per_sec(double value);

  private:
  double _internal_maximum_rate_deg_per_sec() const;
  void _internal_set_maximum_rate_deg_per_sec(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double minimum_rate_deg_per_sec_;
    double maximum_rate_deg_per_sec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class AntennaConstraints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.AntennaConstraints) */ {
 public:
  inline AntennaConstraints() : AntennaConstraints(nullptr) {}
  ~AntennaConstraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AntennaConstraints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AntennaConstraints(const AntennaConstraints& from);
  AntennaConstraints(AntennaConstraints&& from) noexcept
    : AntennaConstraints() {
    *this = ::std::move(from);
  }

  inline AntennaConstraints& operator=(const AntennaConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntennaConstraints& operator=(AntennaConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AntennaConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const AntennaConstraints* internal_default_instance() {
    return reinterpret_cast<const AntennaConstraints*>(
               &_AntennaConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AntennaConstraints& a, AntennaConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(AntennaConstraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntennaConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AntennaConstraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AntennaConstraints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AntennaConstraints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AntennaConstraints& from) {
    AntennaConstraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntennaConstraints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.AntennaConstraints";
  }
  protected:
  explicit AntennaConstraints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AntennaConstraints_LinkRangeConstraint LinkRangeConstraint;
  typedef AntennaConstraints_AzimuthAngleRateConstraint AzimuthAngleRateConstraint;
  typedef AntennaConstraints_ElevationAngleRateConstraint ElevationAngleRateConstraint;
  typedef AntennaConstraints_TotalAngularRateConstraint TotalAngularRateConstraint;

  // accessors -------------------------------------------------------

  enum : int {
    kLinkRangeFieldNumber = 1,
    kAzimuthAngleRateFieldNumber = 3,
    kElevationAngleRateFieldNumber = 4,
    kTotalAngularRateFieldNumber = 5,
    kMinimumSunAngleDegFieldNumber = 6,
    kMinimumAzimuthElevationMaskSeparationDegFieldNumber = 7,
  };
  // optional .aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint link_range = 1 [json_name = "linkRange"];
  bool has_link_range() const;
  void clear_link_range() ;
  const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint& link_range() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* release_link_range();
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* mutable_link_range();
  void set_allocated_link_range(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* link_range);
  private:
  const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint& _internal_link_range() const;
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* _internal_mutable_link_range();
  public:
  void unsafe_arena_set_allocated_link_range(
      ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* link_range);
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* unsafe_arena_release_link_range();
  // optional .aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint azimuth_angle_rate = 3 [json_name = "azimuthAngleRate"];
  bool has_azimuth_angle_rate() const;
  void clear_azimuth_angle_rate() ;
  const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint& azimuth_angle_rate() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* release_azimuth_angle_rate();
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* mutable_azimuth_angle_rate();
  void set_allocated_azimuth_angle_rate(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* azimuth_angle_rate);
  private:
  const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint& _internal_azimuth_angle_rate() const;
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* _internal_mutable_azimuth_angle_rate();
  public:
  void unsafe_arena_set_allocated_azimuth_angle_rate(
      ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* azimuth_angle_rate);
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* unsafe_arena_release_azimuth_angle_rate();
  // optional .aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint elevation_angle_rate = 4 [json_name = "elevationAngleRate"];
  bool has_elevation_angle_rate() const;
  void clear_elevation_angle_rate() ;
  const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint& elevation_angle_rate() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* release_elevation_angle_rate();
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* mutable_elevation_angle_rate();
  void set_allocated_elevation_angle_rate(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* elevation_angle_rate);
  private:
  const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint& _internal_elevation_angle_rate() const;
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* _internal_mutable_elevation_angle_rate();
  public:
  void unsafe_arena_set_allocated_elevation_angle_rate(
      ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* elevation_angle_rate);
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* unsafe_arena_release_elevation_angle_rate();
  // optional .aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint total_angular_rate = 5 [json_name = "totalAngularRate"];
  bool has_total_angular_rate() const;
  void clear_total_angular_rate() ;
  const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint& total_angular_rate() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* release_total_angular_rate();
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* mutable_total_angular_rate();
  void set_allocated_total_angular_rate(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* total_angular_rate);
  private:
  const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint& _internal_total_angular_rate() const;
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* _internal_mutable_total_angular_rate();
  public:
  void unsafe_arena_set_allocated_total_angular_rate(
      ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* total_angular_rate);
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* unsafe_arena_release_total_angular_rate();
  // optional double minimum_sun_angle_deg = 6 [json_name = "minimumSunAngleDeg"];
  bool has_minimum_sun_angle_deg() const;
  void clear_minimum_sun_angle_deg() ;
  double minimum_sun_angle_deg() const;
  void set_minimum_sun_angle_deg(double value);

  private:
  double _internal_minimum_sun_angle_deg() const;
  void _internal_set_minimum_sun_angle_deg(double value);

  public:
  // optional double minimum_azimuth_elevation_mask_separation_deg = 7 [json_name = "minimumAzimuthElevationMaskSeparationDeg"];
  bool has_minimum_azimuth_elevation_mask_separation_deg() const;
  void clear_minimum_azimuth_elevation_mask_separation_deg() ;
  double minimum_azimuth_elevation_mask_separation_deg() const;
  void set_minimum_azimuth_elevation_mask_separation_deg(double value);

  private:
  double _internal_minimum_azimuth_elevation_mask_separation_deg() const;
  void _internal_set_minimum_azimuth_elevation_mask_separation_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.AntennaConstraints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* link_range_;
    ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* azimuth_angle_rate_;
    ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* elevation_angle_rate_;
    ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* total_angular_rate_;
    double minimum_sun_angle_deg_;
    double minimum_azimuth_elevation_mask_separation_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Projection_Conic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Projection.Conic) */ {
 public:
  inline Projection_Conic() : Projection_Conic(nullptr) {}
  ~Projection_Conic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Projection_Conic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Projection_Conic(const Projection_Conic& from);
  Projection_Conic(Projection_Conic&& from) noexcept
    : Projection_Conic() {
    *this = ::std::move(from);
  }

  inline Projection_Conic& operator=(const Projection_Conic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Projection_Conic& operator=(Projection_Conic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Projection_Conic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Projection_Conic* internal_default_instance() {
    return reinterpret_cast<const Projection_Conic*>(
               &_Projection_Conic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Projection_Conic& a, Projection_Conic& b) {
    a.Swap(&b);
  }
  inline void Swap(Projection_Conic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Projection_Conic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Projection_Conic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Projection_Conic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Projection_Conic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Projection_Conic& from) {
    Projection_Conic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Projection_Conic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Projection.Conic";
  }
  protected:
  explicit Projection_Conic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOuterHalfAngleDegFieldNumber = 1,
    kInnerHalfAngleDegFieldNumber = 2,
  };
  // optional double outer_half_angle_deg = 1 [json_name = "outerHalfAngleDeg"];
  bool has_outer_half_angle_deg() const;
  void clear_outer_half_angle_deg() ;
  double outer_half_angle_deg() const;
  void set_outer_half_angle_deg(double value);

  private:
  double _internal_outer_half_angle_deg() const;
  void _internal_set_outer_half_angle_deg(double value);

  public:
  // optional double inner_half_angle_deg = 2 [json_name = "innerHalfAngleDeg"];
  bool has_inner_half_angle_deg() const;
  void clear_inner_half_angle_deg() ;
  double inner_half_angle_deg() const;
  void set_inner_half_angle_deg(double value);

  private:
  double _internal_inner_half_angle_deg() const;
  void _internal_set_inner_half_angle_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Projection.Conic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double outer_half_angle_deg_;
    double inner_half_angle_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Projection_Rectangular final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Projection.Rectangular) */ {
 public:
  inline Projection_Rectangular() : Projection_Rectangular(nullptr) {}
  ~Projection_Rectangular() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Projection_Rectangular(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Projection_Rectangular(const Projection_Rectangular& from);
  Projection_Rectangular(Projection_Rectangular&& from) noexcept
    : Projection_Rectangular() {
    *this = ::std::move(from);
  }

  inline Projection_Rectangular& operator=(const Projection_Rectangular& from) {
    CopyFrom(from);
    return *this;
  }
  inline Projection_Rectangular& operator=(Projection_Rectangular&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Projection_Rectangular& default_instance() {
    return *internal_default_instance();
  }
  static inline const Projection_Rectangular* internal_default_instance() {
    return reinterpret_cast<const Projection_Rectangular*>(
               &_Projection_Rectangular_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Projection_Rectangular& a, Projection_Rectangular& b) {
    a.Swap(&b);
  }
  inline void Swap(Projection_Rectangular* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Projection_Rectangular* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Projection_Rectangular* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Projection_Rectangular>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Projection_Rectangular& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Projection_Rectangular& from) {
    Projection_Rectangular::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Projection_Rectangular* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Projection.Rectangular";
  }
  protected:
  explicit Projection_Rectangular(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXHalfAngleDegFieldNumber = 1,
    kYHalfAngleDegFieldNumber = 2,
  };
  // optional double x_half_angle_deg = 1 [json_name = "xHalfAngleDeg"];
  bool has_x_half_angle_deg() const;
  void clear_x_half_angle_deg() ;
  double x_half_angle_deg() const;
  void set_x_half_angle_deg(double value);

  private:
  double _internal_x_half_angle_deg() const;
  void _internal_set_x_half_angle_deg(double value);

  public:
  // optional double y_half_angle_deg = 2 [json_name = "yHalfAngleDeg"];
  bool has_y_half_angle_deg() const;
  void clear_y_half_angle_deg() ;
  double y_half_angle_deg() const;
  void set_y_half_angle_deg(double value);

  private:
  double _internal_y_half_angle_deg() const;
  void _internal_set_y_half_angle_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Projection.Rectangular)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_half_angle_deg_;
    double y_half_angle_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Projection_Custom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Projection.Custom) */ {
 public:
  inline Projection_Custom() : Projection_Custom(nullptr) {}
  ~Projection_Custom() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Projection_Custom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Projection_Custom(const Projection_Custom& from);
  Projection_Custom(Projection_Custom&& from) noexcept
    : Projection_Custom() {
    *this = ::std::move(from);
  }

  inline Projection_Custom& operator=(const Projection_Custom& from) {
    CopyFrom(from);
    return *this;
  }
  inline Projection_Custom& operator=(Projection_Custom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Projection_Custom& default_instance() {
    return *internal_default_instance();
  }
  static inline const Projection_Custom* internal_default_instance() {
    return reinterpret_cast<const Projection_Custom*>(
               &_Projection_Custom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Projection_Custom& a, Projection_Custom& b) {
    a.Swap(&b);
  }
  inline void Swap(Projection_Custom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Projection_Custom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Projection_Custom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Projection_Custom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Projection_Custom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Projection_Custom& from) {
    Projection_Custom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Projection_Custom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Projection.Custom";
  }
  protected:
  explicit Projection_Custom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionsFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.common.PointingVector directions = 1 [json_name = "directions"];
  int directions_size() const;
  private:
  int _internal_directions_size() const;

  public:
  void clear_directions() ;
  ::aalyria::spacetime::api::common::PointingVector* mutable_directions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointingVector >*
      mutable_directions();
  private:
  const ::aalyria::spacetime::api::common::PointingVector& _internal_directions(int index) const;
  ::aalyria::spacetime::api::common::PointingVector* _internal_add_directions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointingVector>& _internal_directions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointingVector>* _internal_mutable_directions();
  public:
  const ::aalyria::spacetime::api::common::PointingVector& directions(int index) const;
  ::aalyria::spacetime::api::common::PointingVector* add_directions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointingVector >&
      directions() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Projection.Custom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointingVector > directions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Projection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Projection) */ {
 public:
  inline Projection() : Projection(nullptr) {}
  ~Projection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Projection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Projection(const Projection& from);
  Projection(Projection&& from) noexcept
    : Projection() {
    *this = ::std::move(from);
  }

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Projection& operator=(Projection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Projection& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeTypeCase {
    kConic = 1,
    kRectangular = 2,
    kCustom = 3,
    SHAPE_TYPE_NOT_SET = 0,
  };

  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Projection& a, Projection& b) {
    a.Swap(&b);
  }
  inline void Swap(Projection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Projection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Projection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Projection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Projection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Projection& from) {
    Projection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Projection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Projection";
  }
  protected:
  explicit Projection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Projection_Conic Conic;
  typedef Projection_Rectangular Rectangular;
  typedef Projection_Custom Custom;

  // accessors -------------------------------------------------------

  enum : int {
    kConicFieldNumber = 1,
    kRectangularFieldNumber = 2,
    kCustomFieldNumber = 3,
  };
  // .aalyria.spacetime.api.common.Projection.Conic conic = 1 [json_name = "conic"];
  bool has_conic() const;
  private:
  bool _internal_has_conic() const;

  public:
  void clear_conic() ;
  const ::aalyria::spacetime::api::common::Projection_Conic& conic() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Projection_Conic* release_conic();
  ::aalyria::spacetime::api::common::Projection_Conic* mutable_conic();
  void set_allocated_conic(::aalyria::spacetime::api::common::Projection_Conic* conic);
  private:
  const ::aalyria::spacetime::api::common::Projection_Conic& _internal_conic() const;
  ::aalyria::spacetime::api::common::Projection_Conic* _internal_mutable_conic();
  public:
  void unsafe_arena_set_allocated_conic(
      ::aalyria::spacetime::api::common::Projection_Conic* conic);
  ::aalyria::spacetime::api::common::Projection_Conic* unsafe_arena_release_conic();
  // .aalyria.spacetime.api.common.Projection.Rectangular rectangular = 2 [json_name = "rectangular"];
  bool has_rectangular() const;
  private:
  bool _internal_has_rectangular() const;

  public:
  void clear_rectangular() ;
  const ::aalyria::spacetime::api::common::Projection_Rectangular& rectangular() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Projection_Rectangular* release_rectangular();
  ::aalyria::spacetime::api::common::Projection_Rectangular* mutable_rectangular();
  void set_allocated_rectangular(::aalyria::spacetime::api::common::Projection_Rectangular* rectangular);
  private:
  const ::aalyria::spacetime::api::common::Projection_Rectangular& _internal_rectangular() const;
  ::aalyria::spacetime::api::common::Projection_Rectangular* _internal_mutable_rectangular();
  public:
  void unsafe_arena_set_allocated_rectangular(
      ::aalyria::spacetime::api::common::Projection_Rectangular* rectangular);
  ::aalyria::spacetime::api::common::Projection_Rectangular* unsafe_arena_release_rectangular();
  // .aalyria.spacetime.api.common.Projection.Custom custom = 3 [json_name = "custom"];
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;

  public:
  void clear_custom() ;
  const ::aalyria::spacetime::api::common::Projection_Custom& custom() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Projection_Custom* release_custom();
  ::aalyria::spacetime::api::common::Projection_Custom* mutable_custom();
  void set_allocated_custom(::aalyria::spacetime::api::common::Projection_Custom* custom);
  private:
  const ::aalyria::spacetime::api::common::Projection_Custom& _internal_custom() const;
  ::aalyria::spacetime::api::common::Projection_Custom* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::aalyria::spacetime::api::common::Projection_Custom* custom);
  ::aalyria::spacetime::api::common::Projection_Custom* unsafe_arena_release_custom();
  void clear_shape_type();
  ShapeTypeCase shape_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Projection)
 private:
  class _Internal;
  void set_has_conic();
  void set_has_rectangular();
  void set_has_custom();

  inline bool has_shape_type() const;
  inline void clear_has_shape_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ShapeTypeUnion {
      constexpr ShapeTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::Projection_Conic* conic_;
      ::aalyria::spacetime::api::common::Projection_Rectangular* rectangular_;
      ::aalyria::spacetime::api::common::Projection_Custom* custom_;
    } shape_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Polarization_Constant_Linear final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Polarization.Constant.Linear) */ {
 public:
  inline Polarization_Constant_Linear() : Polarization_Constant_Linear(nullptr) {}
  ~Polarization_Constant_Linear() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Polarization_Constant_Linear(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polarization_Constant_Linear(const Polarization_Constant_Linear& from);
  Polarization_Constant_Linear(Polarization_Constant_Linear&& from) noexcept
    : Polarization_Constant_Linear() {
    *this = ::std::move(from);
  }

  inline Polarization_Constant_Linear& operator=(const Polarization_Constant_Linear& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polarization_Constant_Linear& operator=(Polarization_Constant_Linear&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polarization_Constant_Linear& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polarization_Constant_Linear* internal_default_instance() {
    return reinterpret_cast<const Polarization_Constant_Linear*>(
               &_Polarization_Constant_Linear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Polarization_Constant_Linear& a, Polarization_Constant_Linear& b) {
    a.Swap(&b);
  }
  inline void Swap(Polarization_Constant_Linear* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polarization_Constant_Linear* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polarization_Constant_Linear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polarization_Constant_Linear>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polarization_Constant_Linear& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polarization_Constant_Linear& from) {
    Polarization_Constant_Linear::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polarization_Constant_Linear* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Polarization.Constant.Linear";
  }
  protected:
  explicit Polarization_Constant_Linear(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTiltAngleDegFieldNumber = 1,
  };
  // optional double tilt_angle_deg = 1 [json_name = "tiltAngleDeg"];
  bool has_tilt_angle_deg() const;
  void clear_tilt_angle_deg() ;
  double tilt_angle_deg() const;
  void set_tilt_angle_deg(double value);

  private:
  double _internal_tilt_angle_deg() const;
  void _internal_set_tilt_angle_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Polarization.Constant.Linear)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double tilt_angle_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Polarization_Constant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Polarization.Constant) */ {
 public:
  inline Polarization_Constant() : Polarization_Constant(nullptr) {}
  ~Polarization_Constant() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Polarization_Constant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polarization_Constant(const Polarization_Constant& from);
  Polarization_Constant(Polarization_Constant&& from) noexcept
    : Polarization_Constant() {
    *this = ::std::move(from);
  }

  inline Polarization_Constant& operator=(const Polarization_Constant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polarization_Constant& operator=(Polarization_Constant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polarization_Constant& default_instance() {
    return *internal_default_instance();
  }
  enum PolarizationCase {
    kLeftHandCircular = 1,
    kRightHandCircular = 2,
    kLinear = 3,
    POLARIZATION_NOT_SET = 0,
  };

  static inline const Polarization_Constant* internal_default_instance() {
    return reinterpret_cast<const Polarization_Constant*>(
               &_Polarization_Constant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Polarization_Constant& a, Polarization_Constant& b) {
    a.Swap(&b);
  }
  inline void Swap(Polarization_Constant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polarization_Constant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polarization_Constant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polarization_Constant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polarization_Constant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polarization_Constant& from) {
    Polarization_Constant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polarization_Constant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Polarization.Constant";
  }
  protected:
  explicit Polarization_Constant(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Polarization_Constant_Linear Linear;

  // accessors -------------------------------------------------------

  enum : int {
    kLeftHandCircularFieldNumber = 1,
    kRightHandCircularFieldNumber = 2,
    kLinearFieldNumber = 3,
  };
  // .google.protobuf.Empty left_hand_circular = 1 [json_name = "leftHandCircular"];
  bool has_left_hand_circular() const;
  private:
  bool _internal_has_left_hand_circular() const;

  public:
  void clear_left_hand_circular() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& left_hand_circular() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_left_hand_circular();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_left_hand_circular();
  void set_allocated_left_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* left_hand_circular);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_left_hand_circular() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_left_hand_circular();
  public:
  void unsafe_arena_set_allocated_left_hand_circular(
      ::PROTOBUF_NAMESPACE_ID::Empty* left_hand_circular);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_left_hand_circular();
  // .google.protobuf.Empty right_hand_circular = 2 [json_name = "rightHandCircular"];
  bool has_right_hand_circular() const;
  private:
  bool _internal_has_right_hand_circular() const;

  public:
  void clear_right_hand_circular() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& right_hand_circular() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_right_hand_circular();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_right_hand_circular();
  void set_allocated_right_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* right_hand_circular);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_right_hand_circular() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_right_hand_circular();
  public:
  void unsafe_arena_set_allocated_right_hand_circular(
      ::PROTOBUF_NAMESPACE_ID::Empty* right_hand_circular);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_right_hand_circular();
  // .aalyria.spacetime.api.common.Polarization.Constant.Linear linear = 3 [json_name = "linear"];
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;

  public:
  void clear_linear() ;
  const ::aalyria::spacetime::api::common::Polarization_Constant_Linear& linear() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Polarization_Constant_Linear* release_linear();
  ::aalyria::spacetime::api::common::Polarization_Constant_Linear* mutable_linear();
  void set_allocated_linear(::aalyria::spacetime::api::common::Polarization_Constant_Linear* linear);
  private:
  const ::aalyria::spacetime::api::common::Polarization_Constant_Linear& _internal_linear() const;
  ::aalyria::spacetime::api::common::Polarization_Constant_Linear* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::aalyria::spacetime::api::common::Polarization_Constant_Linear* linear);
  ::aalyria::spacetime::api::common::Polarization_Constant_Linear* unsafe_arena_release_linear();
  void clear_polarization();
  PolarizationCase polarization_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Polarization.Constant)
 private:
  class _Internal;
  void set_has_left_hand_circular();
  void set_has_right_hand_circular();
  void set_has_linear();

  inline bool has_polarization() const;
  inline void clear_has_polarization();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PolarizationUnion {
      constexpr PolarizationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Empty* left_hand_circular_;
      ::PROTOBUF_NAMESPACE_ID::Empty* right_hand_circular_;
      ::aalyria::spacetime::api::common::Polarization_Constant_Linear* linear_;
    } polarization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Polarization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Polarization) */ {
 public:
  inline Polarization() : Polarization(nullptr) {}
  ~Polarization() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Polarization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polarization(const Polarization& from);
  Polarization(Polarization&& from) noexcept
    : Polarization() {
    *this = ::std::move(from);
  }

  inline Polarization& operator=(const Polarization& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polarization& operator=(Polarization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polarization& default_instance() {
    return *internal_default_instance();
  }
  enum SourceCase {
    kConstant = 1,
    SOURCE_NOT_SET = 0,
  };

  static inline const Polarization* internal_default_instance() {
    return reinterpret_cast<const Polarization*>(
               &_Polarization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Polarization& a, Polarization& b) {
    a.Swap(&b);
  }
  inline void Swap(Polarization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polarization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polarization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polarization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polarization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polarization& from) {
    Polarization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polarization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Polarization";
  }
  protected:
  explicit Polarization(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Polarization_Constant Constant;

  // accessors -------------------------------------------------------

  enum : int {
    kConstantFieldNumber = 1,
  };
  // .aalyria.spacetime.api.common.Polarization.Constant constant = 1 [json_name = "constant"];
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;

  public:
  void clear_constant() ;
  const ::aalyria::spacetime::api::common::Polarization_Constant& constant() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Polarization_Constant* release_constant();
  ::aalyria::spacetime::api::common::Polarization_Constant* mutable_constant();
  void set_allocated_constant(::aalyria::spacetime::api::common::Polarization_Constant* constant);
  private:
  const ::aalyria::spacetime::api::common::Polarization_Constant& _internal_constant() const;
  ::aalyria::spacetime::api::common::Polarization_Constant* _internal_mutable_constant();
  public:
  void unsafe_arena_set_allocated_constant(
      ::aalyria::spacetime::api::common::Polarization_Constant* constant);
  ::aalyria::spacetime::api::common::Polarization_Constant* unsafe_arena_release_constant();
  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Polarization)
 private:
  class _Internal;
  void set_has_constant();

  inline bool has_source() const;
  inline void clear_has_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::Polarization_Constant* constant_;
    } source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};// -------------------------------------------------------------------

class Targeting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Targeting) */ {
 public:
  inline Targeting() : Targeting(nullptr) {}
  ~Targeting() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Targeting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Targeting(const Targeting& from);
  Targeting(Targeting&& from) noexcept
    : Targeting() {
    *this = ::std::move(from);
  }

  inline Targeting& operator=(const Targeting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Targeting& operator=(Targeting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Targeting& default_instance() {
    return *internal_default_instance();
  }
  static inline const Targeting* internal_default_instance() {
    return reinterpret_cast<const Targeting*>(
               &_Targeting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Targeting& a, Targeting& b) {
    a.Swap(&b);
  }
  inline void Swap(Targeting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Targeting* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Targeting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Targeting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Targeting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Targeting& from) {
    Targeting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Targeting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Targeting";
  }
  protected:
  explicit Targeting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionFormatFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.common.Motion.Type motion_format = 1 [json_name = "motionFormat"];
  bool has_motion_format() const;
  void clear_motion_format() ;
  ::aalyria::spacetime::api::common::Motion_Type motion_format() const;
  void set_motion_format(::aalyria::spacetime::api::common::Motion_Type value);

  private:
  ::aalyria::spacetime::api::common::Motion_Type _internal_motion_format() const;
  void _internal_set_motion_format(::aalyria::spacetime::api::common::Motion_Type value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Targeting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int motion_format_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AntennaDefinition_ElevationMask_ElevationRise

// optional double distance = 1 [json_name = "distance"];
inline bool AntennaDefinition_ElevationMask_ElevationRise::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaDefinition_ElevationMask_ElevationRise::clear_distance() {
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaDefinition_ElevationMask_ElevationRise::distance() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise.distance)
  return _internal_distance();
}
inline void AntennaDefinition_ElevationMask_ElevationRise::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise.distance)
}
inline double AntennaDefinition_ElevationMask_ElevationRise::_internal_distance() const {
  return _impl_.distance_;
}
inline void AntennaDefinition_ElevationMask_ElevationRise::_internal_set_distance(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.distance_ = value;
}

// optional double obscured_elevation_deg = 2 [json_name = "obscuredElevationDeg"];
inline bool AntennaDefinition_ElevationMask_ElevationRise::has_obscured_elevation_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaDefinition_ElevationMask_ElevationRise::clear_obscured_elevation_deg() {
  _impl_.obscured_elevation_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaDefinition_ElevationMask_ElevationRise::obscured_elevation_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise.obscured_elevation_deg)
  return _internal_obscured_elevation_deg();
}
inline void AntennaDefinition_ElevationMask_ElevationRise::set_obscured_elevation_deg(double value) {
  _internal_set_obscured_elevation_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise.obscured_elevation_deg)
}
inline double AntennaDefinition_ElevationMask_ElevationRise::_internal_obscured_elevation_deg() const {
  return _impl_.obscured_elevation_deg_;
}
inline void AntennaDefinition_ElevationMask_ElevationRise::_internal_set_obscured_elevation_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obscured_elevation_deg_ = value;
}

// -------------------------------------------------------------------

// AntennaDefinition_ElevationMask

// optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
inline bool AntennaDefinition_ElevationMask::has_azimuth_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaDefinition_ElevationMask::clear_azimuth_deg() {
  _impl_.azimuth_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaDefinition_ElevationMask::azimuth_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.azimuth_deg)
  return _internal_azimuth_deg();
}
inline void AntennaDefinition_ElevationMask::set_azimuth_deg(double value) {
  _internal_set_azimuth_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.azimuth_deg)
}
inline double AntennaDefinition_ElevationMask::_internal_azimuth_deg() const {
  return _impl_.azimuth_deg_;
}
inline void AntennaDefinition_ElevationMask::_internal_set_azimuth_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.azimuth_deg_ = value;
}

// optional double maximum_obscured_elevation_deg = 2 [json_name = "maximumObscuredElevationDeg"];
inline bool AntennaDefinition_ElevationMask::has_maximum_obscured_elevation_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaDefinition_ElevationMask::clear_maximum_obscured_elevation_deg() {
  _impl_.maximum_obscured_elevation_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaDefinition_ElevationMask::maximum_obscured_elevation_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.maximum_obscured_elevation_deg)
  return _internal_maximum_obscured_elevation_deg();
}
inline void AntennaDefinition_ElevationMask::set_maximum_obscured_elevation_deg(double value) {
  _internal_set_maximum_obscured_elevation_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.maximum_obscured_elevation_deg)
}
inline double AntennaDefinition_ElevationMask::_internal_maximum_obscured_elevation_deg() const {
  return _impl_.maximum_obscured_elevation_deg_;
}
inline void AntennaDefinition_ElevationMask::_internal_set_maximum_obscured_elevation_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_obscured_elevation_deg_ = value;
}

// repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise elevation_rise = 3 [json_name = "elevationRise"];
inline int AntennaDefinition_ElevationMask::_internal_elevation_rise_size() const {
  return _impl_.elevation_rise_.size();
}
inline int AntennaDefinition_ElevationMask::elevation_rise_size() const {
  return _internal_elevation_rise_size();
}
inline void AntennaDefinition_ElevationMask::clear_elevation_rise() {
  _internal_mutable_elevation_rise()->Clear();
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* AntennaDefinition_ElevationMask::mutable_elevation_rise(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise)
  return _internal_mutable_elevation_rise()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >*
AntennaDefinition_ElevationMask::mutable_elevation_rise() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise)
  return _internal_mutable_elevation_rise();
}
inline const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise& AntennaDefinition_ElevationMask::_internal_elevation_rise(int index) const {
  return _internal_elevation_rise().Get(index);
}
inline const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise& AntennaDefinition_ElevationMask::elevation_rise(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise)
  return _internal_elevation_rise(index);
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* AntennaDefinition_ElevationMask::_internal_add_elevation_rise() {
  return _internal_mutable_elevation_rise()->Add();
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* AntennaDefinition_ElevationMask::add_elevation_rise() {
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise* _add = _internal_add_elevation_rise();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >&
AntennaDefinition_ElevationMask::elevation_rise() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise)
  return _internal_elevation_rise();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise>&
AntennaDefinition_ElevationMask::_internal_elevation_rise() const {
  return _impl_.elevation_rise_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise>*
AntennaDefinition_ElevationMask::_internal_mutable_elevation_rise() {
  return &_impl_.elevation_rise_;
}

// -------------------------------------------------------------------

// AntennaDefinition

// optional string name = 2 [json_name = "name"];
inline bool AntennaDefinition::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AntennaDefinition::name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AntennaDefinition::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.name)
}
inline std::string* AntennaDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.name)
  return _s;
}
inline const std::string& AntennaDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AntennaDefinition::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AntennaDefinition::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AntennaDefinition::release_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AntennaDefinition::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.name)
}

// optional .aalyria.spacetime.api.common.PointAxes fixed_coordinate_offset = 3 [json_name = "fixedCoordinateOffset"];
inline bool AntennaDefinition::has_fixed_coordinate_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fixed_coordinate_offset_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::PointAxes& AntennaDefinition::_internal_fixed_coordinate_offset() const {
  const ::aalyria::spacetime::api::common::PointAxes* p = _impl_.fixed_coordinate_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PointAxes&>(
      ::aalyria::spacetime::api::common::_PointAxes_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PointAxes& AntennaDefinition::fixed_coordinate_offset() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset)
  return _internal_fixed_coordinate_offset();
}
inline void AntennaDefinition::unsafe_arena_set_allocated_fixed_coordinate_offset(
    ::aalyria::spacetime::api::common::PointAxes* fixed_coordinate_offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fixed_coordinate_offset_);
  }
  _impl_.fixed_coordinate_offset_ = fixed_coordinate_offset;
  if (fixed_coordinate_offset) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset)
}
inline ::aalyria::spacetime::api::common::PointAxes* AntennaDefinition::release_fixed_coordinate_offset() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PointAxes* temp = _impl_.fixed_coordinate_offset_;
  _impl_.fixed_coordinate_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PointAxes* AntennaDefinition::unsafe_arena_release_fixed_coordinate_offset() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PointAxes* temp = _impl_.fixed_coordinate_offset_;
  _impl_.fixed_coordinate_offset_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PointAxes* AntennaDefinition::_internal_mutable_fixed_coordinate_offset() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.fixed_coordinate_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PointAxes>(GetArenaForAllocation());
    _impl_.fixed_coordinate_offset_ = p;
  }
  return _impl_.fixed_coordinate_offset_;
}
inline ::aalyria::spacetime::api::common::PointAxes* AntennaDefinition::mutable_fixed_coordinate_offset() {
  ::aalyria::spacetime::api::common::PointAxes* _msg = _internal_mutable_fixed_coordinate_offset();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset)
  return _msg;
}
inline void AntennaDefinition::set_allocated_fixed_coordinate_offset(::aalyria::spacetime::api::common::PointAxes* fixed_coordinate_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fixed_coordinate_offset_);
  }
  if (fixed_coordinate_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fixed_coordinate_offset));
    if (message_arena != submessage_arena) {
      fixed_coordinate_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed_coordinate_offset, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fixed_coordinate_offset_ = fixed_coordinate_offset;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset)
}

// optional .aalyria.spacetime.api.common.Targeting targeting = 18 [json_name = "targeting"];
inline bool AntennaDefinition::has_targeting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targeting_ != nullptr);
  return value;
}
inline void AntennaDefinition::clear_targeting() {
  if (_impl_.targeting_ != nullptr) _impl_.targeting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::aalyria::spacetime::api::common::Targeting& AntennaDefinition::_internal_targeting() const {
  const ::aalyria::spacetime::api::common::Targeting* p = _impl_.targeting_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Targeting&>(
      ::aalyria::spacetime::api::common::_Targeting_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Targeting& AntennaDefinition::targeting() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.targeting)
  return _internal_targeting();
}
inline void AntennaDefinition::unsafe_arena_set_allocated_targeting(
    ::aalyria::spacetime::api::common::Targeting* targeting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.targeting_);
  }
  _impl_.targeting_ = targeting;
  if (targeting) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.targeting)
}
inline ::aalyria::spacetime::api::common::Targeting* AntennaDefinition::release_targeting() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::aalyria::spacetime::api::common::Targeting* temp = _impl_.targeting_;
  _impl_.targeting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Targeting* AntennaDefinition::unsafe_arena_release_targeting() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.targeting)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::aalyria::spacetime::api::common::Targeting* temp = _impl_.targeting_;
  _impl_.targeting_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Targeting* AntennaDefinition::_internal_mutable_targeting() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.targeting_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Targeting>(GetArenaForAllocation());
    _impl_.targeting_ = p;
  }
  return _impl_.targeting_;
}
inline ::aalyria::spacetime::api::common::Targeting* AntennaDefinition::mutable_targeting() {
  ::aalyria::spacetime::api::common::Targeting* _msg = _internal_mutable_targeting();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.targeting)
  return _msg;
}
inline void AntennaDefinition::set_allocated_targeting(::aalyria::spacetime::api::common::Targeting* targeting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.targeting_;
  }
  if (targeting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(targeting);
    if (message_arena != submessage_arena) {
      targeting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targeting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.targeting_ = targeting;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.targeting)
}

// optional string antenna_pattern_id = 10 [json_name = "antennaPatternId"];
inline bool AntennaDefinition::has_antenna_pattern_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaDefinition::clear_antenna_pattern_id() {
  _impl_.antenna_pattern_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AntennaDefinition::antenna_pattern_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id)
  return _internal_antenna_pattern_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AntennaDefinition::set_antenna_pattern_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.antenna_pattern_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id)
}
inline std::string* AntennaDefinition::mutable_antenna_pattern_id() {
  std::string* _s = _internal_mutable_antenna_pattern_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id)
  return _s;
}
inline const std::string& AntennaDefinition::_internal_antenna_pattern_id() const {
  return _impl_.antenna_pattern_id_.Get();
}
inline void AntennaDefinition::_internal_set_antenna_pattern_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.antenna_pattern_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AntennaDefinition::_internal_mutable_antenna_pattern_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.antenna_pattern_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AntennaDefinition::release_antenna_pattern_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.antenna_pattern_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.antenna_pattern_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AntennaDefinition::set_allocated_antenna_pattern_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.antenna_pattern_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.antenna_pattern_id_.IsDefault()) {
          _impl_.antenna_pattern_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id)
}

// optional .aalyria.spacetime.api.common.Polarization polarization = 17 [json_name = "polarization"];
inline bool AntennaDefinition::has_polarization() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.polarization_ != nullptr);
  return value;
}
inline void AntennaDefinition::clear_polarization() {
  if (_impl_.polarization_ != nullptr) _impl_.polarization_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::aalyria::spacetime::api::common::Polarization& AntennaDefinition::_internal_polarization() const {
  const ::aalyria::spacetime::api::common::Polarization* p = _impl_.polarization_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Polarization&>(
      ::aalyria::spacetime::api::common::_Polarization_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Polarization& AntennaDefinition::polarization() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.polarization)
  return _internal_polarization();
}
inline void AntennaDefinition::unsafe_arena_set_allocated_polarization(
    ::aalyria::spacetime::api::common::Polarization* polarization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polarization_);
  }
  _impl_.polarization_ = polarization;
  if (polarization) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.polarization)
}
inline ::aalyria::spacetime::api::common::Polarization* AntennaDefinition::release_polarization() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::aalyria::spacetime::api::common::Polarization* temp = _impl_.polarization_;
  _impl_.polarization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Polarization* AntennaDefinition::unsafe_arena_release_polarization() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.polarization)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::aalyria::spacetime::api::common::Polarization* temp = _impl_.polarization_;
  _impl_.polarization_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Polarization* AntennaDefinition::_internal_mutable_polarization() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.polarization_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Polarization>(GetArenaForAllocation());
    _impl_.polarization_ = p;
  }
  return _impl_.polarization_;
}
inline ::aalyria::spacetime::api::common::Polarization* AntennaDefinition::mutable_polarization() {
  ::aalyria::spacetime::api::common::Polarization* _msg = _internal_mutable_polarization();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.polarization)
  return _msg;
}
inline void AntennaDefinition::set_allocated_polarization(::aalyria::spacetime::api::common::Polarization* polarization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.polarization_;
  }
  if (polarization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polarization);
    if (message_arena != submessage_arena) {
      polarization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polarization, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.polarization_ = polarization;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.polarization)
}

// optional .aalyria.spacetime.api.common.Projection field_of_regard = 11 [json_name = "fieldOfRegard"];
inline bool AntennaDefinition::has_field_of_regard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.field_of_regard_ != nullptr);
  return value;
}
inline void AntennaDefinition::clear_field_of_regard() {
  if (_impl_.field_of_regard_ != nullptr) _impl_.field_of_regard_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::aalyria::spacetime::api::common::Projection& AntennaDefinition::_internal_field_of_regard() const {
  const ::aalyria::spacetime::api::common::Projection* p = _impl_.field_of_regard_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Projection&>(
      ::aalyria::spacetime::api::common::_Projection_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Projection& AntennaDefinition::field_of_regard() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.field_of_regard)
  return _internal_field_of_regard();
}
inline void AntennaDefinition::unsafe_arena_set_allocated_field_of_regard(
    ::aalyria::spacetime::api::common::Projection* field_of_regard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_of_regard_);
  }
  _impl_.field_of_regard_ = field_of_regard;
  if (field_of_regard) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.field_of_regard)
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::release_field_of_regard() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::Projection* temp = _impl_.field_of_regard_;
  _impl_.field_of_regard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::unsafe_arena_release_field_of_regard() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.field_of_regard)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::Projection* temp = _impl_.field_of_regard_;
  _impl_.field_of_regard_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::_internal_mutable_field_of_regard() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.field_of_regard_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Projection>(GetArenaForAllocation());
    _impl_.field_of_regard_ = p;
  }
  return _impl_.field_of_regard_;
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::mutable_field_of_regard() {
  ::aalyria::spacetime::api::common::Projection* _msg = _internal_mutable_field_of_regard();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.field_of_regard)
  return _msg;
}
inline void AntennaDefinition::set_allocated_field_of_regard(::aalyria::spacetime::api::common::Projection* field_of_regard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.field_of_regard_;
  }
  if (field_of_regard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(field_of_regard);
    if (message_arena != submessage_arena) {
      field_of_regard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_of_regard, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.field_of_regard_ = field_of_regard;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.field_of_regard)
}

// repeated .aalyria.spacetime.api.common.Projection obstructions = 12 [json_name = "obstructions"];
inline int AntennaDefinition::_internal_obstructions_size() const {
  return _impl_.obstructions_.size();
}
inline int AntennaDefinition::obstructions_size() const {
  return _internal_obstructions_size();
}
inline void AntennaDefinition::clear_obstructions() {
  _internal_mutable_obstructions()->Clear();
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::mutable_obstructions(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.obstructions)
  return _internal_mutable_obstructions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Projection >*
AntennaDefinition::mutable_obstructions() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.AntennaDefinition.obstructions)
  return _internal_mutable_obstructions();
}
inline const ::aalyria::spacetime::api::common::Projection& AntennaDefinition::_internal_obstructions(int index) const {
  return _internal_obstructions().Get(index);
}
inline const ::aalyria::spacetime::api::common::Projection& AntennaDefinition::obstructions(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.obstructions)
  return _internal_obstructions(index);
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::_internal_add_obstructions() {
  return _internal_mutable_obstructions()->Add();
}
inline ::aalyria::spacetime::api::common::Projection* AntennaDefinition::add_obstructions() {
  ::aalyria::spacetime::api::common::Projection* _add = _internal_add_obstructions();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.AntennaDefinition.obstructions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Projection >&
AntennaDefinition::obstructions() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.AntennaDefinition.obstructions)
  return _internal_obstructions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Projection>&
AntennaDefinition::_internal_obstructions() const {
  return _impl_.obstructions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Projection>*
AntennaDefinition::_internal_mutable_obstructions() {
  return &_impl_.obstructions_;
}

// repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask azimuth_elevation_mask = 9 [json_name = "azimuthElevationMask"];
inline int AntennaDefinition::_internal_azimuth_elevation_mask_size() const {
  return _impl_.azimuth_elevation_mask_.size();
}
inline int AntennaDefinition::azimuth_elevation_mask_size() const {
  return _internal_azimuth_elevation_mask_size();
}
inline void AntennaDefinition::clear_azimuth_elevation_mask() {
  _internal_mutable_azimuth_elevation_mask()->Clear();
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* AntennaDefinition::mutable_azimuth_elevation_mask(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask)
  return _internal_mutable_azimuth_elevation_mask()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >*
AntennaDefinition::mutable_azimuth_elevation_mask() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask)
  return _internal_mutable_azimuth_elevation_mask();
}
inline const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask& AntennaDefinition::_internal_azimuth_elevation_mask(int index) const {
  return _internal_azimuth_elevation_mask().Get(index);
}
inline const ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask& AntennaDefinition::azimuth_elevation_mask(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask)
  return _internal_azimuth_elevation_mask(index);
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* AntennaDefinition::_internal_add_azimuth_elevation_mask() {
  return _internal_mutable_azimuth_elevation_mask()->Add();
}
inline ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* AntennaDefinition::add_azimuth_elevation_mask() {
  ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask* _add = _internal_add_azimuth_elevation_mask();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >&
AntennaDefinition::azimuth_elevation_mask() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask)
  return _internal_azimuth_elevation_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask>&
AntennaDefinition::_internal_azimuth_elevation_mask() const {
  return _impl_.azimuth_elevation_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask>*
AntennaDefinition::_internal_mutable_azimuth_elevation_mask() {
  return &_impl_.azimuth_elevation_mask_;
}

// optional .aalyria.spacetime.api.common.AntennaConstraints constraints = 6 [json_name = "constraints"];
inline bool AntennaDefinition::has_constraints() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.constraints_ != nullptr);
  return value;
}
inline void AntennaDefinition::clear_constraints() {
  if (_impl_.constraints_ != nullptr) _impl_.constraints_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints& AntennaDefinition::_internal_constraints() const {
  const ::aalyria::spacetime::api::common::AntennaConstraints* p = _impl_.constraints_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AntennaConstraints&>(
      ::aalyria::spacetime::api::common::_AntennaConstraints_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints& AntennaDefinition::constraints() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaDefinition.constraints)
  return _internal_constraints();
}
inline void AntennaDefinition::unsafe_arena_set_allocated_constraints(
    ::aalyria::spacetime::api::common::AntennaConstraints* constraints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.constraints_);
  }
  _impl_.constraints_ = constraints;
  if (constraints) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.constraints)
}
inline ::aalyria::spacetime::api::common::AntennaConstraints* AntennaDefinition::release_constraints() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::AntennaConstraints* temp = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints* AntennaDefinition::unsafe_arena_release_constraints() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaDefinition.constraints)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::AntennaConstraints* temp = _impl_.constraints_;
  _impl_.constraints_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints* AntennaDefinition::_internal_mutable_constraints() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints>(GetArenaForAllocation());
    _impl_.constraints_ = p;
  }
  return _impl_.constraints_;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints* AntennaDefinition::mutable_constraints() {
  ::aalyria::spacetime::api::common::AntennaConstraints* _msg = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaDefinition.constraints)
  return _msg;
}
inline void AntennaDefinition::set_allocated_constraints(::aalyria::spacetime::api::common::AntennaConstraints* constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.constraints_;
  }
  if (constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constraints);
    if (message_arena != submessage_arena) {
      constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaDefinition.constraints)
}

// -------------------------------------------------------------------

// AntennaConstraints_LinkRangeConstraint

// optional double minimum_range = 1 [json_name = "minimumRange"];
inline bool AntennaConstraints_LinkRangeConstraint::has_minimum_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaConstraints_LinkRangeConstraint::clear_minimum_range() {
  _impl_.minimum_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaConstraints_LinkRangeConstraint::minimum_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint.minimum_range)
  return _internal_minimum_range();
}
inline void AntennaConstraints_LinkRangeConstraint::set_minimum_range(double value) {
  _internal_set_minimum_range(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint.minimum_range)
}
inline double AntennaConstraints_LinkRangeConstraint::_internal_minimum_range() const {
  return _impl_.minimum_range_;
}
inline void AntennaConstraints_LinkRangeConstraint::_internal_set_minimum_range(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_range_ = value;
}

// optional double maximum_range = 2 [json_name = "maximumRange"];
inline bool AntennaConstraints_LinkRangeConstraint::has_maximum_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaConstraints_LinkRangeConstraint::clear_maximum_range() {
  _impl_.maximum_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaConstraints_LinkRangeConstraint::maximum_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint.maximum_range)
  return _internal_maximum_range();
}
inline void AntennaConstraints_LinkRangeConstraint::set_maximum_range(double value) {
  _internal_set_maximum_range(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint.maximum_range)
}
inline double AntennaConstraints_LinkRangeConstraint::_internal_maximum_range() const {
  return _impl_.maximum_range_;
}
inline void AntennaConstraints_LinkRangeConstraint::_internal_set_maximum_range(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_range_ = value;
}

// -------------------------------------------------------------------

// AntennaConstraints_AzimuthAngleRateConstraint

// optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
inline bool AntennaConstraints_AzimuthAngleRateConstraint::has_minimum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::clear_minimum_rate_deg_per_sec() {
  _impl_.minimum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaConstraints_AzimuthAngleRateConstraint::minimum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint.minimum_rate_deg_per_sec)
  return _internal_minimum_rate_deg_per_sec();
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::set_minimum_rate_deg_per_sec(double value) {
  _internal_set_minimum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint.minimum_rate_deg_per_sec)
}
inline double AntennaConstraints_AzimuthAngleRateConstraint::_internal_minimum_rate_deg_per_sec() const {
  return _impl_.minimum_rate_deg_per_sec_;
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::_internal_set_minimum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_rate_deg_per_sec_ = value;
}

// optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
inline bool AntennaConstraints_AzimuthAngleRateConstraint::has_maximum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::clear_maximum_rate_deg_per_sec() {
  _impl_.maximum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaConstraints_AzimuthAngleRateConstraint::maximum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint.maximum_rate_deg_per_sec)
  return _internal_maximum_rate_deg_per_sec();
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::set_maximum_rate_deg_per_sec(double value) {
  _internal_set_maximum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint.maximum_rate_deg_per_sec)
}
inline double AntennaConstraints_AzimuthAngleRateConstraint::_internal_maximum_rate_deg_per_sec() const {
  return _impl_.maximum_rate_deg_per_sec_;
}
inline void AntennaConstraints_AzimuthAngleRateConstraint::_internal_set_maximum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_rate_deg_per_sec_ = value;
}

// -------------------------------------------------------------------

// AntennaConstraints_ElevationAngleRateConstraint

// optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
inline bool AntennaConstraints_ElevationAngleRateConstraint::has_minimum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaConstraints_ElevationAngleRateConstraint::clear_minimum_rate_deg_per_sec() {
  _impl_.minimum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaConstraints_ElevationAngleRateConstraint::minimum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint.minimum_rate_deg_per_sec)
  return _internal_minimum_rate_deg_per_sec();
}
inline void AntennaConstraints_ElevationAngleRateConstraint::set_minimum_rate_deg_per_sec(double value) {
  _internal_set_minimum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint.minimum_rate_deg_per_sec)
}
inline double AntennaConstraints_ElevationAngleRateConstraint::_internal_minimum_rate_deg_per_sec() const {
  return _impl_.minimum_rate_deg_per_sec_;
}
inline void AntennaConstraints_ElevationAngleRateConstraint::_internal_set_minimum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_rate_deg_per_sec_ = value;
}

// optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
inline bool AntennaConstraints_ElevationAngleRateConstraint::has_maximum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaConstraints_ElevationAngleRateConstraint::clear_maximum_rate_deg_per_sec() {
  _impl_.maximum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaConstraints_ElevationAngleRateConstraint::maximum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint.maximum_rate_deg_per_sec)
  return _internal_maximum_rate_deg_per_sec();
}
inline void AntennaConstraints_ElevationAngleRateConstraint::set_maximum_rate_deg_per_sec(double value) {
  _internal_set_maximum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint.maximum_rate_deg_per_sec)
}
inline double AntennaConstraints_ElevationAngleRateConstraint::_internal_maximum_rate_deg_per_sec() const {
  return _impl_.maximum_rate_deg_per_sec_;
}
inline void AntennaConstraints_ElevationAngleRateConstraint::_internal_set_maximum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_rate_deg_per_sec_ = value;
}

// -------------------------------------------------------------------

// AntennaConstraints_TotalAngularRateConstraint

// optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
inline bool AntennaConstraints_TotalAngularRateConstraint::has_minimum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AntennaConstraints_TotalAngularRateConstraint::clear_minimum_rate_deg_per_sec() {
  _impl_.minimum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AntennaConstraints_TotalAngularRateConstraint::minimum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint.minimum_rate_deg_per_sec)
  return _internal_minimum_rate_deg_per_sec();
}
inline void AntennaConstraints_TotalAngularRateConstraint::set_minimum_rate_deg_per_sec(double value) {
  _internal_set_minimum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint.minimum_rate_deg_per_sec)
}
inline double AntennaConstraints_TotalAngularRateConstraint::_internal_minimum_rate_deg_per_sec() const {
  return _impl_.minimum_rate_deg_per_sec_;
}
inline void AntennaConstraints_TotalAngularRateConstraint::_internal_set_minimum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_rate_deg_per_sec_ = value;
}

// optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
inline bool AntennaConstraints_TotalAngularRateConstraint::has_maximum_rate_deg_per_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AntennaConstraints_TotalAngularRateConstraint::clear_maximum_rate_deg_per_sec() {
  _impl_.maximum_rate_deg_per_sec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double AntennaConstraints_TotalAngularRateConstraint::maximum_rate_deg_per_sec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint.maximum_rate_deg_per_sec)
  return _internal_maximum_rate_deg_per_sec();
}
inline void AntennaConstraints_TotalAngularRateConstraint::set_maximum_rate_deg_per_sec(double value) {
  _internal_set_maximum_rate_deg_per_sec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint.maximum_rate_deg_per_sec)
}
inline double AntennaConstraints_TotalAngularRateConstraint::_internal_maximum_rate_deg_per_sec() const {
  return _impl_.maximum_rate_deg_per_sec_;
}
inline void AntennaConstraints_TotalAngularRateConstraint::_internal_set_maximum_rate_deg_per_sec(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_rate_deg_per_sec_ = value;
}

// -------------------------------------------------------------------

// AntennaConstraints

// optional .aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint link_range = 1 [json_name = "linkRange"];
inline bool AntennaConstraints::has_link_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_range_ != nullptr);
  return value;
}
inline void AntennaConstraints::clear_link_range() {
  if (_impl_.link_range_ != nullptr) _impl_.link_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint& AntennaConstraints::_internal_link_range() const {
  const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* p = _impl_.link_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint&>(
      ::aalyria::spacetime::api::common::_AntennaConstraints_LinkRangeConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint& AntennaConstraints::link_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.link_range)
  return _internal_link_range();
}
inline void AntennaConstraints::unsafe_arena_set_allocated_link_range(
    ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* link_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_range_);
  }
  _impl_.link_range_ = link_range;
  if (link_range) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.link_range)
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* AntennaConstraints::release_link_range() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* temp = _impl_.link_range_;
  _impl_.link_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* AntennaConstraints::unsafe_arena_release_link_range() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaConstraints.link_range)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* temp = _impl_.link_range_;
  _impl_.link_range_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* AntennaConstraints::_internal_mutable_link_range() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.link_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint>(GetArenaForAllocation());
    _impl_.link_range_ = p;
  }
  return _impl_.link_range_;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* AntennaConstraints::mutable_link_range() {
  ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* _msg = _internal_mutable_link_range();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaConstraints.link_range)
  return _msg;
}
inline void AntennaConstraints::set_allocated_link_range(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint* link_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.link_range_;
  }
  if (link_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link_range);
    if (message_arena != submessage_arena) {
      link_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.link_range_ = link_range;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.link_range)
}

// optional .aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint azimuth_angle_rate = 3 [json_name = "azimuthAngleRate"];
inline bool AntennaConstraints::has_azimuth_angle_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.azimuth_angle_rate_ != nullptr);
  return value;
}
inline void AntennaConstraints::clear_azimuth_angle_rate() {
  if (_impl_.azimuth_angle_rate_ != nullptr) _impl_.azimuth_angle_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint& AntennaConstraints::_internal_azimuth_angle_rate() const {
  const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* p = _impl_.azimuth_angle_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint&>(
      ::aalyria::spacetime::api::common::_AntennaConstraints_AzimuthAngleRateConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint& AntennaConstraints::azimuth_angle_rate() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate)
  return _internal_azimuth_angle_rate();
}
inline void AntennaConstraints::unsafe_arena_set_allocated_azimuth_angle_rate(
    ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* azimuth_angle_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.azimuth_angle_rate_);
  }
  _impl_.azimuth_angle_rate_ = azimuth_angle_rate;
  if (azimuth_angle_rate) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate)
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* AntennaConstraints::release_azimuth_angle_rate() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* temp = _impl_.azimuth_angle_rate_;
  _impl_.azimuth_angle_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* AntennaConstraints::unsafe_arena_release_azimuth_angle_rate() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* temp = _impl_.azimuth_angle_rate_;
  _impl_.azimuth_angle_rate_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* AntennaConstraints::_internal_mutable_azimuth_angle_rate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.azimuth_angle_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint>(GetArenaForAllocation());
    _impl_.azimuth_angle_rate_ = p;
  }
  return _impl_.azimuth_angle_rate_;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* AntennaConstraints::mutable_azimuth_angle_rate() {
  ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* _msg = _internal_mutable_azimuth_angle_rate();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate)
  return _msg;
}
inline void AntennaConstraints::set_allocated_azimuth_angle_rate(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint* azimuth_angle_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.azimuth_angle_rate_;
  }
  if (azimuth_angle_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(azimuth_angle_rate);
    if (message_arena != submessage_arena) {
      azimuth_angle_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, azimuth_angle_rate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.azimuth_angle_rate_ = azimuth_angle_rate;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate)
}

// optional .aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint elevation_angle_rate = 4 [json_name = "elevationAngleRate"];
inline bool AntennaConstraints::has_elevation_angle_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elevation_angle_rate_ != nullptr);
  return value;
}
inline void AntennaConstraints::clear_elevation_angle_rate() {
  if (_impl_.elevation_angle_rate_ != nullptr) _impl_.elevation_angle_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint& AntennaConstraints::_internal_elevation_angle_rate() const {
  const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* p = _impl_.elevation_angle_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint&>(
      ::aalyria::spacetime::api::common::_AntennaConstraints_ElevationAngleRateConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint& AntennaConstraints::elevation_angle_rate() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate)
  return _internal_elevation_angle_rate();
}
inline void AntennaConstraints::unsafe_arena_set_allocated_elevation_angle_rate(
    ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* elevation_angle_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.elevation_angle_rate_);
  }
  _impl_.elevation_angle_rate_ = elevation_angle_rate;
  if (elevation_angle_rate) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate)
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* AntennaConstraints::release_elevation_angle_rate() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* temp = _impl_.elevation_angle_rate_;
  _impl_.elevation_angle_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* AntennaConstraints::unsafe_arena_release_elevation_angle_rate() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* temp = _impl_.elevation_angle_rate_;
  _impl_.elevation_angle_rate_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* AntennaConstraints::_internal_mutable_elevation_angle_rate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.elevation_angle_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint>(GetArenaForAllocation());
    _impl_.elevation_angle_rate_ = p;
  }
  return _impl_.elevation_angle_rate_;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* AntennaConstraints::mutable_elevation_angle_rate() {
  ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* _msg = _internal_mutable_elevation_angle_rate();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate)
  return _msg;
}
inline void AntennaConstraints::set_allocated_elevation_angle_rate(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint* elevation_angle_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.elevation_angle_rate_;
  }
  if (elevation_angle_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(elevation_angle_rate);
    if (message_arena != submessage_arena) {
      elevation_angle_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, elevation_angle_rate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.elevation_angle_rate_ = elevation_angle_rate;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate)
}

// optional .aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint total_angular_rate = 5 [json_name = "totalAngularRate"];
inline bool AntennaConstraints::has_total_angular_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.total_angular_rate_ != nullptr);
  return value;
}
inline void AntennaConstraints::clear_total_angular_rate() {
  if (_impl_.total_angular_rate_ != nullptr) _impl_.total_angular_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint& AntennaConstraints::_internal_total_angular_rate() const {
  const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* p = _impl_.total_angular_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint&>(
      ::aalyria::spacetime::api::common::_AntennaConstraints_TotalAngularRateConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint& AntennaConstraints::total_angular_rate() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate)
  return _internal_total_angular_rate();
}
inline void AntennaConstraints::unsafe_arena_set_allocated_total_angular_rate(
    ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* total_angular_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.total_angular_rate_);
  }
  _impl_.total_angular_rate_ = total_angular_rate;
  if (total_angular_rate) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate)
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* AntennaConstraints::release_total_angular_rate() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* temp = _impl_.total_angular_rate_;
  _impl_.total_angular_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* AntennaConstraints::unsafe_arena_release_total_angular_rate() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* temp = _impl_.total_angular_rate_;
  _impl_.total_angular_rate_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* AntennaConstraints::_internal_mutable_total_angular_rate() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.total_angular_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint>(GetArenaForAllocation());
    _impl_.total_angular_rate_ = p;
  }
  return _impl_.total_angular_rate_;
}
inline ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* AntennaConstraints::mutable_total_angular_rate() {
  ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* _msg = _internal_mutable_total_angular_rate();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate)
  return _msg;
}
inline void AntennaConstraints::set_allocated_total_angular_rate(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint* total_angular_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.total_angular_rate_;
  }
  if (total_angular_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(total_angular_rate);
    if (message_arena != submessage_arena) {
      total_angular_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total_angular_rate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.total_angular_rate_ = total_angular_rate;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate)
}

// optional double minimum_sun_angle_deg = 6 [json_name = "minimumSunAngleDeg"];
inline bool AntennaConstraints::has_minimum_sun_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AntennaConstraints::clear_minimum_sun_angle_deg() {
  _impl_.minimum_sun_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double AntennaConstraints::minimum_sun_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.minimum_sun_angle_deg)
  return _internal_minimum_sun_angle_deg();
}
inline void AntennaConstraints::set_minimum_sun_angle_deg(double value) {
  _internal_set_minimum_sun_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.minimum_sun_angle_deg)
}
inline double AntennaConstraints::_internal_minimum_sun_angle_deg() const {
  return _impl_.minimum_sun_angle_deg_;
}
inline void AntennaConstraints::_internal_set_minimum_sun_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.minimum_sun_angle_deg_ = value;
}

// optional double minimum_azimuth_elevation_mask_separation_deg = 7 [json_name = "minimumAzimuthElevationMaskSeparationDeg"];
inline bool AntennaConstraints::has_minimum_azimuth_elevation_mask_separation_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AntennaConstraints::clear_minimum_azimuth_elevation_mask_separation_deg() {
  _impl_.minimum_azimuth_elevation_mask_separation_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double AntennaConstraints::minimum_azimuth_elevation_mask_separation_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.AntennaConstraints.minimum_azimuth_elevation_mask_separation_deg)
  return _internal_minimum_azimuth_elevation_mask_separation_deg();
}
inline void AntennaConstraints::set_minimum_azimuth_elevation_mask_separation_deg(double value) {
  _internal_set_minimum_azimuth_elevation_mask_separation_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.AntennaConstraints.minimum_azimuth_elevation_mask_separation_deg)
}
inline double AntennaConstraints::_internal_minimum_azimuth_elevation_mask_separation_deg() const {
  return _impl_.minimum_azimuth_elevation_mask_separation_deg_;
}
inline void AntennaConstraints::_internal_set_minimum_azimuth_elevation_mask_separation_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.minimum_azimuth_elevation_mask_separation_deg_ = value;
}

// -------------------------------------------------------------------

// Projection_Conic

// optional double outer_half_angle_deg = 1 [json_name = "outerHalfAngleDeg"];
inline bool Projection_Conic::has_outer_half_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Projection_Conic::clear_outer_half_angle_deg() {
  _impl_.outer_half_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Projection_Conic::outer_half_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.Conic.outer_half_angle_deg)
  return _internal_outer_half_angle_deg();
}
inline void Projection_Conic::set_outer_half_angle_deg(double value) {
  _internal_set_outer_half_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Projection.Conic.outer_half_angle_deg)
}
inline double Projection_Conic::_internal_outer_half_angle_deg() const {
  return _impl_.outer_half_angle_deg_;
}
inline void Projection_Conic::_internal_set_outer_half_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.outer_half_angle_deg_ = value;
}

// optional double inner_half_angle_deg = 2 [json_name = "innerHalfAngleDeg"];
inline bool Projection_Conic::has_inner_half_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Projection_Conic::clear_inner_half_angle_deg() {
  _impl_.inner_half_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Projection_Conic::inner_half_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.Conic.inner_half_angle_deg)
  return _internal_inner_half_angle_deg();
}
inline void Projection_Conic::set_inner_half_angle_deg(double value) {
  _internal_set_inner_half_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Projection.Conic.inner_half_angle_deg)
}
inline double Projection_Conic::_internal_inner_half_angle_deg() const {
  return _impl_.inner_half_angle_deg_;
}
inline void Projection_Conic::_internal_set_inner_half_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.inner_half_angle_deg_ = value;
}

// -------------------------------------------------------------------

// Projection_Rectangular

// optional double x_half_angle_deg = 1 [json_name = "xHalfAngleDeg"];
inline bool Projection_Rectangular::has_x_half_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Projection_Rectangular::clear_x_half_angle_deg() {
  _impl_.x_half_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Projection_Rectangular::x_half_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.Rectangular.x_half_angle_deg)
  return _internal_x_half_angle_deg();
}
inline void Projection_Rectangular::set_x_half_angle_deg(double value) {
  _internal_set_x_half_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Projection.Rectangular.x_half_angle_deg)
}
inline double Projection_Rectangular::_internal_x_half_angle_deg() const {
  return _impl_.x_half_angle_deg_;
}
inline void Projection_Rectangular::_internal_set_x_half_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_half_angle_deg_ = value;
}

// optional double y_half_angle_deg = 2 [json_name = "yHalfAngleDeg"];
inline bool Projection_Rectangular::has_y_half_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Projection_Rectangular::clear_y_half_angle_deg() {
  _impl_.y_half_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Projection_Rectangular::y_half_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.Rectangular.y_half_angle_deg)
  return _internal_y_half_angle_deg();
}
inline void Projection_Rectangular::set_y_half_angle_deg(double value) {
  _internal_set_y_half_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Projection.Rectangular.y_half_angle_deg)
}
inline double Projection_Rectangular::_internal_y_half_angle_deg() const {
  return _impl_.y_half_angle_deg_;
}
inline void Projection_Rectangular::_internal_set_y_half_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_half_angle_deg_ = value;
}

// -------------------------------------------------------------------

// Projection_Custom

// repeated .aalyria.spacetime.api.common.PointingVector directions = 1 [json_name = "directions"];
inline int Projection_Custom::_internal_directions_size() const {
  return _impl_.directions_.size();
}
inline int Projection_Custom::directions_size() const {
  return _internal_directions_size();
}
inline ::aalyria::spacetime::api::common::PointingVector* Projection_Custom::mutable_directions(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Projection.Custom.directions)
  return _internal_mutable_directions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointingVector >*
Projection_Custom::mutable_directions() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.Projection.Custom.directions)
  return _internal_mutable_directions();
}
inline const ::aalyria::spacetime::api::common::PointingVector& Projection_Custom::_internal_directions(int index) const {
  return _internal_directions().Get(index);
}
inline const ::aalyria::spacetime::api::common::PointingVector& Projection_Custom::directions(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.Custom.directions)
  return _internal_directions(index);
}
inline ::aalyria::spacetime::api::common::PointingVector* Projection_Custom::_internal_add_directions() {
  return _internal_mutable_directions()->Add();
}
inline ::aalyria::spacetime::api::common::PointingVector* Projection_Custom::add_directions() {
  ::aalyria::spacetime::api::common::PointingVector* _add = _internal_add_directions();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.Projection.Custom.directions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointingVector >&
Projection_Custom::directions() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.Projection.Custom.directions)
  return _internal_directions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointingVector>&
Projection_Custom::_internal_directions() const {
  return _impl_.directions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointingVector>*
Projection_Custom::_internal_mutable_directions() {
  return &_impl_.directions_;
}

// -------------------------------------------------------------------

// Projection

// .aalyria.spacetime.api.common.Projection.Conic conic = 1 [json_name = "conic"];
inline bool Projection::has_conic() const {
  return shape_type_case() == kConic;
}
inline bool Projection::_internal_has_conic() const {
  return shape_type_case() == kConic;
}
inline void Projection::set_has_conic() {
  _impl_._oneof_case_[0] = kConic;
}
inline void Projection::clear_conic() {
  if (shape_type_case() == kConic) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_type_.conic_;
    }
    clear_has_shape_type();
  }
}
inline ::aalyria::spacetime::api::common::Projection_Conic* Projection::release_conic() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Projection.conic)
  if (shape_type_case() == kConic) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Conic* temp = _impl_.shape_type_.conic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_type_.conic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Projection_Conic& Projection::_internal_conic() const {
  return shape_type_case() == kConic
      ? *_impl_.shape_type_.conic_
      : reinterpret_cast<::aalyria::spacetime::api::common::Projection_Conic&>(::aalyria::spacetime::api::common::_Projection_Conic_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Projection_Conic& Projection::conic() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.conic)
  return _internal_conic();
}
inline ::aalyria::spacetime::api::common::Projection_Conic* Projection::unsafe_arena_release_conic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Projection.conic)
  if (shape_type_case() == kConic) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Conic* temp = _impl_.shape_type_.conic_;
    _impl_.shape_type_.conic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Projection::unsafe_arena_set_allocated_conic(::aalyria::spacetime::api::common::Projection_Conic* conic) {
  clear_shape_type();
  if (conic) {
    set_has_conic();
    _impl_.shape_type_.conic_ = conic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Projection.conic)
}
inline ::aalyria::spacetime::api::common::Projection_Conic* Projection::_internal_mutable_conic() {
  if (shape_type_case() != kConic) {
    clear_shape_type();
    set_has_conic();
    _impl_.shape_type_.conic_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Conic >(GetArenaForAllocation());
  }
  return _impl_.shape_type_.conic_;
}
inline ::aalyria::spacetime::api::common::Projection_Conic* Projection::mutable_conic() {
  ::aalyria::spacetime::api::common::Projection_Conic* _msg = _internal_mutable_conic();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Projection.conic)
  return _msg;
}

// .aalyria.spacetime.api.common.Projection.Rectangular rectangular = 2 [json_name = "rectangular"];
inline bool Projection::has_rectangular() const {
  return shape_type_case() == kRectangular;
}
inline bool Projection::_internal_has_rectangular() const {
  return shape_type_case() == kRectangular;
}
inline void Projection::set_has_rectangular() {
  _impl_._oneof_case_[0] = kRectangular;
}
inline void Projection::clear_rectangular() {
  if (shape_type_case() == kRectangular) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_type_.rectangular_;
    }
    clear_has_shape_type();
  }
}
inline ::aalyria::spacetime::api::common::Projection_Rectangular* Projection::release_rectangular() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Projection.rectangular)
  if (shape_type_case() == kRectangular) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Rectangular* temp = _impl_.shape_type_.rectangular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_type_.rectangular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Projection_Rectangular& Projection::_internal_rectangular() const {
  return shape_type_case() == kRectangular
      ? *_impl_.shape_type_.rectangular_
      : reinterpret_cast<::aalyria::spacetime::api::common::Projection_Rectangular&>(::aalyria::spacetime::api::common::_Projection_Rectangular_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Projection_Rectangular& Projection::rectangular() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.rectangular)
  return _internal_rectangular();
}
inline ::aalyria::spacetime::api::common::Projection_Rectangular* Projection::unsafe_arena_release_rectangular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Projection.rectangular)
  if (shape_type_case() == kRectangular) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Rectangular* temp = _impl_.shape_type_.rectangular_;
    _impl_.shape_type_.rectangular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Projection::unsafe_arena_set_allocated_rectangular(::aalyria::spacetime::api::common::Projection_Rectangular* rectangular) {
  clear_shape_type();
  if (rectangular) {
    set_has_rectangular();
    _impl_.shape_type_.rectangular_ = rectangular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Projection.rectangular)
}
inline ::aalyria::spacetime::api::common::Projection_Rectangular* Projection::_internal_mutable_rectangular() {
  if (shape_type_case() != kRectangular) {
    clear_shape_type();
    set_has_rectangular();
    _impl_.shape_type_.rectangular_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Rectangular >(GetArenaForAllocation());
  }
  return _impl_.shape_type_.rectangular_;
}
inline ::aalyria::spacetime::api::common::Projection_Rectangular* Projection::mutable_rectangular() {
  ::aalyria::spacetime::api::common::Projection_Rectangular* _msg = _internal_mutable_rectangular();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Projection.rectangular)
  return _msg;
}

// .aalyria.spacetime.api.common.Projection.Custom custom = 3 [json_name = "custom"];
inline bool Projection::has_custom() const {
  return shape_type_case() == kCustom;
}
inline bool Projection::_internal_has_custom() const {
  return shape_type_case() == kCustom;
}
inline void Projection::set_has_custom() {
  _impl_._oneof_case_[0] = kCustom;
}
inline void Projection::clear_custom() {
  if (shape_type_case() == kCustom) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.shape_type_.custom_;
    }
    clear_has_shape_type();
  }
}
inline ::aalyria::spacetime::api::common::Projection_Custom* Projection::release_custom() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Projection.custom)
  if (shape_type_case() == kCustom) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Custom* temp = _impl_.shape_type_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.shape_type_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Projection_Custom& Projection::_internal_custom() const {
  return shape_type_case() == kCustom
      ? *_impl_.shape_type_.custom_
      : reinterpret_cast<::aalyria::spacetime::api::common::Projection_Custom&>(::aalyria::spacetime::api::common::_Projection_Custom_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Projection_Custom& Projection::custom() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Projection.custom)
  return _internal_custom();
}
inline ::aalyria::spacetime::api::common::Projection_Custom* Projection::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Projection.custom)
  if (shape_type_case() == kCustom) {
    clear_has_shape_type();
    ::aalyria::spacetime::api::common::Projection_Custom* temp = _impl_.shape_type_.custom_;
    _impl_.shape_type_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Projection::unsafe_arena_set_allocated_custom(::aalyria::spacetime::api::common::Projection_Custom* custom) {
  clear_shape_type();
  if (custom) {
    set_has_custom();
    _impl_.shape_type_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Projection.custom)
}
inline ::aalyria::spacetime::api::common::Projection_Custom* Projection::_internal_mutable_custom() {
  if (shape_type_case() != kCustom) {
    clear_shape_type();
    set_has_custom();
    _impl_.shape_type_.custom_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Custom >(GetArenaForAllocation());
  }
  return _impl_.shape_type_.custom_;
}
inline ::aalyria::spacetime::api::common::Projection_Custom* Projection::mutable_custom() {
  ::aalyria::spacetime::api::common::Projection_Custom* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Projection.custom)
  return _msg;
}

inline bool Projection::has_shape_type() const {
  return shape_type_case() != SHAPE_TYPE_NOT_SET;
}
inline void Projection::clear_has_shape_type() {
  _impl_._oneof_case_[0] = SHAPE_TYPE_NOT_SET;
}
inline Projection::ShapeTypeCase Projection::shape_type_case() const {
  return Projection::ShapeTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Polarization_Constant_Linear

// optional double tilt_angle_deg = 1 [json_name = "tiltAngleDeg"];
inline bool Polarization_Constant_Linear::has_tilt_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Polarization_Constant_Linear::clear_tilt_angle_deg() {
  _impl_.tilt_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Polarization_Constant_Linear::tilt_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Polarization.Constant.Linear.tilt_angle_deg)
  return _internal_tilt_angle_deg();
}
inline void Polarization_Constant_Linear::set_tilt_angle_deg(double value) {
  _internal_set_tilt_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Polarization.Constant.Linear.tilt_angle_deg)
}
inline double Polarization_Constant_Linear::_internal_tilt_angle_deg() const {
  return _impl_.tilt_angle_deg_;
}
inline void Polarization_Constant_Linear::_internal_set_tilt_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tilt_angle_deg_ = value;
}

// -------------------------------------------------------------------

// Polarization_Constant

// .google.protobuf.Empty left_hand_circular = 1 [json_name = "leftHandCircular"];
inline bool Polarization_Constant::has_left_hand_circular() const {
  return polarization_case() == kLeftHandCircular;
}
inline bool Polarization_Constant::_internal_has_left_hand_circular() const {
  return polarization_case() == kLeftHandCircular;
}
inline void Polarization_Constant::set_has_left_hand_circular() {
  _impl_._oneof_case_[0] = kLeftHandCircular;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::release_left_hand_circular() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
  if (polarization_case() == kLeftHandCircular) {
    clear_has_polarization();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.polarization_.left_hand_circular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.polarization_.left_hand_circular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Polarization_Constant::_internal_left_hand_circular() const {
  return polarization_case() == kLeftHandCircular
      ? *_impl_.polarization_.left_hand_circular_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Polarization_Constant::left_hand_circular() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
  return _internal_left_hand_circular();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::unsafe_arena_release_left_hand_circular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
  if (polarization_case() == kLeftHandCircular) {
    clear_has_polarization();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.polarization_.left_hand_circular_;
    _impl_.polarization_.left_hand_circular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Polarization_Constant::unsafe_arena_set_allocated_left_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* left_hand_circular) {
  clear_polarization();
  if (left_hand_circular) {
    set_has_left_hand_circular();
    _impl_.polarization_.left_hand_circular_ = left_hand_circular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::_internal_mutable_left_hand_circular() {
  if (polarization_case() != kLeftHandCircular) {
    clear_polarization();
    set_has_left_hand_circular();
    _impl_.polarization_.left_hand_circular_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.polarization_.left_hand_circular_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::mutable_left_hand_circular() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_left_hand_circular();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
  return _msg;
}

// .google.protobuf.Empty right_hand_circular = 2 [json_name = "rightHandCircular"];
inline bool Polarization_Constant::has_right_hand_circular() const {
  return polarization_case() == kRightHandCircular;
}
inline bool Polarization_Constant::_internal_has_right_hand_circular() const {
  return polarization_case() == kRightHandCircular;
}
inline void Polarization_Constant::set_has_right_hand_circular() {
  _impl_._oneof_case_[0] = kRightHandCircular;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::release_right_hand_circular() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
  if (polarization_case() == kRightHandCircular) {
    clear_has_polarization();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.polarization_.right_hand_circular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.polarization_.right_hand_circular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Polarization_Constant::_internal_right_hand_circular() const {
  return polarization_case() == kRightHandCircular
      ? *_impl_.polarization_.right_hand_circular_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Polarization_Constant::right_hand_circular() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
  return _internal_right_hand_circular();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::unsafe_arena_release_right_hand_circular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
  if (polarization_case() == kRightHandCircular) {
    clear_has_polarization();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.polarization_.right_hand_circular_;
    _impl_.polarization_.right_hand_circular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Polarization_Constant::unsafe_arena_set_allocated_right_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* right_hand_circular) {
  clear_polarization();
  if (right_hand_circular) {
    set_has_right_hand_circular();
    _impl_.polarization_.right_hand_circular_ = right_hand_circular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::_internal_mutable_right_hand_circular() {
  if (polarization_case() != kRightHandCircular) {
    clear_polarization();
    set_has_right_hand_circular();
    _impl_.polarization_.right_hand_circular_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.polarization_.right_hand_circular_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Polarization_Constant::mutable_right_hand_circular() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_right_hand_circular();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
  return _msg;
}

// .aalyria.spacetime.api.common.Polarization.Constant.Linear linear = 3 [json_name = "linear"];
inline bool Polarization_Constant::has_linear() const {
  return polarization_case() == kLinear;
}
inline bool Polarization_Constant::_internal_has_linear() const {
  return polarization_case() == kLinear;
}
inline void Polarization_Constant::set_has_linear() {
  _impl_._oneof_case_[0] = kLinear;
}
inline void Polarization_Constant::clear_linear() {
  if (polarization_case() == kLinear) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.polarization_.linear_;
    }
    clear_has_polarization();
  }
}
inline ::aalyria::spacetime::api::common::Polarization_Constant_Linear* Polarization_Constant::release_linear() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Polarization.Constant.linear)
  if (polarization_case() == kLinear) {
    clear_has_polarization();
    ::aalyria::spacetime::api::common::Polarization_Constant_Linear* temp = _impl_.polarization_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.polarization_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Polarization_Constant_Linear& Polarization_Constant::_internal_linear() const {
  return polarization_case() == kLinear
      ? *_impl_.polarization_.linear_
      : reinterpret_cast<::aalyria::spacetime::api::common::Polarization_Constant_Linear&>(::aalyria::spacetime::api::common::_Polarization_Constant_Linear_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Polarization_Constant_Linear& Polarization_Constant::linear() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Polarization.Constant.linear)
  return _internal_linear();
}
inline ::aalyria::spacetime::api::common::Polarization_Constant_Linear* Polarization_Constant::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Polarization.Constant.linear)
  if (polarization_case() == kLinear) {
    clear_has_polarization();
    ::aalyria::spacetime::api::common::Polarization_Constant_Linear* temp = _impl_.polarization_.linear_;
    _impl_.polarization_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Polarization_Constant::unsafe_arena_set_allocated_linear(::aalyria::spacetime::api::common::Polarization_Constant_Linear* linear) {
  clear_polarization();
  if (linear) {
    set_has_linear();
    _impl_.polarization_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.linear)
}
inline ::aalyria::spacetime::api::common::Polarization_Constant_Linear* Polarization_Constant::_internal_mutable_linear() {
  if (polarization_case() != kLinear) {
    clear_polarization();
    set_has_linear();
    _impl_.polarization_.linear_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Polarization_Constant_Linear >(GetArenaForAllocation());
  }
  return _impl_.polarization_.linear_;
}
inline ::aalyria::spacetime::api::common::Polarization_Constant_Linear* Polarization_Constant::mutable_linear() {
  ::aalyria::spacetime::api::common::Polarization_Constant_Linear* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Polarization.Constant.linear)
  return _msg;
}

inline bool Polarization_Constant::has_polarization() const {
  return polarization_case() != POLARIZATION_NOT_SET;
}
inline void Polarization_Constant::clear_has_polarization() {
  _impl_._oneof_case_[0] = POLARIZATION_NOT_SET;
}
inline Polarization_Constant::PolarizationCase Polarization_Constant::polarization_case() const {
  return Polarization_Constant::PolarizationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Polarization

// .aalyria.spacetime.api.common.Polarization.Constant constant = 1 [json_name = "constant"];
inline bool Polarization::has_constant() const {
  return source_case() == kConstant;
}
inline bool Polarization::_internal_has_constant() const {
  return source_case() == kConstant;
}
inline void Polarization::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline void Polarization::clear_constant() {
  if (source_case() == kConstant) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_.constant_;
    }
    clear_has_source();
  }
}
inline ::aalyria::spacetime::api::common::Polarization_Constant* Polarization::release_constant() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Polarization.constant)
  if (source_case() == kConstant) {
    clear_has_source();
    ::aalyria::spacetime::api::common::Polarization_Constant* temp = _impl_.source_.constant_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Polarization_Constant& Polarization::_internal_constant() const {
  return source_case() == kConstant
      ? *_impl_.source_.constant_
      : reinterpret_cast<::aalyria::spacetime::api::common::Polarization_Constant&>(::aalyria::spacetime::api::common::_Polarization_Constant_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Polarization_Constant& Polarization::constant() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Polarization.constant)
  return _internal_constant();
}
inline ::aalyria::spacetime::api::common::Polarization_Constant* Polarization::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Polarization.constant)
  if (source_case() == kConstant) {
    clear_has_source();
    ::aalyria::spacetime::api::common::Polarization_Constant* temp = _impl_.source_.constant_;
    _impl_.source_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Polarization::unsafe_arena_set_allocated_constant(::aalyria::spacetime::api::common::Polarization_Constant* constant) {
  clear_source();
  if (constant) {
    set_has_constant();
    _impl_.source_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Polarization.constant)
}
inline ::aalyria::spacetime::api::common::Polarization_Constant* Polarization::_internal_mutable_constant() {
  if (source_case() != kConstant) {
    clear_source();
    set_has_constant();
    _impl_.source_.constant_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Polarization_Constant >(GetArenaForAllocation());
  }
  return _impl_.source_.constant_;
}
inline ::aalyria::spacetime::api::common::Polarization_Constant* Polarization::mutable_constant() {
  ::aalyria::spacetime::api::common::Polarization_Constant* _msg = _internal_mutable_constant();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Polarization.constant)
  return _msg;
}

inline bool Polarization::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void Polarization::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline Polarization::SourceCase Polarization::source_case() const {
  return Polarization::SourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Targeting

// optional .aalyria.spacetime.api.common.Motion.Type motion_format = 1 [json_name = "motionFormat"];
inline bool Targeting::has_motion_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Targeting::clear_motion_format() {
  _impl_.motion_format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::aalyria::spacetime::api::common::Motion_Type Targeting::motion_format() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Targeting.motion_format)
  return _internal_motion_format();
}
inline void Targeting::set_motion_format(::aalyria::spacetime::api::common::Motion_Type value) {
   _internal_set_motion_format(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Targeting.motion_format)
}
inline ::aalyria::spacetime::api::common::Motion_Type Targeting::_internal_motion_format() const {
  return static_cast<::aalyria::spacetime::api::common::Motion_Type>(_impl_.motion_format_);
}
inline void Targeting::_internal_set_motion_format(::aalyria::spacetime::api::common::Motion_Type value) {
  assert(::aalyria::spacetime::api::common::Motion_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.motion_format_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fplatform_5fantenna_2eproto_2epb_2eh
