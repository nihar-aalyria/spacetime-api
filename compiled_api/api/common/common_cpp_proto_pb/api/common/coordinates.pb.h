// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/coordinates.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcoordinates_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcoordinates_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/time.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/type/interval.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fcoordinates_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fcoordinates_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fcoordinates_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class Cartesian;
struct CartesianDefaultTypeInternal;
extern CartesianDefaultTypeInternal _Cartesian_default_instance_;
class CartesianDot;
struct CartesianDotDefaultTypeInternal;
extern CartesianDotDefaultTypeInternal _CartesianDot_default_instance_;
class GeodeticMsl;
struct GeodeticMslDefaultTypeInternal;
extern GeodeticMslDefaultTypeInternal _GeodeticMsl_default_instance_;
class GeodeticWgs84;
struct GeodeticWgs84DefaultTypeInternal;
extern GeodeticWgs84DefaultTypeInternal _GeodeticWgs84_default_instance_;
class GeodeticWgs84Temporal;
struct GeodeticWgs84TemporalDefaultTypeInternal;
extern GeodeticWgs84TemporalDefaultTypeInternal _GeodeticWgs84Temporal_default_instance_;
class GeodeticWgs84TemporalInterpolation;
struct GeodeticWgs84TemporalInterpolationDefaultTypeInternal;
extern GeodeticWgs84TemporalInterpolationDefaultTypeInternal _GeodeticWgs84TemporalInterpolation_default_instance_;
class KeplerianElements;
struct KeplerianElementsDefaultTypeInternal;
extern KeplerianElementsDefaultTypeInternal _KeplerianElements_default_instance_;
class Motion;
struct MotionDefaultTypeInternal;
extern MotionDefaultTypeInternal _Motion_default_instance_;
class MotionDefinition;
struct MotionDefinitionDefaultTypeInternal;
extern MotionDefinitionDefaultTypeInternal _MotionDefinition_default_instance_;
class PointAxes;
struct PointAxesDefaultTypeInternal;
extern PointAxesDefaultTypeInternal _PointAxes_default_instance_;
class PointAxesTemporal;
struct PointAxesTemporalDefaultTypeInternal;
extern PointAxesTemporalDefaultTypeInternal _PointAxesTemporal_default_instance_;
class PointAxesTemporalInterpolation;
struct PointAxesTemporalInterpolationDefaultTypeInternal;
extern PointAxesTemporalInterpolationDefaultTypeInternal _PointAxesTemporalInterpolation_default_instance_;
class PointingVector;
struct PointingVectorDefaultTypeInternal;
extern PointingVectorDefaultTypeInternal _PointingVector_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class S2Cells;
struct S2CellsDefaultTypeInternal;
extern S2CellsDefaultTypeInternal _S2Cells_default_instance_;
class SelenographicMlr;
struct SelenographicMlrDefaultTypeInternal;
extern SelenographicMlrDefaultTypeInternal _SelenographicMlr_default_instance_;
class StateVector;
struct StateVectorDefaultTypeInternal;
extern StateVectorDefaultTypeInternal _StateVector_default_instance_;
class StkEphemAndAttitudeFile;
struct StkEphemAndAttitudeFileDefaultTypeInternal;
extern StkEphemAndAttitudeFileDefaultTypeInternal _StkEphemAndAttitudeFile_default_instance_;
class TwoLineElementSet;
struct TwoLineElementSetDefaultTypeInternal;
extern TwoLineElementSetDefaultTypeInternal _TwoLineElementSet_default_instance_;
class YawPitchRoll;
struct YawPitchRollDefaultTypeInternal;
extern YawPitchRollDefaultTypeInternal _YawPitchRoll_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::Cartesian* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Cartesian>(Arena*);
template <>
::aalyria::spacetime::api::common::CartesianDot* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CartesianDot>(Arena*);
template <>
::aalyria::spacetime::api::common::GeodeticMsl* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticMsl>(Arena*);
template <>
::aalyria::spacetime::api::common::GeodeticWgs84* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84>(Arena*);
template <>
::aalyria::spacetime::api::common::GeodeticWgs84Temporal* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84Temporal>(Arena*);
template <>
::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation>(Arena*);
template <>
::aalyria::spacetime::api::common::KeplerianElements* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::KeplerianElements>(Arena*);
template <>
::aalyria::spacetime::api::common::Motion* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Motion>(Arena*);
template <>
::aalyria::spacetime::api::common::MotionDefinition* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::MotionDefinition>(Arena*);
template <>
::aalyria::spacetime::api::common::PointAxes* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PointAxes>(Arena*);
template <>
::aalyria::spacetime::api::common::PointAxesTemporal* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PointAxesTemporal>(Arena*);
template <>
::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PointAxesTemporalInterpolation>(Arena*);
template <>
::aalyria::spacetime::api::common::PointingVector* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PointingVector>(Arena*);
template <>
::aalyria::spacetime::api::common::Quaternion* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Quaternion>(Arena*);
template <>
::aalyria::spacetime::api::common::S2Cells* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::S2Cells>(Arena*);
template <>
::aalyria::spacetime::api::common::SelenographicMlr* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::SelenographicMlr>(Arena*);
template <>
::aalyria::spacetime::api::common::StateVector* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::StateVector>(Arena*);
template <>
::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::StkEphemAndAttitudeFile>(Arena*);
template <>
::aalyria::spacetime::api::common::TwoLineElementSet* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TwoLineElementSet>(Arena*);
template <>
::aalyria::spacetime::api::common::YawPitchRoll* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::YawPitchRoll>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
enum StateVector_CoordinateFrame : int {
  StateVector_CoordinateFrame_UNKNOWN_FRAME = 0,
  StateVector_CoordinateFrame_EARTH_MOON_BARYCENTER_SYNODIC_FRAME = 1,
  StateVector_CoordinateFrame_ECEF_FRAME = 2,
};

bool StateVector_CoordinateFrame_IsValid(int value);
constexpr StateVector_CoordinateFrame StateVector_CoordinateFrame_CoordinateFrame_MIN = static_cast<StateVector_CoordinateFrame>(0);
constexpr StateVector_CoordinateFrame StateVector_CoordinateFrame_CoordinateFrame_MAX = static_cast<StateVector_CoordinateFrame>(2);
constexpr int StateVector_CoordinateFrame_CoordinateFrame_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
StateVector_CoordinateFrame_descriptor();
template <typename T>
const std::string& StateVector_CoordinateFrame_Name(T value) {
  static_assert(std::is_same<T, StateVector_CoordinateFrame>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CoordinateFrame_Name().");
  return StateVector_CoordinateFrame_Name(static_cast<StateVector_CoordinateFrame>(value));
}
template <>
inline const std::string& StateVector_CoordinateFrame_Name(StateVector_CoordinateFrame value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<StateVector_CoordinateFrame_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool StateVector_CoordinateFrame_Parse(absl::string_view name, StateVector_CoordinateFrame* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateVector_CoordinateFrame>(
      StateVector_CoordinateFrame_descriptor(), name, value);
}
enum StateVector_PropagationAlgorithm : int {
  StateVector_PropagationAlgorithm_UNSPECIFIED_ALGORITHM = 0,
  StateVector_PropagationAlgorithm_EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM = 1,
};

bool StateVector_PropagationAlgorithm_IsValid(int value);
constexpr StateVector_PropagationAlgorithm StateVector_PropagationAlgorithm_PropagationAlgorithm_MIN = static_cast<StateVector_PropagationAlgorithm>(0);
constexpr StateVector_PropagationAlgorithm StateVector_PropagationAlgorithm_PropagationAlgorithm_MAX = static_cast<StateVector_PropagationAlgorithm>(1);
constexpr int StateVector_PropagationAlgorithm_PropagationAlgorithm_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
StateVector_PropagationAlgorithm_descriptor();
template <typename T>
const std::string& StateVector_PropagationAlgorithm_Name(T value) {
  static_assert(std::is_same<T, StateVector_PropagationAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PropagationAlgorithm_Name().");
  return StateVector_PropagationAlgorithm_Name(static_cast<StateVector_PropagationAlgorithm>(value));
}
template <>
inline const std::string& StateVector_PropagationAlgorithm_Name(StateVector_PropagationAlgorithm value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<StateVector_PropagationAlgorithm_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool StateVector_PropagationAlgorithm_Parse(absl::string_view name, StateVector_PropagationAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateVector_PropagationAlgorithm>(
      StateVector_PropagationAlgorithm_descriptor(), name, value);
}
enum Motion_Type : int {
  Motion_Type_MOTION_UNSPECIFIED = 0,
  Motion_Type_GEODETIC_MSL = 7,
  Motion_Type_GEODETIC_WGS84 = 1,
  Motion_Type_ECEF_FIXED = 2,
  Motion_Type_ECEF_INTERPOLATION = 3,
  Motion_Type_CARTOGRAPHIC_WAYPOINTS = 4,
  Motion_Type_TLE = 5,
  Motion_Type_KEPLERIAN_ELEMENTS = 6,
  Motion_Type_STATE_VECTOR = 9,
  Motion_Type_SELENOGRAPHIC_MLR = 8,
  Motion_Type_STK_EPHEM_AND_ATTITUDE_FILE = 11,
};

bool Motion_Type_IsValid(int value);
constexpr Motion_Type Motion_Type_Type_MIN = static_cast<Motion_Type>(0);
constexpr Motion_Type Motion_Type_Type_MAX = static_cast<Motion_Type>(11);
constexpr int Motion_Type_Type_ARRAYSIZE = 11 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Motion_Type_descriptor();
template <typename T>
const std::string& Motion_Type_Name(T value) {
  static_assert(std::is_same<T, Motion_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Motion_Type_Name(static_cast<Motion_Type>(value));
}
template <>
inline const std::string& Motion_Type_Name(Motion_Type value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Motion_Type_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool Motion_Type_Parse(absl::string_view name, Motion_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Motion_Type>(
      Motion_Type_descriptor(), name, value);
}
enum CentralBody : int {
  UNKNOWN_CENTRAL_BODY = 0,
  EARTH = 1,
  MOON = 2,
};

bool CentralBody_IsValid(int value);
constexpr CentralBody CentralBody_MIN = static_cast<CentralBody>(0);
constexpr CentralBody CentralBody_MAX = static_cast<CentralBody>(2);
constexpr int CentralBody_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CentralBody_descriptor();
template <typename T>
const std::string& CentralBody_Name(T value) {
  static_assert(std::is_same<T, CentralBody>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CentralBody_Name().");
  return CentralBody_Name(static_cast<CentralBody>(value));
}
template <>
inline const std::string& CentralBody_Name(CentralBody value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CentralBody_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CentralBody_Parse(absl::string_view name, CentralBody* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CentralBody>(
      CentralBody_descriptor(), name, value);
}
enum InterpolationMethod : int {
  UNKNOWN_METHOD = 0,
  LINEAR = 1,
  LAGRANGE = 2,
  HERMITIAN = 3,
};

bool InterpolationMethod_IsValid(int value);
constexpr InterpolationMethod InterpolationMethod_MIN = static_cast<InterpolationMethod>(0);
constexpr InterpolationMethod InterpolationMethod_MAX = static_cast<InterpolationMethod>(3);
constexpr int InterpolationMethod_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
InterpolationMethod_descriptor();
template <typename T>
const std::string& InterpolationMethod_Name(T value) {
  static_assert(std::is_same<T, InterpolationMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InterpolationMethod_Name().");
  return InterpolationMethod_Name(static_cast<InterpolationMethod>(value));
}
template <>
inline const std::string& InterpolationMethod_Name(InterpolationMethod value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<InterpolationMethod_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool InterpolationMethod_Parse(absl::string_view name, InterpolationMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InterpolationMethod>(
      InterpolationMethod_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class GeodeticWgs84 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.GeodeticWgs84) */ {
 public:
  inline GeodeticWgs84() : GeodeticWgs84(nullptr) {}
  ~GeodeticWgs84() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeodeticWgs84(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeodeticWgs84(const GeodeticWgs84& from);
  GeodeticWgs84(GeodeticWgs84&& from) noexcept
    : GeodeticWgs84() {
    *this = ::std::move(from);
  }

  inline GeodeticWgs84& operator=(const GeodeticWgs84& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeodeticWgs84& operator=(GeodeticWgs84&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeodeticWgs84& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeodeticWgs84* internal_default_instance() {
    return reinterpret_cast<const GeodeticWgs84*>(
               &_GeodeticWgs84_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GeodeticWgs84& a, GeodeticWgs84& b) {
    a.Swap(&b);
  }
  inline void Swap(GeodeticWgs84* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeodeticWgs84* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeodeticWgs84* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeodeticWgs84>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeodeticWgs84& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeodeticWgs84& from) {
    GeodeticWgs84::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeodeticWgs84* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.GeodeticWgs84";
  }
  protected:
  explicit GeodeticWgs84(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeDegFieldNumber = 1,
    kLatitudeDegFieldNumber = 2,
    kHeightWgs84MFieldNumber = 3,
  };
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  bool has_longitude_deg() const;
  void clear_longitude_deg() ;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);

  public:
  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  bool has_latitude_deg() const;
  void clear_latitude_deg() ;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);

  public:
  // optional double height_wgs84_m = 3 [json_name = "heightWgs84M"];
  bool has_height_wgs84_m() const;
  void clear_height_wgs84_m() ;
  double height_wgs84_m() const;
  void set_height_wgs84_m(double value);

  private:
  double _internal_height_wgs84_m() const;
  void _internal_set_height_wgs84_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.GeodeticWgs84)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double longitude_deg_;
    double latitude_deg_;
    double height_wgs84_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class GeodeticMsl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.GeodeticMsl) */ {
 public:
  inline GeodeticMsl() : GeodeticMsl(nullptr) {}
  ~GeodeticMsl() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeodeticMsl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeodeticMsl(const GeodeticMsl& from);
  GeodeticMsl(GeodeticMsl&& from) noexcept
    : GeodeticMsl() {
    *this = ::std::move(from);
  }

  inline GeodeticMsl& operator=(const GeodeticMsl& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeodeticMsl& operator=(GeodeticMsl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeodeticMsl& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeodeticMsl* internal_default_instance() {
    return reinterpret_cast<const GeodeticMsl*>(
               &_GeodeticMsl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GeodeticMsl& a, GeodeticMsl& b) {
    a.Swap(&b);
  }
  inline void Swap(GeodeticMsl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeodeticMsl* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeodeticMsl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeodeticMsl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeodeticMsl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeodeticMsl& from) {
    GeodeticMsl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeodeticMsl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.GeodeticMsl";
  }
  protected:
  explicit GeodeticMsl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeDegFieldNumber = 1,
    kLatitudeDegFieldNumber = 2,
    kHeightMslMFieldNumber = 3,
  };
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  bool has_longitude_deg() const;
  void clear_longitude_deg() ;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);

  public:
  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  bool has_latitude_deg() const;
  void clear_latitude_deg() ;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);

  public:
  // optional double height_msl_m = 3 [json_name = "heightMslM"];
  bool has_height_msl_m() const;
  void clear_height_msl_m() ;
  double height_msl_m() const;
  void set_height_msl_m(double value);

  private:
  double _internal_height_msl_m() const;
  void _internal_set_height_msl_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.GeodeticMsl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double longitude_deg_;
    double latitude_deg_;
    double height_msl_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class S2Cells final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.S2Cells) */ {
 public:
  inline S2Cells() : S2Cells(nullptr) {}
  ~S2Cells() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR S2Cells(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2Cells(const S2Cells& from);
  S2Cells(S2Cells&& from) noexcept
    : S2Cells() {
    *this = ::std::move(from);
  }

  inline S2Cells& operator=(const S2Cells& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2Cells& operator=(S2Cells&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2Cells& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2Cells* internal_default_instance() {
    return reinterpret_cast<const S2Cells*>(
               &_S2Cells_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S2Cells& a, S2Cells& b) {
    a.Swap(&b);
  }
  inline void Swap(S2Cells* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2Cells* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2Cells* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2Cells>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2Cells& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2Cells& from) {
    S2Cells::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2Cells* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.S2Cells";
  }
  protected:
  explicit S2Cells(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated uint64 ids = 1 [json_name = "ids"];
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  ::uint64_t ids(int index) const;
  void set_ids(int index, ::uint64_t value);
  void add_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_ids();

  private:
  ::uint64_t _internal_ids(int index) const;
  void _internal_add_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_ids();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.S2Cells)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class Cartesian final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Cartesian) */ {
 public:
  inline Cartesian() : Cartesian(nullptr) {}
  ~Cartesian() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cartesian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cartesian(const Cartesian& from);
  Cartesian(Cartesian&& from) noexcept
    : Cartesian() {
    *this = ::std::move(from);
  }

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cartesian& operator=(Cartesian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cartesian& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cartesian* internal_default_instance() {
    return reinterpret_cast<const Cartesian*>(
               &_Cartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Cartesian& a, Cartesian& b) {
    a.Swap(&b);
  }
  inline void Swap(Cartesian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cartesian* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cartesian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cartesian>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cartesian& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cartesian& from) {
    Cartesian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cartesian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Cartesian";
  }
  protected:
  explicit Cartesian(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXMFieldNumber = 1,
    kYMFieldNumber = 2,
    kZMFieldNumber = 3,
  };
  // required double x_m = 1 [json_name = "xM"];
  bool has_x_m() const;
  void clear_x_m() ;
  double x_m() const;
  void set_x_m(double value);

  private:
  double _internal_x_m() const;
  void _internal_set_x_m(double value);

  public:
  // required double y_m = 2 [json_name = "yM"];
  bool has_y_m() const;
  void clear_y_m() ;
  double y_m() const;
  void set_y_m(double value);

  private:
  double _internal_y_m() const;
  void _internal_set_y_m(double value);

  public:
  // required double z_m = 3 [json_name = "zM"];
  bool has_z_m() const;
  void clear_z_m() ;
  double z_m() const;
  void set_z_m(double value);

  private:
  double _internal_z_m() const;
  void _internal_set_z_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Cartesian)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_m_;
    double y_m_;
    double z_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class CartesianDot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.CartesianDot) */ {
 public:
  inline CartesianDot() : CartesianDot(nullptr) {}
  ~CartesianDot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CartesianDot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CartesianDot(const CartesianDot& from);
  CartesianDot(CartesianDot&& from) noexcept
    : CartesianDot() {
    *this = ::std::move(from);
  }

  inline CartesianDot& operator=(const CartesianDot& from) {
    CopyFrom(from);
    return *this;
  }
  inline CartesianDot& operator=(CartesianDot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CartesianDot& default_instance() {
    return *internal_default_instance();
  }
  static inline const CartesianDot* internal_default_instance() {
    return reinterpret_cast<const CartesianDot*>(
               &_CartesianDot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CartesianDot& a, CartesianDot& b) {
    a.Swap(&b);
  }
  inline void Swap(CartesianDot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CartesianDot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CartesianDot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CartesianDot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CartesianDot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CartesianDot& from) {
    CartesianDot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianDot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.CartesianDot";
  }
  protected:
  explicit CartesianDot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXMpsFieldNumber = 1,
    kYMpsFieldNumber = 2,
    kZMpsFieldNumber = 3,
  };
  // required double x_mps = 1 [json_name = "xMps"];
  bool has_x_mps() const;
  void clear_x_mps() ;
  double x_mps() const;
  void set_x_mps(double value);

  private:
  double _internal_x_mps() const;
  void _internal_set_x_mps(double value);

  public:
  // required double y_mps = 2 [json_name = "yMps"];
  bool has_y_mps() const;
  void clear_y_mps() ;
  double y_mps() const;
  void set_y_mps(double value);

  private:
  double _internal_y_mps() const;
  void _internal_set_y_mps(double value);

  public:
  // required double z_mps = 3 [json_name = "zMps"];
  bool has_z_mps() const;
  void clear_z_mps() ;
  double z_mps() const;
  void set_z_mps(double value);

  private:
  double _internal_z_mps() const;
  void _internal_set_z_mps(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.CartesianDot)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double x_mps_;
    double y_mps_;
    double z_mps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // required double w = 1 [json_name = "w"];
  bool has_w() const;
  void clear_w() ;
  double w() const;
  void set_w(double value);

  private:
  double _internal_w() const;
  void _internal_set_w(double value);

  public:
  // required double x = 2 [json_name = "x"];
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // required double y = 3 [json_name = "y"];
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // required double z = 4 [json_name = "z"];
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Quaternion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double w_;
    double x_;
    double y_;
    double z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class YawPitchRoll final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.YawPitchRoll) */ {
 public:
  inline YawPitchRoll() : YawPitchRoll(nullptr) {}
  ~YawPitchRoll() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR YawPitchRoll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YawPitchRoll(const YawPitchRoll& from);
  YawPitchRoll(YawPitchRoll&& from) noexcept
    : YawPitchRoll() {
    *this = ::std::move(from);
  }

  inline YawPitchRoll& operator=(const YawPitchRoll& from) {
    CopyFrom(from);
    return *this;
  }
  inline YawPitchRoll& operator=(YawPitchRoll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const YawPitchRoll& default_instance() {
    return *internal_default_instance();
  }
  static inline const YawPitchRoll* internal_default_instance() {
    return reinterpret_cast<const YawPitchRoll*>(
               &_YawPitchRoll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(YawPitchRoll& a, YawPitchRoll& b) {
    a.Swap(&b);
  }
  inline void Swap(YawPitchRoll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YawPitchRoll* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YawPitchRoll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YawPitchRoll>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const YawPitchRoll& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const YawPitchRoll& from) {
    YawPitchRoll::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YawPitchRoll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.YawPitchRoll";
  }
  protected:
  explicit YawPitchRoll(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawDegFieldNumber = 1,
    kPitchDegFieldNumber = 2,
    kRollDegFieldNumber = 3,
  };
  // required double yaw_deg = 1 [json_name = "yawDeg"];
  bool has_yaw_deg() const;
  void clear_yaw_deg() ;
  double yaw_deg() const;
  void set_yaw_deg(double value);

  private:
  double _internal_yaw_deg() const;
  void _internal_set_yaw_deg(double value);

  public:
  // required double pitch_deg = 2 [json_name = "pitchDeg"];
  bool has_pitch_deg() const;
  void clear_pitch_deg() ;
  double pitch_deg() const;
  void set_pitch_deg(double value);

  private:
  double _internal_pitch_deg() const;
  void _internal_set_pitch_deg(double value);

  public:
  // required double roll_deg = 3 [json_name = "rollDeg"];
  bool has_roll_deg() const;
  void clear_roll_deg() ;
  double roll_deg() const;
  void set_roll_deg(double value);

  private:
  double _internal_roll_deg() const;
  void _internal_set_roll_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.YawPitchRoll)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double yaw_deg_;
    double pitch_deg_;
    double roll_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class PointingVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PointingVector) */ {
 public:
  inline PointingVector() : PointingVector(nullptr) {}
  ~PointingVector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointingVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointingVector(const PointingVector& from);
  PointingVector(PointingVector&& from) noexcept
    : PointingVector() {
    *this = ::std::move(from);
  }

  inline PointingVector& operator=(const PointingVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointingVector& operator=(PointingVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointingVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointingVector* internal_default_instance() {
    return reinterpret_cast<const PointingVector*>(
               &_PointingVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PointingVector& a, PointingVector& b) {
    a.Swap(&b);
  }
  inline void Swap(PointingVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointingVector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointingVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointingVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointingVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointingVector& from) {
    PointingVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointingVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PointingVector";
  }
  protected:
  explicit PointingVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAzimuthDegFieldNumber = 1,
    kElevationDegFieldNumber = 2,
  };
  // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
  bool has_azimuth_deg() const;
  void clear_azimuth_deg() ;
  double azimuth_deg() const;
  void set_azimuth_deg(double value);

  private:
  double _internal_azimuth_deg() const;
  void _internal_set_azimuth_deg(double value);

  public:
  // optional double elevation_deg = 2 [json_name = "elevationDeg"];
  bool has_elevation_deg() const;
  void clear_elevation_deg() ;
  double elevation_deg() const;
  void set_elevation_deg(double value);

  private:
  double _internal_elevation_deg() const;
  void _internal_set_elevation_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PointingVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double azimuth_deg_;
    double elevation_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class PointAxes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PointAxes) */ {
 public:
  inline PointAxes() : PointAxes(nullptr) {}
  ~PointAxes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointAxes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointAxes(const PointAxes& from);
  PointAxes(PointAxes&& from) noexcept
    : PointAxes() {
    *this = ::std::move(from);
  }

  inline PointAxes& operator=(const PointAxes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointAxes& operator=(PointAxes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointAxes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointAxes* internal_default_instance() {
    return reinterpret_cast<const PointAxes*>(
               &_PointAxes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PointAxes& a, PointAxes& b) {
    a.Swap(&b);
  }
  inline void Swap(PointAxes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointAxes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointAxes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointAxes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointAxes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointAxes& from) {
    PointAxes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointAxes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PointAxes";
  }
  protected:
  explicit PointAxes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kAxesFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
  bool has_point() const;
  void clear_point() ;
  const ::aalyria::spacetime::api::common::Cartesian& point() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Cartesian* release_point();
  ::aalyria::spacetime::api::common::Cartesian* mutable_point();
  void set_allocated_point(::aalyria::spacetime::api::common::Cartesian* point);
  private:
  const ::aalyria::spacetime::api::common::Cartesian& _internal_point() const;
  ::aalyria::spacetime::api::common::Cartesian* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::aalyria::spacetime::api::common::Cartesian* point);
  ::aalyria::spacetime::api::common::Cartesian* unsafe_arena_release_point();
  // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
  bool has_axes() const;
  void clear_axes() ;
  const ::aalyria::spacetime::api::common::Quaternion& axes() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Quaternion* release_axes();
  ::aalyria::spacetime::api::common::Quaternion* mutable_axes();
  void set_allocated_axes(::aalyria::spacetime::api::common::Quaternion* axes);
  private:
  const ::aalyria::spacetime::api::common::Quaternion& _internal_axes() const;
  ::aalyria::spacetime::api::common::Quaternion* _internal_mutable_axes();
  public:
  void unsafe_arena_set_allocated_axes(
      ::aalyria::spacetime::api::common::Quaternion* axes);
  ::aalyria::spacetime::api::common::Quaternion* unsafe_arena_release_axes();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PointAxes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::Cartesian* point_;
    ::aalyria::spacetime::api::common::Quaternion* axes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class PointAxesTemporal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PointAxesTemporal) */ {
 public:
  inline PointAxesTemporal() : PointAxesTemporal(nullptr) {}
  ~PointAxesTemporal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointAxesTemporal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointAxesTemporal(const PointAxesTemporal& from);
  PointAxesTemporal(PointAxesTemporal&& from) noexcept
    : PointAxesTemporal() {
    *this = ::std::move(from);
  }

  inline PointAxesTemporal& operator=(const PointAxesTemporal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointAxesTemporal& operator=(PointAxesTemporal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointAxesTemporal& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointAxesTemporal* internal_default_instance() {
    return reinterpret_cast<const PointAxesTemporal*>(
               &_PointAxesTemporal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PointAxesTemporal& a, PointAxesTemporal& b) {
    a.Swap(&b);
  }
  inline void Swap(PointAxesTemporal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointAxesTemporal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointAxesTemporal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointAxesTemporal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointAxesTemporal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointAxesTemporal& from) {
    PointAxesTemporal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointAxesTemporal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PointAxesTemporal";
  }
  protected:
  explicit PointAxesTemporal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kAxesFieldNumber = 2,
    kGpsTimeFieldNumber = 4,
    kTimeFieldNumber = 5,
  };
  // optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
  bool has_point() const;
  void clear_point() ;
  const ::aalyria::spacetime::api::common::Cartesian& point() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Cartesian* release_point();
  ::aalyria::spacetime::api::common::Cartesian* mutable_point();
  void set_allocated_point(::aalyria::spacetime::api::common::Cartesian* point);
  private:
  const ::aalyria::spacetime::api::common::Cartesian& _internal_point() const;
  ::aalyria::spacetime::api::common::Cartesian* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::aalyria::spacetime::api::common::Cartesian* point);
  ::aalyria::spacetime::api::common::Cartesian* unsafe_arena_release_point();
  // optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
  bool has_axes() const;
  void clear_axes() ;
  const ::aalyria::spacetime::api::common::Quaternion& axes() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Quaternion* release_axes();
  ::aalyria::spacetime::api::common::Quaternion* mutable_axes();
  void set_allocated_axes(::aalyria::spacetime::api::common::Quaternion* axes);
  private:
  const ::aalyria::spacetime::api::common::Quaternion& _internal_axes() const;
  ::aalyria::spacetime::api::common::Quaternion* _internal_mutable_axes();
  public:
  void unsafe_arena_set_allocated_axes(
      ::aalyria::spacetime::api::common::Quaternion* axes);
  ::aalyria::spacetime::api::common::Quaternion* unsafe_arena_release_axes();
  // optional .aalyria.spacetime.api.common.GpsTime gps_time = 4 [json_name = "gpsTime"];
  bool has_gps_time() const;
  void clear_gps_time() ;
  const ::aalyria::spacetime::api::common::GpsTime& gps_time() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GpsTime* release_gps_time();
  ::aalyria::spacetime::api::common::GpsTime* mutable_gps_time();
  void set_allocated_gps_time(::aalyria::spacetime::api::common::GpsTime* gps_time);
  private:
  const ::aalyria::spacetime::api::common::GpsTime& _internal_gps_time() const;
  ::aalyria::spacetime::api::common::GpsTime* _internal_mutable_gps_time();
  public:
  void unsafe_arena_set_allocated_gps_time(
      ::aalyria::spacetime::api::common::GpsTime* gps_time);
  ::aalyria::spacetime::api::common::GpsTime* unsafe_arena_release_gps_time();
  // optional .google.protobuf.Timestamp time = 5 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PointAxesTemporal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::Cartesian* point_;
    ::aalyria::spacetime::api::common::Quaternion* axes_;
    ::aalyria::spacetime::api::common::GpsTime* gps_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class GeodeticWgs84Temporal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.GeodeticWgs84Temporal) */ {
 public:
  inline GeodeticWgs84Temporal() : GeodeticWgs84Temporal(nullptr) {}
  ~GeodeticWgs84Temporal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeodeticWgs84Temporal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeodeticWgs84Temporal(const GeodeticWgs84Temporal& from);
  GeodeticWgs84Temporal(GeodeticWgs84Temporal&& from) noexcept
    : GeodeticWgs84Temporal() {
    *this = ::std::move(from);
  }

  inline GeodeticWgs84Temporal& operator=(const GeodeticWgs84Temporal& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeodeticWgs84Temporal& operator=(GeodeticWgs84Temporal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeodeticWgs84Temporal& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeodeticWgs84Temporal* internal_default_instance() {
    return reinterpret_cast<const GeodeticWgs84Temporal*>(
               &_GeodeticWgs84Temporal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GeodeticWgs84Temporal& a, GeodeticWgs84Temporal& b) {
    a.Swap(&b);
  }
  inline void Swap(GeodeticWgs84Temporal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeodeticWgs84Temporal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeodeticWgs84Temporal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeodeticWgs84Temporal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeodeticWgs84Temporal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeodeticWgs84Temporal& from) {
    GeodeticWgs84Temporal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeodeticWgs84Temporal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.GeodeticWgs84Temporal";
  }
  protected:
  explicit GeodeticWgs84Temporal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 point = 1 [json_name = "point"];
  bool has_point() const;
  void clear_point() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84& point() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84* release_point();
  ::aalyria::spacetime::api::common::GeodeticWgs84* mutable_point();
  void set_allocated_point(::aalyria::spacetime::api::common::GeodeticWgs84* point);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84& _internal_point() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::aalyria::spacetime::api::common::GeodeticWgs84* point);
  ::aalyria::spacetime::api::common::GeodeticWgs84* unsafe_arena_release_point();
  // optional .google.protobuf.Timestamp time = 2 [json_name = "time"];
  bool has_time() const;
  void clear_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.GeodeticWgs84Temporal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::GeodeticWgs84* point_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class PointAxesTemporalInterpolation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PointAxesTemporalInterpolation) */ {
 public:
  inline PointAxesTemporalInterpolation() : PointAxesTemporalInterpolation(nullptr) {}
  ~PointAxesTemporalInterpolation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointAxesTemporalInterpolation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointAxesTemporalInterpolation(const PointAxesTemporalInterpolation& from);
  PointAxesTemporalInterpolation(PointAxesTemporalInterpolation&& from) noexcept
    : PointAxesTemporalInterpolation() {
    *this = ::std::move(from);
  }

  inline PointAxesTemporalInterpolation& operator=(const PointAxesTemporalInterpolation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointAxesTemporalInterpolation& operator=(PointAxesTemporalInterpolation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointAxesTemporalInterpolation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointAxesTemporalInterpolation* internal_default_instance() {
    return reinterpret_cast<const PointAxesTemporalInterpolation*>(
               &_PointAxesTemporalInterpolation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PointAxesTemporalInterpolation& a, PointAxesTemporalInterpolation& b) {
    a.Swap(&b);
  }
  inline void Swap(PointAxesTemporalInterpolation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointAxesTemporalInterpolation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointAxesTemporalInterpolation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointAxesTemporalInterpolation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointAxesTemporalInterpolation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointAxesTemporalInterpolation& from) {
    PointAxesTemporalInterpolation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointAxesTemporalInterpolation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PointAxesTemporalInterpolation";
  }
  protected:
  explicit PointAxesTemporalInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsOrientationsOverTimeFieldNumber = 1,
    kInterpolationMethodFieldNumber = 2,
    kInterpolationDegreeFieldNumber = 3,
  };
  // repeated .aalyria.spacetime.api.common.PointAxesTemporal locations_orientations_over_time = 1 [json_name = "locationsOrientationsOverTime"];
  int locations_orientations_over_time_size() const;
  private:
  int _internal_locations_orientations_over_time_size() const;

  public:
  void clear_locations_orientations_over_time() ;
  ::aalyria::spacetime::api::common::PointAxesTemporal* mutable_locations_orientations_over_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointAxesTemporal >*
      mutable_locations_orientations_over_time();
  private:
  const ::aalyria::spacetime::api::common::PointAxesTemporal& _internal_locations_orientations_over_time(int index) const;
  ::aalyria::spacetime::api::common::PointAxesTemporal* _internal_add_locations_orientations_over_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointAxesTemporal>& _internal_locations_orientations_over_time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointAxesTemporal>* _internal_mutable_locations_orientations_over_time();
  public:
  const ::aalyria::spacetime::api::common::PointAxesTemporal& locations_orientations_over_time(int index) const;
  ::aalyria::spacetime::api::common::PointAxesTemporal* add_locations_orientations_over_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointAxesTemporal >&
      locations_orientations_over_time() const;
  // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
  bool has_interpolation_method() const;
  void clear_interpolation_method() ;
  ::aalyria::spacetime::api::common::InterpolationMethod interpolation_method() const;
  void set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value);

  private:
  ::aalyria::spacetime::api::common::InterpolationMethod _internal_interpolation_method() const;
  void _internal_set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value);

  public:
  // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
  bool has_interpolation_degree() const;
  void clear_interpolation_degree() ;
  ::int32_t interpolation_degree() const;
  void set_interpolation_degree(::int32_t value);

  private:
  ::int32_t _internal_interpolation_degree() const;
  void _internal_set_interpolation_degree(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PointAxesTemporalInterpolation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointAxesTemporal > locations_orientations_over_time_;
    int interpolation_method_;
    ::int32_t interpolation_degree_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class GeodeticWgs84TemporalInterpolation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation) */ {
 public:
  inline GeodeticWgs84TemporalInterpolation() : GeodeticWgs84TemporalInterpolation(nullptr) {}
  ~GeodeticWgs84TemporalInterpolation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeodeticWgs84TemporalInterpolation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeodeticWgs84TemporalInterpolation(const GeodeticWgs84TemporalInterpolation& from);
  GeodeticWgs84TemporalInterpolation(GeodeticWgs84TemporalInterpolation&& from) noexcept
    : GeodeticWgs84TemporalInterpolation() {
    *this = ::std::move(from);
  }

  inline GeodeticWgs84TemporalInterpolation& operator=(const GeodeticWgs84TemporalInterpolation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeodeticWgs84TemporalInterpolation& operator=(GeodeticWgs84TemporalInterpolation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeodeticWgs84TemporalInterpolation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeodeticWgs84TemporalInterpolation* internal_default_instance() {
    return reinterpret_cast<const GeodeticWgs84TemporalInterpolation*>(
               &_GeodeticWgs84TemporalInterpolation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GeodeticWgs84TemporalInterpolation& a, GeodeticWgs84TemporalInterpolation& b) {
    a.Swap(&b);
  }
  inline void Swap(GeodeticWgs84TemporalInterpolation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeodeticWgs84TemporalInterpolation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeodeticWgs84TemporalInterpolation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeodeticWgs84TemporalInterpolation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeodeticWgs84TemporalInterpolation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeodeticWgs84TemporalInterpolation& from) {
    GeodeticWgs84TemporalInterpolation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeodeticWgs84TemporalInterpolation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation";
  }
  protected:
  explicit GeodeticWgs84TemporalInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsOverTimeFieldNumber = 1,
    kInterpolationMethodFieldNumber = 2,
    kInterpolationDegreeFieldNumber = 3,
  };
  // repeated .aalyria.spacetime.api.common.GeodeticWgs84Temporal locations_over_time = 1 [json_name = "locationsOverTime"];
  int locations_over_time_size() const;
  private:
  int _internal_locations_over_time_size() const;

  public:
  void clear_locations_over_time() ;
  ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* mutable_locations_over_time(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >*
      mutable_locations_over_time();
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84Temporal& _internal_locations_over_time(int index) const;
  ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* _internal_add_locations_over_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::GeodeticWgs84Temporal>& _internal_locations_over_time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::GeodeticWgs84Temporal>* _internal_mutable_locations_over_time();
  public:
  const ::aalyria::spacetime::api::common::GeodeticWgs84Temporal& locations_over_time(int index) const;
  ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* add_locations_over_time();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >&
      locations_over_time() const;
  // optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
  bool has_interpolation_method() const;
  void clear_interpolation_method() ;
  ::aalyria::spacetime::api::common::InterpolationMethod interpolation_method() const;
  void set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value);

  private:
  ::aalyria::spacetime::api::common::InterpolationMethod _internal_interpolation_method() const;
  void _internal_set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value);

  public:
  // optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
  bool has_interpolation_degree() const;
  void clear_interpolation_degree() ;
  ::int32_t interpolation_degree() const;
  void set_interpolation_degree(::int32_t value);

  private:
  ::int32_t _internal_interpolation_degree() const;
  void _internal_set_interpolation_degree(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal > locations_over_time_;
    int interpolation_method_;
    ::int32_t interpolation_degree_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class TwoLineElementSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TwoLineElementSet) */ {
 public:
  inline TwoLineElementSet() : TwoLineElementSet(nullptr) {}
  ~TwoLineElementSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwoLineElementSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TwoLineElementSet(const TwoLineElementSet& from);
  TwoLineElementSet(TwoLineElementSet&& from) noexcept
    : TwoLineElementSet() {
    *this = ::std::move(from);
  }

  inline TwoLineElementSet& operator=(const TwoLineElementSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwoLineElementSet& operator=(TwoLineElementSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwoLineElementSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwoLineElementSet* internal_default_instance() {
    return reinterpret_cast<const TwoLineElementSet*>(
               &_TwoLineElementSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TwoLineElementSet& a, TwoLineElementSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TwoLineElementSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwoLineElementSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwoLineElementSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwoLineElementSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TwoLineElementSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TwoLineElementSet& from) {
    TwoLineElementSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TwoLineElementSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TwoLineElementSet";
  }
  protected:
  explicit TwoLineElementSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLine1FieldNumber = 1,
    kLine2FieldNumber = 2,
  };
  // optional string line1 = 1 [json_name = "line1"];
  bool has_line1() const;
  void clear_line1() ;
  const std::string& line1() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_line1(Arg_&& arg, Args_... args);
  std::string* mutable_line1();
  PROTOBUF_NODISCARD std::string* release_line1();
  void set_allocated_line1(std::string* ptr);

  private:
  const std::string& _internal_line1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line1(
      const std::string& value);
  std::string* _internal_mutable_line1();

  public:
  // optional string line2 = 2 [json_name = "line2"];
  bool has_line2() const;
  void clear_line2() ;
  const std::string& line2() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_line2(Arg_&& arg, Args_... args);
  std::string* mutable_line2();
  PROTOBUF_NODISCARD std::string* release_line2();
  void set_allocated_line2(std::string* ptr);

  private:
  const std::string& _internal_line2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line2(
      const std::string& value);
  std::string* _internal_mutable_line2();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TwoLineElementSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class KeplerianElements final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.KeplerianElements) */ {
 public:
  inline KeplerianElements() : KeplerianElements(nullptr) {}
  ~KeplerianElements() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KeplerianElements(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeplerianElements(const KeplerianElements& from);
  KeplerianElements(KeplerianElements&& from) noexcept
    : KeplerianElements() {
    *this = ::std::move(from);
  }

  inline KeplerianElements& operator=(const KeplerianElements& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeplerianElements& operator=(KeplerianElements&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeplerianElements& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeplerianElements* internal_default_instance() {
    return reinterpret_cast<const KeplerianElements*>(
               &_KeplerianElements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(KeplerianElements& a, KeplerianElements& b) {
    a.Swap(&b);
  }
  inline void Swap(KeplerianElements* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeplerianElements* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeplerianElements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeplerianElements>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeplerianElements& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeplerianElements& from) {
    KeplerianElements::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeplerianElements* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.KeplerianElements";
  }
  protected:
  explicit KeplerianElements(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 7,
    kSemimajorAxisMFieldNumber = 1,
    kEccentricityFieldNumber = 2,
    kInclinationDegFieldNumber = 3,
    kArgumentOfPeriapsisDegFieldNumber = 4,
    kRaanDegFieldNumber = 5,
    kTrueAnomalyDegFieldNumber = 6,
    kCentralBodyFieldNumber = 8,
  };
  // optional .aalyria.spacetime.api.common.DateTime epoch = 7 [json_name = "epoch"];
  bool has_epoch() const;
  void clear_epoch() ;
  const ::aalyria::spacetime::api::common::DateTime& epoch() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_epoch();
  ::aalyria::spacetime::api::common::DateTime* mutable_epoch();
  void set_allocated_epoch(::aalyria::spacetime::api::common::DateTime* epoch);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_epoch() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_epoch();
  public:
  void unsafe_arena_set_allocated_epoch(
      ::aalyria::spacetime::api::common::DateTime* epoch);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_epoch();
  // optional double semimajor_axis_m = 1 [json_name = "semimajorAxisM"];
  bool has_semimajor_axis_m() const;
  void clear_semimajor_axis_m() ;
  double semimajor_axis_m() const;
  void set_semimajor_axis_m(double value);

  private:
  double _internal_semimajor_axis_m() const;
  void _internal_set_semimajor_axis_m(double value);

  public:
  // optional double eccentricity = 2 [json_name = "eccentricity"];
  bool has_eccentricity() const;
  void clear_eccentricity() ;
  double eccentricity() const;
  void set_eccentricity(double value);

  private:
  double _internal_eccentricity() const;
  void _internal_set_eccentricity(double value);

  public:
  // optional double inclination_deg = 3 [json_name = "inclinationDeg"];
  bool has_inclination_deg() const;
  void clear_inclination_deg() ;
  double inclination_deg() const;
  void set_inclination_deg(double value);

  private:
  double _internal_inclination_deg() const;
  void _internal_set_inclination_deg(double value);

  public:
  // optional double argument_of_periapsis_deg = 4 [json_name = "argumentOfPeriapsisDeg"];
  bool has_argument_of_periapsis_deg() const;
  void clear_argument_of_periapsis_deg() ;
  double argument_of_periapsis_deg() const;
  void set_argument_of_periapsis_deg(double value);

  private:
  double _internal_argument_of_periapsis_deg() const;
  void _internal_set_argument_of_periapsis_deg(double value);

  public:
  // optional double raan_deg = 5 [json_name = "raanDeg"];
  bool has_raan_deg() const;
  void clear_raan_deg() ;
  double raan_deg() const;
  void set_raan_deg(double value);

  private:
  double _internal_raan_deg() const;
  void _internal_set_raan_deg(double value);

  public:
  // optional double true_anomaly_deg = 6 [json_name = "trueAnomalyDeg"];
  bool has_true_anomaly_deg() const;
  void clear_true_anomaly_deg() ;
  double true_anomaly_deg() const;
  void set_true_anomaly_deg(double value);

  private:
  double _internal_true_anomaly_deg() const;
  void _internal_set_true_anomaly_deg(double value);

  public:
  // optional .aalyria.spacetime.api.common.CentralBody central_body = 8 [default = EARTH, json_name = "centralBody"];
  bool has_central_body() const;
  void clear_central_body() ;
  ::aalyria::spacetime::api::common::CentralBody central_body() const;
  void set_central_body(::aalyria::spacetime::api::common::CentralBody value);

  private:
  ::aalyria::spacetime::api::common::CentralBody _internal_central_body() const;
  void _internal_set_central_body(::aalyria::spacetime::api::common::CentralBody value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.KeplerianElements)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::DateTime* epoch_;
    double semimajor_axis_m_;
    double eccentricity_;
    double inclination_deg_;
    double argument_of_periapsis_deg_;
    double raan_deg_;
    double true_anomaly_deg_;
    int central_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class StateVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.StateVector) */ {
 public:
  inline StateVector() : StateVector(nullptr) {}
  ~StateVector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateVector(const StateVector& from);
  StateVector(StateVector&& from) noexcept
    : StateVector() {
    *this = ::std::move(from);
  }

  inline StateVector& operator=(const StateVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateVector& operator=(StateVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateVector* internal_default_instance() {
    return reinterpret_cast<const StateVector*>(
               &_StateVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StateVector& a, StateVector& b) {
    a.Swap(&b);
  }
  inline void Swap(StateVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateVector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateVector& from) {
    StateVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.StateVector";
  }
  protected:
  explicit StateVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CoordinateFrame = StateVector_CoordinateFrame;
  static constexpr CoordinateFrame UNKNOWN_FRAME = StateVector_CoordinateFrame_UNKNOWN_FRAME;
  static constexpr CoordinateFrame EARTH_MOON_BARYCENTER_SYNODIC_FRAME = StateVector_CoordinateFrame_EARTH_MOON_BARYCENTER_SYNODIC_FRAME;
  static constexpr CoordinateFrame ECEF_FRAME = StateVector_CoordinateFrame_ECEF_FRAME;
  static inline bool CoordinateFrame_IsValid(int value) {
    return StateVector_CoordinateFrame_IsValid(value);
  }
  static constexpr CoordinateFrame CoordinateFrame_MIN = StateVector_CoordinateFrame_CoordinateFrame_MIN;
  static constexpr CoordinateFrame CoordinateFrame_MAX = StateVector_CoordinateFrame_CoordinateFrame_MAX;
  static constexpr int CoordinateFrame_ARRAYSIZE = StateVector_CoordinateFrame_CoordinateFrame_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CoordinateFrame_descriptor() {
    return StateVector_CoordinateFrame_descriptor();
  }
  template <typename T>
  static inline const std::string& CoordinateFrame_Name(T value) {
    return StateVector_CoordinateFrame_Name(value);
  }
  static inline bool CoordinateFrame_Parse(absl::string_view name, CoordinateFrame* value) {
    return StateVector_CoordinateFrame_Parse(name, value);
  }

  using PropagationAlgorithm = StateVector_PropagationAlgorithm;
  static constexpr PropagationAlgorithm UNSPECIFIED_ALGORITHM = StateVector_PropagationAlgorithm_UNSPECIFIED_ALGORITHM;
  static constexpr PropagationAlgorithm EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM = StateVector_PropagationAlgorithm_EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM;
  static inline bool PropagationAlgorithm_IsValid(int value) {
    return StateVector_PropagationAlgorithm_IsValid(value);
  }
  static constexpr PropagationAlgorithm PropagationAlgorithm_MIN = StateVector_PropagationAlgorithm_PropagationAlgorithm_MIN;
  static constexpr PropagationAlgorithm PropagationAlgorithm_MAX = StateVector_PropagationAlgorithm_PropagationAlgorithm_MAX;
  static constexpr int PropagationAlgorithm_ARRAYSIZE = StateVector_PropagationAlgorithm_PropagationAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropagationAlgorithm_descriptor() {
    return StateVector_PropagationAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& PropagationAlgorithm_Name(T value) {
    return StateVector_PropagationAlgorithm_Name(value);
  }
  static inline bool PropagationAlgorithm_Parse(absl::string_view name, PropagationAlgorithm* value) {
    return StateVector_PropagationAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
    kPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kCoordinateFrameFieldNumber = 2,
    kPropagationAlgorithmFieldNumber = 5,
    kMassKgFieldNumber = 6,
    kReflectivityFieldNumber = 7,
    kReflectiveAreaSqmFieldNumber = 8,
  };
  // required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
  bool has_epoch() const;
  void clear_epoch() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& epoch() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_epoch();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_epoch();
  void set_allocated_epoch(::PROTOBUF_NAMESPACE_ID::Timestamp* epoch);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_epoch() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_epoch();
  public:
  void unsafe_arena_set_allocated_epoch(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* epoch);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_epoch();
  // required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::aalyria::spacetime::api::common::Cartesian& position() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Cartesian* release_position();
  ::aalyria::spacetime::api::common::Cartesian* mutable_position();
  void set_allocated_position(::aalyria::spacetime::api::common::Cartesian* position);
  private:
  const ::aalyria::spacetime::api::common::Cartesian& _internal_position() const;
  ::aalyria::spacetime::api::common::Cartesian* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::aalyria::spacetime::api::common::Cartesian* position);
  ::aalyria::spacetime::api::common::Cartesian* unsafe_arena_release_position();
  // required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
  bool has_velocity() const;
  void clear_velocity() ;
  const ::aalyria::spacetime::api::common::CartesianDot& velocity() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::CartesianDot* release_velocity();
  ::aalyria::spacetime::api::common::CartesianDot* mutable_velocity();
  void set_allocated_velocity(::aalyria::spacetime::api::common::CartesianDot* velocity);
  private:
  const ::aalyria::spacetime::api::common::CartesianDot& _internal_velocity() const;
  ::aalyria::spacetime::api::common::CartesianDot* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::aalyria::spacetime::api::common::CartesianDot* velocity);
  ::aalyria::spacetime::api::common::CartesianDot* unsafe_arena_release_velocity();
  // optional .aalyria.spacetime.api.common.StateVector.CoordinateFrame coordinate_frame = 2 [json_name = "coordinateFrame"];
  bool has_coordinate_frame() const;
  void clear_coordinate_frame() ;
  ::aalyria::spacetime::api::common::StateVector_CoordinateFrame coordinate_frame() const;
  void set_coordinate_frame(::aalyria::spacetime::api::common::StateVector_CoordinateFrame value);

  private:
  ::aalyria::spacetime::api::common::StateVector_CoordinateFrame _internal_coordinate_frame() const;
  void _internal_set_coordinate_frame(::aalyria::spacetime::api::common::StateVector_CoordinateFrame value);

  public:
  // optional .aalyria.spacetime.api.common.StateVector.PropagationAlgorithm propagation_algorithm = 5 [json_name = "propagationAlgorithm"];
  bool has_propagation_algorithm() const;
  void clear_propagation_algorithm() ;
  ::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm propagation_algorithm() const;
  void set_propagation_algorithm(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm value);

  private:
  ::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm _internal_propagation_algorithm() const;
  void _internal_set_propagation_algorithm(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm value);

  public:
  // optional double mass_kg = 6 [default = 2000, json_name = "massKg"];
  bool has_mass_kg() const;
  void clear_mass_kg() ;
  double mass_kg() const;
  void set_mass_kg(double value);

  private:
  double _internal_mass_kg() const;
  void _internal_set_mass_kg(double value);

  public:
  // optional double reflectivity = 7 [default = 1, json_name = "reflectivity"];
  bool has_reflectivity() const;
  void clear_reflectivity() ;
  double reflectivity() const;
  void set_reflectivity(double value);

  private:
  double _internal_reflectivity() const;
  void _internal_set_reflectivity(double value);

  public:
  // optional double reflective_area_sqm = 8 [default = 20, json_name = "reflectiveAreaSqm"];
  bool has_reflective_area_sqm() const;
  void clear_reflective_area_sqm() ;
  double reflective_area_sqm() const;
  void set_reflective_area_sqm(double value);

  private:
  double _internal_reflective_area_sqm() const;
  void _internal_set_reflective_area_sqm(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.StateVector)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* epoch_;
    ::aalyria::spacetime::api::common::Cartesian* position_;
    ::aalyria::spacetime::api::common::CartesianDot* velocity_;
    int coordinate_frame_;
    int propagation_algorithm_;
    double mass_kg_;
    double reflectivity_;
    double reflective_area_sqm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class SelenographicMlr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.SelenographicMlr) */ {
 public:
  inline SelenographicMlr() : SelenographicMlr(nullptr) {}
  ~SelenographicMlr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelenographicMlr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelenographicMlr(const SelenographicMlr& from);
  SelenographicMlr(SelenographicMlr&& from) noexcept
    : SelenographicMlr() {
    *this = ::std::move(from);
  }

  inline SelenographicMlr& operator=(const SelenographicMlr& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelenographicMlr& operator=(SelenographicMlr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelenographicMlr& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelenographicMlr* internal_default_instance() {
    return reinterpret_cast<const SelenographicMlr*>(
               &_SelenographicMlr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SelenographicMlr& a, SelenographicMlr& b) {
    a.Swap(&b);
  }
  inline void Swap(SelenographicMlr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelenographicMlr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelenographicMlr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelenographicMlr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelenographicMlr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelenographicMlr& from) {
    SelenographicMlr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelenographicMlr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.SelenographicMlr";
  }
  protected:
  explicit SelenographicMlr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeDegFieldNumber = 1,
    kLatitudeDegFieldNumber = 2,
    kHeightMlrMFieldNumber = 3,
  };
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  bool has_longitude_deg() const;
  void clear_longitude_deg() ;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);

  public:
  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  bool has_latitude_deg() const;
  void clear_latitude_deg() ;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);

  public:
  // optional double height_mlr_m = 3 [json_name = "heightMlrM"];
  bool has_height_mlr_m() const;
  void clear_height_mlr_m() ;
  double height_mlr_m() const;
  void set_height_mlr_m(double value);

  private:
  double _internal_height_mlr_m() const;
  void _internal_set_height_mlr_m(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.SelenographicMlr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double longitude_deg_;
    double latitude_deg_;
    double height_mlr_m_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class StkEphemAndAttitudeFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.StkEphemAndAttitudeFile) */ {
 public:
  inline StkEphemAndAttitudeFile() : StkEphemAndAttitudeFile(nullptr) {}
  ~StkEphemAndAttitudeFile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StkEphemAndAttitudeFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StkEphemAndAttitudeFile(const StkEphemAndAttitudeFile& from);
  StkEphemAndAttitudeFile(StkEphemAndAttitudeFile&& from) noexcept
    : StkEphemAndAttitudeFile() {
    *this = ::std::move(from);
  }

  inline StkEphemAndAttitudeFile& operator=(const StkEphemAndAttitudeFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline StkEphemAndAttitudeFile& operator=(StkEphemAndAttitudeFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StkEphemAndAttitudeFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const StkEphemAndAttitudeFile* internal_default_instance() {
    return reinterpret_cast<const StkEphemAndAttitudeFile*>(
               &_StkEphemAndAttitudeFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StkEphemAndAttitudeFile& a, StkEphemAndAttitudeFile& b) {
    a.Swap(&b);
  }
  inline void Swap(StkEphemAndAttitudeFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StkEphemAndAttitudeFile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StkEphemAndAttitudeFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StkEphemAndAttitudeFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StkEphemAndAttitudeFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StkEphemAndAttitudeFile& from) {
    StkEphemAndAttitudeFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StkEphemAndAttitudeFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.StkEphemAndAttitudeFile";
  }
  protected:
  explicit StkEphemAndAttitudeFile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEphemFileFieldNumber = 1,
    kAttitudeFileFieldNumber = 2,
  };
  // optional string ephem_file = 1 [json_name = "ephemFile"];
  bool has_ephem_file() const;
  void clear_ephem_file() ;
  const std::string& ephem_file() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ephem_file(Arg_&& arg, Args_... args);
  std::string* mutable_ephem_file();
  PROTOBUF_NODISCARD std::string* release_ephem_file();
  void set_allocated_ephem_file(std::string* ptr);

  private:
  const std::string& _internal_ephem_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ephem_file(
      const std::string& value);
  std::string* _internal_mutable_ephem_file();

  public:
  // optional string attitude_file = 2 [json_name = "attitudeFile"];
  bool has_attitude_file() const;
  void clear_attitude_file() ;
  const std::string& attitude_file() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attitude_file(Arg_&& arg, Args_... args);
  std::string* mutable_attitude_file();
  PROTOBUF_NODISCARD std::string* release_attitude_file();
  void set_allocated_attitude_file(std::string* ptr);

  private:
  const std::string& _internal_attitude_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attitude_file(
      const std::string& value);
  std::string* _internal_mutable_attitude_file();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.StkEphemAndAttitudeFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ephem_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attitude_file_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class Motion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Motion) */ {
 public:
  inline Motion() : Motion(nullptr) {}
  ~Motion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Motion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Motion(const Motion& from);
  Motion(Motion&& from) noexcept
    : Motion() {
    *this = ::std::move(from);
  }

  inline Motion& operator=(const Motion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Motion& operator=(Motion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Motion& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kGeodeticMsl = 7,
    kGeodeticWgs84 = 1,
    kEcefFixed = 2,
    kEcefInterpolation = 3,
    kCartographicWaypoints = 4,
    kTle = 5,
    kKeplerianElements = 6,
    kStateVector = 9,
    kSelenographicMlr = 8,
    kStkEphemAndAttitudeFile = 11,
    TYPE_NOT_SET = 0,
  };

  static inline const Motion* internal_default_instance() {
    return reinterpret_cast<const Motion*>(
               &_Motion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Motion& a, Motion& b) {
    a.Swap(&b);
  }
  inline void Swap(Motion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Motion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Motion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Motion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Motion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Motion& from) {
    Motion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Motion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Motion";
  }
  protected:
  explicit Motion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Motion_Type;
  static constexpr Type MOTION_UNSPECIFIED = Motion_Type_MOTION_UNSPECIFIED;
  static constexpr Type GEODETIC_MSL = Motion_Type_GEODETIC_MSL;
  static constexpr Type GEODETIC_WGS84 = Motion_Type_GEODETIC_WGS84;
  static constexpr Type ECEF_FIXED = Motion_Type_ECEF_FIXED;
  static constexpr Type ECEF_INTERPOLATION = Motion_Type_ECEF_INTERPOLATION;
  static constexpr Type CARTOGRAPHIC_WAYPOINTS = Motion_Type_CARTOGRAPHIC_WAYPOINTS;
  static constexpr Type TLE = Motion_Type_TLE;
  static constexpr Type KEPLERIAN_ELEMENTS = Motion_Type_KEPLERIAN_ELEMENTS;
  static constexpr Type STATE_VECTOR = Motion_Type_STATE_VECTOR;
  static constexpr Type SELENOGRAPHIC_MLR = Motion_Type_SELENOGRAPHIC_MLR;
  static constexpr Type STK_EPHEM_AND_ATTITUDE_FILE = Motion_Type_STK_EPHEM_AND_ATTITUDE_FILE;
  static inline bool Type_IsValid(int value) {
    return Motion_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Motion_Type_Type_MIN;
  static constexpr Type Type_MAX = Motion_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Motion_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
    return Motion_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Motion_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Motion_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 10,
    kGeodeticMslFieldNumber = 7,
    kGeodeticWgs84FieldNumber = 1,
    kEcefFixedFieldNumber = 2,
    kEcefInterpolationFieldNumber = 3,
    kCartographicWaypointsFieldNumber = 4,
    kTleFieldNumber = 5,
    kKeplerianElementsFieldNumber = 6,
    kStateVectorFieldNumber = 9,
    kSelenographicMlrFieldNumber = 8,
    kStkEphemAndAttitudeFileFieldNumber = 11,
  };
  // optional .google.type.Interval interval = 10 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::google::type::Interval& interval() const;
  PROTOBUF_NODISCARD ::google::type::Interval* release_interval();
  ::google::type::Interval* mutable_interval();
  void set_allocated_interval(::google::type::Interval* interval);
  private:
  const ::google::type::Interval& _internal_interval() const;
  ::google::type::Interval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::google::type::Interval* interval);
  ::google::type::Interval* unsafe_arena_release_interval();
  // .aalyria.spacetime.api.common.GeodeticMsl geodetic_msl = 7 [json_name = "geodeticMsl"];
  bool has_geodetic_msl() const;
  private:
  bool _internal_has_geodetic_msl() const;

  public:
  void clear_geodetic_msl() ;
  const ::aalyria::spacetime::api::common::GeodeticMsl& geodetic_msl() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticMsl* release_geodetic_msl();
  ::aalyria::spacetime::api::common::GeodeticMsl* mutable_geodetic_msl();
  void set_allocated_geodetic_msl(::aalyria::spacetime::api::common::GeodeticMsl* geodetic_msl);
  private:
  const ::aalyria::spacetime::api::common::GeodeticMsl& _internal_geodetic_msl() const;
  ::aalyria::spacetime::api::common::GeodeticMsl* _internal_mutable_geodetic_msl();
  public:
  void unsafe_arena_set_allocated_geodetic_msl(
      ::aalyria::spacetime::api::common::GeodeticMsl* geodetic_msl);
  ::aalyria::spacetime::api::common::GeodeticMsl* unsafe_arena_release_geodetic_msl();
  // .aalyria.spacetime.api.common.GeodeticWgs84 geodetic_wgs84 = 1 [json_name = "geodeticWgs84"];
  bool has_geodetic_wgs84() const;
  private:
  bool _internal_has_geodetic_wgs84() const;

  public:
  void clear_geodetic_wgs84() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84& geodetic_wgs84() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84* release_geodetic_wgs84();
  ::aalyria::spacetime::api::common::GeodeticWgs84* mutable_geodetic_wgs84();
  void set_allocated_geodetic_wgs84(::aalyria::spacetime::api::common::GeodeticWgs84* geodetic_wgs84);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84& _internal_geodetic_wgs84() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84* _internal_mutable_geodetic_wgs84();
  public:
  void unsafe_arena_set_allocated_geodetic_wgs84(
      ::aalyria::spacetime::api::common::GeodeticWgs84* geodetic_wgs84);
  ::aalyria::spacetime::api::common::GeodeticWgs84* unsafe_arena_release_geodetic_wgs84();
  // .aalyria.spacetime.api.common.PointAxes ecef_fixed = 2 [json_name = "ecefFixed"];
  bool has_ecef_fixed() const;
  private:
  bool _internal_has_ecef_fixed() const;

  public:
  void clear_ecef_fixed() ;
  const ::aalyria::spacetime::api::common::PointAxes& ecef_fixed() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PointAxes* release_ecef_fixed();
  ::aalyria::spacetime::api::common::PointAxes* mutable_ecef_fixed();
  void set_allocated_ecef_fixed(::aalyria::spacetime::api::common::PointAxes* ecef_fixed);
  private:
  const ::aalyria::spacetime::api::common::PointAxes& _internal_ecef_fixed() const;
  ::aalyria::spacetime::api::common::PointAxes* _internal_mutable_ecef_fixed();
  public:
  void unsafe_arena_set_allocated_ecef_fixed(
      ::aalyria::spacetime::api::common::PointAxes* ecef_fixed);
  ::aalyria::spacetime::api::common::PointAxes* unsafe_arena_release_ecef_fixed();
  // .aalyria.spacetime.api.common.PointAxesTemporalInterpolation ecef_interpolation = 3 [json_name = "ecefInterpolation"];
  bool has_ecef_interpolation() const;
  private:
  bool _internal_has_ecef_interpolation() const;

  public:
  void clear_ecef_interpolation() ;
  const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation& ecef_interpolation() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* release_ecef_interpolation();
  ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* mutable_ecef_interpolation();
  void set_allocated_ecef_interpolation(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* ecef_interpolation);
  private:
  const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation& _internal_ecef_interpolation() const;
  ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* _internal_mutable_ecef_interpolation();
  public:
  void unsafe_arena_set_allocated_ecef_interpolation(
      ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* ecef_interpolation);
  ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* unsafe_arena_release_ecef_interpolation();
  // .aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation cartographic_waypoints = 4 [json_name = "cartographicWaypoints"];
  bool has_cartographic_waypoints() const;
  private:
  bool _internal_has_cartographic_waypoints() const;

  public:
  void clear_cartographic_waypoints() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation& cartographic_waypoints() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* release_cartographic_waypoints();
  ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* mutable_cartographic_waypoints();
  void set_allocated_cartographic_waypoints(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* cartographic_waypoints);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation& _internal_cartographic_waypoints() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* _internal_mutable_cartographic_waypoints();
  public:
  void unsafe_arena_set_allocated_cartographic_waypoints(
      ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* cartographic_waypoints);
  ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* unsafe_arena_release_cartographic_waypoints();
  // .aalyria.spacetime.api.common.TwoLineElementSet tle = 5 [json_name = "tle"];
  bool has_tle() const;
  private:
  bool _internal_has_tle() const;

  public:
  void clear_tle() ;
  const ::aalyria::spacetime::api::common::TwoLineElementSet& tle() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TwoLineElementSet* release_tle();
  ::aalyria::spacetime::api::common::TwoLineElementSet* mutable_tle();
  void set_allocated_tle(::aalyria::spacetime::api::common::TwoLineElementSet* tle);
  private:
  const ::aalyria::spacetime::api::common::TwoLineElementSet& _internal_tle() const;
  ::aalyria::spacetime::api::common::TwoLineElementSet* _internal_mutable_tle();
  public:
  void unsafe_arena_set_allocated_tle(
      ::aalyria::spacetime::api::common::TwoLineElementSet* tle);
  ::aalyria::spacetime::api::common::TwoLineElementSet* unsafe_arena_release_tle();
  // .aalyria.spacetime.api.common.KeplerianElements keplerian_elements = 6 [json_name = "keplerianElements"];
  bool has_keplerian_elements() const;
  private:
  bool _internal_has_keplerian_elements() const;

  public:
  void clear_keplerian_elements() ;
  const ::aalyria::spacetime::api::common::KeplerianElements& keplerian_elements() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::KeplerianElements* release_keplerian_elements();
  ::aalyria::spacetime::api::common::KeplerianElements* mutable_keplerian_elements();
  void set_allocated_keplerian_elements(::aalyria::spacetime::api::common::KeplerianElements* keplerian_elements);
  private:
  const ::aalyria::spacetime::api::common::KeplerianElements& _internal_keplerian_elements() const;
  ::aalyria::spacetime::api::common::KeplerianElements* _internal_mutable_keplerian_elements();
  public:
  void unsafe_arena_set_allocated_keplerian_elements(
      ::aalyria::spacetime::api::common::KeplerianElements* keplerian_elements);
  ::aalyria::spacetime::api::common::KeplerianElements* unsafe_arena_release_keplerian_elements();
  // .aalyria.spacetime.api.common.StateVector state_vector = 9 [json_name = "stateVector"];
  bool has_state_vector() const;
  private:
  bool _internal_has_state_vector() const;

  public:
  void clear_state_vector() ;
  const ::aalyria::spacetime::api::common::StateVector& state_vector() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::StateVector* release_state_vector();
  ::aalyria::spacetime::api::common::StateVector* mutable_state_vector();
  void set_allocated_state_vector(::aalyria::spacetime::api::common::StateVector* state_vector);
  private:
  const ::aalyria::spacetime::api::common::StateVector& _internal_state_vector() const;
  ::aalyria::spacetime::api::common::StateVector* _internal_mutable_state_vector();
  public:
  void unsafe_arena_set_allocated_state_vector(
      ::aalyria::spacetime::api::common::StateVector* state_vector);
  ::aalyria::spacetime::api::common::StateVector* unsafe_arena_release_state_vector();
  // .aalyria.spacetime.api.common.SelenographicMlr selenographic_mlr = 8 [json_name = "selenographicMlr"];
  bool has_selenographic_mlr() const;
  private:
  bool _internal_has_selenographic_mlr() const;

  public:
  void clear_selenographic_mlr() ;
  const ::aalyria::spacetime::api::common::SelenographicMlr& selenographic_mlr() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::SelenographicMlr* release_selenographic_mlr();
  ::aalyria::spacetime::api::common::SelenographicMlr* mutable_selenographic_mlr();
  void set_allocated_selenographic_mlr(::aalyria::spacetime::api::common::SelenographicMlr* selenographic_mlr);
  private:
  const ::aalyria::spacetime::api::common::SelenographicMlr& _internal_selenographic_mlr() const;
  ::aalyria::spacetime::api::common::SelenographicMlr* _internal_mutable_selenographic_mlr();
  public:
  void unsafe_arena_set_allocated_selenographic_mlr(
      ::aalyria::spacetime::api::common::SelenographicMlr* selenographic_mlr);
  ::aalyria::spacetime::api::common::SelenographicMlr* unsafe_arena_release_selenographic_mlr();
  // .aalyria.spacetime.api.common.StkEphemAndAttitudeFile stk_ephem_and_attitude_file = 11 [json_name = "stkEphemAndAttitudeFile"];
  bool has_stk_ephem_and_attitude_file() const;
  private:
  bool _internal_has_stk_ephem_and_attitude_file() const;

  public:
  void clear_stk_ephem_and_attitude_file() ;
  const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile& stk_ephem_and_attitude_file() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* release_stk_ephem_and_attitude_file();
  ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* mutable_stk_ephem_and_attitude_file();
  void set_allocated_stk_ephem_and_attitude_file(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* stk_ephem_and_attitude_file);
  private:
  const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile& _internal_stk_ephem_and_attitude_file() const;
  ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* _internal_mutable_stk_ephem_and_attitude_file();
  public:
  void unsafe_arena_set_allocated_stk_ephem_and_attitude_file(
      ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* stk_ephem_and_attitude_file);
  ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* unsafe_arena_release_stk_ephem_and_attitude_file();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Motion)
 private:
  class _Internal;
  void set_has_geodetic_msl();
  void set_has_geodetic_wgs84();
  void set_has_ecef_fixed();
  void set_has_ecef_interpolation();
  void set_has_cartographic_waypoints();
  void set_has_tle();
  void set_has_keplerian_elements();
  void set_has_state_vector();
  void set_has_selenographic_mlr();
  void set_has_stk_ephem_and_attitude_file();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::google::type::Interval* interval_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::GeodeticMsl* geodetic_msl_;
      ::aalyria::spacetime::api::common::GeodeticWgs84* geodetic_wgs84_;
      ::aalyria::spacetime::api::common::PointAxes* ecef_fixed_;
      ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* ecef_interpolation_;
      ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* cartographic_waypoints_;
      ::aalyria::spacetime::api::common::TwoLineElementSet* tle_;
      ::aalyria::spacetime::api::common::KeplerianElements* keplerian_elements_;
      ::aalyria::spacetime::api::common::StateVector* state_vector_;
      ::aalyria::spacetime::api::common::SelenographicMlr* selenographic_mlr_;
      ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* stk_ephem_and_attitude_file_;
    } type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};// -------------------------------------------------------------------

class MotionDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.MotionDefinition) */ {
 public:
  inline MotionDefinition() : MotionDefinition(nullptr) {}
  ~MotionDefinition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotionDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionDefinition(const MotionDefinition& from);
  MotionDefinition(MotionDefinition&& from) noexcept
    : MotionDefinition() {
    *this = ::std::move(from);
  }

  inline MotionDefinition& operator=(const MotionDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionDefinition& operator=(MotionDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionDefinition* internal_default_instance() {
    return reinterpret_cast<const MotionDefinition*>(
               &_MotionDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MotionDefinition& a, MotionDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionDefinition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotionDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotionDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotionDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MotionDefinition& from) {
    MotionDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.MotionDefinition";
  }
  protected:
  explicit MotionDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionsFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.common.Motion motions = 1 [json_name = "motions"];
  int motions_size() const;
  private:
  int _internal_motions_size() const;

  public:
  void clear_motions() ;
  ::aalyria::spacetime::api::common::Motion* mutable_motions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Motion >*
      mutable_motions();
  private:
  const ::aalyria::spacetime::api::common::Motion& _internal_motions(int index) const;
  ::aalyria::spacetime::api::common::Motion* _internal_add_motions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Motion>& _internal_motions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Motion>* _internal_mutable_motions();
  public:
  const ::aalyria::spacetime::api::common::Motion& motions(int index) const;
  ::aalyria::spacetime::api::common::Motion* add_motions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Motion >&
      motions() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.MotionDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Motion > motions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcoordinates_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GeodeticWgs84

// optional double longitude_deg = 1 [json_name = "longitudeDeg"];
inline bool GeodeticWgs84::has_longitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeodeticWgs84::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double GeodeticWgs84::longitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84.longitude_deg)
  return _internal_longitude_deg();
}
inline void GeodeticWgs84::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticWgs84.longitude_deg)
}
inline double GeodeticWgs84::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline void GeodeticWgs84::_internal_set_longitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_deg_ = value;
}

// optional double latitude_deg = 2 [json_name = "latitudeDeg"];
inline bool GeodeticWgs84::has_latitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GeodeticWgs84::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double GeodeticWgs84::latitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84.latitude_deg)
  return _internal_latitude_deg();
}
inline void GeodeticWgs84::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticWgs84.latitude_deg)
}
inline double GeodeticWgs84::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline void GeodeticWgs84::_internal_set_latitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_deg_ = value;
}

// optional double height_wgs84_m = 3 [json_name = "heightWgs84M"];
inline bool GeodeticWgs84::has_height_wgs84_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GeodeticWgs84::clear_height_wgs84_m() {
  _impl_.height_wgs84_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double GeodeticWgs84::height_wgs84_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84.height_wgs84_m)
  return _internal_height_wgs84_m();
}
inline void GeodeticWgs84::set_height_wgs84_m(double value) {
  _internal_set_height_wgs84_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticWgs84.height_wgs84_m)
}
inline double GeodeticWgs84::_internal_height_wgs84_m() const {
  return _impl_.height_wgs84_m_;
}
inline void GeodeticWgs84::_internal_set_height_wgs84_m(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_wgs84_m_ = value;
}

// -------------------------------------------------------------------

// GeodeticMsl

// optional double longitude_deg = 1 [json_name = "longitudeDeg"];
inline bool GeodeticMsl::has_longitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeodeticMsl::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double GeodeticMsl::longitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticMsl.longitude_deg)
  return _internal_longitude_deg();
}
inline void GeodeticMsl::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticMsl.longitude_deg)
}
inline double GeodeticMsl::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline void GeodeticMsl::_internal_set_longitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_deg_ = value;
}

// optional double latitude_deg = 2 [json_name = "latitudeDeg"];
inline bool GeodeticMsl::has_latitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GeodeticMsl::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double GeodeticMsl::latitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticMsl.latitude_deg)
  return _internal_latitude_deg();
}
inline void GeodeticMsl::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticMsl.latitude_deg)
}
inline double GeodeticMsl::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline void GeodeticMsl::_internal_set_latitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_deg_ = value;
}

// optional double height_msl_m = 3 [json_name = "heightMslM"];
inline bool GeodeticMsl::has_height_msl_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GeodeticMsl::clear_height_msl_m() {
  _impl_.height_msl_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double GeodeticMsl::height_msl_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticMsl.height_msl_m)
  return _internal_height_msl_m();
}
inline void GeodeticMsl::set_height_msl_m(double value) {
  _internal_set_height_msl_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticMsl.height_msl_m)
}
inline double GeodeticMsl::_internal_height_msl_m() const {
  return _impl_.height_msl_m_;
}
inline void GeodeticMsl::_internal_set_height_msl_m(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_msl_m_ = value;
}

// -------------------------------------------------------------------

// S2Cells

// repeated uint64 ids = 1 [json_name = "ids"];
inline int S2Cells::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int S2Cells::ids_size() const {
  return _internal_ids_size();
}
inline void S2Cells::clear_ids() {
  _internal_mutable_ids()->Clear();
}
inline ::uint64_t S2Cells::ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.S2Cells.ids)
  return _internal_ids(index);
}
inline void S2Cells::set_ids(int index, ::uint64_t value) {
  _internal_mutable_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.S2Cells.ids)
}
inline void S2Cells::add_ids(::uint64_t value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.S2Cells.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& S2Cells::ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.S2Cells.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* S2Cells::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.S2Cells.ids)
  return _internal_mutable_ids();
}

inline ::uint64_t S2Cells::_internal_ids(int index) const {
  return _internal_ids().Get(index);
}
inline void S2Cells::_internal_add_ids(::uint64_t value) {
  _internal_mutable_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& S2Cells::_internal_ids() const {
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* S2Cells::_internal_mutable_ids() {
  return &_impl_.ids_;
}

// -------------------------------------------------------------------

// Cartesian

// required double x_m = 1 [json_name = "xM"];
inline bool Cartesian::has_x_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Cartesian::clear_x_m() {
  _impl_.x_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Cartesian::x_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Cartesian.x_m)
  return _internal_x_m();
}
inline void Cartesian::set_x_m(double value) {
  _internal_set_x_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Cartesian.x_m)
}
inline double Cartesian::_internal_x_m() const {
  return _impl_.x_m_;
}
inline void Cartesian::_internal_set_x_m(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_m_ = value;
}

// required double y_m = 2 [json_name = "yM"];
inline bool Cartesian::has_y_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Cartesian::clear_y_m() {
  _impl_.y_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Cartesian::y_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Cartesian.y_m)
  return _internal_y_m();
}
inline void Cartesian::set_y_m(double value) {
  _internal_set_y_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Cartesian.y_m)
}
inline double Cartesian::_internal_y_m() const {
  return _impl_.y_m_;
}
inline void Cartesian::_internal_set_y_m(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_m_ = value;
}

// required double z_m = 3 [json_name = "zM"];
inline bool Cartesian::has_z_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Cartesian::clear_z_m() {
  _impl_.z_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Cartesian::z_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Cartesian.z_m)
  return _internal_z_m();
}
inline void Cartesian::set_z_m(double value) {
  _internal_set_z_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Cartesian.z_m)
}
inline double Cartesian::_internal_z_m() const {
  return _impl_.z_m_;
}
inline void Cartesian::_internal_set_z_m(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_m_ = value;
}

// -------------------------------------------------------------------

// CartesianDot

// required double x_mps = 1 [json_name = "xMps"];
inline bool CartesianDot::has_x_mps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CartesianDot::clear_x_mps() {
  _impl_.x_mps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double CartesianDot::x_mps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.CartesianDot.x_mps)
  return _internal_x_mps();
}
inline void CartesianDot::set_x_mps(double value) {
  _internal_set_x_mps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.CartesianDot.x_mps)
}
inline double CartesianDot::_internal_x_mps() const {
  return _impl_.x_mps_;
}
inline void CartesianDot::_internal_set_x_mps(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_mps_ = value;
}

// required double y_mps = 2 [json_name = "yMps"];
inline bool CartesianDot::has_y_mps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CartesianDot::clear_y_mps() {
  _impl_.y_mps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double CartesianDot::y_mps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.CartesianDot.y_mps)
  return _internal_y_mps();
}
inline void CartesianDot::set_y_mps(double value) {
  _internal_set_y_mps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.CartesianDot.y_mps)
}
inline double CartesianDot::_internal_y_mps() const {
  return _impl_.y_mps_;
}
inline void CartesianDot::_internal_set_y_mps(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_mps_ = value;
}

// required double z_mps = 3 [json_name = "zMps"];
inline bool CartesianDot::has_z_mps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CartesianDot::clear_z_mps() {
  _impl_.z_mps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CartesianDot::z_mps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.CartesianDot.z_mps)
  return _internal_z_mps();
}
inline void CartesianDot::set_z_mps(double value) {
  _internal_set_z_mps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.CartesianDot.z_mps)
}
inline double CartesianDot::_internal_z_mps() const {
  return _impl_.z_mps_;
}
inline void CartesianDot::_internal_set_z_mps(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_mps_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// required double w = 1 [json_name = "w"];
inline bool Quaternion::has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Quaternion.w)
}
inline double Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline void Quaternion::_internal_set_w(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.w_ = value;
}

// required double x = 2 [json_name = "x"];
inline bool Quaternion::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Quaternion.x)
}
inline double Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline void Quaternion::_internal_set_x(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}

// required double y = 3 [json_name = "y"];
inline bool Quaternion::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Quaternion.y)
}
inline double Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline void Quaternion::_internal_set_y(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}

// required double z = 4 [json_name = "z"];
inline bool Quaternion::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Quaternion.z)
}
inline double Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline void Quaternion::_internal_set_z(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// YawPitchRoll

// required double yaw_deg = 1 [json_name = "yawDeg"];
inline bool YawPitchRoll::has_yaw_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void YawPitchRoll::clear_yaw_deg() {
  _impl_.yaw_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double YawPitchRoll::yaw_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.YawPitchRoll.yaw_deg)
  return _internal_yaw_deg();
}
inline void YawPitchRoll::set_yaw_deg(double value) {
  _internal_set_yaw_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.YawPitchRoll.yaw_deg)
}
inline double YawPitchRoll::_internal_yaw_deg() const {
  return _impl_.yaw_deg_;
}
inline void YawPitchRoll::_internal_set_yaw_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.yaw_deg_ = value;
}

// required double pitch_deg = 2 [json_name = "pitchDeg"];
inline bool YawPitchRoll::has_pitch_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void YawPitchRoll::clear_pitch_deg() {
  _impl_.pitch_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double YawPitchRoll::pitch_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.YawPitchRoll.pitch_deg)
  return _internal_pitch_deg();
}
inline void YawPitchRoll::set_pitch_deg(double value) {
  _internal_set_pitch_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.YawPitchRoll.pitch_deg)
}
inline double YawPitchRoll::_internal_pitch_deg() const {
  return _impl_.pitch_deg_;
}
inline void YawPitchRoll::_internal_set_pitch_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pitch_deg_ = value;
}

// required double roll_deg = 3 [json_name = "rollDeg"];
inline bool YawPitchRoll::has_roll_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void YawPitchRoll::clear_roll_deg() {
  _impl_.roll_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double YawPitchRoll::roll_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.YawPitchRoll.roll_deg)
  return _internal_roll_deg();
}
inline void YawPitchRoll::set_roll_deg(double value) {
  _internal_set_roll_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.YawPitchRoll.roll_deg)
}
inline double YawPitchRoll::_internal_roll_deg() const {
  return _impl_.roll_deg_;
}
inline void YawPitchRoll::_internal_set_roll_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.roll_deg_ = value;
}

// -------------------------------------------------------------------

// PointingVector

// optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
inline bool PointingVector::has_azimuth_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PointingVector::clear_azimuth_deg() {
  _impl_.azimuth_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PointingVector::azimuth_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointingVector.azimuth_deg)
  return _internal_azimuth_deg();
}
inline void PointingVector::set_azimuth_deg(double value) {
  _internal_set_azimuth_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PointingVector.azimuth_deg)
}
inline double PointingVector::_internal_azimuth_deg() const {
  return _impl_.azimuth_deg_;
}
inline void PointingVector::_internal_set_azimuth_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.azimuth_deg_ = value;
}

// optional double elevation_deg = 2 [json_name = "elevationDeg"];
inline bool PointingVector::has_elevation_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PointingVector::clear_elevation_deg() {
  _impl_.elevation_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PointingVector::elevation_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointingVector.elevation_deg)
  return _internal_elevation_deg();
}
inline void PointingVector::set_elevation_deg(double value) {
  _internal_set_elevation_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PointingVector.elevation_deg)
}
inline double PointingVector::_internal_elevation_deg() const {
  return _impl_.elevation_deg_;
}
inline void PointingVector::_internal_set_elevation_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.elevation_deg_ = value;
}

// -------------------------------------------------------------------

// PointAxes

// optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
inline bool PointAxes::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void PointAxes::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::Cartesian& PointAxes::_internal_point() const {
  const ::aalyria::spacetime::api::common::Cartesian* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Cartesian&>(
      ::aalyria::spacetime::api::common::_Cartesian_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Cartesian& PointAxes::point() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxes.point)
  return _internal_point();
}
inline void PointAxes::unsafe_arena_set_allocated_point(
    ::aalyria::spacetime::api::common::Cartesian* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxes.point)
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxes::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxes::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxes.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxes::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Cartesian>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxes::mutable_point() {
  ::aalyria::spacetime::api::common::Cartesian* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxes.point)
  return _msg;
}
inline void PointAxes::set_allocated_point(::aalyria::spacetime::api::common::Cartesian* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxes.point)
}

// optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
inline bool PointAxes::has_axes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.axes_ != nullptr);
  return value;
}
inline void PointAxes::clear_axes() {
  if (_impl_.axes_ != nullptr) _impl_.axes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::Quaternion& PointAxes::_internal_axes() const {
  const ::aalyria::spacetime::api::common::Quaternion* p = _impl_.axes_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Quaternion&>(
      ::aalyria::spacetime::api::common::_Quaternion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Quaternion& PointAxes::axes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxes.axes)
  return _internal_axes();
}
inline void PointAxes::unsafe_arena_set_allocated_axes(
    ::aalyria::spacetime::api::common::Quaternion* axes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axes_);
  }
  _impl_.axes_ = axes;
  if (axes) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxes.axes)
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxes::release_axes() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.axes_;
  _impl_.axes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxes::unsafe_arena_release_axes() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxes.axes)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.axes_;
  _impl_.axes_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxes::_internal_mutable_axes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.axes_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Quaternion>(GetArenaForAllocation());
    _impl_.axes_ = p;
  }
  return _impl_.axes_;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxes::mutable_axes() {
  ::aalyria::spacetime::api::common::Quaternion* _msg = _internal_mutable_axes();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxes.axes)
  return _msg;
}
inline void PointAxes::set_allocated_axes(::aalyria::spacetime::api::common::Quaternion* axes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.axes_;
  }
  if (axes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(axes);
    if (message_arena != submessage_arena) {
      axes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.axes_ = axes;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxes.axes)
}

// -------------------------------------------------------------------

// PointAxesTemporal

// optional .aalyria.spacetime.api.common.Cartesian point = 1 [json_name = "point"];
inline bool PointAxesTemporal::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void PointAxesTemporal::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::Cartesian& PointAxesTemporal::_internal_point() const {
  const ::aalyria::spacetime::api::common::Cartesian* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Cartesian&>(
      ::aalyria::spacetime::api::common::_Cartesian_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Cartesian& PointAxesTemporal::point() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporal.point)
  return _internal_point();
}
inline void PointAxesTemporal::unsafe_arena_set_allocated_point(
    ::aalyria::spacetime::api::common::Cartesian* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.point)
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxesTemporal::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxesTemporal::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxesTemporal.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxesTemporal::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Cartesian>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::aalyria::spacetime::api::common::Cartesian* PointAxesTemporal::mutable_point() {
  ::aalyria::spacetime::api::common::Cartesian* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxesTemporal.point)
  return _msg;
}
inline void PointAxesTemporal::set_allocated_point(::aalyria::spacetime::api::common::Cartesian* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.point)
}

// optional .aalyria.spacetime.api.common.Quaternion axes = 2 [json_name = "axes"];
inline bool PointAxesTemporal::has_axes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.axes_ != nullptr);
  return value;
}
inline void PointAxesTemporal::clear_axes() {
  if (_impl_.axes_ != nullptr) _impl_.axes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::Quaternion& PointAxesTemporal::_internal_axes() const {
  const ::aalyria::spacetime::api::common::Quaternion* p = _impl_.axes_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Quaternion&>(
      ::aalyria::spacetime::api::common::_Quaternion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Quaternion& PointAxesTemporal::axes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporal.axes)
  return _internal_axes();
}
inline void PointAxesTemporal::unsafe_arena_set_allocated_axes(
    ::aalyria::spacetime::api::common::Quaternion* axes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axes_);
  }
  _impl_.axes_ = axes;
  if (axes) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.axes)
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxesTemporal::release_axes() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.axes_;
  _impl_.axes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxesTemporal::unsafe_arena_release_axes() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxesTemporal.axes)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Quaternion* temp = _impl_.axes_;
  _impl_.axes_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxesTemporal::_internal_mutable_axes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.axes_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Quaternion>(GetArenaForAllocation());
    _impl_.axes_ = p;
  }
  return _impl_.axes_;
}
inline ::aalyria::spacetime::api::common::Quaternion* PointAxesTemporal::mutable_axes() {
  ::aalyria::spacetime::api::common::Quaternion* _msg = _internal_mutable_axes();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxesTemporal.axes)
  return _msg;
}
inline void PointAxesTemporal::set_allocated_axes(::aalyria::spacetime::api::common::Quaternion* axes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.axes_;
  }
  if (axes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(axes);
    if (message_arena != submessage_arena) {
      axes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.axes_ = axes;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.axes)
}

// optional .aalyria.spacetime.api.common.GpsTime gps_time = 4 [json_name = "gpsTime"];
inline bool PointAxesTemporal::has_gps_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gps_time_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::GpsTime& PointAxesTemporal::_internal_gps_time() const {
  const ::aalyria::spacetime::api::common::GpsTime* p = _impl_.gps_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::GpsTime&>(
      ::aalyria::spacetime::api::common::_GpsTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GpsTime& PointAxesTemporal::gps_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporal.gps_time)
  return _internal_gps_time();
}
inline void PointAxesTemporal::unsafe_arena_set_allocated_gps_time(
    ::aalyria::spacetime::api::common::GpsTime* gps_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gps_time_);
  }
  _impl_.gps_time_ = gps_time;
  if (gps_time) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.gps_time)
}
inline ::aalyria::spacetime::api::common::GpsTime* PointAxesTemporal::release_gps_time() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::GpsTime* temp = _impl_.gps_time_;
  _impl_.gps_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::GpsTime* PointAxesTemporal::unsafe_arena_release_gps_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxesTemporal.gps_time)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::GpsTime* temp = _impl_.gps_time_;
  _impl_.gps_time_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::GpsTime* PointAxesTemporal::_internal_mutable_gps_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.gps_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::GpsTime>(GetArenaForAllocation());
    _impl_.gps_time_ = p;
  }
  return _impl_.gps_time_;
}
inline ::aalyria::spacetime::api::common::GpsTime* PointAxesTemporal::mutable_gps_time() {
  ::aalyria::spacetime::api::common::GpsTime* _msg = _internal_mutable_gps_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxesTemporal.gps_time)
  return _msg;
}
inline void PointAxesTemporal::set_allocated_gps_time(::aalyria::spacetime::api::common::GpsTime* gps_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gps_time_);
  }
  if (gps_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gps_time));
    if (message_arena != submessage_arena) {
      gps_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gps_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gps_time_ = gps_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.gps_time)
}

// optional .google.protobuf.Timestamp time = 5 [json_name = "time"];
inline bool PointAxesTemporal::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PointAxesTemporal::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PointAxesTemporal::time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporal.time)
  return _internal_time();
}
inline void PointAxesTemporal::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PointAxesTemporal::release_time() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PointAxesTemporal::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PointAxesTemporal.time)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PointAxesTemporal::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PointAxesTemporal::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxesTemporal.time)
  return _msg;
}
inline void PointAxesTemporal::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PointAxesTemporal.time)
}

// -------------------------------------------------------------------

// GeodeticWgs84Temporal

// optional .aalyria.spacetime.api.common.GeodeticWgs84 point = 1 [json_name = "point"];
inline bool GeodeticWgs84Temporal::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void GeodeticWgs84Temporal::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& GeodeticWgs84Temporal::_internal_point() const {
  const ::aalyria::spacetime::api::common::GeodeticWgs84* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::GeodeticWgs84&>(
      ::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& GeodeticWgs84Temporal::point() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84Temporal.point)
  return _internal_point();
}
inline void GeodeticWgs84Temporal::unsafe_arena_set_allocated_point(
    ::aalyria::spacetime::api::common::GeodeticWgs84* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.GeodeticWgs84Temporal.point)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* GeodeticWgs84Temporal::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* GeodeticWgs84Temporal::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.GeodeticWgs84Temporal.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* GeodeticWgs84Temporal::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* GeodeticWgs84Temporal::mutable_point() {
  ::aalyria::spacetime::api::common::GeodeticWgs84* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.GeodeticWgs84Temporal.point)
  return _msg;
}
inline void GeodeticWgs84Temporal::set_allocated_point(::aalyria::spacetime::api::common::GeodeticWgs84* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.GeodeticWgs84Temporal.point)
}

// optional .google.protobuf.Timestamp time = 2 [json_name = "time"];
inline bool GeodeticWgs84Temporal::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GeodeticWgs84Temporal::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GeodeticWgs84Temporal::time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84Temporal.time)
  return _internal_time();
}
inline void GeodeticWgs84Temporal::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.GeodeticWgs84Temporal.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GeodeticWgs84Temporal::release_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GeodeticWgs84Temporal::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.GeodeticWgs84Temporal.time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GeodeticWgs84Temporal::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GeodeticWgs84Temporal::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.GeodeticWgs84Temporal.time)
  return _msg;
}
inline void GeodeticWgs84Temporal::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.GeodeticWgs84Temporal.time)
}

// -------------------------------------------------------------------

// PointAxesTemporalInterpolation

// repeated .aalyria.spacetime.api.common.PointAxesTemporal locations_orientations_over_time = 1 [json_name = "locationsOrientationsOverTime"];
inline int PointAxesTemporalInterpolation::_internal_locations_orientations_over_time_size() const {
  return _impl_.locations_orientations_over_time_.size();
}
inline int PointAxesTemporalInterpolation::locations_orientations_over_time_size() const {
  return _internal_locations_orientations_over_time_size();
}
inline void PointAxesTemporalInterpolation::clear_locations_orientations_over_time() {
  _internal_mutable_locations_orientations_over_time()->Clear();
}
inline ::aalyria::spacetime::api::common::PointAxesTemporal* PointAxesTemporalInterpolation::mutable_locations_orientations_over_time(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time)
  return _internal_mutable_locations_orientations_over_time()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointAxesTemporal >*
PointAxesTemporalInterpolation::mutable_locations_orientations_over_time() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time)
  return _internal_mutable_locations_orientations_over_time();
}
inline const ::aalyria::spacetime::api::common::PointAxesTemporal& PointAxesTemporalInterpolation::_internal_locations_orientations_over_time(int index) const {
  return _internal_locations_orientations_over_time().Get(index);
}
inline const ::aalyria::spacetime::api::common::PointAxesTemporal& PointAxesTemporalInterpolation::locations_orientations_over_time(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time)
  return _internal_locations_orientations_over_time(index);
}
inline ::aalyria::spacetime::api::common::PointAxesTemporal* PointAxesTemporalInterpolation::_internal_add_locations_orientations_over_time() {
  return _internal_mutable_locations_orientations_over_time()->Add();
}
inline ::aalyria::spacetime::api::common::PointAxesTemporal* PointAxesTemporalInterpolation::add_locations_orientations_over_time() {
  ::aalyria::spacetime::api::common::PointAxesTemporal* _add = _internal_add_locations_orientations_over_time();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PointAxesTemporal >&
PointAxesTemporalInterpolation::locations_orientations_over_time() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time)
  return _internal_locations_orientations_over_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointAxesTemporal>&
PointAxesTemporalInterpolation::_internal_locations_orientations_over_time() const {
  return _impl_.locations_orientations_over_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PointAxesTemporal>*
PointAxesTemporalInterpolation::_internal_mutable_locations_orientations_over_time() {
  return &_impl_.locations_orientations_over_time_;
}

// optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
inline bool PointAxesTemporalInterpolation::has_interpolation_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PointAxesTemporalInterpolation::clear_interpolation_method() {
  _impl_.interpolation_method_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::aalyria::spacetime::api::common::InterpolationMethod PointAxesTemporalInterpolation::interpolation_method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.interpolation_method)
  return _internal_interpolation_method();
}
inline void PointAxesTemporalInterpolation::set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value) {
   _internal_set_interpolation_method(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.interpolation_method)
}
inline ::aalyria::spacetime::api::common::InterpolationMethod PointAxesTemporalInterpolation::_internal_interpolation_method() const {
  return static_cast<::aalyria::spacetime::api::common::InterpolationMethod>(_impl_.interpolation_method_);
}
inline void PointAxesTemporalInterpolation::_internal_set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value) {
  assert(::aalyria::spacetime::api::common::InterpolationMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interpolation_method_ = value;
}

// optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
inline bool PointAxesTemporalInterpolation::has_interpolation_degree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PointAxesTemporalInterpolation::clear_interpolation_degree() {
  _impl_.interpolation_degree_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t PointAxesTemporalInterpolation::interpolation_degree() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.interpolation_degree)
  return _internal_interpolation_degree();
}
inline void PointAxesTemporalInterpolation::set_interpolation_degree(::int32_t value) {
  _internal_set_interpolation_degree(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PointAxesTemporalInterpolation.interpolation_degree)
}
inline ::int32_t PointAxesTemporalInterpolation::_internal_interpolation_degree() const {
  return _impl_.interpolation_degree_;
}
inline void PointAxesTemporalInterpolation::_internal_set_interpolation_degree(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interpolation_degree_ = value;
}

// -------------------------------------------------------------------

// GeodeticWgs84TemporalInterpolation

// repeated .aalyria.spacetime.api.common.GeodeticWgs84Temporal locations_over_time = 1 [json_name = "locationsOverTime"];
inline int GeodeticWgs84TemporalInterpolation::_internal_locations_over_time_size() const {
  return _impl_.locations_over_time_.size();
}
inline int GeodeticWgs84TemporalInterpolation::locations_over_time_size() const {
  return _internal_locations_over_time_size();
}
inline void GeodeticWgs84TemporalInterpolation::clear_locations_over_time() {
  _internal_mutable_locations_over_time()->Clear();
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* GeodeticWgs84TemporalInterpolation::mutable_locations_over_time(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time)
  return _internal_mutable_locations_over_time()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >*
GeodeticWgs84TemporalInterpolation::mutable_locations_over_time() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time)
  return _internal_mutable_locations_over_time();
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84Temporal& GeodeticWgs84TemporalInterpolation::_internal_locations_over_time(int index) const {
  return _internal_locations_over_time().Get(index);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84Temporal& GeodeticWgs84TemporalInterpolation::locations_over_time(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time)
  return _internal_locations_over_time(index);
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* GeodeticWgs84TemporalInterpolation::_internal_add_locations_over_time() {
  return _internal_mutable_locations_over_time()->Add();
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* GeodeticWgs84TemporalInterpolation::add_locations_over_time() {
  ::aalyria::spacetime::api::common::GeodeticWgs84Temporal* _add = _internal_add_locations_over_time();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::GeodeticWgs84Temporal >&
GeodeticWgs84TemporalInterpolation::locations_over_time() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time)
  return _internal_locations_over_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::GeodeticWgs84Temporal>&
GeodeticWgs84TemporalInterpolation::_internal_locations_over_time() const {
  return _impl_.locations_over_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::GeodeticWgs84Temporal>*
GeodeticWgs84TemporalInterpolation::_internal_mutable_locations_over_time() {
  return &_impl_.locations_over_time_;
}

// optional .aalyria.spacetime.api.common.InterpolationMethod interpolation_method = 2 [default = LINEAR, json_name = "interpolationMethod"];
inline bool GeodeticWgs84TemporalInterpolation::has_interpolation_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeodeticWgs84TemporalInterpolation::clear_interpolation_method() {
  _impl_.interpolation_method_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::aalyria::spacetime::api::common::InterpolationMethod GeodeticWgs84TemporalInterpolation::interpolation_method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.interpolation_method)
  return _internal_interpolation_method();
}
inline void GeodeticWgs84TemporalInterpolation::set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value) {
   _internal_set_interpolation_method(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.interpolation_method)
}
inline ::aalyria::spacetime::api::common::InterpolationMethod GeodeticWgs84TemporalInterpolation::_internal_interpolation_method() const {
  return static_cast<::aalyria::spacetime::api::common::InterpolationMethod>(_impl_.interpolation_method_);
}
inline void GeodeticWgs84TemporalInterpolation::_internal_set_interpolation_method(::aalyria::spacetime::api::common::InterpolationMethod value) {
  assert(::aalyria::spacetime::api::common::InterpolationMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interpolation_method_ = value;
}

// optional int32 interpolation_degree = 3 [default = 1, json_name = "interpolationDegree"];
inline bool GeodeticWgs84TemporalInterpolation::has_interpolation_degree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GeodeticWgs84TemporalInterpolation::clear_interpolation_degree() {
  _impl_.interpolation_degree_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GeodeticWgs84TemporalInterpolation::interpolation_degree() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.interpolation_degree)
  return _internal_interpolation_degree();
}
inline void GeodeticWgs84TemporalInterpolation::set_interpolation_degree(::int32_t value) {
  _internal_set_interpolation_degree(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.interpolation_degree)
}
inline ::int32_t GeodeticWgs84TemporalInterpolation::_internal_interpolation_degree() const {
  return _impl_.interpolation_degree_;
}
inline void GeodeticWgs84TemporalInterpolation::_internal_set_interpolation_degree(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interpolation_degree_ = value;
}

// -------------------------------------------------------------------

// TwoLineElementSet

// optional string line1 = 1 [json_name = "line1"];
inline bool TwoLineElementSet::has_line1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TwoLineElementSet::clear_line1() {
  _impl_.line1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TwoLineElementSet::line1() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TwoLineElementSet.line1)
  return _internal_line1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TwoLineElementSet::set_line1(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.line1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TwoLineElementSet.line1)
}
inline std::string* TwoLineElementSet::mutable_line1() {
  std::string* _s = _internal_mutable_line1();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TwoLineElementSet.line1)
  return _s;
}
inline const std::string& TwoLineElementSet::_internal_line1() const {
  return _impl_.line1_.Get();
}
inline void TwoLineElementSet::_internal_set_line1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.line1_.Set(value, GetArenaForAllocation());
}
inline std::string* TwoLineElementSet::_internal_mutable_line1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.line1_.Mutable( GetArenaForAllocation());
}
inline std::string* TwoLineElementSet::release_line1() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TwoLineElementSet.line1)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.line1_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.line1_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TwoLineElementSet::set_allocated_line1(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.line1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.line1_.IsDefault()) {
          _impl_.line1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TwoLineElementSet.line1)
}

// optional string line2 = 2 [json_name = "line2"];
inline bool TwoLineElementSet::has_line2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TwoLineElementSet::clear_line2() {
  _impl_.line2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TwoLineElementSet::line2() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.TwoLineElementSet.line2)
  return _internal_line2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TwoLineElementSet::set_line2(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.line2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.TwoLineElementSet.line2)
}
inline std::string* TwoLineElementSet::mutable_line2() {
  std::string* _s = _internal_mutable_line2();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.TwoLineElementSet.line2)
  return _s;
}
inline const std::string& TwoLineElementSet::_internal_line2() const {
  return _impl_.line2_.Get();
}
inline void TwoLineElementSet::_internal_set_line2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.line2_.Set(value, GetArenaForAllocation());
}
inline std::string* TwoLineElementSet::_internal_mutable_line2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.line2_.Mutable( GetArenaForAllocation());
}
inline std::string* TwoLineElementSet::release_line2() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.TwoLineElementSet.line2)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.line2_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.line2_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TwoLineElementSet::set_allocated_line2(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.line2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.line2_.IsDefault()) {
          _impl_.line2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.TwoLineElementSet.line2)
}

// -------------------------------------------------------------------

// KeplerianElements

// optional double semimajor_axis_m = 1 [json_name = "semimajorAxisM"];
inline bool KeplerianElements::has_semimajor_axis_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeplerianElements::clear_semimajor_axis_m() {
  _impl_.semimajor_axis_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double KeplerianElements::semimajor_axis_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.semimajor_axis_m)
  return _internal_semimajor_axis_m();
}
inline void KeplerianElements::set_semimajor_axis_m(double value) {
  _internal_set_semimajor_axis_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.semimajor_axis_m)
}
inline double KeplerianElements::_internal_semimajor_axis_m() const {
  return _impl_.semimajor_axis_m_;
}
inline void KeplerianElements::_internal_set_semimajor_axis_m(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.semimajor_axis_m_ = value;
}

// optional double eccentricity = 2 [json_name = "eccentricity"];
inline bool KeplerianElements::has_eccentricity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KeplerianElements::clear_eccentricity() {
  _impl_.eccentricity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double KeplerianElements::eccentricity() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.eccentricity)
  return _internal_eccentricity();
}
inline void KeplerianElements::set_eccentricity(double value) {
  _internal_set_eccentricity(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.eccentricity)
}
inline double KeplerianElements::_internal_eccentricity() const {
  return _impl_.eccentricity_;
}
inline void KeplerianElements::_internal_set_eccentricity(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.eccentricity_ = value;
}

// optional double inclination_deg = 3 [json_name = "inclinationDeg"];
inline bool KeplerianElements::has_inclination_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KeplerianElements::clear_inclination_deg() {
  _impl_.inclination_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double KeplerianElements::inclination_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.inclination_deg)
  return _internal_inclination_deg();
}
inline void KeplerianElements::set_inclination_deg(double value) {
  _internal_set_inclination_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.inclination_deg)
}
inline double KeplerianElements::_internal_inclination_deg() const {
  return _impl_.inclination_deg_;
}
inline void KeplerianElements::_internal_set_inclination_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.inclination_deg_ = value;
}

// optional double argument_of_periapsis_deg = 4 [json_name = "argumentOfPeriapsisDeg"];
inline bool KeplerianElements::has_argument_of_periapsis_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KeplerianElements::clear_argument_of_periapsis_deg() {
  _impl_.argument_of_periapsis_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double KeplerianElements::argument_of_periapsis_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.argument_of_periapsis_deg)
  return _internal_argument_of_periapsis_deg();
}
inline void KeplerianElements::set_argument_of_periapsis_deg(double value) {
  _internal_set_argument_of_periapsis_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.argument_of_periapsis_deg)
}
inline double KeplerianElements::_internal_argument_of_periapsis_deg() const {
  return _impl_.argument_of_periapsis_deg_;
}
inline void KeplerianElements::_internal_set_argument_of_periapsis_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.argument_of_periapsis_deg_ = value;
}

// optional double raan_deg = 5 [json_name = "raanDeg"];
inline bool KeplerianElements::has_raan_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void KeplerianElements::clear_raan_deg() {
  _impl_.raan_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double KeplerianElements::raan_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.raan_deg)
  return _internal_raan_deg();
}
inline void KeplerianElements::set_raan_deg(double value) {
  _internal_set_raan_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.raan_deg)
}
inline double KeplerianElements::_internal_raan_deg() const {
  return _impl_.raan_deg_;
}
inline void KeplerianElements::_internal_set_raan_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.raan_deg_ = value;
}

// optional double true_anomaly_deg = 6 [json_name = "trueAnomalyDeg"];
inline bool KeplerianElements::has_true_anomaly_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void KeplerianElements::clear_true_anomaly_deg() {
  _impl_.true_anomaly_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double KeplerianElements::true_anomaly_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.true_anomaly_deg)
  return _internal_true_anomaly_deg();
}
inline void KeplerianElements::set_true_anomaly_deg(double value) {
  _internal_set_true_anomaly_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.true_anomaly_deg)
}
inline double KeplerianElements::_internal_true_anomaly_deg() const {
  return _impl_.true_anomaly_deg_;
}
inline void KeplerianElements::_internal_set_true_anomaly_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.true_anomaly_deg_ = value;
}

// optional .aalyria.spacetime.api.common.DateTime epoch = 7 [json_name = "epoch"];
inline bool KeplerianElements::has_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.epoch_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& KeplerianElements::_internal_epoch() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.epoch_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& KeplerianElements::epoch() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.epoch)
  return _internal_epoch();
}
inline void KeplerianElements::unsafe_arena_set_allocated_epoch(
    ::aalyria::spacetime::api::common::DateTime* epoch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.epoch_);
  }
  _impl_.epoch_ = epoch;
  if (epoch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.KeplerianElements.epoch)
}
inline ::aalyria::spacetime::api::common::DateTime* KeplerianElements::release_epoch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.epoch_;
  _impl_.epoch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* KeplerianElements::unsafe_arena_release_epoch() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.KeplerianElements.epoch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.epoch_;
  _impl_.epoch_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* KeplerianElements::_internal_mutable_epoch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.epoch_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.epoch_ = p;
  }
  return _impl_.epoch_;
}
inline ::aalyria::spacetime::api::common::DateTime* KeplerianElements::mutable_epoch() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_epoch();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.KeplerianElements.epoch)
  return _msg;
}
inline void KeplerianElements::set_allocated_epoch(::aalyria::spacetime::api::common::DateTime* epoch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.epoch_);
  }
  if (epoch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(epoch));
    if (message_arena != submessage_arena) {
      epoch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epoch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.epoch_ = epoch;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.KeplerianElements.epoch)
}

// optional .aalyria.spacetime.api.common.CentralBody central_body = 8 [default = EARTH, json_name = "centralBody"];
inline bool KeplerianElements::has_central_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void KeplerianElements::clear_central_body() {
  _impl_.central_body_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::aalyria::spacetime::api::common::CentralBody KeplerianElements::central_body() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.KeplerianElements.central_body)
  return _internal_central_body();
}
inline void KeplerianElements::set_central_body(::aalyria::spacetime::api::common::CentralBody value) {
   _internal_set_central_body(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.KeplerianElements.central_body)
}
inline ::aalyria::spacetime::api::common::CentralBody KeplerianElements::_internal_central_body() const {
  return static_cast<::aalyria::spacetime::api::common::CentralBody>(_impl_.central_body_);
}
inline void KeplerianElements::_internal_set_central_body(::aalyria::spacetime::api::common::CentralBody value) {
  assert(::aalyria::spacetime::api::common::CentralBody_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.central_body_ = value;
}

// -------------------------------------------------------------------

// StateVector

// required .google.protobuf.Timestamp epoch = 1 [json_name = "epoch"];
inline bool StateVector::has_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.epoch_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StateVector::_internal_epoch() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.epoch_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StateVector::epoch() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.epoch)
  return _internal_epoch();
}
inline void StateVector::unsafe_arena_set_allocated_epoch(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* epoch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.epoch_);
  }
  _impl_.epoch_ = epoch;
  if (epoch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.StateVector.epoch)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StateVector::release_epoch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.epoch_;
  _impl_.epoch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StateVector::unsafe_arena_release_epoch() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.StateVector.epoch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.epoch_;
  _impl_.epoch_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StateVector::_internal_mutable_epoch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.epoch_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.epoch_ = p;
  }
  return _impl_.epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StateVector::mutable_epoch() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_epoch();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.StateVector.epoch)
  return _msg;
}
inline void StateVector::set_allocated_epoch(::PROTOBUF_NAMESPACE_ID::Timestamp* epoch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.epoch_);
  }
  if (epoch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(epoch));
    if (message_arena != submessage_arena) {
      epoch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epoch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.epoch_ = epoch;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.StateVector.epoch)
}

// optional .aalyria.spacetime.api.common.StateVector.CoordinateFrame coordinate_frame = 2 [json_name = "coordinateFrame"];
inline bool StateVector::has_coordinate_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StateVector::clear_coordinate_frame() {
  _impl_.coordinate_frame_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::aalyria::spacetime::api::common::StateVector_CoordinateFrame StateVector::coordinate_frame() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.coordinate_frame)
  return _internal_coordinate_frame();
}
inline void StateVector::set_coordinate_frame(::aalyria::spacetime::api::common::StateVector_CoordinateFrame value) {
   _internal_set_coordinate_frame(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StateVector.coordinate_frame)
}
inline ::aalyria::spacetime::api::common::StateVector_CoordinateFrame StateVector::_internal_coordinate_frame() const {
  return static_cast<::aalyria::spacetime::api::common::StateVector_CoordinateFrame>(_impl_.coordinate_frame_);
}
inline void StateVector::_internal_set_coordinate_frame(::aalyria::spacetime::api::common::StateVector_CoordinateFrame value) {
  assert(::aalyria::spacetime::api::common::StateVector_CoordinateFrame_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.coordinate_frame_ = value;
}

// required .aalyria.spacetime.api.common.Cartesian position = 3 [json_name = "position"];
inline bool StateVector::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void StateVector::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::Cartesian& StateVector::_internal_position() const {
  const ::aalyria::spacetime::api::common::Cartesian* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Cartesian&>(
      ::aalyria::spacetime::api::common::_Cartesian_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Cartesian& StateVector::position() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.position)
  return _internal_position();
}
inline void StateVector::unsafe_arena_set_allocated_position(
    ::aalyria::spacetime::api::common::Cartesian* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.StateVector.position)
}
inline ::aalyria::spacetime::api::common::Cartesian* StateVector::release_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* StateVector::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.StateVector.position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Cartesian* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Cartesian* StateVector::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Cartesian>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::aalyria::spacetime::api::common::Cartesian* StateVector::mutable_position() {
  ::aalyria::spacetime::api::common::Cartesian* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.StateVector.position)
  return _msg;
}
inline void StateVector::set_allocated_position(::aalyria::spacetime::api::common::Cartesian* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.StateVector.position)
}

// required .aalyria.spacetime.api.common.CartesianDot velocity = 4 [json_name = "velocity"];
inline bool StateVector::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void StateVector::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::CartesianDot& StateVector::_internal_velocity() const {
  const ::aalyria::spacetime::api::common::CartesianDot* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::CartesianDot&>(
      ::aalyria::spacetime::api::common::_CartesianDot_default_instance_);
}
inline const ::aalyria::spacetime::api::common::CartesianDot& StateVector::velocity() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.velocity)
  return _internal_velocity();
}
inline void StateVector::unsafe_arena_set_allocated_velocity(
    ::aalyria::spacetime::api::common::CartesianDot* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.StateVector.velocity)
}
inline ::aalyria::spacetime::api::common::CartesianDot* StateVector::release_velocity() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::CartesianDot* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::CartesianDot* StateVector::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.StateVector.velocity)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::CartesianDot* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::CartesianDot* StateVector::_internal_mutable_velocity() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::CartesianDot>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::aalyria::spacetime::api::common::CartesianDot* StateVector::mutable_velocity() {
  ::aalyria::spacetime::api::common::CartesianDot* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.StateVector.velocity)
  return _msg;
}
inline void StateVector::set_allocated_velocity(::aalyria::spacetime::api::common::CartesianDot* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.StateVector.velocity)
}

// optional .aalyria.spacetime.api.common.StateVector.PropagationAlgorithm propagation_algorithm = 5 [json_name = "propagationAlgorithm"];
inline bool StateVector::has_propagation_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StateVector::clear_propagation_algorithm() {
  _impl_.propagation_algorithm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm StateVector::propagation_algorithm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.propagation_algorithm)
  return _internal_propagation_algorithm();
}
inline void StateVector::set_propagation_algorithm(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm value) {
   _internal_set_propagation_algorithm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StateVector.propagation_algorithm)
}
inline ::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm StateVector::_internal_propagation_algorithm() const {
  return static_cast<::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm>(_impl_.propagation_algorithm_);
}
inline void StateVector::_internal_set_propagation_algorithm(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm value) {
  assert(::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.propagation_algorithm_ = value;
}

// optional double mass_kg = 6 [default = 2000, json_name = "massKg"];
inline bool StateVector::has_mass_kg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StateVector::clear_mass_kg() {
  _impl_.mass_kg_ = 2000;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double StateVector::mass_kg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.mass_kg)
  return _internal_mass_kg();
}
inline void StateVector::set_mass_kg(double value) {
  _internal_set_mass_kg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StateVector.mass_kg)
}
inline double StateVector::_internal_mass_kg() const {
  return _impl_.mass_kg_;
}
inline void StateVector::_internal_set_mass_kg(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mass_kg_ = value;
}

// optional double reflectivity = 7 [default = 1, json_name = "reflectivity"];
inline bool StateVector::has_reflectivity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StateVector::clear_reflectivity() {
  _impl_.reflectivity_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double StateVector::reflectivity() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.reflectivity)
  return _internal_reflectivity();
}
inline void StateVector::set_reflectivity(double value) {
  _internal_set_reflectivity(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StateVector.reflectivity)
}
inline double StateVector::_internal_reflectivity() const {
  return _impl_.reflectivity_;
}
inline void StateVector::_internal_set_reflectivity(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.reflectivity_ = value;
}

// optional double reflective_area_sqm = 8 [default = 20, json_name = "reflectiveAreaSqm"];
inline bool StateVector::has_reflective_area_sqm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StateVector::clear_reflective_area_sqm() {
  _impl_.reflective_area_sqm_ = 20;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double StateVector::reflective_area_sqm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StateVector.reflective_area_sqm)
  return _internal_reflective_area_sqm();
}
inline void StateVector::set_reflective_area_sqm(double value) {
  _internal_set_reflective_area_sqm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StateVector.reflective_area_sqm)
}
inline double StateVector::_internal_reflective_area_sqm() const {
  return _impl_.reflective_area_sqm_;
}
inline void StateVector::_internal_set_reflective_area_sqm(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.reflective_area_sqm_ = value;
}

// -------------------------------------------------------------------

// SelenographicMlr

// optional double longitude_deg = 1 [json_name = "longitudeDeg"];
inline bool SelenographicMlr::has_longitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SelenographicMlr::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SelenographicMlr::longitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.SelenographicMlr.longitude_deg)
  return _internal_longitude_deg();
}
inline void SelenographicMlr::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.SelenographicMlr.longitude_deg)
}
inline double SelenographicMlr::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline void SelenographicMlr::_internal_set_longitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_deg_ = value;
}

// optional double latitude_deg = 2 [json_name = "latitudeDeg"];
inline bool SelenographicMlr::has_latitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SelenographicMlr::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double SelenographicMlr::latitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.SelenographicMlr.latitude_deg)
  return _internal_latitude_deg();
}
inline void SelenographicMlr::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.SelenographicMlr.latitude_deg)
}
inline double SelenographicMlr::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline void SelenographicMlr::_internal_set_latitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_deg_ = value;
}

// optional double height_mlr_m = 3 [json_name = "heightMlrM"];
inline bool SelenographicMlr::has_height_mlr_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SelenographicMlr::clear_height_mlr_m() {
  _impl_.height_mlr_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double SelenographicMlr::height_mlr_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.SelenographicMlr.height_mlr_m)
  return _internal_height_mlr_m();
}
inline void SelenographicMlr::set_height_mlr_m(double value) {
  _internal_set_height_mlr_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.SelenographicMlr.height_mlr_m)
}
inline double SelenographicMlr::_internal_height_mlr_m() const {
  return _impl_.height_mlr_m_;
}
inline void SelenographicMlr::_internal_set_height_mlr_m(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_mlr_m_ = value;
}

// -------------------------------------------------------------------

// StkEphemAndAttitudeFile

// optional string ephem_file = 1 [json_name = "ephemFile"];
inline bool StkEphemAndAttitudeFile::has_ephem_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StkEphemAndAttitudeFile::clear_ephem_file() {
  _impl_.ephem_file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StkEphemAndAttitudeFile::ephem_file() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file)
  return _internal_ephem_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StkEphemAndAttitudeFile::set_ephem_file(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ephem_file_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file)
}
inline std::string* StkEphemAndAttitudeFile::mutable_ephem_file() {
  std::string* _s = _internal_mutable_ephem_file();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file)
  return _s;
}
inline const std::string& StkEphemAndAttitudeFile::_internal_ephem_file() const {
  return _impl_.ephem_file_.Get();
}
inline void StkEphemAndAttitudeFile::_internal_set_ephem_file(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.ephem_file_.Set(value, GetArenaForAllocation());
}
inline std::string* StkEphemAndAttitudeFile::_internal_mutable_ephem_file() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ephem_file_.Mutable( GetArenaForAllocation());
}
inline std::string* StkEphemAndAttitudeFile::release_ephem_file() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ephem_file_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ephem_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StkEphemAndAttitudeFile::set_allocated_ephem_file(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ephem_file_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ephem_file_.IsDefault()) {
          _impl_.ephem_file_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.ephem_file)
}

// optional string attitude_file = 2 [json_name = "attitudeFile"];
inline bool StkEphemAndAttitudeFile::has_attitude_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StkEphemAndAttitudeFile::clear_attitude_file() {
  _impl_.attitude_file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StkEphemAndAttitudeFile::attitude_file() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file)
  return _internal_attitude_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StkEphemAndAttitudeFile::set_attitude_file(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attitude_file_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file)
}
inline std::string* StkEphemAndAttitudeFile::mutable_attitude_file() {
  std::string* _s = _internal_mutable_attitude_file();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file)
  return _s;
}
inline const std::string& StkEphemAndAttitudeFile::_internal_attitude_file() const {
  return _impl_.attitude_file_.Get();
}
inline void StkEphemAndAttitudeFile::_internal_set_attitude_file(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.attitude_file_.Set(value, GetArenaForAllocation());
}
inline std::string* StkEphemAndAttitudeFile::_internal_mutable_attitude_file() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.attitude_file_.Mutable( GetArenaForAllocation());
}
inline std::string* StkEphemAndAttitudeFile::release_attitude_file() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.attitude_file_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attitude_file_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StkEphemAndAttitudeFile::set_allocated_attitude_file(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attitude_file_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attitude_file_.IsDefault()) {
          _impl_.attitude_file_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.StkEphemAndAttitudeFile.attitude_file)
}

// -------------------------------------------------------------------

// Motion

// optional .google.type.Interval interval = 10 [json_name = "interval"];
inline bool Motion::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::google::type::Interval& Motion::_internal_interval() const {
  const ::google::type::Interval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::Interval&>(
      ::google::type::_Interval_default_instance_);
}
inline const ::google::type::Interval& Motion::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.interval)
  return _internal_interval();
}
inline void Motion::unsafe_arena_set_allocated_interval(
    ::google::type::Interval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.interval)
}
inline ::google::type::Interval* Motion::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::type::Interval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::Interval* Motion::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::type::Interval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::google::type::Interval* Motion::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::Interval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::google::type::Interval* Motion::mutable_interval() {
  ::google::type::Interval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.interval)
  return _msg;
}
inline void Motion::set_allocated_interval(::google::type::Interval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Motion.interval)
}

// .aalyria.spacetime.api.common.GeodeticMsl geodetic_msl = 7 [json_name = "geodeticMsl"];
inline bool Motion::has_geodetic_msl() const {
  return type_case() == kGeodeticMsl;
}
inline bool Motion::_internal_has_geodetic_msl() const {
  return type_case() == kGeodeticMsl;
}
inline void Motion::set_has_geodetic_msl() {
  _impl_._oneof_case_[0] = kGeodeticMsl;
}
inline void Motion::clear_geodetic_msl() {
  if (type_case() == kGeodeticMsl) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.geodetic_msl_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::GeodeticMsl* Motion::release_geodetic_msl() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.geodetic_msl)
  if (type_case() == kGeodeticMsl) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticMsl* temp = _impl_.type_.geodetic_msl_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.geodetic_msl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::GeodeticMsl& Motion::_internal_geodetic_msl() const {
  return type_case() == kGeodeticMsl
      ? *_impl_.type_.geodetic_msl_
      : reinterpret_cast<::aalyria::spacetime::api::common::GeodeticMsl&>(::aalyria::spacetime::api::common::_GeodeticMsl_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticMsl& Motion::geodetic_msl() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.geodetic_msl)
  return _internal_geodetic_msl();
}
inline ::aalyria::spacetime::api::common::GeodeticMsl* Motion::unsafe_arena_release_geodetic_msl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.geodetic_msl)
  if (type_case() == kGeodeticMsl) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticMsl* temp = _impl_.type_.geodetic_msl_;
    _impl_.type_.geodetic_msl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_geodetic_msl(::aalyria::spacetime::api::common::GeodeticMsl* geodetic_msl) {
  clear_type();
  if (geodetic_msl) {
    set_has_geodetic_msl();
    _impl_.type_.geodetic_msl_ = geodetic_msl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.geodetic_msl)
}
inline ::aalyria::spacetime::api::common::GeodeticMsl* Motion::_internal_mutable_geodetic_msl() {
  if (type_case() != kGeodeticMsl) {
    clear_type();
    set_has_geodetic_msl();
    _impl_.type_.geodetic_msl_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticMsl >(GetArenaForAllocation());
  }
  return _impl_.type_.geodetic_msl_;
}
inline ::aalyria::spacetime::api::common::GeodeticMsl* Motion::mutable_geodetic_msl() {
  ::aalyria::spacetime::api::common::GeodeticMsl* _msg = _internal_mutable_geodetic_msl();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.geodetic_msl)
  return _msg;
}

// .aalyria.spacetime.api.common.GeodeticWgs84 geodetic_wgs84 = 1 [json_name = "geodeticWgs84"];
inline bool Motion::has_geodetic_wgs84() const {
  return type_case() == kGeodeticWgs84;
}
inline bool Motion::_internal_has_geodetic_wgs84() const {
  return type_case() == kGeodeticWgs84;
}
inline void Motion::set_has_geodetic_wgs84() {
  _impl_._oneof_case_[0] = kGeodeticWgs84;
}
inline void Motion::clear_geodetic_wgs84() {
  if (type_case() == kGeodeticWgs84) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.geodetic_wgs84_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* Motion::release_geodetic_wgs84() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
  if (type_case() == kGeodeticWgs84) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.type_.geodetic_wgs84_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.geodetic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& Motion::_internal_geodetic_wgs84() const {
  return type_case() == kGeodeticWgs84
      ? *_impl_.type_.geodetic_wgs84_
      : reinterpret_cast<::aalyria::spacetime::api::common::GeodeticWgs84&>(::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& Motion::geodetic_wgs84() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
  return _internal_geodetic_wgs84();
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* Motion::unsafe_arena_release_geodetic_wgs84() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
  if (type_case() == kGeodeticWgs84) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.type_.geodetic_wgs84_;
    _impl_.type_.geodetic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_geodetic_wgs84(::aalyria::spacetime::api::common::GeodeticWgs84* geodetic_wgs84) {
  clear_type();
  if (geodetic_wgs84) {
    set_has_geodetic_wgs84();
    _impl_.type_.geodetic_wgs84_ = geodetic_wgs84;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* Motion::_internal_mutable_geodetic_wgs84() {
  if (type_case() != kGeodeticWgs84) {
    clear_type();
    set_has_geodetic_wgs84();
    _impl_.type_.geodetic_wgs84_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticWgs84 >(GetArenaForAllocation());
  }
  return _impl_.type_.geodetic_wgs84_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* Motion::mutable_geodetic_wgs84() {
  ::aalyria::spacetime::api::common::GeodeticWgs84* _msg = _internal_mutable_geodetic_wgs84();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.geodetic_wgs84)
  return _msg;
}

// .aalyria.spacetime.api.common.PointAxes ecef_fixed = 2 [json_name = "ecefFixed"];
inline bool Motion::has_ecef_fixed() const {
  return type_case() == kEcefFixed;
}
inline bool Motion::_internal_has_ecef_fixed() const {
  return type_case() == kEcefFixed;
}
inline void Motion::set_has_ecef_fixed() {
  _impl_._oneof_case_[0] = kEcefFixed;
}
inline void Motion::clear_ecef_fixed() {
  if (type_case() == kEcefFixed) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.ecef_fixed_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::PointAxes* Motion::release_ecef_fixed() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.ecef_fixed)
  if (type_case() == kEcefFixed) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PointAxes* temp = _impl_.type_.ecef_fixed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ecef_fixed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PointAxes& Motion::_internal_ecef_fixed() const {
  return type_case() == kEcefFixed
      ? *_impl_.type_.ecef_fixed_
      : reinterpret_cast<::aalyria::spacetime::api::common::PointAxes&>(::aalyria::spacetime::api::common::_PointAxes_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PointAxes& Motion::ecef_fixed() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.ecef_fixed)
  return _internal_ecef_fixed();
}
inline ::aalyria::spacetime::api::common::PointAxes* Motion::unsafe_arena_release_ecef_fixed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.ecef_fixed)
  if (type_case() == kEcefFixed) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PointAxes* temp = _impl_.type_.ecef_fixed_;
    _impl_.type_.ecef_fixed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_ecef_fixed(::aalyria::spacetime::api::common::PointAxes* ecef_fixed) {
  clear_type();
  if (ecef_fixed) {
    set_has_ecef_fixed();
    _impl_.type_.ecef_fixed_ = ecef_fixed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.ecef_fixed)
}
inline ::aalyria::spacetime::api::common::PointAxes* Motion::_internal_mutable_ecef_fixed() {
  if (type_case() != kEcefFixed) {
    clear_type();
    set_has_ecef_fixed();
    _impl_.type_.ecef_fixed_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PointAxes >(GetArenaForAllocation());
  }
  return _impl_.type_.ecef_fixed_;
}
inline ::aalyria::spacetime::api::common::PointAxes* Motion::mutable_ecef_fixed() {
  ::aalyria::spacetime::api::common::PointAxes* _msg = _internal_mutable_ecef_fixed();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.ecef_fixed)
  return _msg;
}

// .aalyria.spacetime.api.common.PointAxesTemporalInterpolation ecef_interpolation = 3 [json_name = "ecefInterpolation"];
inline bool Motion::has_ecef_interpolation() const {
  return type_case() == kEcefInterpolation;
}
inline bool Motion::_internal_has_ecef_interpolation() const {
  return type_case() == kEcefInterpolation;
}
inline void Motion::set_has_ecef_interpolation() {
  _impl_._oneof_case_[0] = kEcefInterpolation;
}
inline void Motion::clear_ecef_interpolation() {
  if (type_case() == kEcefInterpolation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.ecef_interpolation_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* Motion::release_ecef_interpolation() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.ecef_interpolation)
  if (type_case() == kEcefInterpolation) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* temp = _impl_.type_.ecef_interpolation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ecef_interpolation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation& Motion::_internal_ecef_interpolation() const {
  return type_case() == kEcefInterpolation
      ? *_impl_.type_.ecef_interpolation_
      : reinterpret_cast<::aalyria::spacetime::api::common::PointAxesTemporalInterpolation&>(::aalyria::spacetime::api::common::_PointAxesTemporalInterpolation_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation& Motion::ecef_interpolation() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.ecef_interpolation)
  return _internal_ecef_interpolation();
}
inline ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* Motion::unsafe_arena_release_ecef_interpolation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.ecef_interpolation)
  if (type_case() == kEcefInterpolation) {
    clear_has_type();
    ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* temp = _impl_.type_.ecef_interpolation_;
    _impl_.type_.ecef_interpolation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_ecef_interpolation(::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* ecef_interpolation) {
  clear_type();
  if (ecef_interpolation) {
    set_has_ecef_interpolation();
    _impl_.type_.ecef_interpolation_ = ecef_interpolation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.ecef_interpolation)
}
inline ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* Motion::_internal_mutable_ecef_interpolation() {
  if (type_case() != kEcefInterpolation) {
    clear_type();
    set_has_ecef_interpolation();
    _impl_.type_.ecef_interpolation_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation >(GetArenaForAllocation());
  }
  return _impl_.type_.ecef_interpolation_;
}
inline ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* Motion::mutable_ecef_interpolation() {
  ::aalyria::spacetime::api::common::PointAxesTemporalInterpolation* _msg = _internal_mutable_ecef_interpolation();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.ecef_interpolation)
  return _msg;
}

// .aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation cartographic_waypoints = 4 [json_name = "cartographicWaypoints"];
inline bool Motion::has_cartographic_waypoints() const {
  return type_case() == kCartographicWaypoints;
}
inline bool Motion::_internal_has_cartographic_waypoints() const {
  return type_case() == kCartographicWaypoints;
}
inline void Motion::set_has_cartographic_waypoints() {
  _impl_._oneof_case_[0] = kCartographicWaypoints;
}
inline void Motion::clear_cartographic_waypoints() {
  if (type_case() == kCartographicWaypoints) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.cartographic_waypoints_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* Motion::release_cartographic_waypoints() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
  if (type_case() == kCartographicWaypoints) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* temp = _impl_.type_.cartographic_waypoints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.cartographic_waypoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation& Motion::_internal_cartographic_waypoints() const {
  return type_case() == kCartographicWaypoints
      ? *_impl_.type_.cartographic_waypoints_
      : reinterpret_cast<::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation&>(::aalyria::spacetime::api::common::_GeodeticWgs84TemporalInterpolation_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation& Motion::cartographic_waypoints() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
  return _internal_cartographic_waypoints();
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* Motion::unsafe_arena_release_cartographic_waypoints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
  if (type_case() == kCartographicWaypoints) {
    clear_has_type();
    ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* temp = _impl_.type_.cartographic_waypoints_;
    _impl_.type_.cartographic_waypoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_cartographic_waypoints(::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* cartographic_waypoints) {
  clear_type();
  if (cartographic_waypoints) {
    set_has_cartographic_waypoints();
    _impl_.type_.cartographic_waypoints_ = cartographic_waypoints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* Motion::_internal_mutable_cartographic_waypoints() {
  if (type_case() != kCartographicWaypoints) {
    clear_type();
    set_has_cartographic_waypoints();
    _impl_.type_.cartographic_waypoints_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation >(GetArenaForAllocation());
  }
  return _impl_.type_.cartographic_waypoints_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* Motion::mutable_cartographic_waypoints() {
  ::aalyria::spacetime::api::common::GeodeticWgs84TemporalInterpolation* _msg = _internal_mutable_cartographic_waypoints();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.cartographic_waypoints)
  return _msg;
}

// .aalyria.spacetime.api.common.TwoLineElementSet tle = 5 [json_name = "tle"];
inline bool Motion::has_tle() const {
  return type_case() == kTle;
}
inline bool Motion::_internal_has_tle() const {
  return type_case() == kTle;
}
inline void Motion::set_has_tle() {
  _impl_._oneof_case_[0] = kTle;
}
inline void Motion::clear_tle() {
  if (type_case() == kTle) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.tle_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::TwoLineElementSet* Motion::release_tle() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.tle)
  if (type_case() == kTle) {
    clear_has_type();
    ::aalyria::spacetime::api::common::TwoLineElementSet* temp = _impl_.type_.tle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.tle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::TwoLineElementSet& Motion::_internal_tle() const {
  return type_case() == kTle
      ? *_impl_.type_.tle_
      : reinterpret_cast<::aalyria::spacetime::api::common::TwoLineElementSet&>(::aalyria::spacetime::api::common::_TwoLineElementSet_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TwoLineElementSet& Motion::tle() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.tle)
  return _internal_tle();
}
inline ::aalyria::spacetime::api::common::TwoLineElementSet* Motion::unsafe_arena_release_tle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.tle)
  if (type_case() == kTle) {
    clear_has_type();
    ::aalyria::spacetime::api::common::TwoLineElementSet* temp = _impl_.type_.tle_;
    _impl_.type_.tle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_tle(::aalyria::spacetime::api::common::TwoLineElementSet* tle) {
  clear_type();
  if (tle) {
    set_has_tle();
    _impl_.type_.tle_ = tle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.tle)
}
inline ::aalyria::spacetime::api::common::TwoLineElementSet* Motion::_internal_mutable_tle() {
  if (type_case() != kTle) {
    clear_type();
    set_has_tle();
    _impl_.type_.tle_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::TwoLineElementSet >(GetArenaForAllocation());
  }
  return _impl_.type_.tle_;
}
inline ::aalyria::spacetime::api::common::TwoLineElementSet* Motion::mutable_tle() {
  ::aalyria::spacetime::api::common::TwoLineElementSet* _msg = _internal_mutable_tle();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.tle)
  return _msg;
}

// .aalyria.spacetime.api.common.KeplerianElements keplerian_elements = 6 [json_name = "keplerianElements"];
inline bool Motion::has_keplerian_elements() const {
  return type_case() == kKeplerianElements;
}
inline bool Motion::_internal_has_keplerian_elements() const {
  return type_case() == kKeplerianElements;
}
inline void Motion::set_has_keplerian_elements() {
  _impl_._oneof_case_[0] = kKeplerianElements;
}
inline void Motion::clear_keplerian_elements() {
  if (type_case() == kKeplerianElements) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.keplerian_elements_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::KeplerianElements* Motion::release_keplerian_elements() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.keplerian_elements)
  if (type_case() == kKeplerianElements) {
    clear_has_type();
    ::aalyria::spacetime::api::common::KeplerianElements* temp = _impl_.type_.keplerian_elements_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.keplerian_elements_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::KeplerianElements& Motion::_internal_keplerian_elements() const {
  return type_case() == kKeplerianElements
      ? *_impl_.type_.keplerian_elements_
      : reinterpret_cast<::aalyria::spacetime::api::common::KeplerianElements&>(::aalyria::spacetime::api::common::_KeplerianElements_default_instance_);
}
inline const ::aalyria::spacetime::api::common::KeplerianElements& Motion::keplerian_elements() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.keplerian_elements)
  return _internal_keplerian_elements();
}
inline ::aalyria::spacetime::api::common::KeplerianElements* Motion::unsafe_arena_release_keplerian_elements() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.keplerian_elements)
  if (type_case() == kKeplerianElements) {
    clear_has_type();
    ::aalyria::spacetime::api::common::KeplerianElements* temp = _impl_.type_.keplerian_elements_;
    _impl_.type_.keplerian_elements_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_keplerian_elements(::aalyria::spacetime::api::common::KeplerianElements* keplerian_elements) {
  clear_type();
  if (keplerian_elements) {
    set_has_keplerian_elements();
    _impl_.type_.keplerian_elements_ = keplerian_elements;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.keplerian_elements)
}
inline ::aalyria::spacetime::api::common::KeplerianElements* Motion::_internal_mutable_keplerian_elements() {
  if (type_case() != kKeplerianElements) {
    clear_type();
    set_has_keplerian_elements();
    _impl_.type_.keplerian_elements_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::KeplerianElements >(GetArenaForAllocation());
  }
  return _impl_.type_.keplerian_elements_;
}
inline ::aalyria::spacetime::api::common::KeplerianElements* Motion::mutable_keplerian_elements() {
  ::aalyria::spacetime::api::common::KeplerianElements* _msg = _internal_mutable_keplerian_elements();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.keplerian_elements)
  return _msg;
}

// .aalyria.spacetime.api.common.StateVector state_vector = 9 [json_name = "stateVector"];
inline bool Motion::has_state_vector() const {
  return type_case() == kStateVector;
}
inline bool Motion::_internal_has_state_vector() const {
  return type_case() == kStateVector;
}
inline void Motion::set_has_state_vector() {
  _impl_._oneof_case_[0] = kStateVector;
}
inline void Motion::clear_state_vector() {
  if (type_case() == kStateVector) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.state_vector_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::StateVector* Motion::release_state_vector() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.state_vector)
  if (type_case() == kStateVector) {
    clear_has_type();
    ::aalyria::spacetime::api::common::StateVector* temp = _impl_.type_.state_vector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.state_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::StateVector& Motion::_internal_state_vector() const {
  return type_case() == kStateVector
      ? *_impl_.type_.state_vector_
      : reinterpret_cast<::aalyria::spacetime::api::common::StateVector&>(::aalyria::spacetime::api::common::_StateVector_default_instance_);
}
inline const ::aalyria::spacetime::api::common::StateVector& Motion::state_vector() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.state_vector)
  return _internal_state_vector();
}
inline ::aalyria::spacetime::api::common::StateVector* Motion::unsafe_arena_release_state_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.state_vector)
  if (type_case() == kStateVector) {
    clear_has_type();
    ::aalyria::spacetime::api::common::StateVector* temp = _impl_.type_.state_vector_;
    _impl_.type_.state_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_state_vector(::aalyria::spacetime::api::common::StateVector* state_vector) {
  clear_type();
  if (state_vector) {
    set_has_state_vector();
    _impl_.type_.state_vector_ = state_vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.state_vector)
}
inline ::aalyria::spacetime::api::common::StateVector* Motion::_internal_mutable_state_vector() {
  if (type_case() != kStateVector) {
    clear_type();
    set_has_state_vector();
    _impl_.type_.state_vector_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::StateVector >(GetArenaForAllocation());
  }
  return _impl_.type_.state_vector_;
}
inline ::aalyria::spacetime::api::common::StateVector* Motion::mutable_state_vector() {
  ::aalyria::spacetime::api::common::StateVector* _msg = _internal_mutable_state_vector();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.state_vector)
  return _msg;
}

// .aalyria.spacetime.api.common.SelenographicMlr selenographic_mlr = 8 [json_name = "selenographicMlr"];
inline bool Motion::has_selenographic_mlr() const {
  return type_case() == kSelenographicMlr;
}
inline bool Motion::_internal_has_selenographic_mlr() const {
  return type_case() == kSelenographicMlr;
}
inline void Motion::set_has_selenographic_mlr() {
  _impl_._oneof_case_[0] = kSelenographicMlr;
}
inline void Motion::clear_selenographic_mlr() {
  if (type_case() == kSelenographicMlr) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.selenographic_mlr_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::SelenographicMlr* Motion::release_selenographic_mlr() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.selenographic_mlr)
  if (type_case() == kSelenographicMlr) {
    clear_has_type();
    ::aalyria::spacetime::api::common::SelenographicMlr* temp = _impl_.type_.selenographic_mlr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.selenographic_mlr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::SelenographicMlr& Motion::_internal_selenographic_mlr() const {
  return type_case() == kSelenographicMlr
      ? *_impl_.type_.selenographic_mlr_
      : reinterpret_cast<::aalyria::spacetime::api::common::SelenographicMlr&>(::aalyria::spacetime::api::common::_SelenographicMlr_default_instance_);
}
inline const ::aalyria::spacetime::api::common::SelenographicMlr& Motion::selenographic_mlr() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.selenographic_mlr)
  return _internal_selenographic_mlr();
}
inline ::aalyria::spacetime::api::common::SelenographicMlr* Motion::unsafe_arena_release_selenographic_mlr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.selenographic_mlr)
  if (type_case() == kSelenographicMlr) {
    clear_has_type();
    ::aalyria::spacetime::api::common::SelenographicMlr* temp = _impl_.type_.selenographic_mlr_;
    _impl_.type_.selenographic_mlr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_selenographic_mlr(::aalyria::spacetime::api::common::SelenographicMlr* selenographic_mlr) {
  clear_type();
  if (selenographic_mlr) {
    set_has_selenographic_mlr();
    _impl_.type_.selenographic_mlr_ = selenographic_mlr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.selenographic_mlr)
}
inline ::aalyria::spacetime::api::common::SelenographicMlr* Motion::_internal_mutable_selenographic_mlr() {
  if (type_case() != kSelenographicMlr) {
    clear_type();
    set_has_selenographic_mlr();
    _impl_.type_.selenographic_mlr_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::SelenographicMlr >(GetArenaForAllocation());
  }
  return _impl_.type_.selenographic_mlr_;
}
inline ::aalyria::spacetime::api::common::SelenographicMlr* Motion::mutable_selenographic_mlr() {
  ::aalyria::spacetime::api::common::SelenographicMlr* _msg = _internal_mutable_selenographic_mlr();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.selenographic_mlr)
  return _msg;
}

// .aalyria.spacetime.api.common.StkEphemAndAttitudeFile stk_ephem_and_attitude_file = 11 [json_name = "stkEphemAndAttitudeFile"];
inline bool Motion::has_stk_ephem_and_attitude_file() const {
  return type_case() == kStkEphemAndAttitudeFile;
}
inline bool Motion::_internal_has_stk_ephem_and_attitude_file() const {
  return type_case() == kStkEphemAndAttitudeFile;
}
inline void Motion::set_has_stk_ephem_and_attitude_file() {
  _impl_._oneof_case_[0] = kStkEphemAndAttitudeFile;
}
inline void Motion::clear_stk_ephem_and_attitude_file() {
  if (type_case() == kStkEphemAndAttitudeFile) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.stk_ephem_and_attitude_file_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* Motion::release_stk_ephem_and_attitude_file() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
  if (type_case() == kStkEphemAndAttitudeFile) {
    clear_has_type();
    ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* temp = _impl_.type_.stk_ephem_and_attitude_file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.stk_ephem_and_attitude_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile& Motion::_internal_stk_ephem_and_attitude_file() const {
  return type_case() == kStkEphemAndAttitudeFile
      ? *_impl_.type_.stk_ephem_and_attitude_file_
      : reinterpret_cast<::aalyria::spacetime::api::common::StkEphemAndAttitudeFile&>(::aalyria::spacetime::api::common::_StkEphemAndAttitudeFile_default_instance_);
}
inline const ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile& Motion::stk_ephem_and_attitude_file() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
  return _internal_stk_ephem_and_attitude_file();
}
inline ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* Motion::unsafe_arena_release_stk_ephem_and_attitude_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
  if (type_case() == kStkEphemAndAttitudeFile) {
    clear_has_type();
    ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* temp = _impl_.type_.stk_ephem_and_attitude_file_;
    _impl_.type_.stk_ephem_and_attitude_file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Motion::unsafe_arena_set_allocated_stk_ephem_and_attitude_file(::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* stk_ephem_and_attitude_file) {
  clear_type();
  if (stk_ephem_and_attitude_file) {
    set_has_stk_ephem_and_attitude_file();
    _impl_.type_.stk_ephem_and_attitude_file_ = stk_ephem_and_attitude_file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
}
inline ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* Motion::_internal_mutable_stk_ephem_and_attitude_file() {
  if (type_case() != kStkEphemAndAttitudeFile) {
    clear_type();
    set_has_stk_ephem_and_attitude_file();
    _impl_.type_.stk_ephem_and_attitude_file_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile >(GetArenaForAllocation());
  }
  return _impl_.type_.stk_ephem_and_attitude_file_;
}
inline ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* Motion::mutable_stk_ephem_and_attitude_file() {
  ::aalyria::spacetime::api::common::StkEphemAndAttitudeFile* _msg = _internal_mutable_stk_ephem_and_attitude_file();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file)
  return _msg;
}

inline bool Motion::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Motion::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Motion::TypeCase Motion::type_case() const {
  return Motion::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MotionDefinition

// repeated .aalyria.spacetime.api.common.Motion motions = 1 [json_name = "motions"];
inline int MotionDefinition::_internal_motions_size() const {
  return _impl_.motions_.size();
}
inline int MotionDefinition::motions_size() const {
  return _internal_motions_size();
}
inline void MotionDefinition::clear_motions() {
  _internal_mutable_motions()->Clear();
}
inline ::aalyria::spacetime::api::common::Motion* MotionDefinition::mutable_motions(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.MotionDefinition.motions)
  return _internal_mutable_motions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Motion >*
MotionDefinition::mutable_motions() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.MotionDefinition.motions)
  return _internal_mutable_motions();
}
inline const ::aalyria::spacetime::api::common::Motion& MotionDefinition::_internal_motions(int index) const {
  return _internal_motions().Get(index);
}
inline const ::aalyria::spacetime::api::common::Motion& MotionDefinition::motions(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.MotionDefinition.motions)
  return _internal_motions(index);
}
inline ::aalyria::spacetime::api::common::Motion* MotionDefinition::_internal_add_motions() {
  return _internal_mutable_motions()->Add();
}
inline ::aalyria::spacetime::api::common::Motion* MotionDefinition::add_motions() {
  ::aalyria::spacetime::api::common::Motion* _add = _internal_add_motions();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.MotionDefinition.motions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::Motion >&
MotionDefinition::motions() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.MotionDefinition.motions)
  return _internal_motions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Motion>&
MotionDefinition::_internal_motions() const {
  return _impl_.motions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::Motion>*
MotionDefinition::_internal_mutable_motions() {
  return &_impl_.motions_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::common::StateVector_CoordinateFrame> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::StateVector_CoordinateFrame>() {
  return ::aalyria::spacetime::api::common::StateVector_CoordinateFrame_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm>() {
  return ::aalyria::spacetime::api::common::StateVector_PropagationAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::Motion_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::Motion_Type>() {
  return ::aalyria::spacetime::api::common::Motion_Type_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::CentralBody> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::CentralBody>() {
  return ::aalyria::spacetime::api::common::CentralBody_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::common::InterpolationMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::common::InterpolationMethod>() {
  return ::aalyria::spacetime::api::common::InterpolationMethod_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcoordinates_2eproto_2epb_2eh
