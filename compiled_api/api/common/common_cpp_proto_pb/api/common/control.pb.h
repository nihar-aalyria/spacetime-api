// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/control_beam.pb.h"
#include "api/common/control_flow.pb.h"
#include "api/common/control_radio.pb.h"
#include "api/common/control_tunnel.pb.h"
#include "api/common/time.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fcontrol_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fcontrol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fcontrol_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class CdpiFrontendInfo;
struct CdpiFrontendInfoDefaultTypeInternal;
extern CdpiFrontendInfoDefaultTypeInternal _CdpiFrontendInfo_default_instance_;
class CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse;
struct CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUseDefaultTypeInternal;
extern CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUseDefaultTypeInternal _CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse_default_instance_;
class CdpiStreamInfo;
struct CdpiStreamInfoDefaultTypeInternal;
extern CdpiStreamInfoDefaultTypeInternal _CdpiStreamInfo_default_instance_;
class CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse;
struct CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUseDefaultTypeInternal;
extern CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUseDefaultTypeInternal _CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse_default_instance_;
class CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse;
struct CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUseDefaultTypeInternal;
extern CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUseDefaultTypeInternal _CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse_default_instance_;
class ControlPlaneState;
struct ControlPlaneStateDefaultTypeInternal;
extern ControlPlaneStateDefaultTypeInternal _ControlPlaneState_default_instance_;
class ControlPlaneUpdate;
struct ControlPlaneUpdateDefaultTypeInternal;
extern ControlPlaneUpdateDefaultTypeInternal _ControlPlaneUpdate_default_instance_;
class ScheduledControlDeletion;
struct ScheduledControlDeletionDefaultTypeInternal;
extern ScheduledControlDeletionDefaultTypeInternal _ScheduledControlDeletion_default_instance_;
class ScheduledControlUpdate;
struct ScheduledControlUpdateDefaultTypeInternal;
extern ScheduledControlUpdateDefaultTypeInternal _ScheduledControlUpdate_default_instance_;
class ScheduledControlUpdateReq;
struct ScheduledControlUpdateReqDefaultTypeInternal;
extern ScheduledControlUpdateReqDefaultTypeInternal _ScheduledControlUpdateReq_default_instance_;
class ScheduledControlUpdateStatus;
struct ScheduledControlUpdateStatusDefaultTypeInternal;
extern ScheduledControlUpdateStatusDefaultTypeInternal _ScheduledControlUpdateStatus_default_instance_;
class TaskCdpiStreamCount;
struct TaskCdpiStreamCountDefaultTypeInternal;
extern TaskCdpiStreamCountDefaultTypeInternal _TaskCdpiStreamCount_default_instance_;
class TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse;
struct TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUseDefaultTypeInternal;
extern TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUseDefaultTypeInternal _TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::CdpiFrontendInfo* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CdpiFrontendInfo>(Arena*);
template <>
::aalyria::spacetime::api::common::CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::CdpiStreamInfo* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CdpiStreamInfo>(Arena*);
template <>
::aalyria::spacetime::api::common::CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::common::ControlPlaneState* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ControlPlaneState>(Arena*);
template <>
::aalyria::spacetime::api::common::ControlPlaneUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ControlPlaneUpdate>(Arena*);
template <>
::aalyria::spacetime::api::common::ScheduledControlDeletion* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlDeletion>(Arena*);
template <>
::aalyria::spacetime::api::common::ScheduledControlUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlUpdate>(Arena*);
template <>
::aalyria::spacetime::api::common::ScheduledControlUpdateReq* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlUpdateReq>(Arena*);
template <>
::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>(Arena*);
template <>
::aalyria::spacetime::api::common::TaskCdpiStreamCount* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TaskCdpiStreamCount>(Arena*);
template <>
::aalyria::spacetime::api::common::TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class ScheduledControlUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ScheduledControlUpdate) */ {
 public:
  inline ScheduledControlUpdate() : ScheduledControlUpdate(nullptr) {}
  ~ScheduledControlUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScheduledControlUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduledControlUpdate(const ScheduledControlUpdate& from);
  ScheduledControlUpdate(ScheduledControlUpdate&& from) noexcept
    : ScheduledControlUpdate() {
    *this = ::std::move(from);
  }

  inline ScheduledControlUpdate& operator=(const ScheduledControlUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduledControlUpdate& operator=(ScheduledControlUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduledControlUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduledControlUpdate* internal_default_instance() {
    return reinterpret_cast<const ScheduledControlUpdate*>(
               &_ScheduledControlUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ScheduledControlUpdate& a, ScheduledControlUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduledControlUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduledControlUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduledControlUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduledControlUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduledControlUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduledControlUpdate& from) {
    ScheduledControlUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduledControlUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ScheduledControlUpdate";
  }
  protected:
  explicit ScheduledControlUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kUpdateIdFieldNumber = 2,
    kTimeToEnactFieldNumber = 3,
    kChangeFieldNumber = 4,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional string update_id = 2 [json_name = "updateId"];
  bool has_update_id() const;
  void clear_update_id() ;
  const std::string& update_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* ptr);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
  bool has_time_to_enact() const;
  void clear_time_to_enact() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_to_enact() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_to_enact();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_to_enact();
  void set_allocated_time_to_enact(::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_to_enact() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_to_enact();
  public:
  void unsafe_arena_set_allocated_time_to_enact(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_to_enact();
  // optional .aalyria.spacetime.api.common.ControlPlaneUpdate change = 4 [json_name = "change"];
  bool has_change() const;
  void clear_change() ;
  const ::aalyria::spacetime::api::common::ControlPlaneUpdate& change() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ControlPlaneUpdate* release_change();
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* mutable_change();
  void set_allocated_change(::aalyria::spacetime::api::common::ControlPlaneUpdate* change);
  private:
  const ::aalyria::spacetime::api::common::ControlPlaneUpdate& _internal_change() const;
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* _internal_mutable_change();
  public:
  void unsafe_arena_set_allocated_change(
      ::aalyria::spacetime::api::common::ControlPlaneUpdate* change);
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* unsafe_arena_release_change();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ScheduledControlUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact_;
    ::aalyria::spacetime::api::common::ControlPlaneUpdate* change_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class ScheduledControlDeletion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ScheduledControlDeletion) */ {
 public:
  inline ScheduledControlDeletion() : ScheduledControlDeletion(nullptr) {}
  ~ScheduledControlDeletion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScheduledControlDeletion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduledControlDeletion(const ScheduledControlDeletion& from);
  ScheduledControlDeletion(ScheduledControlDeletion&& from) noexcept
    : ScheduledControlDeletion() {
    *this = ::std::move(from);
  }

  inline ScheduledControlDeletion& operator=(const ScheduledControlDeletion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduledControlDeletion& operator=(ScheduledControlDeletion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduledControlDeletion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduledControlDeletion* internal_default_instance() {
    return reinterpret_cast<const ScheduledControlDeletion*>(
               &_ScheduledControlDeletion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ScheduledControlDeletion& a, ScheduledControlDeletion& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduledControlDeletion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduledControlDeletion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduledControlDeletion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduledControlDeletion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduledControlDeletion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduledControlDeletion& from) {
    ScheduledControlDeletion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduledControlDeletion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ScheduledControlDeletion";
  }
  protected:
  explicit ScheduledControlDeletion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIdsFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // repeated string update_ids = 2 [json_name = "updateIds"];
  int update_ids_size() const;
  private:
  int _internal_update_ids_size() const;

  public:
  void clear_update_ids() ;
  const std::string& update_ids(int index) const;
  std::string* mutable_update_ids(int index);
  void set_update_ids(int index, const std::string& value);
  void set_update_ids(int index, std::string&& value);
  void set_update_ids(int index, const char* value);
  void set_update_ids(int index, const char* value, std::size_t size);
  void set_update_ids(int index, absl::string_view value);
  std::string* add_update_ids();
  void add_update_ids(const std::string& value);
  void add_update_ids(std::string&& value);
  void add_update_ids(const char* value);
  void add_update_ids(const char* value, std::size_t size);
  void add_update_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& update_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_update_ids();

  private:
  const std::string& _internal_update_ids(int index) const;
  std::string* _internal_add_update_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_update_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_update_ids();

  public:
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ScheduledControlDeletion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> update_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class ScheduledControlUpdateStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ScheduledControlUpdateStatus) */ {
 public:
  inline ScheduledControlUpdateStatus() : ScheduledControlUpdateStatus(nullptr) {}
  ~ScheduledControlUpdateStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScheduledControlUpdateStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduledControlUpdateStatus(const ScheduledControlUpdateStatus& from);
  ScheduledControlUpdateStatus(ScheduledControlUpdateStatus&& from) noexcept
    : ScheduledControlUpdateStatus() {
    *this = ::std::move(from);
  }

  inline ScheduledControlUpdateStatus& operator=(const ScheduledControlUpdateStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduledControlUpdateStatus& operator=(ScheduledControlUpdateStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduledControlUpdateStatus& default_instance() {
    return *internal_default_instance();
  }
  enum StateCase {
    kScheduled = 4,
    kEnactmentAttempted = 6,
    kUnscheduled = 8,
    STATE_NOT_SET = 0,
  };

  static inline const ScheduledControlUpdateStatus* internal_default_instance() {
    return reinterpret_cast<const ScheduledControlUpdateStatus*>(
               &_ScheduledControlUpdateStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ScheduledControlUpdateStatus& a, ScheduledControlUpdateStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduledControlUpdateStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduledControlUpdateStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduledControlUpdateStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduledControlUpdateStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduledControlUpdateStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduledControlUpdateStatus& from) {
    ScheduledControlUpdateStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduledControlUpdateStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ScheduledControlUpdateStatus";
  }
  protected:
  explicit ScheduledControlUpdateStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIdFieldNumber = 1,
    kTimestampFieldNumber = 7,
    kScheduledFieldNumber = 4,
    kEnactmentAttemptedFieldNumber = 6,
    kUnscheduledFieldNumber = 8,
  };
  // optional string update_id = 1 [json_name = "updateId"];
  bool has_update_id() const;
  void clear_update_id() ;
  const std::string& update_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* ptr);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 7 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // .google.rpc.Status scheduled = 4 [json_name = "scheduled"];
  bool has_scheduled() const;
  private:
  bool _internal_has_scheduled() const;

  public:
  void clear_scheduled() ;
  const ::google::rpc::Status& scheduled() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_scheduled();
  ::google::rpc::Status* mutable_scheduled();
  void set_allocated_scheduled(::google::rpc::Status* scheduled);
  private:
  const ::google::rpc::Status& _internal_scheduled() const;
  ::google::rpc::Status* _internal_mutable_scheduled();
  public:
  void unsafe_arena_set_allocated_scheduled(
      ::google::rpc::Status* scheduled);
  ::google::rpc::Status* unsafe_arena_release_scheduled();
  // .google.rpc.Status enactment_attempted = 6 [json_name = "enactmentAttempted"];
  bool has_enactment_attempted() const;
  private:
  bool _internal_has_enactment_attempted() const;

  public:
  void clear_enactment_attempted() ;
  const ::google::rpc::Status& enactment_attempted() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_enactment_attempted();
  ::google::rpc::Status* mutable_enactment_attempted();
  void set_allocated_enactment_attempted(::google::rpc::Status* enactment_attempted);
  private:
  const ::google::rpc::Status& _internal_enactment_attempted() const;
  ::google::rpc::Status* _internal_mutable_enactment_attempted();
  public:
  void unsafe_arena_set_allocated_enactment_attempted(
      ::google::rpc::Status* enactment_attempted);
  ::google::rpc::Status* unsafe_arena_release_enactment_attempted();
  // .google.rpc.Status unscheduled = 8 [json_name = "unscheduled"];
  bool has_unscheduled() const;
  private:
  bool _internal_has_unscheduled() const;

  public:
  void clear_unscheduled() ;
  const ::google::rpc::Status& unscheduled() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_unscheduled();
  ::google::rpc::Status* mutable_unscheduled();
  void set_allocated_unscheduled(::google::rpc::Status* unscheduled);
  private:
  const ::google::rpc::Status& _internal_unscheduled() const;
  ::google::rpc::Status* _internal_mutable_unscheduled();
  public:
  void unsafe_arena_set_allocated_unscheduled(
      ::google::rpc::Status* unscheduled);
  ::google::rpc::Status* unsafe_arena_release_unscheduled();
  void clear_state();
  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ScheduledControlUpdateStatus)
 private:
  class _Internal;
  void set_has_scheduled();
  void set_has_enactment_attempted();
  void set_has_unscheduled();

  inline bool has_state() const;
  inline void clear_has_state();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_id_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    union StateUnion {
      constexpr StateUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::rpc::Status* scheduled_;
      ::google::rpc::Status* enactment_attempted_;
      ::google::rpc::Status* unscheduled_;
    } state_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class ControlPlaneUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ControlPlaneUpdate) */ {
 public:
  inline ControlPlaneUpdate() : ControlPlaneUpdate(nullptr) {}
  ~ControlPlaneUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlPlaneUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlPlaneUpdate(const ControlPlaneUpdate& from);
  ControlPlaneUpdate(ControlPlaneUpdate&& from) noexcept
    : ControlPlaneUpdate() {
    *this = ::std::move(from);
  }

  inline ControlPlaneUpdate& operator=(const ControlPlaneUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPlaneUpdate& operator=(ControlPlaneUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlPlaneUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum UpdateTypeCase {
    kBeamUpdate = 1,
    kRadioUpdate = 2,
    kFlowUpdate = 3,
    kTunnelUpdate = 4,
    UPDATE_TYPE_NOT_SET = 0,
  };

  static inline const ControlPlaneUpdate* internal_default_instance() {
    return reinterpret_cast<const ControlPlaneUpdate*>(
               &_ControlPlaneUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ControlPlaneUpdate& a, ControlPlaneUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPlaneUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlPlaneUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlPlaneUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlPlaneUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlPlaneUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlPlaneUpdate& from) {
    ControlPlaneUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPlaneUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ControlPlaneUpdate";
  }
  protected:
  explicit ControlPlaneUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeamUpdateFieldNumber = 1,
    kRadioUpdateFieldNumber = 2,
    kFlowUpdateFieldNumber = 3,
    kTunnelUpdateFieldNumber = 4,
  };
  // .aalyria.spacetime.api.common.BeamUpdate beam_update = 1 [json_name = "beamUpdate"];
  bool has_beam_update() const;
  private:
  bool _internal_has_beam_update() const;

  public:
  void clear_beam_update() ;
  const ::aalyria::spacetime::api::common::BeamUpdate& beam_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::BeamUpdate* release_beam_update();
  ::aalyria::spacetime::api::common::BeamUpdate* mutable_beam_update();
  void set_allocated_beam_update(::aalyria::spacetime::api::common::BeamUpdate* beam_update);
  private:
  const ::aalyria::spacetime::api::common::BeamUpdate& _internal_beam_update() const;
  ::aalyria::spacetime::api::common::BeamUpdate* _internal_mutable_beam_update();
  public:
  void unsafe_arena_set_allocated_beam_update(
      ::aalyria::spacetime::api::common::BeamUpdate* beam_update);
  ::aalyria::spacetime::api::common::BeamUpdate* unsafe_arena_release_beam_update();
  // .aalyria.spacetime.api.common.RadioUpdate radio_update = 2 [json_name = "radioUpdate"];
  bool has_radio_update() const;
  private:
  bool _internal_has_radio_update() const;

  public:
  void clear_radio_update() ;
  const ::aalyria::spacetime::api::common::RadioUpdate& radio_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioUpdate* release_radio_update();
  ::aalyria::spacetime::api::common::RadioUpdate* mutable_radio_update();
  void set_allocated_radio_update(::aalyria::spacetime::api::common::RadioUpdate* radio_update);
  private:
  const ::aalyria::spacetime::api::common::RadioUpdate& _internal_radio_update() const;
  ::aalyria::spacetime::api::common::RadioUpdate* _internal_mutable_radio_update();
  public:
  void unsafe_arena_set_allocated_radio_update(
      ::aalyria::spacetime::api::common::RadioUpdate* radio_update);
  ::aalyria::spacetime::api::common::RadioUpdate* unsafe_arena_release_radio_update();
  // .aalyria.spacetime.api.common.FlowUpdate flow_update = 3 [json_name = "flowUpdate"];
  bool has_flow_update() const;
  private:
  bool _internal_has_flow_update() const;

  public:
  void clear_flow_update() ;
  const ::aalyria::spacetime::api::common::FlowUpdate& flow_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowUpdate* release_flow_update();
  ::aalyria::spacetime::api::common::FlowUpdate* mutable_flow_update();
  void set_allocated_flow_update(::aalyria::spacetime::api::common::FlowUpdate* flow_update);
  private:
  const ::aalyria::spacetime::api::common::FlowUpdate& _internal_flow_update() const;
  ::aalyria::spacetime::api::common::FlowUpdate* _internal_mutable_flow_update();
  public:
  void unsafe_arena_set_allocated_flow_update(
      ::aalyria::spacetime::api::common::FlowUpdate* flow_update);
  ::aalyria::spacetime::api::common::FlowUpdate* unsafe_arena_release_flow_update();
  // .aalyria.spacetime.api.common.TunnelUpdate tunnel_update = 4 [json_name = "tunnelUpdate"];
  bool has_tunnel_update() const;
  private:
  bool _internal_has_tunnel_update() const;

  public:
  void clear_tunnel_update() ;
  const ::aalyria::spacetime::api::common::TunnelUpdate& tunnel_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TunnelUpdate* release_tunnel_update();
  ::aalyria::spacetime::api::common::TunnelUpdate* mutable_tunnel_update();
  void set_allocated_tunnel_update(::aalyria::spacetime::api::common::TunnelUpdate* tunnel_update);
  private:
  const ::aalyria::spacetime::api::common::TunnelUpdate& _internal_tunnel_update() const;
  ::aalyria::spacetime::api::common::TunnelUpdate* _internal_mutable_tunnel_update();
  public:
  void unsafe_arena_set_allocated_tunnel_update(
      ::aalyria::spacetime::api::common::TunnelUpdate* tunnel_update);
  ::aalyria::spacetime::api::common::TunnelUpdate* unsafe_arena_release_tunnel_update();
  void clear_update_type();
  UpdateTypeCase update_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ControlPlaneUpdate)
 private:
  class _Internal;
  void set_has_beam_update();
  void set_has_radio_update();
  void set_has_flow_update();
  void set_has_tunnel_update();

  inline bool has_update_type() const;
  inline void clear_has_update_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union UpdateTypeUnion {
      constexpr UpdateTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::BeamUpdate* beam_update_;
      ::aalyria::spacetime::api::common::RadioUpdate* radio_update_;
      ::aalyria::spacetime::api::common::FlowUpdate* flow_update_;
      ::aalyria::spacetime::api::common::TunnelUpdate* tunnel_update_;
    } update_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class ControlPlaneState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ControlPlaneState) */ {
 public:
  inline ControlPlaneState() : ControlPlaneState(nullptr) {}
  ~ControlPlaneState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlPlaneState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlPlaneState(const ControlPlaneState& from);
  ControlPlaneState(ControlPlaneState&& from) noexcept
    : ControlPlaneState() {
    *this = ::std::move(from);
  }

  inline ControlPlaneState& operator=(const ControlPlaneState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPlaneState& operator=(ControlPlaneState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlPlaneState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlPlaneState* internal_default_instance() {
    return reinterpret_cast<const ControlPlaneState*>(
               &_ControlPlaneState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ControlPlaneState& a, ControlPlaneState& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPlaneState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlPlaneState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlPlaneState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlPlaneState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlPlaneState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlPlaneState& from) {
    ControlPlaneState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPlaneState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ControlPlaneState";
  }
  protected:
  explicit ControlPlaneState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeamStatesFieldNumber = 2,
    kRadioStatesFieldNumber = 3,
    kForwardingStateFieldNumber = 5,
    kTunnelStatesFieldNumber = 6,
  };
  // optional .aalyria.spacetime.api.common.BeamStates beam_states = 2 [json_name = "beamStates"];
  bool has_beam_states() const;
  void clear_beam_states() ;
  const ::aalyria::spacetime::api::common::BeamStates& beam_states() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::BeamStates* release_beam_states();
  ::aalyria::spacetime::api::common::BeamStates* mutable_beam_states();
  void set_allocated_beam_states(::aalyria::spacetime::api::common::BeamStates* beam_states);
  private:
  const ::aalyria::spacetime::api::common::BeamStates& _internal_beam_states() const;
  ::aalyria::spacetime::api::common::BeamStates* _internal_mutable_beam_states();
  public:
  void unsafe_arena_set_allocated_beam_states(
      ::aalyria::spacetime::api::common::BeamStates* beam_states);
  ::aalyria::spacetime::api::common::BeamStates* unsafe_arena_release_beam_states();
  // optional .aalyria.spacetime.api.common.RadioStates radio_states = 3 [json_name = "radioStates"];
  bool has_radio_states() const;
  void clear_radio_states() ;
  const ::aalyria::spacetime::api::common::RadioStates& radio_states() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::RadioStates* release_radio_states();
  ::aalyria::spacetime::api::common::RadioStates* mutable_radio_states();
  void set_allocated_radio_states(::aalyria::spacetime::api::common::RadioStates* radio_states);
  private:
  const ::aalyria::spacetime::api::common::RadioStates& _internal_radio_states() const;
  ::aalyria::spacetime::api::common::RadioStates* _internal_mutable_radio_states();
  public:
  void unsafe_arena_set_allocated_radio_states(
      ::aalyria::spacetime::api::common::RadioStates* radio_states);
  ::aalyria::spacetime::api::common::RadioStates* unsafe_arena_release_radio_states();
  // optional .aalyria.spacetime.api.common.FlowState forwarding_state = 5 [json_name = "forwardingState"];
  bool has_forwarding_state() const;
  void clear_forwarding_state() ;
  const ::aalyria::spacetime::api::common::FlowState& forwarding_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowState* release_forwarding_state();
  ::aalyria::spacetime::api::common::FlowState* mutable_forwarding_state();
  void set_allocated_forwarding_state(::aalyria::spacetime::api::common::FlowState* forwarding_state);
  private:
  const ::aalyria::spacetime::api::common::FlowState& _internal_forwarding_state() const;
  ::aalyria::spacetime::api::common::FlowState* _internal_mutable_forwarding_state();
  public:
  void unsafe_arena_set_allocated_forwarding_state(
      ::aalyria::spacetime::api::common::FlowState* forwarding_state);
  ::aalyria::spacetime::api::common::FlowState* unsafe_arena_release_forwarding_state();
  // optional .aalyria.spacetime.api.common.TunnelStates tunnel_states = 6 [json_name = "tunnelStates"];
  bool has_tunnel_states() const;
  void clear_tunnel_states() ;
  const ::aalyria::spacetime::api::common::TunnelStates& tunnel_states() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TunnelStates* release_tunnel_states();
  ::aalyria::spacetime::api::common::TunnelStates* mutable_tunnel_states();
  void set_allocated_tunnel_states(::aalyria::spacetime::api::common::TunnelStates* tunnel_states);
  private:
  const ::aalyria::spacetime::api::common::TunnelStates& _internal_tunnel_states() const;
  ::aalyria::spacetime::api::common::TunnelStates* _internal_mutable_tunnel_states();
  public:
  void unsafe_arena_set_allocated_tunnel_states(
      ::aalyria::spacetime::api::common::TunnelStates* tunnel_states);
  ::aalyria::spacetime::api::common::TunnelStates* unsafe_arena_release_tunnel_states();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ControlPlaneState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::BeamStates* beam_states_;
    ::aalyria::spacetime::api::common::RadioStates* radio_states_;
    ::aalyria::spacetime::api::common::FlowState* forwarding_state_;
    ::aalyria::spacetime::api::common::TunnelStates* tunnel_states_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class ScheduledControlUpdateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.ScheduledControlUpdateReq) */ {
 public:
  inline ScheduledControlUpdateReq() : ScheduledControlUpdateReq(nullptr) {}
  ~ScheduledControlUpdateReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScheduledControlUpdateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduledControlUpdateReq(const ScheduledControlUpdateReq& from);
  ScheduledControlUpdateReq(ScheduledControlUpdateReq&& from) noexcept
    : ScheduledControlUpdateReq() {
    *this = ::std::move(from);
  }

  inline ScheduledControlUpdateReq& operator=(const ScheduledControlUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduledControlUpdateReq& operator=(ScheduledControlUpdateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduledControlUpdateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduledControlUpdateReq* internal_default_instance() {
    return reinterpret_cast<const ScheduledControlUpdateReq*>(
               &_ScheduledControlUpdateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScheduledControlUpdateReq& a, ScheduledControlUpdateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduledControlUpdateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduledControlUpdateReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduledControlUpdateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduledControlUpdateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduledControlUpdateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduledControlUpdateReq& from) {
    ScheduledControlUpdateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduledControlUpdateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.ScheduledControlUpdateReq";
  }
  protected:
  explicit ScheduledControlUpdateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompiledUpdateFieldNumber = 1,
    kCompletedFieldNumber = 8,
    kUnscheduledFieldNumber = 12,
    kScheduledFieldNumber = 11,
  };
  // optional .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_update = 1 [json_name = "compiledUpdate"];
  bool has_compiled_update() const;
  void clear_compiled_update() ;
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& compiled_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ScheduledControlUpdate* release_compiled_update();
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* mutable_compiled_update();
  void set_allocated_compiled_update(::aalyria::spacetime::api::common::ScheduledControlUpdate* compiled_update);
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& _internal_compiled_update() const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _internal_mutable_compiled_update();
  public:
  void unsafe_arena_set_allocated_compiled_update(
      ::aalyria::spacetime::api::common::ScheduledControlUpdate* compiled_update);
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* unsafe_arena_release_compiled_update();
  // optional .google.rpc.Status completed = 8 [json_name = "completed"];
  bool has_completed() const;
  void clear_completed() ;
  const ::google::rpc::Status& completed() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_completed();
  ::google::rpc::Status* mutable_completed();
  void set_allocated_completed(::google::rpc::Status* completed);
  private:
  const ::google::rpc::Status& _internal_completed() const;
  ::google::rpc::Status* _internal_mutable_completed();
  public:
  void unsafe_arena_set_allocated_completed(
      ::google::rpc::Status* completed);
  ::google::rpc::Status* unsafe_arena_release_completed();
  // optional .google.rpc.Status unscheduled = 12 [json_name = "unscheduled"];
  bool has_unscheduled() const;
  void clear_unscheduled() ;
  const ::google::rpc::Status& unscheduled() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_unscheduled();
  ::google::rpc::Status* mutable_unscheduled();
  void set_allocated_unscheduled(::google::rpc::Status* unscheduled);
  private:
  const ::google::rpc::Status& _internal_unscheduled() const;
  ::google::rpc::Status* _internal_mutable_unscheduled();
  public:
  void unsafe_arena_set_allocated_unscheduled(
      ::google::rpc::Status* unscheduled);
  ::google::rpc::Status* unsafe_arena_release_unscheduled();
  // optional bool scheduled = 11 [json_name = "scheduled"];
  bool has_scheduled() const;
  void clear_scheduled() ;
  bool scheduled() const;
  void set_scheduled(bool value);

  private:
  bool _internal_scheduled() const;
  void _internal_set_scheduled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.ScheduledControlUpdateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::ScheduledControlUpdate* compiled_update_;
    ::google::rpc::Status* completed_;
    ::google::rpc::Status* unscheduled_;
    bool scheduled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse, 
    ::uint32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse, 
    ::uint32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse& other);
  static const TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse*>(&_TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class TaskCdpiStreamCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.TaskCdpiStreamCount) */ {
 public:
  inline TaskCdpiStreamCount() : TaskCdpiStreamCount(nullptr) {}
  ~TaskCdpiStreamCount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskCdpiStreamCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskCdpiStreamCount(const TaskCdpiStreamCount& from);
  TaskCdpiStreamCount(TaskCdpiStreamCount&& from) noexcept
    : TaskCdpiStreamCount() {
    *this = ::std::move(from);
  }

  inline TaskCdpiStreamCount& operator=(const TaskCdpiStreamCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskCdpiStreamCount& operator=(TaskCdpiStreamCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskCdpiStreamCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskCdpiStreamCount* internal_default_instance() {
    return reinterpret_cast<const TaskCdpiStreamCount*>(
               &_TaskCdpiStreamCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TaskCdpiStreamCount& a, TaskCdpiStreamCount& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskCdpiStreamCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskCdpiStreamCount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskCdpiStreamCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskCdpiStreamCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskCdpiStreamCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskCdpiStreamCount& from) {
    TaskCdpiStreamCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskCdpiStreamCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.TaskCdpiStreamCount";
  }
  protected:
  explicit TaskCdpiStreamCount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStreamCountPerPriorityFieldNumber = 1,
  };
  // map<uint32, int32> stream_count_per_priority = 1 [json_name = "streamCountPerPriority"];
  int stream_count_per_priority_size() const;
  private:
  int _internal_stream_count_per_priority_size() const;

  public:
  void clear_stream_count_per_priority() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
      _internal_stream_count_per_priority() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
      _internal_mutable_stream_count_per_priority();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
      stream_count_per_priority() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
      mutable_stream_count_per_priority();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.TaskCdpiStreamCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TaskCdpiStreamCount_StreamCountPerPriorityEntry_DoNotUse,
        ::uint32_t, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> stream_count_per_priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse& other);
  static const CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse*>(&_CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.CdpiFrontendInfo.StreamCountPerNodeEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class CdpiFrontendInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.CdpiFrontendInfo) */ {
 public:
  inline CdpiFrontendInfo() : CdpiFrontendInfo(nullptr) {}
  ~CdpiFrontendInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiFrontendInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiFrontendInfo(const CdpiFrontendInfo& from);
  CdpiFrontendInfo(CdpiFrontendInfo&& from) noexcept
    : CdpiFrontendInfo() {
    *this = ::std::move(from);
  }

  inline CdpiFrontendInfo& operator=(const CdpiFrontendInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiFrontendInfo& operator=(CdpiFrontendInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiFrontendInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiFrontendInfo* internal_default_instance() {
    return reinterpret_cast<const CdpiFrontendInfo*>(
               &_CdpiFrontendInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CdpiFrontendInfo& a, CdpiFrontendInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiFrontendInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiFrontendInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiFrontendInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiFrontendInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiFrontendInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiFrontendInfo& from) {
    CdpiFrontendInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiFrontendInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.CdpiFrontendInfo";
  }
  protected:
  explicit CdpiFrontendInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStreamCountPerNodeFieldNumber = 1,
  };
  // map<string, .aalyria.spacetime.api.common.TaskCdpiStreamCount> stream_count_per_node = 1 [json_name = "streamCountPerNode"];
  int stream_count_per_node_size() const;
  private:
  int _internal_stream_count_per_node_size() const;

  public:
  void clear_stream_count_per_node() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
      _internal_stream_count_per_node() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
      _internal_mutable_stream_count_per_node();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
      stream_count_per_node() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
      mutable_stream_count_per_node();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.CdpiFrontendInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CdpiFrontendInfo_StreamCountPerNodeEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> stream_count_per_node_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};// -------------------------------------------------------------------

class CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse, 
    std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse& other);
  static const CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse*>(&_CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.common.CdpiStreamInfo.StreamCountPerTaskEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse, 
    ::uint32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse, 
    ::uint32_t, ::int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse& other);
  static const CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse*>(&_CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class CdpiStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.CdpiStreamInfo) */ {
 public:
  inline CdpiStreamInfo() : CdpiStreamInfo(nullptr) {}
  ~CdpiStreamInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiStreamInfo(const CdpiStreamInfo& from);
  CdpiStreamInfo(CdpiStreamInfo&& from) noexcept
    : CdpiStreamInfo() {
    *this = ::std::move(from);
  }

  inline CdpiStreamInfo& operator=(const CdpiStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiStreamInfo& operator=(CdpiStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiStreamInfo* internal_default_instance() {
    return reinterpret_cast<const CdpiStreamInfo*>(
               &_CdpiStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CdpiStreamInfo& a, CdpiStreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiStreamInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiStreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiStreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiStreamInfo& from) {
    CdpiStreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.CdpiStreamInfo";
  }
  protected:
  explicit CdpiStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStreamCountPerTaskFieldNumber = 2,
    kStreamCountPerPriorityFieldNumber = 3,
  };
  // map<string, .aalyria.spacetime.api.common.TaskCdpiStreamCount> stream_count_per_task = 2 [json_name = "streamCountPerTask"];
  int stream_count_per_task_size() const;
  private:
  int _internal_stream_count_per_task_size() const;

  public:
  void clear_stream_count_per_task() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
      _internal_stream_count_per_task() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
      _internal_mutable_stream_count_per_task();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
      stream_count_per_task() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
      mutable_stream_count_per_task();
  // map<uint32, int32> stream_count_per_priority = 3 [json_name = "streamCountPerPriority"];
  int stream_count_per_priority_size() const;
  private:
  int _internal_stream_count_per_priority_size() const;

  public:
  void clear_stream_count_per_priority() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
      _internal_stream_count_per_priority() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
      _internal_mutable_stream_count_per_priority();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
      stream_count_per_priority() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
      mutable_stream_count_per_priority();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.CdpiStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CdpiStreamInfo_StreamCountPerTaskEntry_DoNotUse,
        std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> stream_count_per_task_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CdpiStreamInfo_StreamCountPerPriorityEntry_DoNotUse,
        ::uint32_t, ::int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> stream_count_per_priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fcontrol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ScheduledControlUpdate

// optional string node_id = 1 [json_name = "nodeId"];
inline bool ScheduledControlUpdate::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ScheduledControlUpdate::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScheduledControlUpdate::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdate.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScheduledControlUpdate::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlUpdate.node_id)
}
inline std::string* ScheduledControlUpdate::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdate.node_id)
  return _s;
}
inline const std::string& ScheduledControlUpdate::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void ScheduledControlUpdate::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdate::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdate::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdate.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScheduledControlUpdate::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.node_id)
}

// optional string update_id = 2 [json_name = "updateId"];
inline bool ScheduledControlUpdate::has_update_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ScheduledControlUpdate::clear_update_id() {
  _impl_.update_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScheduledControlUpdate::update_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdate.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScheduledControlUpdate::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlUpdate.update_id)
}
inline std::string* ScheduledControlUpdate::mutable_update_id() {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdate.update_id)
  return _s;
}
inline const std::string& ScheduledControlUpdate::_internal_update_id() const {
  return _impl_.update_id_.Get();
}
inline void ScheduledControlUpdate::_internal_set_update_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.update_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdate::_internal_mutable_update_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.update_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdate::release_update_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdate.update_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.update_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.update_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScheduledControlUpdate::set_allocated_update_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.update_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_id_.IsDefault()) {
          _impl_.update_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.update_id)
}

// optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
inline bool ScheduledControlUpdate::has_time_to_enact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_to_enact_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ScheduledControlUpdate::_internal_time_to_enact() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_to_enact_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ScheduledControlUpdate::time_to_enact() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdate.time_to_enact)
  return _internal_time_to_enact();
}
inline void ScheduledControlUpdate::unsafe_arena_set_allocated_time_to_enact(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_enact_);
  }
  _impl_.time_to_enact_ = time_to_enact;
  if (time_to_enact) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.time_to_enact)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ScheduledControlUpdate::release_time_to_enact() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_to_enact_;
  _impl_.time_to_enact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ScheduledControlUpdate::unsafe_arena_release_time_to_enact() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdate.time_to_enact)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_to_enact_;
  _impl_.time_to_enact_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ScheduledControlUpdate::_internal_mutable_time_to_enact() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_to_enact_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_to_enact_ = p;
  }
  return _impl_.time_to_enact_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ScheduledControlUpdate::mutable_time_to_enact() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_to_enact();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdate.time_to_enact)
  return _msg;
}
inline void ScheduledControlUpdate::set_allocated_time_to_enact(::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_enact_);
  }
  if (time_to_enact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_to_enact));
    if (message_arena != submessage_arena) {
      time_to_enact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_to_enact, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.time_to_enact_ = time_to_enact;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.time_to_enact)
}

// optional .aalyria.spacetime.api.common.ControlPlaneUpdate change = 4 [json_name = "change"];
inline bool ScheduledControlUpdate::has_change() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_ != nullptr);
  return value;
}
inline void ScheduledControlUpdate::clear_change() {
  if (_impl_.change_ != nullptr) _impl_.change_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::ControlPlaneUpdate& ScheduledControlUpdate::_internal_change() const {
  const ::aalyria::spacetime::api::common::ControlPlaneUpdate* p = _impl_.change_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ControlPlaneUpdate&>(
      ::aalyria::spacetime::api::common::_ControlPlaneUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ControlPlaneUpdate& ScheduledControlUpdate::change() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdate.change)
  return _internal_change();
}
inline void ScheduledControlUpdate::unsafe_arena_set_allocated_change(
    ::aalyria::spacetime::api::common::ControlPlaneUpdate* change) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_);
  }
  _impl_.change_ = change;
  if (change) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.change)
}
inline ::aalyria::spacetime::api::common::ControlPlaneUpdate* ScheduledControlUpdate::release_change() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* temp = _impl_.change_;
  _impl_.change_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneUpdate* ScheduledControlUpdate::unsafe_arena_release_change() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdate.change)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* temp = _impl_.change_;
  _impl_.change_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneUpdate* ScheduledControlUpdate::_internal_mutable_change() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.change_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ControlPlaneUpdate>(GetArenaForAllocation());
    _impl_.change_ = p;
  }
  return _impl_.change_;
}
inline ::aalyria::spacetime::api::common::ControlPlaneUpdate* ScheduledControlUpdate::mutable_change() {
  ::aalyria::spacetime::api::common::ControlPlaneUpdate* _msg = _internal_mutable_change();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdate.change)
  return _msg;
}
inline void ScheduledControlUpdate::set_allocated_change(::aalyria::spacetime::api::common::ControlPlaneUpdate* change) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.change_;
  }
  if (change) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change);
    if (message_arena != submessage_arena) {
      change = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.change_ = change;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdate.change)
}

// -------------------------------------------------------------------

// ScheduledControlDeletion

// optional string node_id = 1 [json_name = "nodeId"];
inline bool ScheduledControlDeletion::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ScheduledControlDeletion::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScheduledControlDeletion::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlDeletion.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScheduledControlDeletion::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlDeletion.node_id)
}
inline std::string* ScheduledControlDeletion::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlDeletion.node_id)
  return _s;
}
inline const std::string& ScheduledControlDeletion::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void ScheduledControlDeletion::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduledControlDeletion::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ScheduledControlDeletion::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlDeletion.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScheduledControlDeletion::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlDeletion.node_id)
}

// repeated string update_ids = 2 [json_name = "updateIds"];
inline int ScheduledControlDeletion::_internal_update_ids_size() const {
  return _impl_.update_ids_.size();
}
inline int ScheduledControlDeletion::update_ids_size() const {
  return _internal_update_ids_size();
}
inline void ScheduledControlDeletion::clear_update_ids() {
  _internal_mutable_update_ids()->Clear();
}
inline std::string* ScheduledControlDeletion::add_update_ids() {
  std::string* _s = _internal_add_update_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
  return _s;
}
inline const std::string& ScheduledControlDeletion::update_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
  return _internal_update_ids(index);
}
inline std::string* ScheduledControlDeletion::mutable_update_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
  return _internal_mutable_update_ids()->Mutable(index);
}
inline void ScheduledControlDeletion::set_update_ids(int index, const std::string& value) {
  _internal_mutable_update_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::set_update_ids(int index, std::string&& value) {
  _internal_mutable_update_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::set_update_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_update_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::set_update_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_update_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::set_update_ids(int index, absl::string_view value) {
  _internal_mutable_update_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::add_update_ids(const std::string& value) {
  _internal_mutable_update_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::add_update_ids(std::string&& value) {
  _internal_mutable_update_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::add_update_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_update_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::add_update_ids(const char* value, std::size_t size) {
  _internal_mutable_update_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline void ScheduledControlDeletion::add_update_ids(absl::string_view value) {
  _internal_mutable_update_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScheduledControlDeletion::update_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
  return _internal_update_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ScheduledControlDeletion::mutable_update_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.ScheduledControlDeletion.update_ids)
  return _internal_mutable_update_ids();
}
inline const std::string& ScheduledControlDeletion::_internal_update_ids(int index) const {
  return _internal_update_ids().Get(index);
}
inline std::string* ScheduledControlDeletion::_internal_add_update_ids() {
  return _internal_mutable_update_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScheduledControlDeletion::_internal_update_ids() const {
  return _impl_.update_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ScheduledControlDeletion::_internal_mutable_update_ids() {
  return &_impl_.update_ids_;
}

// -------------------------------------------------------------------

// ScheduledControlUpdateStatus

// optional string update_id = 1 [json_name = "updateId"];
inline bool ScheduledControlUpdateStatus::has_update_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ScheduledControlUpdateStatus::clear_update_id() {
  _impl_.update_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScheduledControlUpdateStatus::update_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScheduledControlUpdateStatus::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.update_id)
}
inline std::string* ScheduledControlUpdateStatus::mutable_update_id() {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.update_id)
  return _s;
}
inline const std::string& ScheduledControlUpdateStatus::_internal_update_id() const {
  return _impl_.update_id_.Get();
}
inline void ScheduledControlUpdateStatus::_internal_set_update_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.update_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdateStatus::_internal_mutable_update_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.update_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ScheduledControlUpdateStatus::release_update_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.update_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.update_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.update_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ScheduledControlUpdateStatus::set_allocated_update_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.update_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_id_.IsDefault()) {
          _impl_.update_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.update_id)
}

// optional .aalyria.spacetime.api.common.DateTime timestamp = 7 [json_name = "timestamp"];
inline bool ScheduledControlUpdateStatus::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& ScheduledControlUpdateStatus::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& ScheduledControlUpdateStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.timestamp)
  return _internal_timestamp();
}
inline void ScheduledControlUpdateStatus::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* ScheduledControlUpdateStatus::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* ScheduledControlUpdateStatus::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.timestamp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* ScheduledControlUpdateStatus::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* ScheduledControlUpdateStatus::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.timestamp)
  return _msg;
}
inline void ScheduledControlUpdateStatus::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.timestamp)
}

// .google.rpc.Status scheduled = 4 [json_name = "scheduled"];
inline bool ScheduledControlUpdateStatus::has_scheduled() const {
  return state_case() == kScheduled;
}
inline bool ScheduledControlUpdateStatus::_internal_has_scheduled() const {
  return state_case() == kScheduled;
}
inline void ScheduledControlUpdateStatus::set_has_scheduled() {
  _impl_._oneof_case_[0] = kScheduled;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::release_scheduled() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.scheduled)
  if (state_case() == kScheduled) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.scheduled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.scheduled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::_internal_scheduled() const {
  return state_case() == kScheduled
      ? *_impl_.state_.scheduled_
      : reinterpret_cast<::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::scheduled() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.scheduled)
  return _internal_scheduled();
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::unsafe_arena_release_scheduled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.scheduled)
  if (state_case() == kScheduled) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.scheduled_;
    _impl_.state_.scheduled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScheduledControlUpdateStatus::unsafe_arena_set_allocated_scheduled(::google::rpc::Status* scheduled) {
  clear_state();
  if (scheduled) {
    set_has_scheduled();
    _impl_.state_.scheduled_ = scheduled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.scheduled)
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::_internal_mutable_scheduled() {
  if (state_case() != kScheduled) {
    clear_state();
    set_has_scheduled();
    _impl_.state_.scheduled_ = CreateMaybeMessage< ::google::rpc::Status >(GetArenaForAllocation());
  }
  return _impl_.state_.scheduled_;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::mutable_scheduled() {
  ::google::rpc::Status* _msg = _internal_mutable_scheduled();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.scheduled)
  return _msg;
}

// .google.rpc.Status enactment_attempted = 6 [json_name = "enactmentAttempted"];
inline bool ScheduledControlUpdateStatus::has_enactment_attempted() const {
  return state_case() == kEnactmentAttempted;
}
inline bool ScheduledControlUpdateStatus::_internal_has_enactment_attempted() const {
  return state_case() == kEnactmentAttempted;
}
inline void ScheduledControlUpdateStatus::set_has_enactment_attempted() {
  _impl_._oneof_case_[0] = kEnactmentAttempted;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::release_enactment_attempted() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.enactment_attempted)
  if (state_case() == kEnactmentAttempted) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.enactment_attempted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.enactment_attempted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::_internal_enactment_attempted() const {
  return state_case() == kEnactmentAttempted
      ? *_impl_.state_.enactment_attempted_
      : reinterpret_cast<::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::enactment_attempted() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.enactment_attempted)
  return _internal_enactment_attempted();
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::unsafe_arena_release_enactment_attempted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.enactment_attempted)
  if (state_case() == kEnactmentAttempted) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.enactment_attempted_;
    _impl_.state_.enactment_attempted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScheduledControlUpdateStatus::unsafe_arena_set_allocated_enactment_attempted(::google::rpc::Status* enactment_attempted) {
  clear_state();
  if (enactment_attempted) {
    set_has_enactment_attempted();
    _impl_.state_.enactment_attempted_ = enactment_attempted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.enactment_attempted)
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::_internal_mutable_enactment_attempted() {
  if (state_case() != kEnactmentAttempted) {
    clear_state();
    set_has_enactment_attempted();
    _impl_.state_.enactment_attempted_ = CreateMaybeMessage< ::google::rpc::Status >(GetArenaForAllocation());
  }
  return _impl_.state_.enactment_attempted_;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::mutable_enactment_attempted() {
  ::google::rpc::Status* _msg = _internal_mutable_enactment_attempted();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.enactment_attempted)
  return _msg;
}

// .google.rpc.Status unscheduled = 8 [json_name = "unscheduled"];
inline bool ScheduledControlUpdateStatus::has_unscheduled() const {
  return state_case() == kUnscheduled;
}
inline bool ScheduledControlUpdateStatus::_internal_has_unscheduled() const {
  return state_case() == kUnscheduled;
}
inline void ScheduledControlUpdateStatus::set_has_unscheduled() {
  _impl_._oneof_case_[0] = kUnscheduled;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::release_unscheduled() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.unscheduled)
  if (state_case() == kUnscheduled) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.unscheduled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.state_.unscheduled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::_internal_unscheduled() const {
  return state_case() == kUnscheduled
      ? *_impl_.state_.unscheduled_
      : reinterpret_cast<::google::rpc::Status&>(::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ScheduledControlUpdateStatus::unscheduled() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.unscheduled)
  return _internal_unscheduled();
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::unsafe_arena_release_unscheduled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.unscheduled)
  if (state_case() == kUnscheduled) {
    clear_has_state();
    ::google::rpc::Status* temp = _impl_.state_.unscheduled_;
    _impl_.state_.unscheduled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScheduledControlUpdateStatus::unsafe_arena_set_allocated_unscheduled(::google::rpc::Status* unscheduled) {
  clear_state();
  if (unscheduled) {
    set_has_unscheduled();
    _impl_.state_.unscheduled_ = unscheduled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.unscheduled)
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::_internal_mutable_unscheduled() {
  if (state_case() != kUnscheduled) {
    clear_state();
    set_has_unscheduled();
    _impl_.state_.unscheduled_ = CreateMaybeMessage< ::google::rpc::Status >(GetArenaForAllocation());
  }
  return _impl_.state_.unscheduled_;
}
inline ::google::rpc::Status* ScheduledControlUpdateStatus::mutable_unscheduled() {
  ::google::rpc::Status* _msg = _internal_mutable_unscheduled();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateStatus.unscheduled)
  return _msg;
}

inline bool ScheduledControlUpdateStatus::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void ScheduledControlUpdateStatus::clear_has_state() {
  _impl_._oneof_case_[0] = STATE_NOT_SET;
}
inline ScheduledControlUpdateStatus::StateCase ScheduledControlUpdateStatus::state_case() const {
  return ScheduledControlUpdateStatus::StateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlPlaneUpdate

// .aalyria.spacetime.api.common.BeamUpdate beam_update = 1 [json_name = "beamUpdate"];
inline bool ControlPlaneUpdate::has_beam_update() const {
  return update_type_case() == kBeamUpdate;
}
inline bool ControlPlaneUpdate::_internal_has_beam_update() const {
  return update_type_case() == kBeamUpdate;
}
inline void ControlPlaneUpdate::set_has_beam_update() {
  _impl_._oneof_case_[0] = kBeamUpdate;
}
inline ::aalyria::spacetime::api::common::BeamUpdate* ControlPlaneUpdate::release_beam_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneUpdate.beam_update)
  if (update_type_case() == kBeamUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::BeamUpdate* temp = _impl_.update_type_.beam_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_type_.beam_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::BeamUpdate& ControlPlaneUpdate::_internal_beam_update() const {
  return update_type_case() == kBeamUpdate
      ? *_impl_.update_type_.beam_update_
      : reinterpret_cast<::aalyria::spacetime::api::common::BeamUpdate&>(::aalyria::spacetime::api::common::_BeamUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::BeamUpdate& ControlPlaneUpdate::beam_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneUpdate.beam_update)
  return _internal_beam_update();
}
inline ::aalyria::spacetime::api::common::BeamUpdate* ControlPlaneUpdate::unsafe_arena_release_beam_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ControlPlaneUpdate.beam_update)
  if (update_type_case() == kBeamUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::BeamUpdate* temp = _impl_.update_type_.beam_update_;
    _impl_.update_type_.beam_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlPlaneUpdate::unsafe_arena_set_allocated_beam_update(::aalyria::spacetime::api::common::BeamUpdate* beam_update) {
  clear_update_type();
  if (beam_update) {
    set_has_beam_update();
    _impl_.update_type_.beam_update_ = beam_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneUpdate.beam_update)
}
inline ::aalyria::spacetime::api::common::BeamUpdate* ControlPlaneUpdate::_internal_mutable_beam_update() {
  if (update_type_case() != kBeamUpdate) {
    clear_update_type();
    set_has_beam_update();
    _impl_.update_type_.beam_update_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::BeamUpdate >(GetArenaForAllocation());
  }
  return _impl_.update_type_.beam_update_;
}
inline ::aalyria::spacetime::api::common::BeamUpdate* ControlPlaneUpdate::mutable_beam_update() {
  ::aalyria::spacetime::api::common::BeamUpdate* _msg = _internal_mutable_beam_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneUpdate.beam_update)
  return _msg;
}

// .aalyria.spacetime.api.common.RadioUpdate radio_update = 2 [json_name = "radioUpdate"];
inline bool ControlPlaneUpdate::has_radio_update() const {
  return update_type_case() == kRadioUpdate;
}
inline bool ControlPlaneUpdate::_internal_has_radio_update() const {
  return update_type_case() == kRadioUpdate;
}
inline void ControlPlaneUpdate::set_has_radio_update() {
  _impl_._oneof_case_[0] = kRadioUpdate;
}
inline ::aalyria::spacetime::api::common::RadioUpdate* ControlPlaneUpdate::release_radio_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneUpdate.radio_update)
  if (update_type_case() == kRadioUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::RadioUpdate* temp = _impl_.update_type_.radio_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_type_.radio_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::RadioUpdate& ControlPlaneUpdate::_internal_radio_update() const {
  return update_type_case() == kRadioUpdate
      ? *_impl_.update_type_.radio_update_
      : reinterpret_cast<::aalyria::spacetime::api::common::RadioUpdate&>(::aalyria::spacetime::api::common::_RadioUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioUpdate& ControlPlaneUpdate::radio_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneUpdate.radio_update)
  return _internal_radio_update();
}
inline ::aalyria::spacetime::api::common::RadioUpdate* ControlPlaneUpdate::unsafe_arena_release_radio_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ControlPlaneUpdate.radio_update)
  if (update_type_case() == kRadioUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::RadioUpdate* temp = _impl_.update_type_.radio_update_;
    _impl_.update_type_.radio_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlPlaneUpdate::unsafe_arena_set_allocated_radio_update(::aalyria::spacetime::api::common::RadioUpdate* radio_update) {
  clear_update_type();
  if (radio_update) {
    set_has_radio_update();
    _impl_.update_type_.radio_update_ = radio_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneUpdate.radio_update)
}
inline ::aalyria::spacetime::api::common::RadioUpdate* ControlPlaneUpdate::_internal_mutable_radio_update() {
  if (update_type_case() != kRadioUpdate) {
    clear_update_type();
    set_has_radio_update();
    _impl_.update_type_.radio_update_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::RadioUpdate >(GetArenaForAllocation());
  }
  return _impl_.update_type_.radio_update_;
}
inline ::aalyria::spacetime::api::common::RadioUpdate* ControlPlaneUpdate::mutable_radio_update() {
  ::aalyria::spacetime::api::common::RadioUpdate* _msg = _internal_mutable_radio_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneUpdate.radio_update)
  return _msg;
}

// .aalyria.spacetime.api.common.FlowUpdate flow_update = 3 [json_name = "flowUpdate"];
inline bool ControlPlaneUpdate::has_flow_update() const {
  return update_type_case() == kFlowUpdate;
}
inline bool ControlPlaneUpdate::_internal_has_flow_update() const {
  return update_type_case() == kFlowUpdate;
}
inline void ControlPlaneUpdate::set_has_flow_update() {
  _impl_._oneof_case_[0] = kFlowUpdate;
}
inline ::aalyria::spacetime::api::common::FlowUpdate* ControlPlaneUpdate::release_flow_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneUpdate.flow_update)
  if (update_type_case() == kFlowUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::FlowUpdate* temp = _impl_.update_type_.flow_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_type_.flow_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::FlowUpdate& ControlPlaneUpdate::_internal_flow_update() const {
  return update_type_case() == kFlowUpdate
      ? *_impl_.update_type_.flow_update_
      : reinterpret_cast<::aalyria::spacetime::api::common::FlowUpdate&>(::aalyria::spacetime::api::common::_FlowUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowUpdate& ControlPlaneUpdate::flow_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneUpdate.flow_update)
  return _internal_flow_update();
}
inline ::aalyria::spacetime::api::common::FlowUpdate* ControlPlaneUpdate::unsafe_arena_release_flow_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ControlPlaneUpdate.flow_update)
  if (update_type_case() == kFlowUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::FlowUpdate* temp = _impl_.update_type_.flow_update_;
    _impl_.update_type_.flow_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlPlaneUpdate::unsafe_arena_set_allocated_flow_update(::aalyria::spacetime::api::common::FlowUpdate* flow_update) {
  clear_update_type();
  if (flow_update) {
    set_has_flow_update();
    _impl_.update_type_.flow_update_ = flow_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneUpdate.flow_update)
}
inline ::aalyria::spacetime::api::common::FlowUpdate* ControlPlaneUpdate::_internal_mutable_flow_update() {
  if (update_type_case() != kFlowUpdate) {
    clear_update_type();
    set_has_flow_update();
    _impl_.update_type_.flow_update_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::FlowUpdate >(GetArenaForAllocation());
  }
  return _impl_.update_type_.flow_update_;
}
inline ::aalyria::spacetime::api::common::FlowUpdate* ControlPlaneUpdate::mutable_flow_update() {
  ::aalyria::spacetime::api::common::FlowUpdate* _msg = _internal_mutable_flow_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneUpdate.flow_update)
  return _msg;
}

// .aalyria.spacetime.api.common.TunnelUpdate tunnel_update = 4 [json_name = "tunnelUpdate"];
inline bool ControlPlaneUpdate::has_tunnel_update() const {
  return update_type_case() == kTunnelUpdate;
}
inline bool ControlPlaneUpdate::_internal_has_tunnel_update() const {
  return update_type_case() == kTunnelUpdate;
}
inline void ControlPlaneUpdate::set_has_tunnel_update() {
  _impl_._oneof_case_[0] = kTunnelUpdate;
}
inline ::aalyria::spacetime::api::common::TunnelUpdate* ControlPlaneUpdate::release_tunnel_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneUpdate.tunnel_update)
  if (update_type_case() == kTunnelUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::TunnelUpdate* temp = _impl_.update_type_.tunnel_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.update_type_.tunnel_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::TunnelUpdate& ControlPlaneUpdate::_internal_tunnel_update() const {
  return update_type_case() == kTunnelUpdate
      ? *_impl_.update_type_.tunnel_update_
      : reinterpret_cast<::aalyria::spacetime::api::common::TunnelUpdate&>(::aalyria::spacetime::api::common::_TunnelUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TunnelUpdate& ControlPlaneUpdate::tunnel_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneUpdate.tunnel_update)
  return _internal_tunnel_update();
}
inline ::aalyria::spacetime::api::common::TunnelUpdate* ControlPlaneUpdate::unsafe_arena_release_tunnel_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.ControlPlaneUpdate.tunnel_update)
  if (update_type_case() == kTunnelUpdate) {
    clear_has_update_type();
    ::aalyria::spacetime::api::common::TunnelUpdate* temp = _impl_.update_type_.tunnel_update_;
    _impl_.update_type_.tunnel_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlPlaneUpdate::unsafe_arena_set_allocated_tunnel_update(::aalyria::spacetime::api::common::TunnelUpdate* tunnel_update) {
  clear_update_type();
  if (tunnel_update) {
    set_has_tunnel_update();
    _impl_.update_type_.tunnel_update_ = tunnel_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneUpdate.tunnel_update)
}
inline ::aalyria::spacetime::api::common::TunnelUpdate* ControlPlaneUpdate::_internal_mutable_tunnel_update() {
  if (update_type_case() != kTunnelUpdate) {
    clear_update_type();
    set_has_tunnel_update();
    _impl_.update_type_.tunnel_update_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::TunnelUpdate >(GetArenaForAllocation());
  }
  return _impl_.update_type_.tunnel_update_;
}
inline ::aalyria::spacetime::api::common::TunnelUpdate* ControlPlaneUpdate::mutable_tunnel_update() {
  ::aalyria::spacetime::api::common::TunnelUpdate* _msg = _internal_mutable_tunnel_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneUpdate.tunnel_update)
  return _msg;
}

inline bool ControlPlaneUpdate::has_update_type() const {
  return update_type_case() != UPDATE_TYPE_NOT_SET;
}
inline void ControlPlaneUpdate::clear_has_update_type() {
  _impl_._oneof_case_[0] = UPDATE_TYPE_NOT_SET;
}
inline ControlPlaneUpdate::UpdateTypeCase ControlPlaneUpdate::update_type_case() const {
  return ControlPlaneUpdate::UpdateTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlPlaneState

// optional .aalyria.spacetime.api.common.BeamStates beam_states = 2 [json_name = "beamStates"];
inline bool ControlPlaneState::has_beam_states() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.beam_states_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::BeamStates& ControlPlaneState::_internal_beam_states() const {
  const ::aalyria::spacetime::api::common::BeamStates* p = _impl_.beam_states_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::BeamStates&>(
      ::aalyria::spacetime::api::common::_BeamStates_default_instance_);
}
inline const ::aalyria::spacetime::api::common::BeamStates& ControlPlaneState::beam_states() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneState.beam_states)
  return _internal_beam_states();
}
inline void ControlPlaneState::unsafe_arena_set_allocated_beam_states(
    ::aalyria::spacetime::api::common::BeamStates* beam_states) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.beam_states_);
  }
  _impl_.beam_states_ = beam_states;
  if (beam_states) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.beam_states)
}
inline ::aalyria::spacetime::api::common::BeamStates* ControlPlaneState::release_beam_states() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::BeamStates* temp = _impl_.beam_states_;
  _impl_.beam_states_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStates* ControlPlaneState::unsafe_arena_release_beam_states() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneState.beam_states)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::BeamStates* temp = _impl_.beam_states_;
  _impl_.beam_states_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::BeamStates* ControlPlaneState::_internal_mutable_beam_states() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.beam_states_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::BeamStates>(GetArenaForAllocation());
    _impl_.beam_states_ = p;
  }
  return _impl_.beam_states_;
}
inline ::aalyria::spacetime::api::common::BeamStates* ControlPlaneState::mutable_beam_states() {
  ::aalyria::spacetime::api::common::BeamStates* _msg = _internal_mutable_beam_states();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneState.beam_states)
  return _msg;
}
inline void ControlPlaneState::set_allocated_beam_states(::aalyria::spacetime::api::common::BeamStates* beam_states) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.beam_states_);
  }
  if (beam_states) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beam_states));
    if (message_arena != submessage_arena) {
      beam_states = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, beam_states, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.beam_states_ = beam_states;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.beam_states)
}

// optional .aalyria.spacetime.api.common.RadioStates radio_states = 3 [json_name = "radioStates"];
inline bool ControlPlaneState::has_radio_states() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radio_states_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::RadioStates& ControlPlaneState::_internal_radio_states() const {
  const ::aalyria::spacetime::api::common::RadioStates* p = _impl_.radio_states_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::RadioStates&>(
      ::aalyria::spacetime::api::common::_RadioStates_default_instance_);
}
inline const ::aalyria::spacetime::api::common::RadioStates& ControlPlaneState::radio_states() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneState.radio_states)
  return _internal_radio_states();
}
inline void ControlPlaneState::unsafe_arena_set_allocated_radio_states(
    ::aalyria::spacetime::api::common::RadioStates* radio_states) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.radio_states_);
  }
  _impl_.radio_states_ = radio_states;
  if (radio_states) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.radio_states)
}
inline ::aalyria::spacetime::api::common::RadioStates* ControlPlaneState::release_radio_states() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::RadioStates* temp = _impl_.radio_states_;
  _impl_.radio_states_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioStates* ControlPlaneState::unsafe_arena_release_radio_states() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneState.radio_states)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::RadioStates* temp = _impl_.radio_states_;
  _impl_.radio_states_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::RadioStates* ControlPlaneState::_internal_mutable_radio_states() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.radio_states_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::RadioStates>(GetArenaForAllocation());
    _impl_.radio_states_ = p;
  }
  return _impl_.radio_states_;
}
inline ::aalyria::spacetime::api::common::RadioStates* ControlPlaneState::mutable_radio_states() {
  ::aalyria::spacetime::api::common::RadioStates* _msg = _internal_mutable_radio_states();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneState.radio_states)
  return _msg;
}
inline void ControlPlaneState::set_allocated_radio_states(::aalyria::spacetime::api::common::RadioStates* radio_states) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.radio_states_);
  }
  if (radio_states) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(radio_states));
    if (message_arena != submessage_arena) {
      radio_states = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio_states, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.radio_states_ = radio_states;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.radio_states)
}

// optional .aalyria.spacetime.api.common.FlowState forwarding_state = 5 [json_name = "forwardingState"];
inline bool ControlPlaneState::has_forwarding_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forwarding_state_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::FlowState& ControlPlaneState::_internal_forwarding_state() const {
  const ::aalyria::spacetime::api::common::FlowState* p = _impl_.forwarding_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowState&>(
      ::aalyria::spacetime::api::common::_FlowState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowState& ControlPlaneState::forwarding_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneState.forwarding_state)
  return _internal_forwarding_state();
}
inline void ControlPlaneState::unsafe_arena_set_allocated_forwarding_state(
    ::aalyria::spacetime::api::common::FlowState* forwarding_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forwarding_state_);
  }
  _impl_.forwarding_state_ = forwarding_state;
  if (forwarding_state) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.forwarding_state)
}
inline ::aalyria::spacetime::api::common::FlowState* ControlPlaneState::release_forwarding_state() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowState* temp = _impl_.forwarding_state_;
  _impl_.forwarding_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowState* ControlPlaneState::unsafe_arena_release_forwarding_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneState.forwarding_state)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowState* temp = _impl_.forwarding_state_;
  _impl_.forwarding_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowState* ControlPlaneState::_internal_mutable_forwarding_state() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.forwarding_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowState>(GetArenaForAllocation());
    _impl_.forwarding_state_ = p;
  }
  return _impl_.forwarding_state_;
}
inline ::aalyria::spacetime::api::common::FlowState* ControlPlaneState::mutable_forwarding_state() {
  ::aalyria::spacetime::api::common::FlowState* _msg = _internal_mutable_forwarding_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneState.forwarding_state)
  return _msg;
}
inline void ControlPlaneState::set_allocated_forwarding_state(::aalyria::spacetime::api::common::FlowState* forwarding_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.forwarding_state_);
  }
  if (forwarding_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forwarding_state));
    if (message_arena != submessage_arena) {
      forwarding_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forwarding_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.forwarding_state_ = forwarding_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.forwarding_state)
}

// optional .aalyria.spacetime.api.common.TunnelStates tunnel_states = 6 [json_name = "tunnelStates"];
inline bool ControlPlaneState::has_tunnel_states() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tunnel_states_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TunnelStates& ControlPlaneState::_internal_tunnel_states() const {
  const ::aalyria::spacetime::api::common::TunnelStates* p = _impl_.tunnel_states_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TunnelStates&>(
      ::aalyria::spacetime::api::common::_TunnelStates_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TunnelStates& ControlPlaneState::tunnel_states() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ControlPlaneState.tunnel_states)
  return _internal_tunnel_states();
}
inline void ControlPlaneState::unsafe_arena_set_allocated_tunnel_states(
    ::aalyria::spacetime::api::common::TunnelStates* tunnel_states) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tunnel_states_);
  }
  _impl_.tunnel_states_ = tunnel_states;
  if (tunnel_states) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.tunnel_states)
}
inline ::aalyria::spacetime::api::common::TunnelStates* ControlPlaneState::release_tunnel_states() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TunnelStates* temp = _impl_.tunnel_states_;
  _impl_.tunnel_states_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelStates* ControlPlaneState::unsafe_arena_release_tunnel_states() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ControlPlaneState.tunnel_states)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::TunnelStates* temp = _impl_.tunnel_states_;
  _impl_.tunnel_states_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelStates* ControlPlaneState::_internal_mutable_tunnel_states() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tunnel_states_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TunnelStates>(GetArenaForAllocation());
    _impl_.tunnel_states_ = p;
  }
  return _impl_.tunnel_states_;
}
inline ::aalyria::spacetime::api::common::TunnelStates* ControlPlaneState::mutable_tunnel_states() {
  ::aalyria::spacetime::api::common::TunnelStates* _msg = _internal_mutable_tunnel_states();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ControlPlaneState.tunnel_states)
  return _msg;
}
inline void ControlPlaneState::set_allocated_tunnel_states(::aalyria::spacetime::api::common::TunnelStates* tunnel_states) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tunnel_states_);
  }
  if (tunnel_states) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tunnel_states));
    if (message_arena != submessage_arena) {
      tunnel_states = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tunnel_states, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tunnel_states_ = tunnel_states;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ControlPlaneState.tunnel_states)
}

// -------------------------------------------------------------------

// ScheduledControlUpdateReq

// optional .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_update = 1 [json_name = "compiledUpdate"];
inline bool ScheduledControlUpdateReq::has_compiled_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.compiled_update_ != nullptr);
  return value;
}
inline void ScheduledControlUpdateReq::clear_compiled_update() {
  if (_impl_.compiled_update_ != nullptr) _impl_.compiled_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& ScheduledControlUpdateReq::_internal_compiled_update() const {
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate* p = _impl_.compiled_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ScheduledControlUpdate&>(
      ::aalyria::spacetime::api::common::_ScheduledControlUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& ScheduledControlUpdateReq::compiled_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateReq.compiled_update)
  return _internal_compiled_update();
}
inline void ScheduledControlUpdateReq::unsafe_arena_set_allocated_compiled_update(
    ::aalyria::spacetime::api::common::ScheduledControlUpdate* compiled_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compiled_update_);
  }
  _impl_.compiled_update_ = compiled_update;
  if (compiled_update) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.compiled_update)
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ScheduledControlUpdateReq::release_compiled_update() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* temp = _impl_.compiled_update_;
  _impl_.compiled_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ScheduledControlUpdateReq::unsafe_arena_release_compiled_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateReq.compiled_update)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* temp = _impl_.compiled_update_;
  _impl_.compiled_update_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ScheduledControlUpdateReq::_internal_mutable_compiled_update() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.compiled_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlUpdate>(GetArenaForAllocation());
    _impl_.compiled_update_ = p;
  }
  return _impl_.compiled_update_;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ScheduledControlUpdateReq::mutable_compiled_update() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _msg = _internal_mutable_compiled_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateReq.compiled_update)
  return _msg;
}
inline void ScheduledControlUpdateReq::set_allocated_compiled_update(::aalyria::spacetime::api::common::ScheduledControlUpdate* compiled_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compiled_update_;
  }
  if (compiled_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compiled_update);
    if (message_arena != submessage_arena) {
      compiled_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compiled_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.compiled_update_ = compiled_update;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.compiled_update)
}

// optional .google.rpc.Status completed = 8 [json_name = "completed"];
inline bool ScheduledControlUpdateReq::has_completed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completed_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& ScheduledControlUpdateReq::_internal_completed() const {
  const ::google::rpc::Status* p = _impl_.completed_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ScheduledControlUpdateReq::completed() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateReq.completed)
  return _internal_completed();
}
inline void ScheduledControlUpdateReq::unsafe_arena_set_allocated_completed(
    ::google::rpc::Status* completed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_);
  }
  _impl_.completed_ = completed;
  if (completed) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.completed)
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::release_completed() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.completed_;
  _impl_.completed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::unsafe_arena_release_completed() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateReq.completed)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.completed_;
  _impl_.completed_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::_internal_mutable_completed() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.completed_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.completed_ = p;
  }
  return _impl_.completed_;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::mutable_completed() {
  ::google::rpc::Status* _msg = _internal_mutable_completed();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateReq.completed)
  return _msg;
}
inline void ScheduledControlUpdateReq::set_allocated_completed(::google::rpc::Status* completed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.completed_);
  }
  if (completed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(completed));
    if (message_arena != submessage_arena) {
      completed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, completed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.completed_ = completed;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.completed)
}

// optional bool scheduled = 11 [json_name = "scheduled"];
inline bool ScheduledControlUpdateReq::has_scheduled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ScheduledControlUpdateReq::clear_scheduled() {
  _impl_.scheduled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ScheduledControlUpdateReq::scheduled() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateReq.scheduled)
  return _internal_scheduled();
}
inline void ScheduledControlUpdateReq::set_scheduled(bool value) {
  _internal_set_scheduled(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.ScheduledControlUpdateReq.scheduled)
}
inline bool ScheduledControlUpdateReq::_internal_scheduled() const {
  return _impl_.scheduled_;
}
inline void ScheduledControlUpdateReq::_internal_set_scheduled(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.scheduled_ = value;
}

// optional .google.rpc.Status unscheduled = 12 [json_name = "unscheduled"];
inline bool ScheduledControlUpdateReq::has_unscheduled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unscheduled_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& ScheduledControlUpdateReq::_internal_unscheduled() const {
  const ::google::rpc::Status* p = _impl_.unscheduled_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ScheduledControlUpdateReq::unscheduled() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.ScheduledControlUpdateReq.unscheduled)
  return _internal_unscheduled();
}
inline void ScheduledControlUpdateReq::unsafe_arena_set_allocated_unscheduled(
    ::google::rpc::Status* unscheduled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unscheduled_);
  }
  _impl_.unscheduled_ = unscheduled;
  if (unscheduled) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.unscheduled)
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::release_unscheduled() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::rpc::Status* temp = _impl_.unscheduled_;
  _impl_.unscheduled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::unsafe_arena_release_unscheduled() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.ScheduledControlUpdateReq.unscheduled)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::rpc::Status* temp = _impl_.unscheduled_;
  _impl_.unscheduled_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::_internal_mutable_unscheduled() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.unscheduled_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.unscheduled_ = p;
  }
  return _impl_.unscheduled_;
}
inline ::google::rpc::Status* ScheduledControlUpdateReq::mutable_unscheduled() {
  ::google::rpc::Status* _msg = _internal_mutable_unscheduled();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.ScheduledControlUpdateReq.unscheduled)
  return _msg;
}
inline void ScheduledControlUpdateReq::set_allocated_unscheduled(::google::rpc::Status* unscheduled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unscheduled_);
  }
  if (unscheduled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unscheduled));
    if (message_arena != submessage_arena) {
      unscheduled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unscheduled, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.unscheduled_ = unscheduled;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.ScheduledControlUpdateReq.unscheduled)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskCdpiStreamCount

// map<uint32, int32> stream_count_per_priority = 1 [json_name = "streamCountPerPriority"];
inline int TaskCdpiStreamCount::_internal_stream_count_per_priority_size() const {
  return _impl_.stream_count_per_priority_.size();
}
inline int TaskCdpiStreamCount::stream_count_per_priority_size() const {
  return _internal_stream_count_per_priority_size();
}
inline void TaskCdpiStreamCount::clear_stream_count_per_priority() {
  _impl_.stream_count_per_priority_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
TaskCdpiStreamCount::_internal_stream_count_per_priority() const {
  return _impl_.stream_count_per_priority_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
TaskCdpiStreamCount::stream_count_per_priority() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.TaskCdpiStreamCount.stream_count_per_priority)
  return _internal_stream_count_per_priority();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
TaskCdpiStreamCount::_internal_mutable_stream_count_per_priority() {
  return _impl_.stream_count_per_priority_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
TaskCdpiStreamCount::mutable_stream_count_per_priority() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.TaskCdpiStreamCount.stream_count_per_priority)
  return _internal_mutable_stream_count_per_priority();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CdpiFrontendInfo

// map<string, .aalyria.spacetime.api.common.TaskCdpiStreamCount> stream_count_per_node = 1 [json_name = "streamCountPerNode"];
inline int CdpiFrontendInfo::_internal_stream_count_per_node_size() const {
  return _impl_.stream_count_per_node_.size();
}
inline int CdpiFrontendInfo::stream_count_per_node_size() const {
  return _internal_stream_count_per_node_size();
}
inline void CdpiFrontendInfo::clear_stream_count_per_node() {
  _impl_.stream_count_per_node_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
CdpiFrontendInfo::_internal_stream_count_per_node() const {
  return _impl_.stream_count_per_node_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
CdpiFrontendInfo::stream_count_per_node() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.CdpiFrontendInfo.stream_count_per_node)
  return _internal_stream_count_per_node();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
CdpiFrontendInfo::_internal_mutable_stream_count_per_node() {
  return _impl_.stream_count_per_node_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
CdpiFrontendInfo::mutable_stream_count_per_node() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.CdpiFrontendInfo.stream_count_per_node)
  return _internal_mutable_stream_count_per_node();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CdpiStreamInfo

// map<string, .aalyria.spacetime.api.common.TaskCdpiStreamCount> stream_count_per_task = 2 [json_name = "streamCountPerTask"];
inline int CdpiStreamInfo::_internal_stream_count_per_task_size() const {
  return _impl_.stream_count_per_task_.size();
}
inline int CdpiStreamInfo::stream_count_per_task_size() const {
  return _internal_stream_count_per_task_size();
}
inline void CdpiStreamInfo::clear_stream_count_per_task() {
  _impl_.stream_count_per_task_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
CdpiStreamInfo::_internal_stream_count_per_task() const {
  return _impl_.stream_count_per_task_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >&
CdpiStreamInfo::stream_count_per_task() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.CdpiStreamInfo.stream_count_per_task)
  return _internal_stream_count_per_task();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
CdpiStreamInfo::_internal_mutable_stream_count_per_task() {
  return _impl_.stream_count_per_task_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::aalyria::spacetime::api::common::TaskCdpiStreamCount >*
CdpiStreamInfo::mutable_stream_count_per_task() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.CdpiStreamInfo.stream_count_per_task)
  return _internal_mutable_stream_count_per_task();
}

// map<uint32, int32> stream_count_per_priority = 3 [json_name = "streamCountPerPriority"];
inline int CdpiStreamInfo::_internal_stream_count_per_priority_size() const {
  return _impl_.stream_count_per_priority_.size();
}
inline int CdpiStreamInfo::stream_count_per_priority_size() const {
  return _internal_stream_count_per_priority_size();
}
inline void CdpiStreamInfo::clear_stream_count_per_priority() {
  _impl_.stream_count_per_priority_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
CdpiStreamInfo::_internal_stream_count_per_priority() const {
  return _impl_.stream_count_per_priority_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >&
CdpiStreamInfo::stream_count_per_priority() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.common.CdpiStreamInfo.stream_count_per_priority)
  return _internal_stream_count_per_priority();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
CdpiStreamInfo::_internal_mutable_stream_count_per_priority() {
  return _impl_.stream_count_per_priority_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::int32_t >*
CdpiStreamInfo::mutable_stream_count_per_priority() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.common.CdpiStreamInfo.stream_count_per_priority)
  return _internal_mutable_stream_count_per_priority();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fcontrol_2eproto_2epb_2eh
