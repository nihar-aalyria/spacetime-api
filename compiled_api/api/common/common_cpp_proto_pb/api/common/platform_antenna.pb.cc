// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/platform_antenna.proto

#include "api/common/platform_antenna.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
template <typename>
PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMask_ElevationRise::AntennaDefinition_ElevationMask_ElevationRise(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.distance_)*/ 0

  , /*decltype(_impl_.obscured_elevation_deg_)*/ 0
} {}
struct AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal() {}
  union {
    AntennaDefinition_ElevationMask_ElevationRise _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaDefinition_ElevationMask_ElevationRiseDefaultTypeInternal _AntennaDefinition_ElevationMask_ElevationRise_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMask::AntennaDefinition_ElevationMask(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elevation_rise_)*/{}
  , /*decltype(_impl_.azimuth_deg_)*/ 0

  , /*decltype(_impl_.maximum_obscured_elevation_deg_)*/ 0
} {}
struct AntennaDefinition_ElevationMaskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaDefinition_ElevationMaskDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaDefinition_ElevationMaskDefaultTypeInternal() {}
  union {
    AntennaDefinition_ElevationMask _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaDefinition_ElevationMaskDefaultTypeInternal _AntennaDefinition_ElevationMask_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaDefinition::AntennaDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.azimuth_elevation_mask_)*/{}
  , /*decltype(_impl_.obstructions_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.antenna_pattern_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.fixed_coordinate_offset_)*/nullptr
  , /*decltype(_impl_.constraints_)*/nullptr
  , /*decltype(_impl_.field_of_regard_)*/nullptr
  , /*decltype(_impl_.polarization_)*/nullptr
  , /*decltype(_impl_.targeting_)*/nullptr} {}
struct AntennaDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaDefinitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaDefinitionDefaultTypeInternal() {}
  union {
    AntennaDefinition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaDefinitionDefaultTypeInternal _AntennaDefinition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaConstraints_LinkRangeConstraint::AntennaConstraints_LinkRangeConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_range_)*/ 0

  , /*decltype(_impl_.maximum_range_)*/ 0
} {}
struct AntennaConstraints_LinkRangeConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaConstraints_LinkRangeConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaConstraints_LinkRangeConstraintDefaultTypeInternal() {}
  union {
    AntennaConstraints_LinkRangeConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaConstraints_LinkRangeConstraintDefaultTypeInternal _AntennaConstraints_LinkRangeConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaConstraints_AzimuthAngleRateConstraint::AntennaConstraints_AzimuthAngleRateConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_rate_deg_per_sec_)*/ 0

  , /*decltype(_impl_.maximum_rate_deg_per_sec_)*/ 0
} {}
struct AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal() {}
  union {
    AntennaConstraints_AzimuthAngleRateConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaConstraints_AzimuthAngleRateConstraintDefaultTypeInternal _AntennaConstraints_AzimuthAngleRateConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaConstraints_ElevationAngleRateConstraint::AntennaConstraints_ElevationAngleRateConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_rate_deg_per_sec_)*/ 0

  , /*decltype(_impl_.maximum_rate_deg_per_sec_)*/ 0
} {}
struct AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal() {}
  union {
    AntennaConstraints_ElevationAngleRateConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaConstraints_ElevationAngleRateConstraintDefaultTypeInternal _AntennaConstraints_ElevationAngleRateConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaConstraints_TotalAngularRateConstraint::AntennaConstraints_TotalAngularRateConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_rate_deg_per_sec_)*/ 0

  , /*decltype(_impl_.maximum_rate_deg_per_sec_)*/ 0
} {}
struct AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal() {}
  union {
    AntennaConstraints_TotalAngularRateConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaConstraints_TotalAngularRateConstraintDefaultTypeInternal _AntennaConstraints_TotalAngularRateConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AntennaConstraints::AntennaConstraints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.link_range_)*/nullptr
  , /*decltype(_impl_.azimuth_angle_rate_)*/nullptr
  , /*decltype(_impl_.elevation_angle_rate_)*/nullptr
  , /*decltype(_impl_.total_angular_rate_)*/nullptr
  , /*decltype(_impl_.minimum_sun_angle_deg_)*/ 0

  , /*decltype(_impl_.minimum_azimuth_elevation_mask_separation_deg_)*/ 0
} {}
struct AntennaConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AntennaConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AntennaConstraintsDefaultTypeInternal() {}
  union {
    AntennaConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AntennaConstraintsDefaultTypeInternal _AntennaConstraints_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Projection_Conic::Projection_Conic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outer_half_angle_deg_)*/ 0

  , /*decltype(_impl_.inner_half_angle_deg_)*/ 0
} {}
struct Projection_ConicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Projection_ConicDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Projection_ConicDefaultTypeInternal() {}
  union {
    Projection_Conic _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Projection_ConicDefaultTypeInternal _Projection_Conic_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Projection_Rectangular::Projection_Rectangular(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_half_angle_deg_)*/ 0

  , /*decltype(_impl_.y_half_angle_deg_)*/ 0
} {}
struct Projection_RectangularDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Projection_RectangularDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Projection_RectangularDefaultTypeInternal() {}
  union {
    Projection_Rectangular _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Projection_RectangularDefaultTypeInternal _Projection_Rectangular_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Projection_Custom::Projection_Custom(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.directions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Projection_CustomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Projection_CustomDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Projection_CustomDefaultTypeInternal() {}
  union {
    Projection_Custom _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Projection_CustomDefaultTypeInternal _Projection_Custom_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Projection::Projection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shape_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProjectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProjectionDefaultTypeInternal() {}
  union {
    Projection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProjectionDefaultTypeInternal _Projection_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Polarization_Constant_Linear::Polarization_Constant_Linear(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tilt_angle_deg_)*/ 0
} {}
struct Polarization_Constant_LinearDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Polarization_Constant_LinearDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Polarization_Constant_LinearDefaultTypeInternal() {}
  union {
    Polarization_Constant_Linear _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Polarization_Constant_LinearDefaultTypeInternal _Polarization_Constant_Linear_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Polarization_Constant::Polarization_Constant(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.polarization_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Polarization_ConstantDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Polarization_ConstantDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Polarization_ConstantDefaultTypeInternal() {}
  union {
    Polarization_Constant _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Polarization_ConstantDefaultTypeInternal _Polarization_Constant_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Polarization::Polarization(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PolarizationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolarizationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolarizationDefaultTypeInternal() {}
  union {
    Polarization _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolarizationDefaultTypeInternal _Polarization_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Targeting::Targeting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.motion_format_)*/ 0
} {}
struct TargetingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TargetingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TargetingDefaultTypeInternal() {}
  union {
    Targeting _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TargetingDefaultTypeInternal _Targeting_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[16];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_api_2fcommon_2fplatform_5fantenna_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fcommon_2fplatform_5fantenna_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise, _impl_.distance_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise, _impl_.obscured_elevation_deg_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask, _impl_.azimuth_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask, _impl_.maximum_obscured_elevation_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask, _impl_.elevation_rise_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.fixed_coordinate_offset_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.targeting_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.antenna_pattern_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.polarization_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.field_of_regard_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.obstructions_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.azimuth_elevation_mask_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaDefinition, _impl_.constraints_),
    0,
    2,
    6,
    1,
    5,
    4,
    ~0u,
    ~0u,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint, _impl_.minimum_range_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint, _impl_.maximum_range_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint, _impl_.minimum_rate_deg_per_sec_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint, _impl_.maximum_rate_deg_per_sec_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint, _impl_.minimum_rate_deg_per_sec_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint, _impl_.maximum_rate_deg_per_sec_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint, _impl_.minimum_rate_deg_per_sec_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint, _impl_.maximum_rate_deg_per_sec_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.link_range_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.azimuth_angle_rate_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.elevation_angle_rate_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.total_angular_rate_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.minimum_sun_angle_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::AntennaConstraints, _impl_.minimum_azimuth_elevation_mask_separation_deg_),
    0,
    1,
    2,
    3,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Conic, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Conic, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Conic, _impl_.outer_half_angle_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Conic, _impl_.inner_half_angle_deg_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Rectangular, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Rectangular, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Rectangular, _impl_.x_half_angle_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Rectangular, _impl_.y_half_angle_deg_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Custom, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection_Custom, _impl_.directions_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection, _impl_.shape_type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant_Linear, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant_Linear, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant_Linear, _impl_.tilt_angle_deg_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant, _impl_.polarization_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Targeting, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Targeting, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Targeting, _impl_.motion_format_),
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise)},
        { 12, 23, -1, sizeof(::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask)},
        { 26, 43, -1, sizeof(::aalyria::spacetime::api::common::AntennaDefinition)},
        { 52, 62, -1, sizeof(::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint)},
        { 64, 74, -1, sizeof(::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint)},
        { 76, 86, -1, sizeof(::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint)},
        { 88, 98, -1, sizeof(::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint)},
        { 100, 114, -1, sizeof(::aalyria::spacetime::api::common::AntennaConstraints)},
        { 120, 130, -1, sizeof(::aalyria::spacetime::api::common::Projection_Conic)},
        { 132, 142, -1, sizeof(::aalyria::spacetime::api::common::Projection_Rectangular)},
        { 144, -1, -1, sizeof(::aalyria::spacetime::api::common::Projection_Custom)},
        { 153, -1, -1, sizeof(::aalyria::spacetime::api::common::Projection)},
        { 165, 174, -1, sizeof(::aalyria::spacetime::api::common::Polarization_Constant_Linear)},
        { 175, -1, -1, sizeof(::aalyria::spacetime::api::common::Polarization_Constant)},
        { 187, -1, -1, sizeof(::aalyria::spacetime::api::common::Polarization)},
        { 197, 206, -1, sizeof(::aalyria::spacetime::api::common::Targeting)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::common::_AntennaDefinition_ElevationMask_ElevationRise_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaDefinition_ElevationMask_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaDefinition_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaConstraints_LinkRangeConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaConstraints_AzimuthAngleRateConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaConstraints_ElevationAngleRateConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaConstraints_TotalAngularRateConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::common::_AntennaConstraints_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Projection_Conic_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Projection_Rectangular_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Projection_Custom_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Projection_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Polarization_Constant_Linear_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Polarization_Constant_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Polarization_default_instance_._instance,
    &::aalyria::spacetime::api::common::_Targeting_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fcommon_2fplatform_5fantenna_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n!api/common/platform_antenna.proto\022\034aal"
    "yria.spacetime.api.common\032\034api/common/co"
    "ordinates.proto\032\033google/protobuf/empty.p"
    "roto\"\255\010\n\021AntennaDefinition\022\022\n\004name\030\002 \001(\t"
    "R\004name\022_\n\027fixed_coordinate_offset\030\003 \001(\0132"
    "\'.aalyria.spacetime.api.common.PointAxes"
    "R\025fixedCoordinateOffset\022E\n\ttargeting\030\022 \001"
    "(\0132\'.aalyria.spacetime.api.common.Target"
    "ingR\ttargeting\022,\n\022antenna_pattern_id\030\n \001"
    "(\tR\020antennaPatternId\022N\n\014polarization\030\021 \001"
    "(\0132*.aalyria.spacetime.api.common.Polari"
    "zationR\014polarization\022P\n\017field_of_regard\030"
    "\013 \001(\0132(.aalyria.spacetime.api.common.Pro"
    "jectionR\rfieldOfRegard\022L\n\014obstructions\030\014"
    " \003(\0132(.aalyria.spacetime.api.common.Proj"
    "ectionR\014obstructions\022s\n\026azimuth_elevatio"
    "n_mask\030\t \003(\0132=.aalyria.spacetime.api.com"
    "mon.AntennaDefinition.ElevationMaskR\024azi"
    "muthElevationMask\022R\n\013constraints\030\006 \001(\01320"
    ".aalyria.spacetime.api.common.AntennaCon"
    "straintsR\013constraints\032\314\002\n\rElevationMask\022"
    "\037\n\013azimuth_deg\030\001 \001(\001R\nazimuthDeg\022C\n\036maxi"
    "mum_obscured_elevation_deg\030\002 \001(\001R\033maximu"
    "mObscuredElevationDeg\022r\n\016elevation_rise\030"
    "\003 \003(\0132K.aalyria.spacetime.api.common.Ant"
    "ennaDefinition.ElevationMask.ElevationRi"
    "seR\relevationRise\032a\n\rElevationRise\022\032\n\010di"
    "stance\030\001 \001(\001R\010distance\0224\n\026obscured_eleva"
    "tion_deg\030\002 \001(\001R\024obscuredElevationDegJ\004\010\001"
    "\020\002J\004\010\004\020\005J\004\010\005\020\006J\004\010\007\020\010J\004\010\010\020\tJ\010\010\023\020\200\200\200\200\002\"\236\t\n"
    "\022AntennaConstraints\022c\n\nlink_range\030\001 \001(\0132"
    "D.aalyria.spacetime.api.common.AntennaCo"
    "nstraints.LinkRangeConstraintR\tlinkRange"
    "\022y\n\022azimuth_angle_rate\030\003 \001(\0132K.aalyria.s"
    "pacetime.api.common.AntennaConstraints.A"
    "zimuthAngleRateConstraintR\020azimuthAngleR"
    "ate\022\177\n\024elevation_angle_rate\030\004 \001(\0132M.aaly"
    "ria.spacetime.api.common.AntennaConstrai"
    "nts.ElevationAngleRateConstraintR\022elevat"
    "ionAngleRate\022y\n\022total_angular_rate\030\005 \001(\013"
    "2K.aalyria.spacetime.api.common.AntennaC"
    "onstraints.TotalAngularRateConstraintR\020t"
    "otalAngularRate\0221\n\025minimum_sun_angle_deg"
    "\030\006 \001(\001R\022minimumSunAngleDeg\022_\n-minimum_az"
    "imuth_elevation_mask_separation_deg\030\007 \001("
    "\001R(minimumAzimuthElevationMaskSeparation"
    "Deg\032_\n\023LinkRangeConstraint\022#\n\rminimum_ra"
    "nge\030\001 \001(\001R\014minimumRange\022#\n\rmaximum_range"
    "\030\002 \001(\001R\014maximumRange\032\214\001\n\032AzimuthAngleRat"
    "eConstraint\0226\n\030minimum_rate_deg_per_sec\030"
    "\001 \001(\001R\024minimumRateDegPerSec\0226\n\030maximum_r"
    "ate_deg_per_sec\030\002 \001(\001R\024maximumRateDegPer"
    "Sec\032\216\001\n\034ElevationAngleRateConstraint\0226\n\030"
    "minimum_rate_deg_per_sec\030\001 \001(\001R\024minimumR"
    "ateDegPerSec\0226\n\030maximum_rate_deg_per_sec"
    "\030\002 \001(\001R\024maximumRateDegPerSec\032\214\001\n\032TotalAn"
    "gularRateConstraint\0226\n\030minimum_rate_deg_"
    "per_sec\030\001 \001(\001R\024minimumRateDegPerSec\0226\n\030m"
    "aximum_rate_deg_per_sec\030\002 \001(\001R\024maximumRa"
    "teDegPerSecJ\010\010\010\020\200\200\200\200\002\"\253\004\n\nProjection\022F\n\005"
    "conic\030\001 \001(\0132..aalyria.spacetime.api.comm"
    "on.Projection.ConicH\000R\005conic\022X\n\013rectangu"
    "lar\030\002 \001(\01324.aalyria.spacetime.api.common"
    ".Projection.RectangularH\000R\013rectangular\022I"
    "\n\006custom\030\003 \001(\0132/.aalyria.spacetime.api.c"
    "ommon.Projection.CustomH\000R\006custom\032i\n\005Con"
    "ic\022/\n\024outer_half_angle_deg\030\001 \001(\001R\021outerH"
    "alfAngleDeg\022/\n\024inner_half_angle_deg\030\002 \001("
    "\001R\021innerHalfAngleDeg\032_\n\013Rectangular\022\'\n\020x"
    "_half_angle_deg\030\001 \001(\001R\rxHalfAngleDeg\022\'\n\020"
    "y_half_angle_deg\030\002 \001(\001R\ryHalfAngleDeg\032V\n"
    "\006Custom\022L\n\ndirections\030\001 \003(\0132,.aalyria.sp"
    "acetime.api.common.PointingVectorR\ndirec"
    "tionsB\014\n\nshape_type\"\240\003\n\014Polarization\022Q\n\010"
    "constant\030\001 \001(\01323.aalyria.spacetime.api.c"
    "ommon.Polarization.ConstantH\000R\010constant\032"
    "\262\002\n\010Constant\022F\n\022left_hand_circular\030\001 \001(\013"
    "2\026.google.protobuf.EmptyH\000R\020leftHandCirc"
    "ular\022H\n\023right_hand_circular\030\002 \001(\0132\026.goog"
    "le.protobuf.EmptyH\000R\021rightHandCircular\022T"
    "\n\006linear\030\003 \001(\0132:.aalyria.spacetime.api.c"
    "ommon.Polarization.Constant.LinearH\000R\006li"
    "near\032.\n\006Linear\022$\n\016tilt_angle_deg\030\001 \001(\001R\014"
    "tiltAngleDegB\016\n\014polarizationB\010\n\006source\"["
    "\n\tTargeting\022N\n\rmotion_format\030\001 \001(\0162).aal"
    "yria.spacetime.api.common.Motion.TypeR\014m"
    "otionFormatBD\n com.aalyria.spacetime.api"
    ".commonZ aalyria.com/spacetime/api/commo"
    "n"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_deps[2] =
    {
        &::descriptor_table_api_2fcommon_2fcoordinates_2eproto,
        &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto = {
    false,
    false,
    3521,
    descriptor_table_protodef_api_2fcommon_2fplatform_5fantenna_2eproto,
    "api/common/platform_antenna.proto",
    &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
    descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_deps,
    2,
    16,
    schemas,
    file_default_instances,
    TableStruct_api_2fcommon_2fplatform_5fantenna_2eproto::offsets,
    file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto,
    file_level_enum_descriptors_api_2fcommon_2fplatform_5fantenna_2eproto,
    file_level_service_descriptors_api_2fcommon_2fplatform_5fantenna_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter() {
  return &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fcommon_2fplatform_5fantenna_2eproto(&descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
// ===================================================================

class AntennaDefinition_ElevationMask_ElevationRise::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaDefinition_ElevationMask_ElevationRise>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask_ElevationRise, _impl_._has_bits_);
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obscured_elevation_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaDefinition_ElevationMask_ElevationRise::AntennaDefinition_ElevationMask_ElevationRise(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
}
AntennaDefinition_ElevationMask_ElevationRise::AntennaDefinition_ElevationMask_ElevationRise(const AntennaDefinition_ElevationMask_ElevationRise& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
}

inline void AntennaDefinition_ElevationMask_ElevationRise::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distance_) { 0 }

    , decltype(_impl_.obscured_elevation_deg_) { 0 }

  };
}

AntennaDefinition_ElevationMask_ElevationRise::~AntennaDefinition_ElevationMask_ElevationRise() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaDefinition_ElevationMask_ElevationRise::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AntennaDefinition_ElevationMask_ElevationRise::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaDefinition_ElevationMask_ElevationRise::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.distance_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.obscured_elevation_deg_) -
        reinterpret_cast<char*>(&_impl_.distance_)) + sizeof(_impl_.obscured_elevation_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaDefinition_ElevationMask_ElevationRise::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double distance = 1 [json_name = "distance"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_distance(&has_bits);
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double obscured_elevation_deg = 2 [json_name = "obscuredElevationDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_obscured_elevation_deg(&has_bits);
          _impl_.obscured_elevation_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaDefinition_ElevationMask_ElevationRise::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double distance = 1 [json_name = "distance"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_distance(), target);
  }

  // optional double obscured_elevation_deg = 2 [json_name = "obscuredElevationDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_obscured_elevation_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  return target;
}

::size_t AntennaDefinition_ElevationMask_ElevationRise::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double distance = 1 [json_name = "distance"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double obscured_elevation_deg = 2 [json_name = "obscuredElevationDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaDefinition_ElevationMask_ElevationRise::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaDefinition_ElevationMask_ElevationRise::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaDefinition_ElevationMask_ElevationRise::GetClassData() const { return &_class_data_; }


void AntennaDefinition_ElevationMask_ElevationRise::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaDefinition_ElevationMask_ElevationRise*>(&to_msg);
  auto& from = static_cast<const AntennaDefinition_ElevationMask_ElevationRise&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.obscured_elevation_deg_ = from._impl_.obscured_elevation_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaDefinition_ElevationMask_ElevationRise::CopyFrom(const AntennaDefinition_ElevationMask_ElevationRise& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaDefinition_ElevationMask_ElevationRise::IsInitialized() const {
  return true;
}

void AntennaDefinition_ElevationMask_ElevationRise::InternalSwap(AntennaDefinition_ElevationMask_ElevationRise* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask_ElevationRise, _impl_.obscured_elevation_deg_)
      + sizeof(AntennaDefinition_ElevationMask_ElevationRise::_impl_.obscured_elevation_deg_)
      - PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask_ElevationRise, _impl_.distance_)>(
          reinterpret_cast<char*>(&_impl_.distance_),
          reinterpret_cast<char*>(&other->_impl_.distance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaDefinition_ElevationMask_ElevationRise::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[0]);
}
// ===================================================================

class AntennaDefinition_ElevationMask::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaDefinition_ElevationMask>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask, _impl_._has_bits_);
  static void set_has_azimuth_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum_obscured_elevation_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaDefinition_ElevationMask::AntennaDefinition_ElevationMask(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
}
AntennaDefinition_ElevationMask::AntennaDefinition_ElevationMask(const AntennaDefinition_ElevationMask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AntennaDefinition_ElevationMask* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elevation_rise_){from._impl_.elevation_rise_}
    , decltype(_impl_.azimuth_deg_) {}

    , decltype(_impl_.maximum_obscured_elevation_deg_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.azimuth_deg_, &from._impl_.azimuth_deg_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.maximum_obscured_elevation_deg_) -
    reinterpret_cast<char*>(&_impl_.azimuth_deg_)) + sizeof(_impl_.maximum_obscured_elevation_deg_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
}

inline void AntennaDefinition_ElevationMask::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elevation_rise_){arena}
    , decltype(_impl_.azimuth_deg_) { 0 }

    , decltype(_impl_.maximum_obscured_elevation_deg_) { 0 }

  };
}

AntennaDefinition_ElevationMask::~AntennaDefinition_ElevationMask() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaDefinition_ElevationMask::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_elevation_rise()->~RepeatedPtrField();
}

void AntennaDefinition_ElevationMask::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaDefinition_ElevationMask::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_elevation_rise()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.azimuth_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_obscured_elevation_deg_) -
        reinterpret_cast<char*>(&_impl_.azimuth_deg_)) + sizeof(_impl_.maximum_obscured_elevation_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaDefinition_ElevationMask::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_azimuth_deg(&has_bits);
          _impl_.azimuth_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double maximum_obscured_elevation_deg = 2 [json_name = "maximumObscuredElevationDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum_obscured_elevation_deg(&has_bits);
          _impl_.maximum_obscured_elevation_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise elevation_rise = 3 [json_name = "elevationRise"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elevation_rise(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaDefinition_ElevationMask::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_azimuth_deg(), target);
  }

  // optional double maximum_obscured_elevation_deg = 2 [json_name = "maximumObscuredElevationDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_maximum_obscured_elevation_deg(), target);
  }

  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise elevation_rise = 3 [json_name = "elevationRise"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elevation_rise_size()); i < n; i++) {
    const auto& repfield = this->_internal_elevation_rise(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  return target;
}

::size_t AntennaDefinition_ElevationMask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise elevation_rise = 3 [json_name = "elevationRise"];
  total_size += 1UL * this->_internal_elevation_rise_size();
  for (const auto& msg : this->_internal_elevation_rise()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double azimuth_deg = 1 [json_name = "azimuthDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double maximum_obscured_elevation_deg = 2 [json_name = "maximumObscuredElevationDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaDefinition_ElevationMask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaDefinition_ElevationMask::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaDefinition_ElevationMask::GetClassData() const { return &_class_data_; }


void AntennaDefinition_ElevationMask::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaDefinition_ElevationMask*>(&to_msg);
  auto& from = static_cast<const AntennaDefinition_ElevationMask&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_elevation_rise()->MergeFrom(from._internal_elevation_rise());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.azimuth_deg_ = from._impl_.azimuth_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_obscured_elevation_deg_ = from._impl_.maximum_obscured_elevation_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaDefinition_ElevationMask::CopyFrom(const AntennaDefinition_ElevationMask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaDefinition.ElevationMask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaDefinition_ElevationMask::IsInitialized() const {
  return true;
}

void AntennaDefinition_ElevationMask::InternalSwap(AntennaDefinition_ElevationMask* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_elevation_rise()->InternalSwap(other->_internal_mutable_elevation_rise());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask, _impl_.maximum_obscured_elevation_deg_)
      + sizeof(AntennaDefinition_ElevationMask::_impl_.maximum_obscured_elevation_deg_)
      - PROTOBUF_FIELD_OFFSET(AntennaDefinition_ElevationMask, _impl_.azimuth_deg_)>(
          reinterpret_cast<char*>(&_impl_.azimuth_deg_),
          reinterpret_cast<char*>(&other->_impl_.azimuth_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaDefinition_ElevationMask::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[1]);
}
// ===================================================================

class AntennaDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaDefinition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaDefinition, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::PointAxes& fixed_coordinate_offset(const AntennaDefinition* msg);
  static void set_has_fixed_coordinate_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::common::Targeting& targeting(const AntennaDefinition* msg);
  static void set_has_targeting(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_antenna_pattern_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::Polarization& polarization(const AntennaDefinition* msg);
  static void set_has_polarization(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::aalyria::spacetime::api::common::Projection& field_of_regard(const AntennaDefinition* msg);
  static void set_has_field_of_regard(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::aalyria::spacetime::api::common::AntennaConstraints& constraints(const AntennaDefinition* msg);
  static void set_has_constraints(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::common::PointAxes&
AntennaDefinition::_Internal::fixed_coordinate_offset(const AntennaDefinition* msg) {
  return *msg->_impl_.fixed_coordinate_offset_;
}
const ::aalyria::spacetime::api::common::Targeting&
AntennaDefinition::_Internal::targeting(const AntennaDefinition* msg) {
  return *msg->_impl_.targeting_;
}
const ::aalyria::spacetime::api::common::Polarization&
AntennaDefinition::_Internal::polarization(const AntennaDefinition* msg) {
  return *msg->_impl_.polarization_;
}
const ::aalyria::spacetime::api::common::Projection&
AntennaDefinition::_Internal::field_of_regard(const AntennaDefinition* msg) {
  return *msg->_impl_.field_of_regard_;
}
const ::aalyria::spacetime::api::common::AntennaConstraints&
AntennaDefinition::_Internal::constraints(const AntennaDefinition* msg) {
  return *msg->_impl_.constraints_;
}
void AntennaDefinition::clear_fixed_coordinate_offset() {
  if (_impl_.fixed_coordinate_offset_ != nullptr) _impl_.fixed_coordinate_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
AntennaDefinition::AntennaDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaDefinition)
}
AntennaDefinition::AntennaDefinition(const AntennaDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AntennaDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.azimuth_elevation_mask_){from._impl_.azimuth_elevation_mask_}
    , decltype(_impl_.obstructions_){from._impl_.obstructions_}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.antenna_pattern_id_) {}

    , decltype(_impl_.fixed_coordinate_offset_){nullptr}
    , decltype(_impl_.constraints_){nullptr}
    , decltype(_impl_.field_of_regard_){nullptr}
    , decltype(_impl_.polarization_){nullptr}
    , decltype(_impl_.targeting_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.antenna_pattern_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.antenna_pattern_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.antenna_pattern_id_.Set(from._internal_antenna_pattern_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.fixed_coordinate_offset_ = new ::aalyria::spacetime::api::common::PointAxes(*from._impl_.fixed_coordinate_offset_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.constraints_ = new ::aalyria::spacetime::api::common::AntennaConstraints(*from._impl_.constraints_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.field_of_regard_ = new ::aalyria::spacetime::api::common::Projection(*from._impl_.field_of_regard_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.polarization_ = new ::aalyria::spacetime::api::common::Polarization(*from._impl_.polarization_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.targeting_ = new ::aalyria::spacetime::api::common::Targeting(*from._impl_.targeting_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaDefinition)
}

inline void AntennaDefinition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.azimuth_elevation_mask_){arena}
    , decltype(_impl_.obstructions_){arena}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.antenna_pattern_id_) {}

    , decltype(_impl_.fixed_coordinate_offset_){nullptr}
    , decltype(_impl_.constraints_){nullptr}
    , decltype(_impl_.field_of_regard_){nullptr}
    , decltype(_impl_.polarization_){nullptr}
    , decltype(_impl_.targeting_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.antenna_pattern_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.antenna_pattern_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AntennaDefinition::~AntennaDefinition() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaDefinition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_azimuth_elevation_mask()->~RepeatedPtrField();
  _internal_mutable_obstructions()->~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.antenna_pattern_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fixed_coordinate_offset_;
  if (this != internal_default_instance()) delete _impl_.constraints_;
  if (this != internal_default_instance()) delete _impl_.field_of_regard_;
  if (this != internal_default_instance()) delete _impl_.polarization_;
  if (this != internal_default_instance()) delete _impl_.targeting_;
}

void AntennaDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaDefinition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_azimuth_elevation_mask()->Clear();
  _internal_mutable_obstructions()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.antenna_pattern_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.fixed_coordinate_offset_ != nullptr);
      _impl_.fixed_coordinate_offset_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.constraints_ != nullptr);
      _impl_.constraints_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.field_of_regard_ != nullptr);
      _impl_.field_of_regard_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.polarization_ != nullptr);
      _impl_.polarization_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.targeting_ != nullptr);
      _impl_.targeting_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 2 [json_name = "name"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.AntennaDefinition.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.PointAxes fixed_coordinate_offset = 3 [json_name = "fixedCoordinateOffset"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fixed_coordinate_offset(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.AntennaConstraints constraints = 6 [json_name = "constraints"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_constraints(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask azimuth_elevation_mask = 9 [json_name = "azimuthElevationMask"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_azimuth_elevation_mask(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string antenna_pattern_id = 10 [json_name = "antennaPatternId"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_antenna_pattern_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Projection field_of_regard = 11 [json_name = "fieldOfRegard"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_field_of_regard(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.Projection obstructions = 12 [json_name = "obstructions"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obstructions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Polarization polarization = 17 [json_name = "polarization"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_polarization(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Targeting targeting = 18 [json_name = "targeting"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_targeting(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaDefinition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaDefinition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 2 [json_name = "name"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.AntennaDefinition.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .aalyria.spacetime.api.common.PointAxes fixed_coordinate_offset = 3 [json_name = "fixedCoordinateOffset"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fixed_coordinate_offset(this),
        _Internal::fixed_coordinate_offset(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.AntennaConstraints constraints = 6 [json_name = "constraints"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::constraints(this),
        _Internal::constraints(this).GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask azimuth_elevation_mask = 9 [json_name = "azimuthElevationMask"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_azimuth_elevation_mask_size()); i < n; i++) {
    const auto& repfield = this->_internal_azimuth_elevation_mask(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string antenna_pattern_id = 10 [json_name = "antennaPatternId"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_antenna_pattern_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.common.AntennaDefinition.antenna_pattern_id");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // optional .aalyria.spacetime.api.common.Projection field_of_regard = 11 [json_name = "fieldOfRegard"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::field_of_regard(this),
        _Internal::field_of_regard(this).GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.Projection obstructions = 12 [json_name = "obstructions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_obstructions_size()); i < n; i++) {
    const auto& repfield = this->_internal_obstructions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.Polarization polarization = 17 [json_name = "polarization"];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::polarization(this),
        _Internal::polarization(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.Targeting targeting = 18 [json_name = "targeting"];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::targeting(this),
        _Internal::targeting(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaDefinition)
  return target;
}

::size_t AntennaDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaDefinition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.AntennaDefinition.ElevationMask azimuth_elevation_mask = 9 [json_name = "azimuthElevationMask"];
  total_size += 1UL * this->_internal_azimuth_elevation_mask_size();
  for (const auto& msg : this->_internal_azimuth_elevation_mask()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.common.Projection obstructions = 12 [json_name = "obstructions"];
  total_size += 1UL * this->_internal_obstructions_size();
  for (const auto& msg : this->_internal_obstructions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 2 [json_name = "name"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional string antenna_pattern_id = 10 [json_name = "antennaPatternId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_antenna_pattern_id());
    }

    // optional .aalyria.spacetime.api.common.PointAxes fixed_coordinate_offset = 3 [json_name = "fixedCoordinateOffset"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fixed_coordinate_offset_);
    }

    // optional .aalyria.spacetime.api.common.AntennaConstraints constraints = 6 [json_name = "constraints"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_);
    }

    // optional .aalyria.spacetime.api.common.Projection field_of_regard = 11 [json_name = "fieldOfRegard"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.field_of_regard_);
    }

    // optional .aalyria.spacetime.api.common.Polarization polarization = 17 [json_name = "polarization"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.polarization_);
    }

    // optional .aalyria.spacetime.api.common.Targeting targeting = 18 [json_name = "targeting"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targeting_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaDefinition::GetClassData() const { return &_class_data_; }


void AntennaDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaDefinition*>(&to_msg);
  auto& from = static_cast<const AntennaDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaDefinition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_azimuth_elevation_mask()->MergeFrom(from._internal_azimuth_elevation_mask());
  _this->_internal_mutable_obstructions()->MergeFrom(from._internal_obstructions());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_antenna_pattern_id(from._internal_antenna_pattern_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fixed_coordinate_offset()->::aalyria::spacetime::api::common::PointAxes::MergeFrom(
          from._internal_fixed_coordinate_offset());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_constraints()->::aalyria::spacetime::api::common::AntennaConstraints::MergeFrom(
          from._internal_constraints());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_field_of_regard()->::aalyria::spacetime::api::common::Projection::MergeFrom(
          from._internal_field_of_regard());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_polarization()->::aalyria::spacetime::api::common::Polarization::MergeFrom(
          from._internal_polarization());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_targeting()->::aalyria::spacetime::api::common::Targeting::MergeFrom(
          from._internal_targeting());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaDefinition::CopyFrom(const AntennaDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaDefinition::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.fixed_coordinate_offset_->IsInitialized()) return false;
  }
  return true;
}

void AntennaDefinition::InternalSwap(AntennaDefinition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_azimuth_elevation_mask()->InternalSwap(other->_internal_mutable_azimuth_elevation_mask());
  _internal_mutable_obstructions()->InternalSwap(other->_internal_mutable_obstructions());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.antenna_pattern_id_, lhs_arena,
                                       &other->_impl_.antenna_pattern_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaDefinition, _impl_.targeting_)
      + sizeof(AntennaDefinition::_impl_.targeting_)
      - PROTOBUF_FIELD_OFFSET(AntennaDefinition, _impl_.fixed_coordinate_offset_)>(
          reinterpret_cast<char*>(&_impl_.fixed_coordinate_offset_),
          reinterpret_cast<char*>(&other->_impl_.fixed_coordinate_offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[2]);
}
// ===================================================================

class AntennaConstraints_LinkRangeConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaConstraints_LinkRangeConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaConstraints_LinkRangeConstraint, _impl_._has_bits_);
  static void set_has_minimum_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum_range(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaConstraints_LinkRangeConstraint::AntennaConstraints_LinkRangeConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
}
AntennaConstraints_LinkRangeConstraint::AntennaConstraints_LinkRangeConstraint(const AntennaConstraints_LinkRangeConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
}

inline void AntennaConstraints_LinkRangeConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_range_) { 0 }

    , decltype(_impl_.maximum_range_) { 0 }

  };
}

AntennaConstraints_LinkRangeConstraint::~AntennaConstraints_LinkRangeConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaConstraints_LinkRangeConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AntennaConstraints_LinkRangeConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaConstraints_LinkRangeConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_range_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_range_) -
        reinterpret_cast<char*>(&_impl_.minimum_range_)) + sizeof(_impl_.maximum_range_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaConstraints_LinkRangeConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double minimum_range = 1 [json_name = "minimumRange"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_minimum_range(&has_bits);
          _impl_.minimum_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double maximum_range = 2 [json_name = "maximumRange"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum_range(&has_bits);
          _impl_.maximum_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaConstraints_LinkRangeConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double minimum_range = 1 [json_name = "minimumRange"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_minimum_range(), target);
  }

  // optional double maximum_range = 2 [json_name = "maximumRange"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_maximum_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  return target;
}

::size_t AntennaConstraints_LinkRangeConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double minimum_range = 1 [json_name = "minimumRange"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double maximum_range = 2 [json_name = "maximumRange"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaConstraints_LinkRangeConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaConstraints_LinkRangeConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaConstraints_LinkRangeConstraint::GetClassData() const { return &_class_data_; }


void AntennaConstraints_LinkRangeConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaConstraints_LinkRangeConstraint*>(&to_msg);
  auto& from = static_cast<const AntennaConstraints_LinkRangeConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_range_ = from._impl_.minimum_range_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_range_ = from._impl_.maximum_range_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaConstraints_LinkRangeConstraint::CopyFrom(const AntennaConstraints_LinkRangeConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaConstraints_LinkRangeConstraint::IsInitialized() const {
  return true;
}

void AntennaConstraints_LinkRangeConstraint::InternalSwap(AntennaConstraints_LinkRangeConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaConstraints_LinkRangeConstraint, _impl_.maximum_range_)
      + sizeof(AntennaConstraints_LinkRangeConstraint::_impl_.maximum_range_)
      - PROTOBUF_FIELD_OFFSET(AntennaConstraints_LinkRangeConstraint, _impl_.minimum_range_)>(
          reinterpret_cast<char*>(&_impl_.minimum_range_),
          reinterpret_cast<char*>(&other->_impl_.minimum_range_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaConstraints_LinkRangeConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[3]);
}
// ===================================================================

class AntennaConstraints_AzimuthAngleRateConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaConstraints_AzimuthAngleRateConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaConstraints_AzimuthAngleRateConstraint, _impl_._has_bits_);
  static void set_has_minimum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaConstraints_AzimuthAngleRateConstraint::AntennaConstraints_AzimuthAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
}
AntennaConstraints_AzimuthAngleRateConstraint::AntennaConstraints_AzimuthAngleRateConstraint(const AntennaConstraints_AzimuthAngleRateConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
}

inline void AntennaConstraints_AzimuthAngleRateConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_rate_deg_per_sec_) { 0 }

    , decltype(_impl_.maximum_rate_deg_per_sec_) { 0 }

  };
}

AntennaConstraints_AzimuthAngleRateConstraint::~AntennaConstraints_AzimuthAngleRateConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaConstraints_AzimuthAngleRateConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AntennaConstraints_AzimuthAngleRateConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaConstraints_AzimuthAngleRateConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_rate_deg_per_sec_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_rate_deg_per_sec_) -
        reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_)) + sizeof(_impl_.maximum_rate_deg_per_sec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaConstraints_AzimuthAngleRateConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_minimum_rate_deg_per_sec(&has_bits);
          _impl_.minimum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum_rate_deg_per_sec(&has_bits);
          _impl_.maximum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaConstraints_AzimuthAngleRateConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_minimum_rate_deg_per_sec(), target);
  }

  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_maximum_rate_deg_per_sec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  return target;
}

::size_t AntennaConstraints_AzimuthAngleRateConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaConstraints_AzimuthAngleRateConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaConstraints_AzimuthAngleRateConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaConstraints_AzimuthAngleRateConstraint::GetClassData() const { return &_class_data_; }


void AntennaConstraints_AzimuthAngleRateConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaConstraints_AzimuthAngleRateConstraint*>(&to_msg);
  auto& from = static_cast<const AntennaConstraints_AzimuthAngleRateConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_rate_deg_per_sec_ = from._impl_.minimum_rate_deg_per_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_rate_deg_per_sec_ = from._impl_.maximum_rate_deg_per_sec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaConstraints_AzimuthAngleRateConstraint::CopyFrom(const AntennaConstraints_AzimuthAngleRateConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaConstraints_AzimuthAngleRateConstraint::IsInitialized() const {
  return true;
}

void AntennaConstraints_AzimuthAngleRateConstraint::InternalSwap(AntennaConstraints_AzimuthAngleRateConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaConstraints_AzimuthAngleRateConstraint, _impl_.maximum_rate_deg_per_sec_)
      + sizeof(AntennaConstraints_AzimuthAngleRateConstraint::_impl_.maximum_rate_deg_per_sec_)
      - PROTOBUF_FIELD_OFFSET(AntennaConstraints_AzimuthAngleRateConstraint, _impl_.minimum_rate_deg_per_sec_)>(
          reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_),
          reinterpret_cast<char*>(&other->_impl_.minimum_rate_deg_per_sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaConstraints_AzimuthAngleRateConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[4]);
}
// ===================================================================

class AntennaConstraints_ElevationAngleRateConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaConstraints_ElevationAngleRateConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaConstraints_ElevationAngleRateConstraint, _impl_._has_bits_);
  static void set_has_minimum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaConstraints_ElevationAngleRateConstraint::AntennaConstraints_ElevationAngleRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
}
AntennaConstraints_ElevationAngleRateConstraint::AntennaConstraints_ElevationAngleRateConstraint(const AntennaConstraints_ElevationAngleRateConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
}

inline void AntennaConstraints_ElevationAngleRateConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_rate_deg_per_sec_) { 0 }

    , decltype(_impl_.maximum_rate_deg_per_sec_) { 0 }

  };
}

AntennaConstraints_ElevationAngleRateConstraint::~AntennaConstraints_ElevationAngleRateConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaConstraints_ElevationAngleRateConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AntennaConstraints_ElevationAngleRateConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaConstraints_ElevationAngleRateConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_rate_deg_per_sec_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_rate_deg_per_sec_) -
        reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_)) + sizeof(_impl_.maximum_rate_deg_per_sec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaConstraints_ElevationAngleRateConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_minimum_rate_deg_per_sec(&has_bits);
          _impl_.minimum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum_rate_deg_per_sec(&has_bits);
          _impl_.maximum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaConstraints_ElevationAngleRateConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_minimum_rate_deg_per_sec(), target);
  }

  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_maximum_rate_deg_per_sec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  return target;
}

::size_t AntennaConstraints_ElevationAngleRateConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaConstraints_ElevationAngleRateConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaConstraints_ElevationAngleRateConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaConstraints_ElevationAngleRateConstraint::GetClassData() const { return &_class_data_; }


void AntennaConstraints_ElevationAngleRateConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaConstraints_ElevationAngleRateConstraint*>(&to_msg);
  auto& from = static_cast<const AntennaConstraints_ElevationAngleRateConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_rate_deg_per_sec_ = from._impl_.minimum_rate_deg_per_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_rate_deg_per_sec_ = from._impl_.maximum_rate_deg_per_sec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaConstraints_ElevationAngleRateConstraint::CopyFrom(const AntennaConstraints_ElevationAngleRateConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaConstraints_ElevationAngleRateConstraint::IsInitialized() const {
  return true;
}

void AntennaConstraints_ElevationAngleRateConstraint::InternalSwap(AntennaConstraints_ElevationAngleRateConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaConstraints_ElevationAngleRateConstraint, _impl_.maximum_rate_deg_per_sec_)
      + sizeof(AntennaConstraints_ElevationAngleRateConstraint::_impl_.maximum_rate_deg_per_sec_)
      - PROTOBUF_FIELD_OFFSET(AntennaConstraints_ElevationAngleRateConstraint, _impl_.minimum_rate_deg_per_sec_)>(
          reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_),
          reinterpret_cast<char*>(&other->_impl_.minimum_rate_deg_per_sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaConstraints_ElevationAngleRateConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[5]);
}
// ===================================================================

class AntennaConstraints_TotalAngularRateConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaConstraints_TotalAngularRateConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaConstraints_TotalAngularRateConstraint, _impl_._has_bits_);
  static void set_has_minimum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum_rate_deg_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AntennaConstraints_TotalAngularRateConstraint::AntennaConstraints_TotalAngularRateConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
}
AntennaConstraints_TotalAngularRateConstraint::AntennaConstraints_TotalAngularRateConstraint(const AntennaConstraints_TotalAngularRateConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
}

inline void AntennaConstraints_TotalAngularRateConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_rate_deg_per_sec_) { 0 }

    , decltype(_impl_.maximum_rate_deg_per_sec_) { 0 }

  };
}

AntennaConstraints_TotalAngularRateConstraint::~AntennaConstraints_TotalAngularRateConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaConstraints_TotalAngularRateConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AntennaConstraints_TotalAngularRateConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaConstraints_TotalAngularRateConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_rate_deg_per_sec_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_rate_deg_per_sec_) -
        reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_)) + sizeof(_impl_.maximum_rate_deg_per_sec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaConstraints_TotalAngularRateConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_minimum_rate_deg_per_sec(&has_bits);
          _impl_.minimum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum_rate_deg_per_sec(&has_bits);
          _impl_.maximum_rate_deg_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaConstraints_TotalAngularRateConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_minimum_rate_deg_per_sec(), target);
  }

  // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_maximum_rate_deg_per_sec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  return target;
}

::size_t AntennaConstraints_TotalAngularRateConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double minimum_rate_deg_per_sec = 1 [json_name = "minimumRateDegPerSec"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double maximum_rate_deg_per_sec = 2 [json_name = "maximumRateDegPerSec"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaConstraints_TotalAngularRateConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaConstraints_TotalAngularRateConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaConstraints_TotalAngularRateConstraint::GetClassData() const { return &_class_data_; }


void AntennaConstraints_TotalAngularRateConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaConstraints_TotalAngularRateConstraint*>(&to_msg);
  auto& from = static_cast<const AntennaConstraints_TotalAngularRateConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_rate_deg_per_sec_ = from._impl_.minimum_rate_deg_per_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_rate_deg_per_sec_ = from._impl_.maximum_rate_deg_per_sec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaConstraints_TotalAngularRateConstraint::CopyFrom(const AntennaConstraints_TotalAngularRateConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaConstraints_TotalAngularRateConstraint::IsInitialized() const {
  return true;
}

void AntennaConstraints_TotalAngularRateConstraint::InternalSwap(AntennaConstraints_TotalAngularRateConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaConstraints_TotalAngularRateConstraint, _impl_.maximum_rate_deg_per_sec_)
      + sizeof(AntennaConstraints_TotalAngularRateConstraint::_impl_.maximum_rate_deg_per_sec_)
      - PROTOBUF_FIELD_OFFSET(AntennaConstraints_TotalAngularRateConstraint, _impl_.minimum_rate_deg_per_sec_)>(
          reinterpret_cast<char*>(&_impl_.minimum_rate_deg_per_sec_),
          reinterpret_cast<char*>(&other->_impl_.minimum_rate_deg_per_sec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaConstraints_TotalAngularRateConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[6]);
}
// ===================================================================

class AntennaConstraints::_Internal {
 public:
  using HasBits = decltype(std::declval<AntennaConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AntennaConstraints, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint& link_range(const AntennaConstraints* msg);
  static void set_has_link_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint& azimuth_angle_rate(const AntennaConstraints* msg);
  static void set_has_azimuth_angle_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint& elevation_angle_rate(const AntennaConstraints* msg);
  static void set_has_elevation_angle_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint& total_angular_rate(const AntennaConstraints* msg);
  static void set_has_total_angular_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minimum_sun_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_minimum_azimuth_elevation_mask_separation_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint&
AntennaConstraints::_Internal::link_range(const AntennaConstraints* msg) {
  return *msg->_impl_.link_range_;
}
const ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint&
AntennaConstraints::_Internal::azimuth_angle_rate(const AntennaConstraints* msg) {
  return *msg->_impl_.azimuth_angle_rate_;
}
const ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint&
AntennaConstraints::_Internal::elevation_angle_rate(const AntennaConstraints* msg) {
  return *msg->_impl_.elevation_angle_rate_;
}
const ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint&
AntennaConstraints::_Internal::total_angular_rate(const AntennaConstraints* msg) {
  return *msg->_impl_.total_angular_rate_;
}
AntennaConstraints::AntennaConstraints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.AntennaConstraints)
}
AntennaConstraints::AntennaConstraints(const AntennaConstraints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AntennaConstraints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_range_){nullptr}
    , decltype(_impl_.azimuth_angle_rate_){nullptr}
    , decltype(_impl_.elevation_angle_rate_){nullptr}
    , decltype(_impl_.total_angular_rate_){nullptr}
    , decltype(_impl_.minimum_sun_angle_deg_) {}

    , decltype(_impl_.minimum_azimuth_elevation_mask_separation_deg_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.link_range_ = new ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint(*from._impl_.link_range_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.azimuth_angle_rate_ = new ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint(*from._impl_.azimuth_angle_rate_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.elevation_angle_rate_ = new ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint(*from._impl_.elevation_angle_rate_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.total_angular_rate_ = new ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint(*from._impl_.total_angular_rate_);
  }
  ::memcpy(&_impl_.minimum_sun_angle_deg_, &from._impl_.minimum_sun_angle_deg_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.minimum_azimuth_elevation_mask_separation_deg_) -
    reinterpret_cast<char*>(&_impl_.minimum_sun_angle_deg_)) + sizeof(_impl_.minimum_azimuth_elevation_mask_separation_deg_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.AntennaConstraints)
}

inline void AntennaConstraints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.link_range_){nullptr}
    , decltype(_impl_.azimuth_angle_rate_){nullptr}
    , decltype(_impl_.elevation_angle_rate_){nullptr}
    , decltype(_impl_.total_angular_rate_){nullptr}
    , decltype(_impl_.minimum_sun_angle_deg_) { 0 }

    , decltype(_impl_.minimum_azimuth_elevation_mask_separation_deg_) { 0 }

  };
}

AntennaConstraints::~AntennaConstraints() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.AntennaConstraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AntennaConstraints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.link_range_;
  if (this != internal_default_instance()) delete _impl_.azimuth_angle_rate_;
  if (this != internal_default_instance()) delete _impl_.elevation_angle_rate_;
  if (this != internal_default_instance()) delete _impl_.total_angular_rate_;
}

void AntennaConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AntennaConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.AntennaConstraints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.link_range_ != nullptr);
      _impl_.link_range_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.azimuth_angle_rate_ != nullptr);
      _impl_.azimuth_angle_rate_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.elevation_angle_rate_ != nullptr);
      _impl_.elevation_angle_rate_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.total_angular_rate_ != nullptr);
      _impl_.total_angular_rate_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.minimum_sun_angle_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.minimum_azimuth_elevation_mask_separation_deg_) -
        reinterpret_cast<char*>(&_impl_.minimum_sun_angle_deg_)) + sizeof(_impl_.minimum_azimuth_elevation_mask_separation_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AntennaConstraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint link_range = 1 [json_name = "linkRange"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_link_range(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint azimuth_angle_rate = 3 [json_name = "azimuthAngleRate"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_azimuth_angle_rate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint elevation_angle_rate = 4 [json_name = "elevationAngleRate"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_elevation_angle_rate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint total_angular_rate = 5 [json_name = "totalAngularRate"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_angular_rate(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double minimum_sun_angle_deg = 6 [json_name = "minimumSunAngleDeg"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_minimum_sun_angle_deg(&has_bits);
          _impl_.minimum_sun_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double minimum_azimuth_elevation_mask_separation_deg = 7 [json_name = "minimumAzimuthElevationMaskSeparationDeg"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 57)) {
          _Internal::set_has_minimum_azimuth_elevation_mask_separation_deg(&has_bits);
          _impl_.minimum_azimuth_elevation_mask_separation_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AntennaConstraints::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.AntennaConstraints)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint link_range = 1 [json_name = "linkRange"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::link_range(this),
        _Internal::link_range(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint azimuth_angle_rate = 3 [json_name = "azimuthAngleRate"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::azimuth_angle_rate(this),
        _Internal::azimuth_angle_rate(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint elevation_angle_rate = 4 [json_name = "elevationAngleRate"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::elevation_angle_rate(this),
        _Internal::elevation_angle_rate(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint total_angular_rate = 5 [json_name = "totalAngularRate"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::total_angular_rate(this),
        _Internal::total_angular_rate(this).GetCachedSize(), target, stream);
  }

  // optional double minimum_sun_angle_deg = 6 [json_name = "minimumSunAngleDeg"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_minimum_sun_angle_deg(), target);
  }

  // optional double minimum_azimuth_elevation_mask_separation_deg = 7 [json_name = "minimumAzimuthElevationMaskSeparationDeg"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_minimum_azimuth_elevation_mask_separation_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.AntennaConstraints)
  return target;
}

::size_t AntennaConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.AntennaConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint link_range = 1 [json_name = "linkRange"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.link_range_);
    }

    // optional .aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint azimuth_angle_rate = 3 [json_name = "azimuthAngleRate"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.azimuth_angle_rate_);
    }

    // optional .aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint elevation_angle_rate = 4 [json_name = "elevationAngleRate"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.elevation_angle_rate_);
    }

    // optional .aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint total_angular_rate = 5 [json_name = "totalAngularRate"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_angular_rate_);
    }

    // optional double minimum_sun_angle_deg = 6 [json_name = "minimumSunAngleDeg"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 9;
    }

    // optional double minimum_azimuth_elevation_mask_separation_deg = 7 [json_name = "minimumAzimuthElevationMaskSeparationDeg"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AntennaConstraints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AntennaConstraints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AntennaConstraints::GetClassData() const { return &_class_data_; }


void AntennaConstraints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AntennaConstraints*>(&to_msg);
  auto& from = static_cast<const AntennaConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.AntennaConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_link_range()->::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint::MergeFrom(
          from._internal_link_range());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_azimuth_angle_rate()->::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint::MergeFrom(
          from._internal_azimuth_angle_rate());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_elevation_angle_rate()->::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint::MergeFrom(
          from._internal_elevation_angle_rate());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_total_angular_rate()->::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint::MergeFrom(
          from._internal_total_angular_rate());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.minimum_sun_angle_deg_ = from._impl_.minimum_sun_angle_deg_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.minimum_azimuth_elevation_mask_separation_deg_ = from._impl_.minimum_azimuth_elevation_mask_separation_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AntennaConstraints::CopyFrom(const AntennaConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.AntennaConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntennaConstraints::IsInitialized() const {
  return true;
}

void AntennaConstraints::InternalSwap(AntennaConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AntennaConstraints, _impl_.minimum_azimuth_elevation_mask_separation_deg_)
      + sizeof(AntennaConstraints::_impl_.minimum_azimuth_elevation_mask_separation_deg_)
      - PROTOBUF_FIELD_OFFSET(AntennaConstraints, _impl_.link_range_)>(
          reinterpret_cast<char*>(&_impl_.link_range_),
          reinterpret_cast<char*>(&other->_impl_.link_range_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AntennaConstraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[7]);
}
// ===================================================================

class Projection_Conic::_Internal {
 public:
  using HasBits = decltype(std::declval<Projection_Conic>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Projection_Conic, _impl_._has_bits_);
  static void set_has_outer_half_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_inner_half_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Projection_Conic::Projection_Conic(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Projection.Conic)
}
Projection_Conic::Projection_Conic(const Projection_Conic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Projection.Conic)
}

inline void Projection_Conic::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outer_half_angle_deg_) { 0 }

    , decltype(_impl_.inner_half_angle_deg_) { 0 }

  };
}

Projection_Conic::~Projection_Conic() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Projection.Conic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Projection_Conic::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Projection_Conic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Projection_Conic::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Projection.Conic)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.outer_half_angle_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.inner_half_angle_deg_) -
        reinterpret_cast<char*>(&_impl_.outer_half_angle_deg_)) + sizeof(_impl_.inner_half_angle_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Projection_Conic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double outer_half_angle_deg = 1 [json_name = "outerHalfAngleDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_outer_half_angle_deg(&has_bits);
          _impl_.outer_half_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double inner_half_angle_deg = 2 [json_name = "innerHalfAngleDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_inner_half_angle_deg(&has_bits);
          _impl_.inner_half_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Projection_Conic::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Projection.Conic)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double outer_half_angle_deg = 1 [json_name = "outerHalfAngleDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_outer_half_angle_deg(), target);
  }

  // optional double inner_half_angle_deg = 2 [json_name = "innerHalfAngleDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_inner_half_angle_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Projection.Conic)
  return target;
}

::size_t Projection_Conic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Projection.Conic)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double outer_half_angle_deg = 1 [json_name = "outerHalfAngleDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double inner_half_angle_deg = 2 [json_name = "innerHalfAngleDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Projection_Conic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Projection_Conic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Projection_Conic::GetClassData() const { return &_class_data_; }


void Projection_Conic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Projection_Conic*>(&to_msg);
  auto& from = static_cast<const Projection_Conic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Projection.Conic)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.outer_half_angle_deg_ = from._impl_.outer_half_angle_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.inner_half_angle_deg_ = from._impl_.inner_half_angle_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Projection_Conic::CopyFrom(const Projection_Conic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Projection.Conic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection_Conic::IsInitialized() const {
  return true;
}

void Projection_Conic::InternalSwap(Projection_Conic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Projection_Conic, _impl_.inner_half_angle_deg_)
      + sizeof(Projection_Conic::_impl_.inner_half_angle_deg_)
      - PROTOBUF_FIELD_OFFSET(Projection_Conic, _impl_.outer_half_angle_deg_)>(
          reinterpret_cast<char*>(&_impl_.outer_half_angle_deg_),
          reinterpret_cast<char*>(&other->_impl_.outer_half_angle_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Projection_Conic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[8]);
}
// ===================================================================

class Projection_Rectangular::_Internal {
 public:
  using HasBits = decltype(std::declval<Projection_Rectangular>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Projection_Rectangular, _impl_._has_bits_);
  static void set_has_x_half_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y_half_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Projection_Rectangular::Projection_Rectangular(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Projection.Rectangular)
}
Projection_Rectangular::Projection_Rectangular(const Projection_Rectangular& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Projection.Rectangular)
}

inline void Projection_Rectangular::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_half_angle_deg_) { 0 }

    , decltype(_impl_.y_half_angle_deg_) { 0 }

  };
}

Projection_Rectangular::~Projection_Rectangular() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Projection.Rectangular)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Projection_Rectangular::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Projection_Rectangular::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Projection_Rectangular::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Projection.Rectangular)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_half_angle_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.y_half_angle_deg_) -
        reinterpret_cast<char*>(&_impl_.x_half_angle_deg_)) + sizeof(_impl_.y_half_angle_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Projection_Rectangular::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x_half_angle_deg = 1 [json_name = "xHalfAngleDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_x_half_angle_deg(&has_bits);
          _impl_.x_half_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double y_half_angle_deg = 2 [json_name = "yHalfAngleDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_y_half_angle_deg(&has_bits);
          _impl_.y_half_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Projection_Rectangular::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Projection.Rectangular)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double x_half_angle_deg = 1 [json_name = "xHalfAngleDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_x_half_angle_deg(), target);
  }

  // optional double y_half_angle_deg = 2 [json_name = "yHalfAngleDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_y_half_angle_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Projection.Rectangular)
  return target;
}

::size_t Projection_Rectangular::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Projection.Rectangular)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double x_half_angle_deg = 1 [json_name = "xHalfAngleDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double y_half_angle_deg = 2 [json_name = "yHalfAngleDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Projection_Rectangular::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Projection_Rectangular::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Projection_Rectangular::GetClassData() const { return &_class_data_; }


void Projection_Rectangular::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Projection_Rectangular*>(&to_msg);
  auto& from = static_cast<const Projection_Rectangular&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Projection.Rectangular)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_half_angle_deg_ = from._impl_.x_half_angle_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_half_angle_deg_ = from._impl_.y_half_angle_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Projection_Rectangular::CopyFrom(const Projection_Rectangular& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Projection.Rectangular)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection_Rectangular::IsInitialized() const {
  return true;
}

void Projection_Rectangular::InternalSwap(Projection_Rectangular* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Projection_Rectangular, _impl_.y_half_angle_deg_)
      + sizeof(Projection_Rectangular::_impl_.y_half_angle_deg_)
      - PROTOBUF_FIELD_OFFSET(Projection_Rectangular, _impl_.x_half_angle_deg_)>(
          reinterpret_cast<char*>(&_impl_.x_half_angle_deg_),
          reinterpret_cast<char*>(&other->_impl_.x_half_angle_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Projection_Rectangular::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[9]);
}
// ===================================================================

class Projection_Custom::_Internal {
 public:
};

void Projection_Custom::clear_directions() {
  _internal_mutable_directions()->Clear();
}
Projection_Custom::Projection_Custom(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Projection.Custom)
}
Projection_Custom::Projection_Custom(const Projection_Custom& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Projection_Custom* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.directions_){from._impl_.directions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Projection.Custom)
}

inline void Projection_Custom::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.directions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Projection_Custom::~Projection_Custom() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Projection.Custom)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Projection_Custom::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_directions()->~RepeatedPtrField();
}

void Projection_Custom::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Projection_Custom::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Projection.Custom)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_directions()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Projection_Custom::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.PointingVector directions = 1 [json_name = "directions"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_directions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Projection_Custom::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Projection.Custom)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.PointingVector directions = 1 [json_name = "directions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_directions_size()); i < n; i++) {
    const auto& repfield = this->_internal_directions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Projection.Custom)
  return target;
}

::size_t Projection_Custom::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Projection.Custom)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.PointingVector directions = 1 [json_name = "directions"];
  total_size += 1UL * this->_internal_directions_size();
  for (const auto& msg : this->_internal_directions()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Projection_Custom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Projection_Custom::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Projection_Custom::GetClassData() const { return &_class_data_; }


void Projection_Custom::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Projection_Custom*>(&to_msg);
  auto& from = static_cast<const Projection_Custom&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Projection.Custom)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_directions()->MergeFrom(from._internal_directions());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Projection_Custom::CopyFrom(const Projection_Custom& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Projection.Custom)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection_Custom::IsInitialized() const {
  return true;
}

void Projection_Custom::InternalSwap(Projection_Custom* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_directions()->InternalSwap(other->_internal_mutable_directions());
}

::PROTOBUF_NAMESPACE_ID::Metadata Projection_Custom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[10]);
}
// ===================================================================

class Projection::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Projection, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::Projection_Conic& conic(const Projection* msg);
  static const ::aalyria::spacetime::api::common::Projection_Rectangular& rectangular(const Projection* msg);
  static const ::aalyria::spacetime::api::common::Projection_Custom& custom(const Projection* msg);
};

const ::aalyria::spacetime::api::common::Projection_Conic&
Projection::_Internal::conic(const Projection* msg) {
  return *msg->_impl_.shape_type_.conic_;
}
const ::aalyria::spacetime::api::common::Projection_Rectangular&
Projection::_Internal::rectangular(const Projection* msg) {
  return *msg->_impl_.shape_type_.rectangular_;
}
const ::aalyria::spacetime::api::common::Projection_Custom&
Projection::_Internal::custom(const Projection* msg) {
  return *msg->_impl_.shape_type_.custom_;
}
void Projection::set_allocated_conic(::aalyria::spacetime::api::common::Projection_Conic* conic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape_type();
  if (conic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conic);
    if (message_arena != submessage_arena) {
      conic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conic, submessage_arena);
    }
    set_has_conic();
    _impl_.shape_type_.conic_ = conic;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Projection.conic)
}
void Projection::set_allocated_rectangular(::aalyria::spacetime::api::common::Projection_Rectangular* rectangular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape_type();
  if (rectangular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rectangular);
    if (message_arena != submessage_arena) {
      rectangular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangular, submessage_arena);
    }
    set_has_rectangular();
    _impl_.shape_type_.rectangular_ = rectangular;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Projection.rectangular)
}
void Projection::set_allocated_custom(::aalyria::spacetime::api::common::Projection_Custom* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape_type();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    _impl_.shape_type_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Projection.custom)
}
Projection::Projection(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Projection)
}
Projection::Projection(const Projection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Projection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_shape_type();
  switch (from.shape_type_case()) {
    case kConic: {
      _this->_internal_mutable_conic()->::aalyria::spacetime::api::common::Projection_Conic::MergeFrom(
          from._internal_conic());
      break;
    }
    case kRectangular: {
      _this->_internal_mutable_rectangular()->::aalyria::spacetime::api::common::Projection_Rectangular::MergeFrom(
          from._internal_rectangular());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::aalyria::spacetime::api::common::Projection_Custom::MergeFrom(
          from._internal_custom());
      break;
    }
    case SHAPE_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Projection)
}

inline void Projection::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.shape_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_shape_type();
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Projection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Projection::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_shape_type()) {
    clear_shape_type();
  }
}

void Projection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Projection::clear_shape_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.Projection)
  switch (shape_type_case()) {
    case kConic: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_type_.conic_;
      }
      break;
    }
    case kRectangular: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_type_.rectangular_;
      }
      break;
    }
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.shape_type_.custom_;
      }
      break;
    }
    case SHAPE_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SHAPE_TYPE_NOT_SET;
}


void Projection::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Projection)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_shape_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Projection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.Projection.Conic conic = 1 [json_name = "conic"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_conic(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Projection.Rectangular rectangular = 2 [json_name = "rectangular"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rectangular(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Projection.Custom custom = 3 [json_name = "custom"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Projection::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Projection)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (shape_type_case()) {
    case kConic: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::conic(this),
          _Internal::conic(this).GetCachedSize(), target, stream);
      break;
    }
    case kRectangular: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::rectangular(this),
          _Internal::rectangular(this).GetCachedSize(), target, stream);
      break;
    }
    case kCustom: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::custom(this),
          _Internal::custom(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Projection)
  return target;
}

::size_t Projection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Projection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (shape_type_case()) {
    // .aalyria.spacetime.api.common.Projection.Conic conic = 1 [json_name = "conic"];
    case kConic: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_type_.conic_);
      break;
    }
    // .aalyria.spacetime.api.common.Projection.Rectangular rectangular = 2 [json_name = "rectangular"];
    case kRectangular: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_type_.rectangular_);
      break;
    }
    // .aalyria.spacetime.api.common.Projection.Custom custom = 3 [json_name = "custom"];
    case kCustom: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_type_.custom_);
      break;
    }
    case SHAPE_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Projection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Projection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Projection::GetClassData() const { return &_class_data_; }


void Projection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Projection*>(&to_msg);
  auto& from = static_cast<const Projection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Projection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.shape_type_case()) {
    case kConic: {
      _this->_internal_mutable_conic()->::aalyria::spacetime::api::common::Projection_Conic::MergeFrom(
          from._internal_conic());
      break;
    }
    case kRectangular: {
      _this->_internal_mutable_rectangular()->::aalyria::spacetime::api::common::Projection_Rectangular::MergeFrom(
          from._internal_rectangular());
      break;
    }
    case kCustom: {
      _this->_internal_mutable_custom()->::aalyria::spacetime::api::common::Projection_Custom::MergeFrom(
          from._internal_custom());
      break;
    }
    case SHAPE_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Projection::CopyFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  return true;
}

void Projection::InternalSwap(Projection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.shape_type_, other->_impl_.shape_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Projection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[11]);
}
// ===================================================================

class Polarization_Constant_Linear::_Internal {
 public:
  using HasBits = decltype(std::declval<Polarization_Constant_Linear>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Polarization_Constant_Linear, _impl_._has_bits_);
  static void set_has_tilt_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Polarization_Constant_Linear::Polarization_Constant_Linear(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Polarization.Constant.Linear)
}
Polarization_Constant_Linear::Polarization_Constant_Linear(const Polarization_Constant_Linear& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Polarization.Constant.Linear)
}

inline void Polarization_Constant_Linear::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tilt_angle_deg_) { 0 }

  };
}

Polarization_Constant_Linear::~Polarization_Constant_Linear() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Polarization_Constant_Linear::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Polarization_Constant_Linear::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Polarization_Constant_Linear::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tilt_angle_deg_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Polarization_Constant_Linear::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double tilt_angle_deg = 1 [json_name = "tiltAngleDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_tilt_angle_deg(&has_bits);
          _impl_.tilt_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Polarization_Constant_Linear::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double tilt_angle_deg = 1 [json_name = "tiltAngleDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_tilt_angle_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  return target;
}

::size_t Polarization_Constant_Linear::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double tilt_angle_deg = 1 [json_name = "tiltAngleDeg"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Polarization_Constant_Linear::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Polarization_Constant_Linear::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Polarization_Constant_Linear::GetClassData() const { return &_class_data_; }


void Polarization_Constant_Linear::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Polarization_Constant_Linear*>(&to_msg);
  auto& from = static_cast<const Polarization_Constant_Linear&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_tilt_angle_deg(from._internal_tilt_angle_deg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Polarization_Constant_Linear::CopyFrom(const Polarization_Constant_Linear& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Polarization.Constant.Linear)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polarization_Constant_Linear::IsInitialized() const {
  return true;
}

void Polarization_Constant_Linear::InternalSwap(Polarization_Constant_Linear* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.tilt_angle_deg_, other->_impl_.tilt_angle_deg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Polarization_Constant_Linear::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[12]);
}
// ===================================================================

class Polarization_Constant::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization_Constant, _impl_._oneof_case_);
  static const ::PROTOBUF_NAMESPACE_ID::Empty& left_hand_circular(const Polarization_Constant* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Empty& right_hand_circular(const Polarization_Constant* msg);
  static const ::aalyria::spacetime::api::common::Polarization_Constant_Linear& linear(const Polarization_Constant* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Empty&
Polarization_Constant::_Internal::left_hand_circular(const Polarization_Constant* msg) {
  return *msg->_impl_.polarization_.left_hand_circular_;
}
const ::PROTOBUF_NAMESPACE_ID::Empty&
Polarization_Constant::_Internal::right_hand_circular(const Polarization_Constant* msg) {
  return *msg->_impl_.polarization_.right_hand_circular_;
}
const ::aalyria::spacetime::api::common::Polarization_Constant_Linear&
Polarization_Constant::_Internal::linear(const Polarization_Constant* msg) {
  return *msg->_impl_.polarization_.linear_;
}
void Polarization_Constant::set_allocated_left_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* left_hand_circular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_polarization();
  if (left_hand_circular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_hand_circular));
    if (message_arena != submessage_arena) {
      left_hand_circular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_hand_circular, submessage_arena);
    }
    set_has_left_hand_circular();
    _impl_.polarization_.left_hand_circular_ = left_hand_circular;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular)
}
void Polarization_Constant::clear_left_hand_circular() {
  if (polarization_case() == kLeftHandCircular) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.polarization_.left_hand_circular_;
    }
    clear_has_polarization();
  }
}
void Polarization_Constant::set_allocated_right_hand_circular(::PROTOBUF_NAMESPACE_ID::Empty* right_hand_circular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_polarization();
  if (right_hand_circular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_hand_circular));
    if (message_arena != submessage_arena) {
      right_hand_circular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_hand_circular, submessage_arena);
    }
    set_has_right_hand_circular();
    _impl_.polarization_.right_hand_circular_ = right_hand_circular;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular)
}
void Polarization_Constant::clear_right_hand_circular() {
  if (polarization_case() == kRightHandCircular) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.polarization_.right_hand_circular_;
    }
    clear_has_polarization();
  }
}
void Polarization_Constant::set_allocated_linear(::aalyria::spacetime::api::common::Polarization_Constant_Linear* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_polarization();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    _impl_.polarization_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Polarization.Constant.linear)
}
Polarization_Constant::Polarization_Constant(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Polarization.Constant)
}
Polarization_Constant::Polarization_Constant(const Polarization_Constant& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Polarization_Constant* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.polarization_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_polarization();
  switch (from.polarization_case()) {
    case kLeftHandCircular: {
      _this->_internal_mutable_left_hand_circular()->::PROTOBUF_NAMESPACE_ID::Empty::MergeFrom(
          from._internal_left_hand_circular());
      break;
    }
    case kRightHandCircular: {
      _this->_internal_mutable_right_hand_circular()->::PROTOBUF_NAMESPACE_ID::Empty::MergeFrom(
          from._internal_right_hand_circular());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::aalyria::spacetime::api::common::Polarization_Constant_Linear::MergeFrom(
          from._internal_linear());
      break;
    }
    case POLARIZATION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Polarization.Constant)
}

inline void Polarization_Constant::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.polarization_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_polarization();
}

Polarization_Constant::~Polarization_Constant() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Polarization.Constant)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Polarization_Constant::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_polarization()) {
    clear_polarization();
  }
}

void Polarization_Constant::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Polarization_Constant::clear_polarization() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.Polarization.Constant)
  switch (polarization_case()) {
    case kLeftHandCircular: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.polarization_.left_hand_circular_;
      }
      break;
    }
    case kRightHandCircular: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.polarization_.right_hand_circular_;
      }
      break;
    }
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.polarization_.linear_;
      }
      break;
    }
    case POLARIZATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = POLARIZATION_NOT_SET;
}


void Polarization_Constant::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Polarization.Constant)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_polarization();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Polarization_Constant::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Empty left_hand_circular = 1 [json_name = "leftHandCircular"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_left_hand_circular(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .google.protobuf.Empty right_hand_circular = 2 [json_name = "rightHandCircular"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_right_hand_circular(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.common.Polarization.Constant.Linear linear = 3 [json_name = "linear"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Polarization_Constant::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Polarization.Constant)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (polarization_case()) {
    case kLeftHandCircular: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::left_hand_circular(this),
          _Internal::left_hand_circular(this).GetCachedSize(), target, stream);
      break;
    }
    case kRightHandCircular: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::right_hand_circular(this),
          _Internal::right_hand_circular(this).GetCachedSize(), target, stream);
      break;
    }
    case kLinear: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::linear(this),
          _Internal::linear(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Polarization.Constant)
  return target;
}

::size_t Polarization_Constant::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Polarization.Constant)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (polarization_case()) {
    // .google.protobuf.Empty left_hand_circular = 1 [json_name = "leftHandCircular"];
    case kLeftHandCircular: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.polarization_.left_hand_circular_);
      break;
    }
    // .google.protobuf.Empty right_hand_circular = 2 [json_name = "rightHandCircular"];
    case kRightHandCircular: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.polarization_.right_hand_circular_);
      break;
    }
    // .aalyria.spacetime.api.common.Polarization.Constant.Linear linear = 3 [json_name = "linear"];
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.polarization_.linear_);
      break;
    }
    case POLARIZATION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Polarization_Constant::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Polarization_Constant::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Polarization_Constant::GetClassData() const { return &_class_data_; }


void Polarization_Constant::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Polarization_Constant*>(&to_msg);
  auto& from = static_cast<const Polarization_Constant&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Polarization.Constant)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.polarization_case()) {
    case kLeftHandCircular: {
      _this->_internal_mutable_left_hand_circular()->::PROTOBUF_NAMESPACE_ID::Empty::MergeFrom(
          from._internal_left_hand_circular());
      break;
    }
    case kRightHandCircular: {
      _this->_internal_mutable_right_hand_circular()->::PROTOBUF_NAMESPACE_ID::Empty::MergeFrom(
          from._internal_right_hand_circular());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::aalyria::spacetime::api::common::Polarization_Constant_Linear::MergeFrom(
          from._internal_linear());
      break;
    }
    case POLARIZATION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Polarization_Constant::CopyFrom(const Polarization_Constant& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Polarization.Constant)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polarization_Constant::IsInitialized() const {
  return true;
}

void Polarization_Constant::InternalSwap(Polarization_Constant* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.polarization_, other->_impl_.polarization_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Polarization_Constant::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[13]);
}
// ===================================================================

class Polarization::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::common::Polarization, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::Polarization_Constant& constant(const Polarization* msg);
};

const ::aalyria::spacetime::api::common::Polarization_Constant&
Polarization::_Internal::constant(const Polarization* msg) {
  return *msg->_impl_.source_.constant_;
}
void Polarization::set_allocated_constant(::aalyria::spacetime::api::common::Polarization_Constant* constant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source();
  if (constant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constant);
    if (message_arena != submessage_arena) {
      constant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constant, submessage_arena);
    }
    set_has_constant();
    _impl_.source_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Polarization.constant)
}
Polarization::Polarization(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Polarization)
}
Polarization::Polarization(const Polarization& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Polarization* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_source();
  switch (from.source_case()) {
    case kConstant: {
      _this->_internal_mutable_constant()->::aalyria::spacetime::api::common::Polarization_Constant::MergeFrom(
          from._internal_constant());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Polarization)
}

inline void Polarization::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_source();
}

Polarization::~Polarization() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Polarization)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Polarization::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_source()) {
    clear_source();
  }
}

void Polarization::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Polarization::clear_source() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.common.Polarization)
  switch (source_case()) {
    case kConstant: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_.constant_;
      }
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}


void Polarization::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Polarization)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_source();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Polarization::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.Polarization.Constant constant = 1 [json_name = "constant"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_constant(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Polarization::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Polarization)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .aalyria.spacetime.api.common.Polarization.Constant constant = 1 [json_name = "constant"];
  if (source_case() == kConstant) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::constant(this),
        _Internal::constant(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Polarization)
  return target;
}

::size_t Polarization::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Polarization)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (source_case()) {
    // .aalyria.spacetime.api.common.Polarization.Constant constant = 1 [json_name = "constant"];
    case kConstant: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_.constant_);
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Polarization::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Polarization::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Polarization::GetClassData() const { return &_class_data_; }


void Polarization::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Polarization*>(&to_msg);
  auto& from = static_cast<const Polarization&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Polarization)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.source_case()) {
    case kConstant: {
      _this->_internal_mutable_constant()->::aalyria::spacetime::api::common::Polarization_Constant::MergeFrom(
          from._internal_constant());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Polarization::CopyFrom(const Polarization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Polarization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polarization::IsInitialized() const {
  return true;
}

void Polarization::InternalSwap(Polarization* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.source_, other->_impl_.source_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Polarization::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[14]);
}
// ===================================================================

class Targeting::_Internal {
 public:
  using HasBits = decltype(std::declval<Targeting>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Targeting, _impl_._has_bits_);
  static void set_has_motion_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Targeting::Targeting(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.common.Targeting)
}
Targeting::Targeting(const Targeting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.common.Targeting)
}

inline void Targeting::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.motion_format_) { 0 }

  };
}

Targeting::~Targeting() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.common.Targeting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Targeting::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Targeting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Targeting::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.common.Targeting)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.motion_format_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Targeting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.Motion.Type motion_format = 1 [json_name = "motionFormat"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::common::Motion_Type_IsValid(static_cast<int>(val)))) {
            _internal_set_motion_format(static_cast<::aalyria::spacetime::api::common::Motion_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Targeting::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.common.Targeting)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.Motion.Type motion_format = 1 [json_name = "motionFormat"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_motion_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.common.Targeting)
  return target;
}

::size_t Targeting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.common.Targeting)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .aalyria.spacetime.api.common.Motion.Type motion_format = 1 [json_name = "motionFormat"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_motion_format());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Targeting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Targeting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Targeting::GetClassData() const { return &_class_data_; }


void Targeting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Targeting*>(&to_msg);
  auto& from = static_cast<const Targeting&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.common.Targeting)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_motion_format(from._internal_motion_format());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Targeting::CopyFrom(const Targeting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.common.Targeting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Targeting::IsInitialized() const {
  return true;
}

void Targeting::InternalSwap(Targeting* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.motion_format_, other->_impl_.motion_format_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Targeting::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_getter, &descriptor_table_api_2fcommon_2fplatform_5fantenna_2eproto_once,
      file_level_metadata_api_2fcommon_2fplatform_5fantenna_2eproto[15]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask_ElevationRise >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaDefinition_ElevationMask >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaDefinition*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaConstraints_LinkRangeConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaConstraints_AzimuthAngleRateConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaConstraints_ElevationAngleRateConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaConstraints_TotalAngularRateConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::AntennaConstraints*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::AntennaConstraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::AntennaConstraints >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Projection_Conic*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Conic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Projection_Conic >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Projection_Rectangular*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Rectangular >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Projection_Rectangular >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Projection_Custom*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection_Custom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Projection_Custom >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Projection*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Projection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Projection >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Polarization_Constant_Linear*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Polarization_Constant_Linear >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Polarization_Constant_Linear >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Polarization_Constant*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Polarization_Constant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Polarization_Constant >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Polarization*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Polarization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Polarization >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::common::Targeting*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::common::Targeting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::common::Targeting >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
