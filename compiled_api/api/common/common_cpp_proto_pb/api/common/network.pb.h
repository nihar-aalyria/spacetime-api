// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/common/network.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fnetwork_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fnetwork_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcommon_2fnetwork_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcommon_2fnetwork_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcommon_2fnetwork_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace common {
class FlowClassifier;
struct FlowClassifierDefaultTypeInternal;
extern FlowClassifierDefaultTypeInternal _FlowClassifier_default_instance_;
class IpFlowClassifier;
struct IpFlowClassifierDefaultTypeInternal;
extern IpFlowClassifierDefaultTypeInternal _IpFlowClassifier_default_instance_;
class NetworkInterfaceId;
struct NetworkInterfaceIdDefaultTypeInternal;
extern NetworkInterfaceIdDefaultTypeInternal _NetworkInterfaceId_default_instance_;
class PacketClassifier;
struct PacketClassifierDefaultTypeInternal;
extern PacketClassifierDefaultTypeInternal _PacketClassifier_default_instance_;
class PacketClassifier_EthernetHeader;
struct PacketClassifier_EthernetHeaderDefaultTypeInternal;
extern PacketClassifier_EthernetHeaderDefaultTypeInternal _PacketClassifier_EthernetHeader_default_instance_;
class PacketClassifier_GenericLayer4Header;
struct PacketClassifier_GenericLayer4HeaderDefaultTypeInternal;
extern PacketClassifier_GenericLayer4HeaderDefaultTypeInternal _PacketClassifier_GenericLayer4Header_default_instance_;
class PacketClassifier_IpHeader;
struct PacketClassifier_IpHeaderDefaultTypeInternal;
extern PacketClassifier_IpHeaderDefaultTypeInternal _PacketClassifier_IpHeader_default_instance_;
class PacketClassifier_MplsLabelStackEntry;
struct PacketClassifier_MplsLabelStackEntryDefaultTypeInternal;
extern PacketClassifier_MplsLabelStackEntryDefaultTypeInternal _PacketClassifier_MplsLabelStackEntry_default_instance_;
class PacketClassifier_ValueRange;
struct PacketClassifier_ValueRangeDefaultTypeInternal;
extern PacketClassifier_ValueRangeDefaultTypeInternal _PacketClassifier_ValueRange_default_instance_;
class Subnet;
struct SubnetDefaultTypeInternal;
extern SubnetDefaultTypeInternal _Subnet_default_instance_;
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::common::FlowClassifier* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::FlowClassifier>(Arena*);
template <>
::aalyria::spacetime::api::common::IpFlowClassifier* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::IpFlowClassifier>(Arena*);
template <>
::aalyria::spacetime::api::common::NetworkInterfaceId* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier_IpHeader* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_IpHeader>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry>(Arena*);
template <>
::aalyria::spacetime::api::common::PacketClassifier_ValueRange* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>(Arena*);
template <>
::aalyria::spacetime::api::common::Subnet* Arena::CreateMaybeMessage<::aalyria::spacetime::api::common::Subnet>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class NetworkInterfaceId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.NetworkInterfaceId) */ {
 public:
  inline NetworkInterfaceId() : NetworkInterfaceId(nullptr) {}
  ~NetworkInterfaceId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkInterfaceId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkInterfaceId(const NetworkInterfaceId& from);
  NetworkInterfaceId(NetworkInterfaceId&& from) noexcept
    : NetworkInterfaceId() {
    *this = ::std::move(from);
  }

  inline NetworkInterfaceId& operator=(const NetworkInterfaceId& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkInterfaceId& operator=(NetworkInterfaceId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkInterfaceId& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkInterfaceId* internal_default_instance() {
    return reinterpret_cast<const NetworkInterfaceId*>(
               &_NetworkInterfaceId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetworkInterfaceId& a, NetworkInterfaceId& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkInterfaceId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkInterfaceId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkInterfaceId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkInterfaceId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkInterfaceId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkInterfaceId& from) {
    NetworkInterfaceId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkInterfaceId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.NetworkInterfaceId";
  }
  protected:
  explicit NetworkInterfaceId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kInterfaceIdFieldNumber = 2,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional string interface_id = 2 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.NetworkInterfaceId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier_ValueRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier.ValueRange) */ {
 public:
  inline PacketClassifier_ValueRange() : PacketClassifier_ValueRange(nullptr) {}
  ~PacketClassifier_ValueRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier_ValueRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier_ValueRange(const PacketClassifier_ValueRange& from);
  PacketClassifier_ValueRange(PacketClassifier_ValueRange&& from) noexcept
    : PacketClassifier_ValueRange() {
    *this = ::std::move(from);
  }

  inline PacketClassifier_ValueRange& operator=(const PacketClassifier_ValueRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier_ValueRange& operator=(PacketClassifier_ValueRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier_ValueRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketClassifier_ValueRange* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier_ValueRange*>(
               &_PacketClassifier_ValueRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PacketClassifier_ValueRange& a, PacketClassifier_ValueRange& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier_ValueRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier_ValueRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier_ValueRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier_ValueRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier_ValueRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier_ValueRange& from) {
    PacketClassifier_ValueRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier_ValueRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier.ValueRange";
  }
  protected:
  explicit PacketClassifier_ValueRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // optional uint32 low = 1 [json_name = "low"];
  bool has_low() const;
  void clear_low() ;
  ::uint32_t low() const;
  void set_low(::uint32_t value);

  private:
  ::uint32_t _internal_low() const;
  void _internal_set_low(::uint32_t value);

  public:
  // optional uint32 high = 2 [json_name = "high"];
  bool has_high() const;
  void clear_high() ;
  ::uint32_t high() const;
  void set_high(::uint32_t value);

  private:
  ::uint32_t _internal_high() const;
  void _internal_set_high(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier.ValueRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t low_;
    ::uint32_t high_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier_IpHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier.IpHeader) */ {
 public:
  inline PacketClassifier_IpHeader() : PacketClassifier_IpHeader(nullptr) {}
  ~PacketClassifier_IpHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier_IpHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier_IpHeader(const PacketClassifier_IpHeader& from);
  PacketClassifier_IpHeader(PacketClassifier_IpHeader&& from) noexcept
    : PacketClassifier_IpHeader() {
    *this = ::std::move(from);
  }

  inline PacketClassifier_IpHeader& operator=(const PacketClassifier_IpHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier_IpHeader& operator=(PacketClassifier_IpHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier_IpHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketClassifier_IpHeader* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier_IpHeader*>(
               &_PacketClassifier_IpHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketClassifier_IpHeader& a, PacketClassifier_IpHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier_IpHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier_IpHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier_IpHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier_IpHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier_IpHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier_IpHeader& from) {
    PacketClassifier_IpHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier_IpHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier.IpHeader";
  }
  protected:
  explicit PacketClassifier_IpHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcIpRangeFieldNumber = 1,
    kDstIpRangeFieldNumber = 2,
    kProtocolFieldNumber = 3,
  };
  // optional string src_ip_range = 1 [json_name = "srcIpRange"];
  bool has_src_ip_range() const;
  void clear_src_ip_range() ;
  const std::string& src_ip_range() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_ip_range(Arg_&& arg, Args_... args);
  std::string* mutable_src_ip_range();
  PROTOBUF_NODISCARD std::string* release_src_ip_range();
  void set_allocated_src_ip_range(std::string* ptr);

  private:
  const std::string& _internal_src_ip_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_ip_range(
      const std::string& value);
  std::string* _internal_mutable_src_ip_range();

  public:
  // optional string dst_ip_range = 2 [json_name = "dstIpRange"];
  bool has_dst_ip_range() const;
  void clear_dst_ip_range() ;
  const std::string& dst_ip_range() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_ip_range(Arg_&& arg, Args_... args);
  std::string* mutable_dst_ip_range();
  PROTOBUF_NODISCARD std::string* release_dst_ip_range();
  void set_allocated_dst_ip_range(std::string* ptr);

  private:
  const std::string& _internal_dst_ip_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_ip_range(
      const std::string& value);
  std::string* _internal_mutable_dst_ip_range();

  public:
  // optional uint32 protocol = 3 [json_name = "protocol"];
  bool has_protocol() const;
  void clear_protocol() ;
  ::uint32_t protocol() const;
  void set_protocol(::uint32_t value);

  private:
  ::uint32_t _internal_protocol() const;
  void _internal_set_protocol(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier.IpHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_ip_range_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_ip_range_;
    ::uint32_t protocol_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier_GenericLayer4Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header) */ {
 public:
  inline PacketClassifier_GenericLayer4Header() : PacketClassifier_GenericLayer4Header(nullptr) {}
  ~PacketClassifier_GenericLayer4Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier_GenericLayer4Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier_GenericLayer4Header(const PacketClassifier_GenericLayer4Header& from);
  PacketClassifier_GenericLayer4Header(PacketClassifier_GenericLayer4Header&& from) noexcept
    : PacketClassifier_GenericLayer4Header() {
    *this = ::std::move(from);
  }

  inline PacketClassifier_GenericLayer4Header& operator=(const PacketClassifier_GenericLayer4Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier_GenericLayer4Header& operator=(PacketClassifier_GenericLayer4Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier_GenericLayer4Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketClassifier_GenericLayer4Header* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier_GenericLayer4Header*>(
               &_PacketClassifier_GenericLayer4Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PacketClassifier_GenericLayer4Header& a, PacketClassifier_GenericLayer4Header& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier_GenericLayer4Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier_GenericLayer4Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier_GenericLayer4Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier_GenericLayer4Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier_GenericLayer4Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier_GenericLayer4Header& from) {
    PacketClassifier_GenericLayer4Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier_GenericLayer4Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header";
  }
  protected:
  explicit PacketClassifier_GenericLayer4Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePortFieldNumber = 1,
    kDestinationPortFieldNumber = 2,
  };
  // repeated .aalyria.spacetime.api.common.PacketClassifier.ValueRange source_port = 1 [json_name = "sourcePort"];
  int source_port_size() const;
  private:
  int _internal_source_port_size() const;

  public:
  void clear_source_port() ;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* mutable_source_port(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >*
      mutable_source_port();
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& _internal_source_port(int index) const;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* _internal_add_source_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>& _internal_source_port() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>* _internal_mutable_source_port();
  public:
  const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& source_port(int index) const;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* add_source_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >&
      source_port() const;
  // repeated .aalyria.spacetime.api.common.PacketClassifier.ValueRange destination_port = 2 [json_name = "destinationPort"];
  int destination_port_size() const;
  private:
  int _internal_destination_port_size() const;

  public:
  void clear_destination_port() ;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* mutable_destination_port(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >*
      mutable_destination_port();
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& _internal_destination_port(int index) const;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* _internal_add_destination_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>& _internal_destination_port() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>* _internal_mutable_destination_port();
  public:
  const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& destination_port(int index) const;
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* add_destination_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >&
      destination_port() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange > source_port_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange > destination_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier_EthernetHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader) */ {
 public:
  inline PacketClassifier_EthernetHeader() : PacketClassifier_EthernetHeader(nullptr) {}
  ~PacketClassifier_EthernetHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier_EthernetHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier_EthernetHeader(const PacketClassifier_EthernetHeader& from);
  PacketClassifier_EthernetHeader(PacketClassifier_EthernetHeader&& from) noexcept
    : PacketClassifier_EthernetHeader() {
    *this = ::std::move(from);
  }

  inline PacketClassifier_EthernetHeader& operator=(const PacketClassifier_EthernetHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier_EthernetHeader& operator=(PacketClassifier_EthernetHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier_EthernetHeader& default_instance() {
    return *internal_default_instance();
  }
  enum DestinationCase {
    kMulticast = 1,
    kAddress = 2,
    DESTINATION_NOT_SET = 0,
  };

  static inline const PacketClassifier_EthernetHeader* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier_EthernetHeader*>(
               &_PacketClassifier_EthernetHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PacketClassifier_EthernetHeader& a, PacketClassifier_EthernetHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier_EthernetHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier_EthernetHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier_EthernetHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier_EthernetHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier_EthernetHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier_EthernetHeader& from) {
    PacketClassifier_EthernetHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier_EthernetHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier.EthernetHeader";
  }
  protected:
  explicit PacketClassifier_EthernetHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMulticastFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // .google.protobuf.Empty multicast = 1 [json_name = "multicast"];
  bool has_multicast() const;
  private:
  bool _internal_has_multicast() const;

  public:
  void clear_multicast() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& multicast() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_multicast();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_multicast();
  void set_allocated_multicast(::PROTOBUF_NAMESPACE_ID::Empty* multicast);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_multicast() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_multicast();
  public:
  void unsafe_arena_set_allocated_multicast(
      ::PROTOBUF_NAMESPACE_ID::Empty* multicast);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_multicast();
  // string address = 2 [json_name = "address"];
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  void clear_destination();
  DestinationCase destination_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader)
 private:
  class _Internal;
  void set_has_multicast();
  void set_has_address();

  inline bool has_destination() const;
  inline void clear_has_destination();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DestinationUnion {
      constexpr DestinationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Empty* multicast_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    } destination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier_MplsLabelStackEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry) */ {
 public:
  inline PacketClassifier_MplsLabelStackEntry() : PacketClassifier_MplsLabelStackEntry(nullptr) {}
  ~PacketClassifier_MplsLabelStackEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier_MplsLabelStackEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier_MplsLabelStackEntry(const PacketClassifier_MplsLabelStackEntry& from);
  PacketClassifier_MplsLabelStackEntry(PacketClassifier_MplsLabelStackEntry&& from) noexcept
    : PacketClassifier_MplsLabelStackEntry() {
    *this = ::std::move(from);
  }

  inline PacketClassifier_MplsLabelStackEntry& operator=(const PacketClassifier_MplsLabelStackEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier_MplsLabelStackEntry& operator=(PacketClassifier_MplsLabelStackEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier_MplsLabelStackEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketClassifier_MplsLabelStackEntry* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier_MplsLabelStackEntry*>(
               &_PacketClassifier_MplsLabelStackEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PacketClassifier_MplsLabelStackEntry& a, PacketClassifier_MplsLabelStackEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier_MplsLabelStackEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier_MplsLabelStackEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier_MplsLabelStackEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier_MplsLabelStackEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier_MplsLabelStackEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier_MplsLabelStackEntry& from) {
    PacketClassifier_MplsLabelStackEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier_MplsLabelStackEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry";
  }
  protected:
  explicit PacketClassifier_MplsLabelStackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // optional uint32 label = 1 [json_name = "label"];
  bool has_label() const;
  void clear_label() ;
  ::uint32_t label() const;
  void set_label(::uint32_t value);

  private:
  ::uint32_t _internal_label() const;
  void _internal_set_label(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t label_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class PacketClassifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.PacketClassifier) */ {
 public:
  inline PacketClassifier() : PacketClassifier(nullptr) {}
  ~PacketClassifier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketClassifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketClassifier(const PacketClassifier& from);
  PacketClassifier(PacketClassifier&& from) noexcept
    : PacketClassifier() {
    *this = ::std::move(from);
  }

  inline PacketClassifier& operator=(const PacketClassifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketClassifier& operator=(PacketClassifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketClassifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketClassifier* internal_default_instance() {
    return reinterpret_cast<const PacketClassifier*>(
               &_PacketClassifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PacketClassifier& a, PacketClassifier& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketClassifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketClassifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketClassifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketClassifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketClassifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketClassifier& from) {
    PacketClassifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketClassifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.PacketClassifier";
  }
  protected:
  explicit PacketClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PacketClassifier_ValueRange ValueRange;
  typedef PacketClassifier_IpHeader IpHeader;
  typedef PacketClassifier_GenericLayer4Header GenericLayer4Header;
  typedef PacketClassifier_EthernetHeader EthernetHeader;
  typedef PacketClassifier_MplsLabelStackEntry MplsLabelStackEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kIpHeaderFieldNumber = 1,
    kL4HeaderFieldNumber = 2,
    kEthernetHeaderFieldNumber = 3,
    kMplsLabelStackEntryFieldNumber = 4,
  };
  // optional .aalyria.spacetime.api.common.PacketClassifier.IpHeader ip_header = 1 [json_name = "ipHeader"];
  bool has_ip_header() const;
  void clear_ip_header() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader& ip_header() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* release_ip_header();
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* mutable_ip_header();
  void set_allocated_ip_header(::aalyria::spacetime::api::common::PacketClassifier_IpHeader* ip_header);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader& _internal_ip_header() const;
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* _internal_mutable_ip_header();
  public:
  void unsafe_arena_set_allocated_ip_header(
      ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* ip_header);
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* unsafe_arena_release_ip_header();
  // optional .aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header l4_header = 2 [json_name = "l4Header"];
  bool has_l4_header() const;
  void clear_l4_header() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& l4_header() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* release_l4_header();
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* mutable_l4_header();
  void set_allocated_l4_header(::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_header);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& _internal_l4_header() const;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* _internal_mutable_l4_header();
  public:
  void unsafe_arena_set_allocated_l4_header(
      ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_header);
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* unsafe_arena_release_l4_header();
  // optional .aalyria.spacetime.api.common.PacketClassifier.EthernetHeader ethernet_header = 3 [json_name = "ethernetHeader"];
  bool has_ethernet_header() const;
  void clear_ethernet_header() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& ethernet_header() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* release_ethernet_header();
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* mutable_ethernet_header();
  void set_allocated_ethernet_header(::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_header);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& _internal_ethernet_header() const;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* _internal_mutable_ethernet_header();
  public:
  void unsafe_arena_set_allocated_ethernet_header(
      ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_header);
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* unsafe_arena_release_ethernet_header();
  // optional .aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry mpls_label_stack_entry = 4 [json_name = "mplsLabelStackEntry"];
  bool has_mpls_label_stack_entry() const;
  void clear_mpls_label_stack_entry() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry& mpls_label_stack_entry() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* release_mpls_label_stack_entry();
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mutable_mpls_label_stack_entry();
  void set_allocated_mpls_label_stack_entry(::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mpls_label_stack_entry);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry& _internal_mpls_label_stack_entry() const;
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* _internal_mutable_mpls_label_stack_entry();
  public:
  void unsafe_arena_set_allocated_mpls_label_stack_entry(
      ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mpls_label_stack_entry);
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* unsafe_arena_release_mpls_label_stack_entry();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.PacketClassifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* ip_header_;
    ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_header_;
    ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_header_;
    ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mpls_label_stack_entry_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class Subnet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.Subnet) */ {
 public:
  inline Subnet() : Subnet(nullptr) {}
  ~Subnet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Subnet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subnet(const Subnet& from);
  Subnet(Subnet&& from) noexcept
    : Subnet() {
    *this = ::std::move(from);
  }

  inline Subnet& operator=(const Subnet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subnet& operator=(Subnet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subnet& default_instance() {
    return *internal_default_instance();
  }
  enum SubnetCase {
    kIpRange = 1,
    kNodeId = 2,
    kInterfaceId = 3,
    SUBNET_NOT_SET = 0,
  };

  static inline const Subnet* internal_default_instance() {
    return reinterpret_cast<const Subnet*>(
               &_Subnet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Subnet& a, Subnet& b) {
    a.Swap(&b);
  }
  inline void Swap(Subnet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subnet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subnet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subnet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subnet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subnet& from) {
    Subnet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subnet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.Subnet";
  }
  protected:
  explicit Subnet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpRangeFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kInterfaceIdFieldNumber = 3,
  };
  // string ip_range = 1 [json_name = "ipRange"];
  bool has_ip_range() const;
  void clear_ip_range() ;
  const std::string& ip_range() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_range(Arg_&& arg, Args_... args);
  std::string* mutable_ip_range();
  PROTOBUF_NODISCARD std::string* release_ip_range();
  void set_allocated_ip_range(std::string* ptr);

  private:
  const std::string& _internal_ip_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_range(
      const std::string& value);
  std::string* _internal_mutable_ip_range();

  public:
  // string node_id = 2 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 3 [json_name = "interfaceId"];
  bool has_interface_id() const;
  private:
  bool _internal_has_interface_id() const;

  public:
  void clear_interface_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& interface_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_interface_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_interface_id();
  void set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_interface_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_interface_id();
  public:
  void unsafe_arena_set_allocated_interface_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_interface_id();
  void clear_subnet();
  SubnetCase subnet_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.Subnet)
 private:
  class _Internal;
  void set_has_ip_range();
  void set_has_node_id();
  void set_has_interface_id();

  inline bool has_subnet() const;
  inline void clear_has_subnet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SubnetUnion {
      constexpr SubnetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_range_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
      ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id_;
    } subnet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class IpFlowClassifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.IpFlowClassifier) */ {
 public:
  inline IpFlowClassifier() : IpFlowClassifier(nullptr) {}
  ~IpFlowClassifier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IpFlowClassifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpFlowClassifier(const IpFlowClassifier& from);
  IpFlowClassifier(IpFlowClassifier&& from) noexcept
    : IpFlowClassifier() {
    *this = ::std::move(from);
  }

  inline IpFlowClassifier& operator=(const IpFlowClassifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpFlowClassifier& operator=(IpFlowClassifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IpFlowClassifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpFlowClassifier* internal_default_instance() {
    return reinterpret_cast<const IpFlowClassifier*>(
               &_IpFlowClassifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IpFlowClassifier& a, IpFlowClassifier& b) {
    a.Swap(&b);
  }
  inline void Swap(IpFlowClassifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpFlowClassifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpFlowClassifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpFlowClassifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IpFlowClassifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IpFlowClassifier& from) {
    IpFlowClassifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IpFlowClassifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.IpFlowClassifier";
  }
  protected:
  explicit IpFlowClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kProtocolFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.Subnet src = 1 [json_name = "src"];
  bool has_src() const;
  void clear_src() ;
  const ::aalyria::spacetime::api::common::Subnet& src() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Subnet* release_src();
  ::aalyria::spacetime::api::common::Subnet* mutable_src();
  void set_allocated_src(::aalyria::spacetime::api::common::Subnet* src);
  private:
  const ::aalyria::spacetime::api::common::Subnet& _internal_src() const;
  ::aalyria::spacetime::api::common::Subnet* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::aalyria::spacetime::api::common::Subnet* src);
  ::aalyria::spacetime::api::common::Subnet* unsafe_arena_release_src();
  // optional .aalyria.spacetime.api.common.Subnet dst = 2 [json_name = "dst"];
  bool has_dst() const;
  void clear_dst() ;
  const ::aalyria::spacetime::api::common::Subnet& dst() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Subnet* release_dst();
  ::aalyria::spacetime::api::common::Subnet* mutable_dst();
  void set_allocated_dst(::aalyria::spacetime::api::common::Subnet* dst);
  private:
  const ::aalyria::spacetime::api::common::Subnet& _internal_dst() const;
  ::aalyria::spacetime::api::common::Subnet* _internal_mutable_dst();
  public:
  void unsafe_arena_set_allocated_dst(
      ::aalyria::spacetime::api::common::Subnet* dst);
  ::aalyria::spacetime::api::common::Subnet* unsafe_arena_release_dst();
  // optional uint32 protocol = 3 [json_name = "protocol"];
  bool has_protocol() const;
  void clear_protocol() ;
  ::uint32_t protocol() const;
  void set_protocol(::uint32_t value);

  private:
  ::uint32_t _internal_protocol() const;
  void _internal_set_protocol(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.IpFlowClassifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::Subnet* src_;
    ::aalyria::spacetime::api::common::Subnet* dst_;
    ::uint32_t protocol_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};// -------------------------------------------------------------------

class FlowClassifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.common.FlowClassifier) */ {
 public:
  inline FlowClassifier() : FlowClassifier(nullptr) {}
  ~FlowClassifier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlowClassifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowClassifier(const FlowClassifier& from);
  FlowClassifier(FlowClassifier&& from) noexcept
    : FlowClassifier() {
    *this = ::std::move(from);
  }

  inline FlowClassifier& operator=(const FlowClassifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowClassifier& operator=(FlowClassifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowClassifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowClassifier* internal_default_instance() {
    return reinterpret_cast<const FlowClassifier*>(
               &_FlowClassifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlowClassifier& a, FlowClassifier& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowClassifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowClassifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowClassifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowClassifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowClassifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowClassifier& from) {
    FlowClassifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowClassifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.common.FlowClassifier";
  }
  protected:
  explicit FlowClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpClassifierFieldNumber = 1,
    kL4ClassifierFieldNumber = 2,
    kEthernetClassifierFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.IpFlowClassifier ip_classifier = 1 [json_name = "ipClassifier"];
  bool has_ip_classifier() const;
  void clear_ip_classifier() ;
  const ::aalyria::spacetime::api::common::IpFlowClassifier& ip_classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::IpFlowClassifier* release_ip_classifier();
  ::aalyria::spacetime::api::common::IpFlowClassifier* mutable_ip_classifier();
  void set_allocated_ip_classifier(::aalyria::spacetime::api::common::IpFlowClassifier* ip_classifier);
  private:
  const ::aalyria::spacetime::api::common::IpFlowClassifier& _internal_ip_classifier() const;
  ::aalyria::spacetime::api::common::IpFlowClassifier* _internal_mutable_ip_classifier();
  public:
  void unsafe_arena_set_allocated_ip_classifier(
      ::aalyria::spacetime::api::common::IpFlowClassifier* ip_classifier);
  ::aalyria::spacetime::api::common::IpFlowClassifier* unsafe_arena_release_ip_classifier();
  // optional .aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header l4_classifier = 2 [json_name = "l4Classifier"];
  bool has_l4_classifier() const;
  void clear_l4_classifier() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& l4_classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* release_l4_classifier();
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* mutable_l4_classifier();
  void set_allocated_l4_classifier(::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_classifier);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& _internal_l4_classifier() const;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* _internal_mutable_l4_classifier();
  public:
  void unsafe_arena_set_allocated_l4_classifier(
      ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_classifier);
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* unsafe_arena_release_l4_classifier();
  // optional .aalyria.spacetime.api.common.PacketClassifier.EthernetHeader ethernet_classifier = 3 [json_name = "ethernetClassifier"];
  bool has_ethernet_classifier() const;
  void clear_ethernet_classifier() ;
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& ethernet_classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* release_ethernet_classifier();
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* mutable_ethernet_classifier();
  void set_allocated_ethernet_classifier(::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_classifier);
  private:
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& _internal_ethernet_classifier() const;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* _internal_mutable_ethernet_classifier();
  public:
  void unsafe_arena_set_allocated_ethernet_classifier(
      ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_classifier);
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* unsafe_arena_release_ethernet_classifier();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.common.FlowClassifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::IpFlowClassifier* ip_classifier_;
    ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_classifier_;
    ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_classifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcommon_2fnetwork_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NetworkInterfaceId

// optional string node_id = 1 [json_name = "nodeId"];
inline bool NetworkInterfaceId::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkInterfaceId::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterfaceId::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkInterfaceId.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterfaceId::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.NetworkInterfaceId.node_id)
}
inline std::string* NetworkInterfaceId::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkInterfaceId.node_id)
  return _s;
}
inline const std::string& NetworkInterfaceId::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void NetworkInterfaceId::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterfaceId::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterfaceId::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkInterfaceId.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterfaceId::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkInterfaceId.node_id)
}

// optional string interface_id = 2 [json_name = "interfaceId"];
inline bool NetworkInterfaceId::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkInterfaceId::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterfaceId::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.NetworkInterfaceId.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterfaceId::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.NetworkInterfaceId.interface_id)
}
inline std::string* NetworkInterfaceId::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.NetworkInterfaceId.interface_id)
  return _s;
}
inline const std::string& NetworkInterfaceId::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void NetworkInterfaceId::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterfaceId::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterfaceId::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.NetworkInterfaceId.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterfaceId::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.NetworkInterfaceId.interface_id)
}

// -------------------------------------------------------------------

// PacketClassifier_ValueRange

// optional uint32 low = 1 [json_name = "low"];
inline bool PacketClassifier_ValueRange::has_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PacketClassifier_ValueRange::clear_low() {
  _impl_.low_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PacketClassifier_ValueRange::low() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.ValueRange.low)
  return _internal_low();
}
inline void PacketClassifier_ValueRange::set_low(::uint32_t value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.ValueRange.low)
}
inline ::uint32_t PacketClassifier_ValueRange::_internal_low() const {
  return _impl_.low_;
}
inline void PacketClassifier_ValueRange::_internal_set_low(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_ = value;
}

// optional uint32 high = 2 [json_name = "high"];
inline bool PacketClassifier_ValueRange::has_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PacketClassifier_ValueRange::clear_high() {
  _impl_.high_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t PacketClassifier_ValueRange::high() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.ValueRange.high)
  return _internal_high();
}
inline void PacketClassifier_ValueRange::set_high(::uint32_t value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.ValueRange.high)
}
inline ::uint32_t PacketClassifier_ValueRange::_internal_high() const {
  return _impl_.high_;
}
inline void PacketClassifier_ValueRange::_internal_set_high(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.high_ = value;
}

// -------------------------------------------------------------------

// PacketClassifier_IpHeader

// optional string src_ip_range = 1 [json_name = "srcIpRange"];
inline bool PacketClassifier_IpHeader::has_src_ip_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PacketClassifier_IpHeader::clear_src_ip_range() {
  _impl_.src_ip_range_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PacketClassifier_IpHeader::src_ip_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.IpHeader.src_ip_range)
  return _internal_src_ip_range();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketClassifier_IpHeader::set_src_ip_range(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_ip_range_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.IpHeader.src_ip_range)
}
inline std::string* PacketClassifier_IpHeader::mutable_src_ip_range() {
  std::string* _s = _internal_mutable_src_ip_range();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.IpHeader.src_ip_range)
  return _s;
}
inline const std::string& PacketClassifier_IpHeader::_internal_src_ip_range() const {
  return _impl_.src_ip_range_.Get();
}
inline void PacketClassifier_IpHeader::_internal_set_src_ip_range(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.src_ip_range_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketClassifier_IpHeader::_internal_mutable_src_ip_range() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_ip_range_.Mutable( GetArenaForAllocation());
}
inline std::string* PacketClassifier_IpHeader::release_src_ip_range() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.IpHeader.src_ip_range)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.src_ip_range_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_ip_range_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PacketClassifier_IpHeader::set_allocated_src_ip_range(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_ip_range_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_ip_range_.IsDefault()) {
          _impl_.src_ip_range_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.IpHeader.src_ip_range)
}

// optional string dst_ip_range = 2 [json_name = "dstIpRange"];
inline bool PacketClassifier_IpHeader::has_dst_ip_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PacketClassifier_IpHeader::clear_dst_ip_range() {
  _impl_.dst_ip_range_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PacketClassifier_IpHeader::dst_ip_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.IpHeader.dst_ip_range)
  return _internal_dst_ip_range();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketClassifier_IpHeader::set_dst_ip_range(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dst_ip_range_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.IpHeader.dst_ip_range)
}
inline std::string* PacketClassifier_IpHeader::mutable_dst_ip_range() {
  std::string* _s = _internal_mutable_dst_ip_range();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.IpHeader.dst_ip_range)
  return _s;
}
inline const std::string& PacketClassifier_IpHeader::_internal_dst_ip_range() const {
  return _impl_.dst_ip_range_.Get();
}
inline void PacketClassifier_IpHeader::_internal_set_dst_ip_range(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.dst_ip_range_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketClassifier_IpHeader::_internal_mutable_dst_ip_range() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dst_ip_range_.Mutable( GetArenaForAllocation());
}
inline std::string* PacketClassifier_IpHeader::release_dst_ip_range() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.IpHeader.dst_ip_range)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dst_ip_range_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_ip_range_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PacketClassifier_IpHeader::set_allocated_dst_ip_range(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_ip_range_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_ip_range_.IsDefault()) {
          _impl_.dst_ip_range_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.IpHeader.dst_ip_range)
}

// optional uint32 protocol = 3 [json_name = "protocol"];
inline bool PacketClassifier_IpHeader::has_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PacketClassifier_IpHeader::clear_protocol() {
  _impl_.protocol_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t PacketClassifier_IpHeader::protocol() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.IpHeader.protocol)
  return _internal_protocol();
}
inline void PacketClassifier_IpHeader::set_protocol(::uint32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.IpHeader.protocol)
}
inline ::uint32_t PacketClassifier_IpHeader::_internal_protocol() const {
  return _impl_.protocol_;
}
inline void PacketClassifier_IpHeader::_internal_set_protocol(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.protocol_ = value;
}

// -------------------------------------------------------------------

// PacketClassifier_GenericLayer4Header

// repeated .aalyria.spacetime.api.common.PacketClassifier.ValueRange source_port = 1 [json_name = "sourcePort"];
inline int PacketClassifier_GenericLayer4Header::_internal_source_port_size() const {
  return _impl_.source_port_.size();
}
inline int PacketClassifier_GenericLayer4Header::source_port_size() const {
  return _internal_source_port_size();
}
inline void PacketClassifier_GenericLayer4Header::clear_source_port() {
  _internal_mutable_source_port()->Clear();
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::mutable_source_port(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port)
  return _internal_mutable_source_port()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >*
PacketClassifier_GenericLayer4Header::mutable_source_port() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port)
  return _internal_mutable_source_port();
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& PacketClassifier_GenericLayer4Header::_internal_source_port(int index) const {
  return _internal_source_port().Get(index);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& PacketClassifier_GenericLayer4Header::source_port(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port)
  return _internal_source_port(index);
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::_internal_add_source_port() {
  return _internal_mutable_source_port()->Add();
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::add_source_port() {
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* _add = _internal_add_source_port();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >&
PacketClassifier_GenericLayer4Header::source_port() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port)
  return _internal_source_port();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>&
PacketClassifier_GenericLayer4Header::_internal_source_port() const {
  return _impl_.source_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>*
PacketClassifier_GenericLayer4Header::_internal_mutable_source_port() {
  return &_impl_.source_port_;
}

// repeated .aalyria.spacetime.api.common.PacketClassifier.ValueRange destination_port = 2 [json_name = "destinationPort"];
inline int PacketClassifier_GenericLayer4Header::_internal_destination_port_size() const {
  return _impl_.destination_port_.size();
}
inline int PacketClassifier_GenericLayer4Header::destination_port_size() const {
  return _internal_destination_port_size();
}
inline void PacketClassifier_GenericLayer4Header::clear_destination_port() {
  _internal_mutable_destination_port()->Clear();
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::mutable_destination_port(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port)
  return _internal_mutable_destination_port()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >*
PacketClassifier_GenericLayer4Header::mutable_destination_port() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port)
  return _internal_mutable_destination_port();
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& PacketClassifier_GenericLayer4Header::_internal_destination_port(int index) const {
  return _internal_destination_port().Get(index);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_ValueRange& PacketClassifier_GenericLayer4Header::destination_port(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port)
  return _internal_destination_port(index);
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::_internal_add_destination_port() {
  return _internal_mutable_destination_port()->Add();
}
inline ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* PacketClassifier_GenericLayer4Header::add_destination_port() {
  ::aalyria::spacetime::api::common::PacketClassifier_ValueRange* _add = _internal_add_destination_port();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::PacketClassifier_ValueRange >&
PacketClassifier_GenericLayer4Header::destination_port() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port)
  return _internal_destination_port();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>&
PacketClassifier_GenericLayer4Header::_internal_destination_port() const {
  return _impl_.destination_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::PacketClassifier_ValueRange>*
PacketClassifier_GenericLayer4Header::_internal_mutable_destination_port() {
  return &_impl_.destination_port_;
}

// -------------------------------------------------------------------

// PacketClassifier_EthernetHeader

// .google.protobuf.Empty multicast = 1 [json_name = "multicast"];
inline bool PacketClassifier_EthernetHeader::has_multicast() const {
  return destination_case() == kMulticast;
}
inline bool PacketClassifier_EthernetHeader::_internal_has_multicast() const {
  return destination_case() == kMulticast;
}
inline void PacketClassifier_EthernetHeader::set_has_multicast() {
  _impl_._oneof_case_[0] = kMulticast;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* PacketClassifier_EthernetHeader::release_multicast() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast)
  if (destination_case() == kMulticast) {
    clear_has_destination();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.destination_.multicast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.destination_.multicast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& PacketClassifier_EthernetHeader::_internal_multicast() const {
  return destination_case() == kMulticast
      ? *_impl_.destination_.multicast_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& PacketClassifier_EthernetHeader::multicast() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast)
  return _internal_multicast();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* PacketClassifier_EthernetHeader::unsafe_arena_release_multicast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast)
  if (destination_case() == kMulticast) {
    clear_has_destination();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.destination_.multicast_;
    _impl_.destination_.multicast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketClassifier_EthernetHeader::unsafe_arena_set_allocated_multicast(::PROTOBUF_NAMESPACE_ID::Empty* multicast) {
  clear_destination();
  if (multicast) {
    set_has_multicast();
    _impl_.destination_.multicast_ = multicast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* PacketClassifier_EthernetHeader::_internal_mutable_multicast() {
  if (destination_case() != kMulticast) {
    clear_destination();
    set_has_multicast();
    _impl_.destination_.multicast_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.destination_.multicast_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* PacketClassifier_EthernetHeader::mutable_multicast() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_multicast();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast)
  return _msg;
}

// string address = 2 [json_name = "address"];
inline bool PacketClassifier_EthernetHeader::has_address() const {
  return destination_case() == kAddress;
}
inline void PacketClassifier_EthernetHeader::set_has_address() {
  _impl_._oneof_case_[0] = kAddress;
}
inline void PacketClassifier_EthernetHeader::clear_address() {
  if (destination_case() == kAddress) {
    _impl_.destination_.address_.Destroy();
    clear_has_destination();
  }
}
inline const std::string& PacketClassifier_EthernetHeader::address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketClassifier_EthernetHeader::set_address(Arg_&& arg,
                                                     Args_... args) {
  if (destination_case() != kAddress) {
    clear_destination();

    set_has_address();
    _impl_.destination_.address_.InitDefault();
  }
  _impl_.destination_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.address)
}
inline std::string* PacketClassifier_EthernetHeader::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.address)
  return _s;
}
inline const std::string& PacketClassifier_EthernetHeader::_internal_address() const {
  if (destination_case() != kAddress) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.destination_.address_.Get();
}
inline void PacketClassifier_EthernetHeader::_internal_set_address(const std::string& value) {
  if (destination_case() != kAddress) {
    clear_destination();

    set_has_address();
    _impl_.destination_.address_.InitDefault();
  }


  _impl_.destination_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketClassifier_EthernetHeader::_internal_mutable_address() {
  if (destination_case() != kAddress) {
    clear_destination();

    set_has_address();
    _impl_.destination_.address_.InitDefault();
  }
  return _impl_.destination_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* PacketClassifier_EthernetHeader::release_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.address)
  if (destination_case() != kAddress) {
    return nullptr;
  }
  clear_has_destination();
  return _impl_.destination_.address_.Release();
}
inline void PacketClassifier_EthernetHeader::set_allocated_address(std::string* value) {
  if (has_destination()) {
    clear_destination();
  }
  if (value != nullptr) {
    set_has_address();
    _impl_.destination_.address_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.address)
}

inline bool PacketClassifier_EthernetHeader::has_destination() const {
  return destination_case() != DESTINATION_NOT_SET;
}
inline void PacketClassifier_EthernetHeader::clear_has_destination() {
  _impl_._oneof_case_[0] = DESTINATION_NOT_SET;
}
inline PacketClassifier_EthernetHeader::DestinationCase PacketClassifier_EthernetHeader::destination_case() const {
  return PacketClassifier_EthernetHeader::DestinationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PacketClassifier_MplsLabelStackEntry

// optional uint32 label = 1 [json_name = "label"];
inline bool PacketClassifier_MplsLabelStackEntry::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PacketClassifier_MplsLabelStackEntry::clear_label() {
  _impl_.label_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t PacketClassifier_MplsLabelStackEntry::label() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry.label)
  return _internal_label();
}
inline void PacketClassifier_MplsLabelStackEntry::set_label(::uint32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry.label)
}
inline ::uint32_t PacketClassifier_MplsLabelStackEntry::_internal_label() const {
  return _impl_.label_;
}
inline void PacketClassifier_MplsLabelStackEntry::_internal_set_label(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.label_ = value;
}

// -------------------------------------------------------------------

// PacketClassifier

// optional .aalyria.spacetime.api.common.PacketClassifier.IpHeader ip_header = 1 [json_name = "ipHeader"];
inline bool PacketClassifier::has_ip_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ip_header_ != nullptr);
  return value;
}
inline void PacketClassifier::clear_ip_header() {
  if (_impl_.ip_header_ != nullptr) _impl_.ip_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader& PacketClassifier::_internal_ip_header() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* p = _impl_.ip_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_IpHeader_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_IpHeader& PacketClassifier::ip_header() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.ip_header)
  return _internal_ip_header();
}
inline void PacketClassifier::unsafe_arena_set_allocated_ip_header(
    ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* ip_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_header_);
  }
  _impl_.ip_header_ = ip_header;
  if (ip_header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PacketClassifier.ip_header)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* PacketClassifier::release_ip_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* temp = _impl_.ip_header_;
  _impl_.ip_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* PacketClassifier::unsafe_arena_release_ip_header() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.ip_header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* temp = _impl_.ip_header_;
  _impl_.ip_header_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* PacketClassifier::_internal_mutable_ip_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ip_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_IpHeader>(GetArenaForAllocation());
    _impl_.ip_header_ = p;
  }
  return _impl_.ip_header_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* PacketClassifier::mutable_ip_header() {
  ::aalyria::spacetime::api::common::PacketClassifier_IpHeader* _msg = _internal_mutable_ip_header();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.ip_header)
  return _msg;
}
inline void PacketClassifier::set_allocated_ip_header(::aalyria::spacetime::api::common::PacketClassifier_IpHeader* ip_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ip_header_;
  }
  if (ip_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ip_header);
    if (message_arena != submessage_arena) {
      ip_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_header_ = ip_header;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.ip_header)
}

// optional .aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header l4_header = 2 [json_name = "l4Header"];
inline bool PacketClassifier::has_l4_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.l4_header_ != nullptr);
  return value;
}
inline void PacketClassifier::clear_l4_header() {
  if (_impl_.l4_header_ != nullptr) _impl_.l4_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& PacketClassifier::_internal_l4_header() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* p = _impl_.l4_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_GenericLayer4Header_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& PacketClassifier::l4_header() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.l4_header)
  return _internal_l4_header();
}
inline void PacketClassifier::unsafe_arena_set_allocated_l4_header(
    ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.l4_header_);
  }
  _impl_.l4_header_ = l4_header;
  if (l4_header) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PacketClassifier.l4_header)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* PacketClassifier::release_l4_header() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* temp = _impl_.l4_header_;
  _impl_.l4_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* PacketClassifier::unsafe_arena_release_l4_header() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.l4_header)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* temp = _impl_.l4_header_;
  _impl_.l4_header_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* PacketClassifier::_internal_mutable_l4_header() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.l4_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header>(GetArenaForAllocation());
    _impl_.l4_header_ = p;
  }
  return _impl_.l4_header_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* PacketClassifier::mutable_l4_header() {
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* _msg = _internal_mutable_l4_header();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.l4_header)
  return _msg;
}
inline void PacketClassifier::set_allocated_l4_header(::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.l4_header_;
  }
  if (l4_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(l4_header);
    if (message_arena != submessage_arena) {
      l4_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l4_header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.l4_header_ = l4_header;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.l4_header)
}

// optional .aalyria.spacetime.api.common.PacketClassifier.EthernetHeader ethernet_header = 3 [json_name = "ethernetHeader"];
inline bool PacketClassifier::has_ethernet_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ethernet_header_ != nullptr);
  return value;
}
inline void PacketClassifier::clear_ethernet_header() {
  if (_impl_.ethernet_header_ != nullptr) _impl_.ethernet_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& PacketClassifier::_internal_ethernet_header() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* p = _impl_.ethernet_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_EthernetHeader_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& PacketClassifier::ethernet_header() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.ethernet_header)
  return _internal_ethernet_header();
}
inline void PacketClassifier::unsafe_arena_set_allocated_ethernet_header(
    ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ethernet_header_);
  }
  _impl_.ethernet_header_ = ethernet_header;
  if (ethernet_header) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PacketClassifier.ethernet_header)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* PacketClassifier::release_ethernet_header() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* temp = _impl_.ethernet_header_;
  _impl_.ethernet_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* PacketClassifier::unsafe_arena_release_ethernet_header() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.ethernet_header)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* temp = _impl_.ethernet_header_;
  _impl_.ethernet_header_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* PacketClassifier::_internal_mutable_ethernet_header() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ethernet_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader>(GetArenaForAllocation());
    _impl_.ethernet_header_ = p;
  }
  return _impl_.ethernet_header_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* PacketClassifier::mutable_ethernet_header() {
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* _msg = _internal_mutable_ethernet_header();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.ethernet_header)
  return _msg;
}
inline void PacketClassifier::set_allocated_ethernet_header(::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ethernet_header_;
  }
  if (ethernet_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ethernet_header);
    if (message_arena != submessage_arena) {
      ethernet_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ethernet_header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ethernet_header_ = ethernet_header;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.ethernet_header)
}

// optional .aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry mpls_label_stack_entry = 4 [json_name = "mplsLabelStackEntry"];
inline bool PacketClassifier::has_mpls_label_stack_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mpls_label_stack_entry_ != nullptr);
  return value;
}
inline void PacketClassifier::clear_mpls_label_stack_entry() {
  if (_impl_.mpls_label_stack_entry_ != nullptr) _impl_.mpls_label_stack_entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry& PacketClassifier::_internal_mpls_label_stack_entry() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* p = _impl_.mpls_label_stack_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_MplsLabelStackEntry_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry& PacketClassifier::mpls_label_stack_entry() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry)
  return _internal_mpls_label_stack_entry();
}
inline void PacketClassifier::unsafe_arena_set_allocated_mpls_label_stack_entry(
    ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mpls_label_stack_entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mpls_label_stack_entry_);
  }
  _impl_.mpls_label_stack_entry_ = mpls_label_stack_entry;
  if (mpls_label_stack_entry) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* PacketClassifier::release_mpls_label_stack_entry() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* temp = _impl_.mpls_label_stack_entry_;
  _impl_.mpls_label_stack_entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* PacketClassifier::unsafe_arena_release_mpls_label_stack_entry() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* temp = _impl_.mpls_label_stack_entry_;
  _impl_.mpls_label_stack_entry_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* PacketClassifier::_internal_mutable_mpls_label_stack_entry() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.mpls_label_stack_entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry>(GetArenaForAllocation());
    _impl_.mpls_label_stack_entry_ = p;
  }
  return _impl_.mpls_label_stack_entry_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* PacketClassifier::mutable_mpls_label_stack_entry() {
  ::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* _msg = _internal_mutable_mpls_label_stack_entry();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry)
  return _msg;
}
inline void PacketClassifier::set_allocated_mpls_label_stack_entry(::aalyria::spacetime::api::common::PacketClassifier_MplsLabelStackEntry* mpls_label_stack_entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mpls_label_stack_entry_;
  }
  if (mpls_label_stack_entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mpls_label_stack_entry);
    if (message_arena != submessage_arena) {
      mpls_label_stack_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mpls_label_stack_entry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mpls_label_stack_entry_ = mpls_label_stack_entry;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry)
}

// -------------------------------------------------------------------

// Subnet

// string ip_range = 1 [json_name = "ipRange"];
inline bool Subnet::has_ip_range() const {
  return subnet_case() == kIpRange;
}
inline void Subnet::set_has_ip_range() {
  _impl_._oneof_case_[0] = kIpRange;
}
inline void Subnet::clear_ip_range() {
  if (subnet_case() == kIpRange) {
    _impl_.subnet_.ip_range_.Destroy();
    clear_has_subnet();
  }
}
inline const std::string& Subnet::ip_range() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Subnet.ip_range)
  return _internal_ip_range();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subnet::set_ip_range(Arg_&& arg,
                                                     Args_... args) {
  if (subnet_case() != kIpRange) {
    clear_subnet();

    set_has_ip_range();
    _impl_.subnet_.ip_range_.InitDefault();
  }
  _impl_.subnet_.ip_range_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Subnet.ip_range)
}
inline std::string* Subnet::mutable_ip_range() {
  std::string* _s = _internal_mutable_ip_range();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Subnet.ip_range)
  return _s;
}
inline const std::string& Subnet::_internal_ip_range() const {
  if (subnet_case() != kIpRange) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.subnet_.ip_range_.Get();
}
inline void Subnet::_internal_set_ip_range(const std::string& value) {
  if (subnet_case() != kIpRange) {
    clear_subnet();

    set_has_ip_range();
    _impl_.subnet_.ip_range_.InitDefault();
  }


  _impl_.subnet_.ip_range_.Set(value, GetArenaForAllocation());
}
inline std::string* Subnet::_internal_mutable_ip_range() {
  if (subnet_case() != kIpRange) {
    clear_subnet();

    set_has_ip_range();
    _impl_.subnet_.ip_range_.InitDefault();
  }
  return _impl_.subnet_.ip_range_.Mutable( GetArenaForAllocation());
}
inline std::string* Subnet::release_ip_range() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Subnet.ip_range)
  if (subnet_case() != kIpRange) {
    return nullptr;
  }
  clear_has_subnet();
  return _impl_.subnet_.ip_range_.Release();
}
inline void Subnet::set_allocated_ip_range(std::string* value) {
  if (has_subnet()) {
    clear_subnet();
  }
  if (value != nullptr) {
    set_has_ip_range();
    _impl_.subnet_.ip_range_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Subnet.ip_range)
}

// string node_id = 2 [json_name = "nodeId"];
inline bool Subnet::has_node_id() const {
  return subnet_case() == kNodeId;
}
inline void Subnet::set_has_node_id() {
  _impl_._oneof_case_[0] = kNodeId;
}
inline void Subnet::clear_node_id() {
  if (subnet_case() == kNodeId) {
    _impl_.subnet_.node_id_.Destroy();
    clear_has_subnet();
  }
}
inline const std::string& Subnet::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Subnet.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subnet::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  if (subnet_case() != kNodeId) {
    clear_subnet();

    set_has_node_id();
    _impl_.subnet_.node_id_.InitDefault();
  }
  _impl_.subnet_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.Subnet.node_id)
}
inline std::string* Subnet::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Subnet.node_id)
  return _s;
}
inline const std::string& Subnet::_internal_node_id() const {
  if (subnet_case() != kNodeId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.subnet_.node_id_.Get();
}
inline void Subnet::_internal_set_node_id(const std::string& value) {
  if (subnet_case() != kNodeId) {
    clear_subnet();

    set_has_node_id();
    _impl_.subnet_.node_id_.InitDefault();
  }


  _impl_.subnet_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Subnet::_internal_mutable_node_id() {
  if (subnet_case() != kNodeId) {
    clear_subnet();

    set_has_node_id();
    _impl_.subnet_.node_id_.InitDefault();
  }
  return _impl_.subnet_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Subnet::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Subnet.node_id)
  if (subnet_case() != kNodeId) {
    return nullptr;
  }
  clear_has_subnet();
  return _impl_.subnet_.node_id_.Release();
}
inline void Subnet::set_allocated_node_id(std::string* value) {
  if (has_subnet()) {
    clear_subnet();
  }
  if (value != nullptr) {
    set_has_node_id();
    _impl_.subnet_.node_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.Subnet.node_id)
}

// .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 3 [json_name = "interfaceId"];
inline bool Subnet::has_interface_id() const {
  return subnet_case() == kInterfaceId;
}
inline bool Subnet::_internal_has_interface_id() const {
  return subnet_case() == kInterfaceId;
}
inline void Subnet::set_has_interface_id() {
  _impl_._oneof_case_[0] = kInterfaceId;
}
inline void Subnet::clear_interface_id() {
  if (subnet_case() == kInterfaceId) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subnet_.interface_id_;
    }
    clear_has_subnet();
  }
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* Subnet::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.Subnet.interface_id)
  if (subnet_case() == kInterfaceId) {
    clear_has_subnet();
    ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.subnet_.interface_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subnet_.interface_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& Subnet::_internal_interface_id() const {
  return subnet_case() == kInterfaceId
      ? *_impl_.subnet_.interface_id_
      : reinterpret_cast<::aalyria::spacetime::api::common::NetworkInterfaceId&>(::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& Subnet::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.Subnet.interface_id)
  return _internal_interface_id();
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* Subnet::unsafe_arena_release_interface_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.common.Subnet.interface_id)
  if (subnet_case() == kInterfaceId) {
    clear_has_subnet();
    ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.subnet_.interface_id_;
    _impl_.subnet_.interface_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnet::unsafe_arena_set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id) {
  clear_subnet();
  if (interface_id) {
    set_has_interface_id();
    _impl_.subnet_.interface_id_ = interface_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.Subnet.interface_id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* Subnet::_internal_mutable_interface_id() {
  if (subnet_case() != kInterfaceId) {
    clear_subnet();
    set_has_interface_id();
    _impl_.subnet_.interface_id_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkInterfaceId >(GetArenaForAllocation());
  }
  return _impl_.subnet_.interface_id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* Subnet::mutable_interface_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.Subnet.interface_id)
  return _msg;
}

inline bool Subnet::has_subnet() const {
  return subnet_case() != SUBNET_NOT_SET;
}
inline void Subnet::clear_has_subnet() {
  _impl_._oneof_case_[0] = SUBNET_NOT_SET;
}
inline Subnet::SubnetCase Subnet::subnet_case() const {
  return Subnet::SubnetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IpFlowClassifier

// optional .aalyria.spacetime.api.common.Subnet src = 1 [json_name = "src"];
inline bool IpFlowClassifier::has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_ != nullptr);
  return value;
}
inline void IpFlowClassifier::clear_src() {
  if (_impl_.src_ != nullptr) _impl_.src_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::Subnet& IpFlowClassifier::_internal_src() const {
  const ::aalyria::spacetime::api::common::Subnet* p = _impl_.src_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Subnet&>(
      ::aalyria::spacetime::api::common::_Subnet_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Subnet& IpFlowClassifier::src() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.IpFlowClassifier.src)
  return _internal_src();
}
inline void IpFlowClassifier::unsafe_arena_set_allocated_src(
    ::aalyria::spacetime::api::common::Subnet* src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  _impl_.src_ = src;
  if (src) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.IpFlowClassifier.src)
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::release_src() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Subnet* temp = _impl_.src_;
  _impl_.src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.IpFlowClassifier.src)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::Subnet* temp = _impl_.src_;
  _impl_.src_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.src_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Subnet>(GetArenaForAllocation());
    _impl_.src_ = p;
  }
  return _impl_.src_;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::mutable_src() {
  ::aalyria::spacetime::api::common::Subnet* _msg = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.IpFlowClassifier.src)
  return _msg;
}
inline void IpFlowClassifier::set_allocated_src(::aalyria::spacetime::api::common::Subnet* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_;
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src);
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_ = src;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.IpFlowClassifier.src)
}

// optional .aalyria.spacetime.api.common.Subnet dst = 2 [json_name = "dst"];
inline bool IpFlowClassifier::has_dst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_ != nullptr);
  return value;
}
inline void IpFlowClassifier::clear_dst() {
  if (_impl_.dst_ != nullptr) _impl_.dst_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::Subnet& IpFlowClassifier::_internal_dst() const {
  const ::aalyria::spacetime::api::common::Subnet* p = _impl_.dst_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Subnet&>(
      ::aalyria::spacetime::api::common::_Subnet_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Subnet& IpFlowClassifier::dst() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.IpFlowClassifier.dst)
  return _internal_dst();
}
inline void IpFlowClassifier::unsafe_arena_set_allocated_dst(
    ::aalyria::spacetime::api::common::Subnet* dst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  _impl_.dst_ = dst;
  if (dst) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.IpFlowClassifier.dst)
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::release_dst() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Subnet* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::unsafe_arena_release_dst() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.IpFlowClassifier.dst)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Subnet* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::_internal_mutable_dst() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Subnet>(GetArenaForAllocation());
    _impl_.dst_ = p;
  }
  return _impl_.dst_;
}
inline ::aalyria::spacetime::api::common::Subnet* IpFlowClassifier::mutable_dst() {
  ::aalyria::spacetime::api::common::Subnet* _msg = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.IpFlowClassifier.dst)
  return _msg;
}
inline void IpFlowClassifier::set_allocated_dst(::aalyria::spacetime::api::common::Subnet* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dst_;
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dst);
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.IpFlowClassifier.dst)
}

// optional uint32 protocol = 3 [json_name = "protocol"];
inline bool IpFlowClassifier::has_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IpFlowClassifier::clear_protocol() {
  _impl_.protocol_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IpFlowClassifier::protocol() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.IpFlowClassifier.protocol)
  return _internal_protocol();
}
inline void IpFlowClassifier::set_protocol(::uint32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.common.IpFlowClassifier.protocol)
}
inline ::uint32_t IpFlowClassifier::_internal_protocol() const {
  return _impl_.protocol_;
}
inline void IpFlowClassifier::_internal_set_protocol(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.protocol_ = value;
}

// -------------------------------------------------------------------

// FlowClassifier

// optional .aalyria.spacetime.api.common.IpFlowClassifier ip_classifier = 1 [json_name = "ipClassifier"];
inline bool FlowClassifier::has_ip_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ip_classifier_ != nullptr);
  return value;
}
inline void FlowClassifier::clear_ip_classifier() {
  if (_impl_.ip_classifier_ != nullptr) _impl_.ip_classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::common::IpFlowClassifier& FlowClassifier::_internal_ip_classifier() const {
  const ::aalyria::spacetime::api::common::IpFlowClassifier* p = _impl_.ip_classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::IpFlowClassifier&>(
      ::aalyria::spacetime::api::common::_IpFlowClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::IpFlowClassifier& FlowClassifier::ip_classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowClassifier.ip_classifier)
  return _internal_ip_classifier();
}
inline void FlowClassifier::unsafe_arena_set_allocated_ip_classifier(
    ::aalyria::spacetime::api::common::IpFlowClassifier* ip_classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_classifier_);
  }
  _impl_.ip_classifier_ = ip_classifier;
  if (ip_classifier) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowClassifier.ip_classifier)
}
inline ::aalyria::spacetime::api::common::IpFlowClassifier* FlowClassifier::release_ip_classifier() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::IpFlowClassifier* temp = _impl_.ip_classifier_;
  _impl_.ip_classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::IpFlowClassifier* FlowClassifier::unsafe_arena_release_ip_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowClassifier.ip_classifier)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::IpFlowClassifier* temp = _impl_.ip_classifier_;
  _impl_.ip_classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::IpFlowClassifier* FlowClassifier::_internal_mutable_ip_classifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ip_classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::IpFlowClassifier>(GetArenaForAllocation());
    _impl_.ip_classifier_ = p;
  }
  return _impl_.ip_classifier_;
}
inline ::aalyria::spacetime::api::common::IpFlowClassifier* FlowClassifier::mutable_ip_classifier() {
  ::aalyria::spacetime::api::common::IpFlowClassifier* _msg = _internal_mutable_ip_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowClassifier.ip_classifier)
  return _msg;
}
inline void FlowClassifier::set_allocated_ip_classifier(::aalyria::spacetime::api::common::IpFlowClassifier* ip_classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ip_classifier_;
  }
  if (ip_classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ip_classifier);
    if (message_arena != submessage_arena) {
      ip_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_classifier_ = ip_classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowClassifier.ip_classifier)
}

// optional .aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header l4_classifier = 2 [json_name = "l4Classifier"];
inline bool FlowClassifier::has_l4_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.l4_classifier_ != nullptr);
  return value;
}
inline void FlowClassifier::clear_l4_classifier() {
  if (_impl_.l4_classifier_ != nullptr) _impl_.l4_classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& FlowClassifier::_internal_l4_classifier() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* p = _impl_.l4_classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_GenericLayer4Header_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header& FlowClassifier::l4_classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowClassifier.l4_classifier)
  return _internal_l4_classifier();
}
inline void FlowClassifier::unsafe_arena_set_allocated_l4_classifier(
    ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.l4_classifier_);
  }
  _impl_.l4_classifier_ = l4_classifier;
  if (l4_classifier) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowClassifier.l4_classifier)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* FlowClassifier::release_l4_classifier() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* temp = _impl_.l4_classifier_;
  _impl_.l4_classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* FlowClassifier::unsafe_arena_release_l4_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowClassifier.l4_classifier)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* temp = _impl_.l4_classifier_;
  _impl_.l4_classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* FlowClassifier::_internal_mutable_l4_classifier() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.l4_classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header>(GetArenaForAllocation());
    _impl_.l4_classifier_ = p;
  }
  return _impl_.l4_classifier_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* FlowClassifier::mutable_l4_classifier() {
  ::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* _msg = _internal_mutable_l4_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowClassifier.l4_classifier)
  return _msg;
}
inline void FlowClassifier::set_allocated_l4_classifier(::aalyria::spacetime::api::common::PacketClassifier_GenericLayer4Header* l4_classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.l4_classifier_;
  }
  if (l4_classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(l4_classifier);
    if (message_arena != submessage_arena) {
      l4_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l4_classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.l4_classifier_ = l4_classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowClassifier.l4_classifier)
}

// optional .aalyria.spacetime.api.common.PacketClassifier.EthernetHeader ethernet_classifier = 3 [json_name = "ethernetClassifier"];
inline bool FlowClassifier::has_ethernet_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ethernet_classifier_ != nullptr);
  return value;
}
inline void FlowClassifier::clear_ethernet_classifier() {
  if (_impl_.ethernet_classifier_ != nullptr) _impl_.ethernet_classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& FlowClassifier::_internal_ethernet_classifier() const {
  const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* p = _impl_.ethernet_classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader&>(
      ::aalyria::spacetime::api::common::_PacketClassifier_EthernetHeader_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader& FlowClassifier::ethernet_classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier)
  return _internal_ethernet_classifier();
}
inline void FlowClassifier::unsafe_arena_set_allocated_ethernet_classifier(
    ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ethernet_classifier_);
  }
  _impl_.ethernet_classifier_ = ethernet_classifier;
  if (ethernet_classifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier)
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* FlowClassifier::release_ethernet_classifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* temp = _impl_.ethernet_classifier_;
  _impl_.ethernet_classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* FlowClassifier::unsafe_arena_release_ethernet_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* temp = _impl_.ethernet_classifier_;
  _impl_.ethernet_classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* FlowClassifier::_internal_mutable_ethernet_classifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ethernet_classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader>(GetArenaForAllocation());
    _impl_.ethernet_classifier_ = p;
  }
  return _impl_.ethernet_classifier_;
}
inline ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* FlowClassifier::mutable_ethernet_classifier() {
  ::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* _msg = _internal_mutable_ethernet_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier)
  return _msg;
}
inline void FlowClassifier::set_allocated_ethernet_classifier(::aalyria::spacetime::api::common::PacketClassifier_EthernetHeader* ethernet_classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ethernet_classifier_;
  }
  if (ethernet_classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ethernet_classifier);
    if (message_arena != submessage_arena) {
      ethernet_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ethernet_classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ethernet_classifier_ = ethernet_classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcommon_2fnetwork_2eproto_2epb_2eh
