// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/nbi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fnbi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fnbi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/channel.pb.h"
#include "api/common/control.pb.h"
#include "api/common/coordinates.pb.h"
#include "api/common/platform.pb.h"
#include "api/common/telemetry.pb.h"
#include "api/common/time.pb.h"
#include "api/nbi/v1alpha/resources/antenna_pattern.pb.h"
#include "api/nbi/v1alpha/resources/coverage.pb.h"
#include "api/nbi/v1alpha/resources/devices_in_region.pb.h"
#include "api/nbi/v1alpha/resources/intent.pb.h"
#include "api/nbi/v1alpha/resources/motion_evaluation.pb.h"
#include "api/nbi/v1alpha/resources/network_element.pb.h"
#include "api/nbi/v1alpha/resources/network_link.pb.h"
#include "api/nbi/v1alpha/resources/scenario_settings.pb.h"
#include "api/nbi/v1alpha/resources/service_request.pb.h"
#include "api/nbi/v1alpha/resources/wireless_interference.pb.h"
#include "google/type/interval.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fnbi_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fnbi_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
class CreateEntityRequest;
struct CreateEntityRequestDefaultTypeInternal;
extern CreateEntityRequestDefaultTypeInternal _CreateEntityRequest_default_instance_;
class DeleteEntityRequest;
struct DeleteEntityRequestDefaultTypeInternal;
extern DeleteEntityRequestDefaultTypeInternal _DeleteEntityRequest_default_instance_;
class DeleteEntityResponse;
struct DeleteEntityResponseDefaultTypeInternal;
extern DeleteEntityResponseDefaultTypeInternal _DeleteEntityResponse_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class EntityFilter;
struct EntityFilterDefaultTypeInternal;
extern EntityFilterDefaultTypeInternal _EntityFilter_default_instance_;
class EntityGroup;
struct EntityGroupDefaultTypeInternal;
extern EntityGroupDefaultTypeInternal _EntityGroup_default_instance_;
class GetEntityRequest;
struct GetEntityRequestDefaultTypeInternal;
extern GetEntityRequestDefaultTypeInternal _GetEntityRequest_default_instance_;
class ListEntitiesOverTimeRequest;
struct ListEntitiesOverTimeRequestDefaultTypeInternal;
extern ListEntitiesOverTimeRequestDefaultTypeInternal _ListEntitiesOverTimeRequest_default_instance_;
class ListEntitiesOverTimeResponse;
struct ListEntitiesOverTimeResponseDefaultTypeInternal;
extern ListEntitiesOverTimeResponseDefaultTypeInternal _ListEntitiesOverTimeResponse_default_instance_;
class ListEntitiesRequest;
struct ListEntitiesRequestDefaultTypeInternal;
extern ListEntitiesRequestDefaultTypeInternal _ListEntitiesRequest_default_instance_;
class ListEntitiesResponse;
struct ListEntitiesResponseDefaultTypeInternal;
extern ListEntitiesResponseDefaultTypeInternal _ListEntitiesResponse_default_instance_;
class LoadScenarioRequest;
struct LoadScenarioRequestDefaultTypeInternal;
extern LoadScenarioRequestDefaultTypeInternal _LoadScenarioRequest_default_instance_;
class LoadScenarioResponse;
struct LoadScenarioResponseDefaultTypeInternal;
extern LoadScenarioResponseDefaultTypeInternal _LoadScenarioResponse_default_instance_;
class ResourceOrigin;
struct ResourceOriginDefaultTypeInternal;
extern ResourceOriginDefaultTypeInternal _ResourceOrigin_default_instance_;
class UpdateEntityRequest;
struct UpdateEntityRequestDefaultTypeInternal;
extern UpdateEntityRequestDefaultTypeInternal _UpdateEntityRequest_default_instance_;
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::CreateEntityRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::CreateEntityRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::DeleteEntityRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::DeleteEntityRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::DeleteEntityResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::DeleteEntityResponse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::Entity* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::Entity>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::EntityFilter>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::EntityGroup>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::GetEntityRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::GetEntityRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesOverTimeRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesOverTimeRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesOverTimeResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesOverTimeResponse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ListEntitiesResponse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::LoadScenarioRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::LoadScenarioRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::LoadScenarioResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::LoadScenarioResponse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::UpdateEntityRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::UpdateEntityRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
enum EntityType : int {
  ENTITY_TYPE_UNSPECIFIED = 0,
  ANTENNA_PATTERN = 12,
  BAND_PROFILE = 16,
  CDPI_STREAM_INFO = 17,
  DEVICES_IN_REGION = 24,
  STATION_SET = 21,
  SURFACE_REGION = 22,
  DRAIN_PROVISION = 20,
  INTENT = 6,
  INTERFACE_LINK_REPORT = 5,
  INTERFERENCE_CONSTRAINT = 23,
  MOTION_DEFINITION = 4,
  NETWORK_NODE = 3,
  NETWORK_STATS_REPORT = 8,
  PLATFORM_DEFINITION = 1,
  PROPAGATION_WEATHER = 15,
  SERVICE_REQUEST = 2,
  TRANSCEIVER_LINK_REPORT = 19,
  COMPUTED_MOTION = 7,
};

bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = static_cast<EntityType>(0);
constexpr EntityType EntityType_MAX = static_cast<EntityType>(24);
constexpr int EntityType_ARRAYSIZE = 24 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
EntityType_descriptor();
template <typename T>
const std::string& EntityType_Name(T value) {
  static_assert(std::is_same<T, EntityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EntityType_Name().");
  return EntityType_Name(static_cast<EntityType>(value));
}
template <>
inline const std::string& EntityType_Name(EntityType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<EntityType_descriptor,
                                                 0, 24>(
      static_cast<int>(value));
}
inline bool EntityType_Parse(absl::string_view name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
      EntityType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class EntityGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.EntityGroup) */ {
 public:
  inline EntityGroup() : EntityGroup(nullptr) {}
  ~EntityGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntityGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityGroup(const EntityGroup& from);
  EntityGroup(EntityGroup&& from) noexcept
    : EntityGroup() {
    *this = ::std::move(from);
  }

  inline EntityGroup& operator=(const EntityGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityGroup& operator=(EntityGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityGroup* internal_default_instance() {
    return reinterpret_cast<const EntityGroup*>(
               &_EntityGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EntityGroup& a, EntityGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntityGroup& from) {
    EntityGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.EntityGroup";
  }
  protected:
  explicit EntityGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string app_id = 3 [json_name = "appId"];
  bool has_app_id() const;
  void clear_app_id() ;
  const std::string& app_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.EntityGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class ResourceOrigin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin) */ {
 public:
  inline ResourceOrigin() : ResourceOrigin(nullptr) {}
  ~ResourceOrigin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResourceOrigin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceOrigin(const ResourceOrigin& from);
  ResourceOrigin(ResourceOrigin&& from) noexcept
    : ResourceOrigin() {
    *this = ::std::move(from);
  }

  inline ResourceOrigin& operator=(const ResourceOrigin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceOrigin& operator=(ResourceOrigin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceOrigin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceOrigin* internal_default_instance() {
    return reinterpret_cast<const ResourceOrigin*>(
               &_ResourceOrigin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResourceOrigin& a, ResourceOrigin& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceOrigin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceOrigin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceOrigin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceOrigin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceOrigin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceOrigin& from) {
    ResourceOrigin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceOrigin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin";
  }
  protected:
  explicit ResourceOrigin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProviderEndpointFieldNumber = 1,
  };
  // optional string provider_endpoint = 1 [json_name = "providerEndpoint"];
  bool has_provider_endpoint() const;
  void clear_provider_endpoint() ;
  const std::string& provider_endpoint() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_provider_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_provider_endpoint();
  PROTOBUF_NODISCARD std::string* release_provider_endpoint();
  void set_allocated_provider_endpoint(std::string* ptr);

  private:
  const std::string& _internal_provider_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider_endpoint(
      const std::string& value);
  std::string* _internal_mutable_provider_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_endpoint_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class Entity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Entity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity(const Entity& from);
  Entity(Entity&& from) noexcept
    : Entity() {
    *this = ::std::move(from);
  }

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAntennaPattern = 15,
    kBandProfile = 20,
    kCdpiStreamInfo = 23,
    kComputedMotion = 10,
    kDevicesInRegion = 30,
    kStationSet = 27,
    kSurfaceRegion = 28,
    kDrainProvision = 26,
    kIntent = 9,
    kInterfaceLinkReport = 8,
    kInterferenceConstraint = 29,
    kMotionDefinition = 7,
    kNetworkNode = 6,
    kNetworkStatsReport = 11,
    kPlatform = 4,
    kServiceRequest = 5,
    kTransceiverLinkReport = 25,
    VALUE_NOT_SET = 0,
  };

  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
               &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Entity& a, Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entity& from) {
    Entity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.Entity";
  }
  protected:
  explicit Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kLastModifiedByFieldNumber = 22,
    kGroupFieldNumber = 1,
    kResourceOriginFieldNumber = 34,
    kCommitTimestampFieldNumber = 3,
    kNextCommitTimestampFieldNumber = 33,
    kAntennaPatternFieldNumber = 15,
    kBandProfileFieldNumber = 20,
    kCdpiStreamInfoFieldNumber = 23,
    kComputedMotionFieldNumber = 10,
    kDevicesInRegionFieldNumber = 30,
    kStationSetFieldNumber = 27,
    kSurfaceRegionFieldNumber = 28,
    kDrainProvisionFieldNumber = 26,
    kIntentFieldNumber = 9,
    kInterfaceLinkReportFieldNumber = 8,
    kInterferenceConstraintFieldNumber = 29,
    kMotionDefinitionFieldNumber = 7,
    kNetworkNodeFieldNumber = 6,
    kNetworkStatsReportFieldNumber = 11,
    kPlatformFieldNumber = 4,
    kServiceRequestFieldNumber = 5,
    kTransceiverLinkReportFieldNumber = 25,
  };
  // optional string id = 2 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string last_modified_by = 22 [json_name = "lastModifiedBy"];
  bool has_last_modified_by() const;
  void clear_last_modified_by() ;
  const std::string& last_modified_by() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_modified_by(Arg_&& arg, Args_... args);
  std::string* mutable_last_modified_by();
  PROTOBUF_NODISCARD std::string* release_last_modified_by();
  void set_allocated_last_modified_by(std::string* ptr);

  private:
  const std::string& _internal_last_modified_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_modified_by(
      const std::string& value);
  std::string* _internal_mutable_last_modified_by();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityGroup group = 1 [json_name = "group"];
  bool has_group() const;
  void clear_group() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup& group() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* release_group();
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* mutable_group();
  void set_allocated_group(::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* group);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup& _internal_group() const;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* group);
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* unsafe_arena_release_group();
  // optional .aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin resource_origin = 34 [json_name = "resourceOrigin"];
  bool has_resource_origin() const;
  void clear_resource_origin() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin& resource_origin() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* release_resource_origin();
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* mutable_resource_origin();
  void set_allocated_resource_origin(::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* resource_origin);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin& _internal_resource_origin() const;
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* _internal_mutable_resource_origin();
  public:
  void unsafe_arena_set_allocated_resource_origin(
      ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* resource_origin);
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* unsafe_arena_release_resource_origin();
  // optional int64 commit_timestamp = 3 [json_name = "commitTimestamp"];
  bool has_commit_timestamp() const;
  void clear_commit_timestamp() ;
  ::int64_t commit_timestamp() const;
  void set_commit_timestamp(::int64_t value);

  private:
  ::int64_t _internal_commit_timestamp() const;
  void _internal_set_commit_timestamp(::int64_t value);

  public:
  // optional int64 next_commit_timestamp = 33 [json_name = "nextCommitTimestamp"];
  bool has_next_commit_timestamp() const;
  void clear_next_commit_timestamp() ;
  ::int64_t next_commit_timestamp() const;
  void set_next_commit_timestamp(::int64_t value);

  private:
  ::int64_t _internal_next_commit_timestamp() const;
  void _internal_set_next_commit_timestamp(::int64_t value);

  public:
  // .aalyria.spacetime.api.nbi.v1alpha.resources.AntennaPattern antenna_pattern = 15 [json_name = "antennaPattern"];
  bool has_antenna_pattern() const;
  private:
  bool _internal_has_antenna_pattern() const;

  public:
  void clear_antenna_pattern() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern& antenna_pattern() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* release_antenna_pattern();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* mutable_antenna_pattern();
  void set_allocated_antenna_pattern(::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* antenna_pattern);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern& _internal_antenna_pattern() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* _internal_mutable_antenna_pattern();
  public:
  void unsafe_arena_set_allocated_antenna_pattern(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* antenna_pattern);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* unsafe_arena_release_antenna_pattern();
  // .aalyria.spacetime.api.common.BandProfile band_profile = 20 [json_name = "bandProfile"];
  bool has_band_profile() const;
  private:
  bool _internal_has_band_profile() const;

  public:
  void clear_band_profile() ;
  const ::aalyria::spacetime::api::common::BandProfile& band_profile() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::BandProfile* release_band_profile();
  ::aalyria::spacetime::api::common::BandProfile* mutable_band_profile();
  void set_allocated_band_profile(::aalyria::spacetime::api::common::BandProfile* band_profile);
  private:
  const ::aalyria::spacetime::api::common::BandProfile& _internal_band_profile() const;
  ::aalyria::spacetime::api::common::BandProfile* _internal_mutable_band_profile();
  public:
  void unsafe_arena_set_allocated_band_profile(
      ::aalyria::spacetime::api::common::BandProfile* band_profile);
  ::aalyria::spacetime::api::common::BandProfile* unsafe_arena_release_band_profile();
  // .aalyria.spacetime.api.common.CdpiStreamInfo cdpi_stream_info = 23 [json_name = "cdpiStreamInfo"];
  bool has_cdpi_stream_info() const;
  private:
  bool _internal_has_cdpi_stream_info() const;

  public:
  void clear_cdpi_stream_info() ;
  const ::aalyria::spacetime::api::common::CdpiStreamInfo& cdpi_stream_info() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::CdpiStreamInfo* release_cdpi_stream_info();
  ::aalyria::spacetime::api::common::CdpiStreamInfo* mutable_cdpi_stream_info();
  void set_allocated_cdpi_stream_info(::aalyria::spacetime::api::common::CdpiStreamInfo* cdpi_stream_info);
  private:
  const ::aalyria::spacetime::api::common::CdpiStreamInfo& _internal_cdpi_stream_info() const;
  ::aalyria::spacetime::api::common::CdpiStreamInfo* _internal_mutable_cdpi_stream_info();
  public:
  void unsafe_arena_set_allocated_cdpi_stream_info(
      ::aalyria::spacetime::api::common::CdpiStreamInfo* cdpi_stream_info);
  ::aalyria::spacetime::api::common::CdpiStreamInfo* unsafe_arena_release_cdpi_stream_info();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.ComputedMotion computed_motion = 10 [json_name = "computedMotion"];
  bool has_computed_motion() const;
  private:
  bool _internal_has_computed_motion() const;

  public:
  void clear_computed_motion() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion& computed_motion() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* release_computed_motion();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* mutable_computed_motion();
  void set_allocated_computed_motion(::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* computed_motion);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion& _internal_computed_motion() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* _internal_mutable_computed_motion();
  public:
  void unsafe_arena_set_allocated_computed_motion(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* computed_motion);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* unsafe_arena_release_computed_motion();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.DevicesInRegion devices_in_region = 30 [json_name = "devicesInRegion"];
  bool has_devices_in_region() const;
  private:
  bool _internal_has_devices_in_region() const;

  public:
  void clear_devices_in_region() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion& devices_in_region() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* release_devices_in_region();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* mutable_devices_in_region();
  void set_allocated_devices_in_region(::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* devices_in_region);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion& _internal_devices_in_region() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* _internal_mutable_devices_in_region();
  public:
  void unsafe_arena_set_allocated_devices_in_region(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* devices_in_region);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* unsafe_arena_release_devices_in_region();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.StationSet station_set = 27 [json_name = "stationSet"];
  bool has_station_set() const;
  private:
  bool _internal_has_station_set() const;

  public:
  void clear_station_set() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet& station_set() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* release_station_set();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* mutable_station_set();
  void set_allocated_station_set(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* station_set);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet& _internal_station_set() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* _internal_mutable_station_set();
  public:
  void unsafe_arena_set_allocated_station_set(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* station_set);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* unsafe_arena_release_station_set();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion surface_region = 28 [json_name = "surfaceRegion"];
  bool has_surface_region() const;
  private:
  bool _internal_has_surface_region() const;

  public:
  void clear_surface_region() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion& surface_region() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* release_surface_region();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* mutable_surface_region();
  void set_allocated_surface_region(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* surface_region);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion& _internal_surface_region() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* _internal_mutable_surface_region();
  public:
  void unsafe_arena_set_allocated_surface_region(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* surface_region);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* unsafe_arena_release_surface_region();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision drain_provision = 26 [json_name = "drainProvision"];
  bool has_drain_provision() const;
  private:
  bool _internal_has_drain_provision() const;

  public:
  void clear_drain_provision() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision& drain_provision() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* release_drain_provision();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* mutable_drain_provision();
  void set_allocated_drain_provision(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* drain_provision);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision& _internal_drain_provision() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* _internal_mutable_drain_provision();
  public:
  void unsafe_arena_set_allocated_drain_provision(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* drain_provision);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* unsafe_arena_release_drain_provision();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.Intent intent = 9 [json_name = "intent"];
  bool has_intent() const;
  private:
  bool _internal_has_intent() const;

  public:
  void clear_intent() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent& intent() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* release_intent();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* mutable_intent();
  void set_allocated_intent(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* intent);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent& _internal_intent() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* _internal_mutable_intent();
  public:
  void unsafe_arena_set_allocated_intent(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* intent);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* unsafe_arena_release_intent();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport interface_link_report = 8 [json_name = "interfaceLinkReport"];
  bool has_interface_link_report() const;
  private:
  bool _internal_has_interface_link_report() const;

  public:
  void clear_interface_link_report() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport& interface_link_report() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* release_interface_link_report();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* mutable_interface_link_report();
  void set_allocated_interface_link_report(::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* interface_link_report);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport& _internal_interface_link_report() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* _internal_mutable_interface_link_report();
  public:
  void unsafe_arena_set_allocated_interface_link_report(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* interface_link_report);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* unsafe_arena_release_interface_link_report();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint interference_constraint = 29 [json_name = "interferenceConstraint"];
  bool has_interference_constraint() const;
  private:
  bool _internal_has_interference_constraint() const;

  public:
  void clear_interference_constraint() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint& interference_constraint() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* release_interference_constraint();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* mutable_interference_constraint();
  void set_allocated_interference_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* interference_constraint);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint& _internal_interference_constraint() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* _internal_mutable_interference_constraint();
  public:
  void unsafe_arena_set_allocated_interference_constraint(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* interference_constraint);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* unsafe_arena_release_interference_constraint();
  // .aalyria.spacetime.api.common.MotionDefinition motion_definition = 7 [json_name = "motionDefinition"];
  bool has_motion_definition() const;
  private:
  bool _internal_has_motion_definition() const;

  public:
  void clear_motion_definition() ;
  const ::aalyria::spacetime::api::common::MotionDefinition& motion_definition() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::MotionDefinition* release_motion_definition();
  ::aalyria::spacetime::api::common::MotionDefinition* mutable_motion_definition();
  void set_allocated_motion_definition(::aalyria::spacetime::api::common::MotionDefinition* motion_definition);
  private:
  const ::aalyria::spacetime::api::common::MotionDefinition& _internal_motion_definition() const;
  ::aalyria::spacetime::api::common::MotionDefinition* _internal_mutable_motion_definition();
  public:
  void unsafe_arena_set_allocated_motion_definition(
      ::aalyria::spacetime::api::common::MotionDefinition* motion_definition);
  ::aalyria::spacetime::api::common::MotionDefinition* unsafe_arena_release_motion_definition();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode network_node = 6 [json_name = "networkNode"];
  bool has_network_node() const;
  private:
  bool _internal_has_network_node() const;

  public:
  void clear_network_node() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode& network_node() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* release_network_node();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* mutable_network_node();
  void set_allocated_network_node(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* network_node);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode& _internal_network_node() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* _internal_mutable_network_node();
  public:
  void unsafe_arena_set_allocated_network_node(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* network_node);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* unsafe_arena_release_network_node();
  // .aalyria.spacetime.api.common.NetworkStatsReport network_stats_report = 11 [json_name = "networkStatsReport"];
  bool has_network_stats_report() const;
  private:
  bool _internal_has_network_stats_report() const;

  public:
  void clear_network_stats_report() ;
  const ::aalyria::spacetime::api::common::NetworkStatsReport& network_stats_report() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkStatsReport* release_network_stats_report();
  ::aalyria::spacetime::api::common::NetworkStatsReport* mutable_network_stats_report();
  void set_allocated_network_stats_report(::aalyria::spacetime::api::common::NetworkStatsReport* network_stats_report);
  private:
  const ::aalyria::spacetime::api::common::NetworkStatsReport& _internal_network_stats_report() const;
  ::aalyria::spacetime::api::common::NetworkStatsReport* _internal_mutable_network_stats_report();
  public:
  void unsafe_arena_set_allocated_network_stats_report(
      ::aalyria::spacetime::api::common::NetworkStatsReport* network_stats_report);
  ::aalyria::spacetime::api::common::NetworkStatsReport* unsafe_arena_release_network_stats_report();
  // .aalyria.spacetime.api.common.PlatformDefinition platform = 4 [json_name = "platform"];
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;

  public:
  void clear_platform() ;
  const ::aalyria::spacetime::api::common::PlatformDefinition& platform() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PlatformDefinition* release_platform();
  ::aalyria::spacetime::api::common::PlatformDefinition* mutable_platform();
  void set_allocated_platform(::aalyria::spacetime::api::common::PlatformDefinition* platform);
  private:
  const ::aalyria::spacetime::api::common::PlatformDefinition& _internal_platform() const;
  ::aalyria::spacetime::api::common::PlatformDefinition* _internal_mutable_platform();
  public:
  void unsafe_arena_set_allocated_platform(
      ::aalyria::spacetime::api::common::PlatformDefinition* platform);
  ::aalyria::spacetime::api::common::PlatformDefinition* unsafe_arena_release_platform();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest service_request = 5 [json_name = "serviceRequest"];
  bool has_service_request() const;
  private:
  bool _internal_has_service_request() const;

  public:
  void clear_service_request() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest& service_request() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* release_service_request();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* mutable_service_request();
  void set_allocated_service_request(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* service_request);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest& _internal_service_request() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* _internal_mutable_service_request();
  public:
  void unsafe_arena_set_allocated_service_request(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* service_request);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* unsafe_arena_release_service_request();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport transceiver_link_report = 25 [json_name = "transceiverLinkReport"];
  bool has_transceiver_link_report() const;
  private:
  bool _internal_has_transceiver_link_report() const;

  public:
  void clear_transceiver_link_report() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport& transceiver_link_report() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* release_transceiver_link_report();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* mutable_transceiver_link_report();
  void set_allocated_transceiver_link_report(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* transceiver_link_report);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport& _internal_transceiver_link_report() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* _internal_mutable_transceiver_link_report();
  public:
  void unsafe_arena_set_allocated_transceiver_link_report(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* transceiver_link_report);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* unsafe_arena_release_transceiver_link_report();
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.Entity)
 private:
  class _Internal;
  void set_has_antenna_pattern();
  void set_has_band_profile();
  void set_has_cdpi_stream_info();
  void set_has_computed_motion();
  void set_has_devices_in_region();
  void set_has_station_set();
  void set_has_surface_region();
  void set_has_drain_provision();
  void set_has_intent();
  void set_has_interface_link_report();
  void set_has_interference_constraint();
  void set_has_motion_definition();
  void set_has_network_node();
  void set_has_network_stats_report();
  void set_has_platform();
  void set_has_service_request();
  void set_has_transceiver_link_report();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_by_;
    ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* group_;
    ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* resource_origin_;
    ::int64_t commit_timestamp_;
    ::int64_t next_commit_timestamp_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* antenna_pattern_;
      ::aalyria::spacetime::api::common::BandProfile* band_profile_;
      ::aalyria::spacetime::api::common::CdpiStreamInfo* cdpi_stream_info_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* computed_motion_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* devices_in_region_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* station_set_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* surface_region_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* drain_provision_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* intent_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* interface_link_report_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* interference_constraint_;
      ::aalyria::spacetime::api::common::MotionDefinition* motion_definition_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* network_node_;
      ::aalyria::spacetime::api::common::NetworkStatsReport* network_stats_report_;
      ::aalyria::spacetime::api::common::PlatformDefinition* platform_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* service_request_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* transceiver_link_report_;
    } value_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class GetEntityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest) */ {
 public:
  inline GetEntityRequest() : GetEntityRequest(nullptr) {}
  ~GetEntityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetEntityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEntityRequest(const GetEntityRequest& from);
  GetEntityRequest(GetEntityRequest&& from) noexcept
    : GetEntityRequest() {
    *this = ::std::move(from);
  }

  inline GetEntityRequest& operator=(const GetEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEntityRequest& operator=(GetEntityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEntityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEntityRequest* internal_default_instance() {
    return reinterpret_cast<const GetEntityRequest*>(
               &_GetEntityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetEntityRequest& a, GetEntityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEntityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEntityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEntityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEntityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEntityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEntityRequest& from) {
    GetEntityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEntityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest";
  }
  protected:
  explicit GetEntityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string id = 2 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class CreateEntityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest) */ {
 public:
  inline CreateEntityRequest() : CreateEntityRequest(nullptr) {}
  ~CreateEntityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateEntityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateEntityRequest(const CreateEntityRequest& from);
  CreateEntityRequest(CreateEntityRequest&& from) noexcept
    : CreateEntityRequest() {
    *this = ::std::move(from);
  }

  inline CreateEntityRequest& operator=(const CreateEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEntityRequest& operator=(CreateEntityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateEntityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateEntityRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEntityRequest*>(
               &_CreateEntityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateEntityRequest& a, CreateEntityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEntityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEntityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateEntityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateEntityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateEntityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateEntityRequest& from) {
    CreateEntityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEntityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest";
  }
  protected:
  explicit CreateEntityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.Entity entity = 1 [json_name = "entity"];
  bool has_entity() const;
  void clear_entity() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& entity() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::Entity* release_entity();
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* mutable_entity();
  void set_allocated_entity(::aalyria::spacetime::api::nbi::v1alpha::Entity* entity);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& _internal_entity() const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _internal_mutable_entity();
  public:
  void unsafe_arena_set_allocated_entity(
      ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity);
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* unsafe_arena_release_entity();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class UpdateEntityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest) */ {
 public:
  inline UpdateEntityRequest() : UpdateEntityRequest(nullptr) {}
  ~UpdateEntityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateEntityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEntityRequest(const UpdateEntityRequest& from);
  UpdateEntityRequest(UpdateEntityRequest&& from) noexcept
    : UpdateEntityRequest() {
    *this = ::std::move(from);
  }

  inline UpdateEntityRequest& operator=(const UpdateEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEntityRequest& operator=(UpdateEntityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEntityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEntityRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateEntityRequest*>(
               &_UpdateEntityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateEntityRequest& a, UpdateEntityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEntityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEntityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEntityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEntityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateEntityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateEntityRequest& from) {
    UpdateEntityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEntityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest";
  }
  protected:
  explicit UpdateEntityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
    kIgnoreConsistencyCheckFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.Entity entity = 1 [json_name = "entity"];
  bool has_entity() const;
  void clear_entity() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& entity() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::Entity* release_entity();
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* mutable_entity();
  void set_allocated_entity(::aalyria::spacetime::api::nbi::v1alpha::Entity* entity);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& _internal_entity() const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _internal_mutable_entity();
  public:
  void unsafe_arena_set_allocated_entity(
      ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity);
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* unsafe_arena_release_entity();
  // optional bool ignore_consistency_check = 2 [json_name = "ignoreConsistencyCheck"];
  bool has_ignore_consistency_check() const;
  void clear_ignore_consistency_check() ;
  bool ignore_consistency_check() const;
  void set_ignore_consistency_check(bool value);

  private:
  bool _internal_ignore_consistency_check() const;
  void _internal_set_ignore_consistency_check(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity_;
    bool ignore_consistency_check_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class ListEntitiesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest) */ {
 public:
  inline ListEntitiesRequest() : ListEntitiesRequest(nullptr) {}
  ~ListEntitiesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntitiesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEntitiesRequest(const ListEntitiesRequest& from);
  ListEntitiesRequest(ListEntitiesRequest&& from) noexcept
    : ListEntitiesRequest() {
    *this = ::std::move(from);
  }

  inline ListEntitiesRequest& operator=(const ListEntitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntitiesRequest& operator=(ListEntitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEntitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ListEntitiesRequest*>(
               &_ListEntitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListEntitiesRequest& a, ListEntitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEntitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEntitiesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEntitiesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEntitiesRequest& from) {
    ListEntitiesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEntitiesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest";
  }
  protected:
  explicit ListEntitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 3,
    kFilterFieldNumber = 5,
    kTypeFieldNumber = 1,
    kComputeCartesianCoordinatesFieldNumber = 6,
  };
  // optional .google.type.Interval interval = 3 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::google::type::Interval& interval() const;
  PROTOBUF_NODISCARD ::google::type::Interval* release_interval();
  ::google::type::Interval* mutable_interval();
  void set_allocated_interval(::google::type::Interval* interval);
  private:
  const ::google::type::Interval& _internal_interval() const;
  ::google::type::Interval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::google::type::Interval* interval);
  ::google::type::Interval* unsafe_arena_release_interval();
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityFilter filter = 5 [json_name = "filter"];
  bool has_filter() const;
  void clear_filter() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& filter() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* release_filter();
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* mutable_filter();
  void set_allocated_filter(::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& _internal_filter() const;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter);
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* unsafe_arena_release_filter();
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  public:
  // optional bool compute_cartesian_coordinates = 6 [json_name = "computeCartesianCoordinates"];
  bool has_compute_cartesian_coordinates() const;
  void clear_compute_cartesian_coordinates() ;
  bool compute_cartesian_coordinates() const;
  void set_compute_cartesian_coordinates(bool value);

  private:
  bool _internal_compute_cartesian_coordinates() const;
  void _internal_set_compute_cartesian_coordinates(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::google::type::Interval* interval_;
    ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter_;
    int type_;
    bool compute_cartesian_coordinates_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class ListEntitiesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse) */ {
 public:
  inline ListEntitiesResponse() : ListEntitiesResponse(nullptr) {}
  ~ListEntitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntitiesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEntitiesResponse(const ListEntitiesResponse& from);
  ListEntitiesResponse(ListEntitiesResponse&& from) noexcept
    : ListEntitiesResponse() {
    *this = ::std::move(from);
  }

  inline ListEntitiesResponse& operator=(const ListEntitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntitiesResponse& operator=(ListEntitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEntitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ListEntitiesResponse*>(
               &_ListEntitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListEntitiesResponse& a, ListEntitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEntitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEntitiesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEntitiesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEntitiesResponse& from) {
    ListEntitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEntitiesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse";
  }
  protected:
  explicit ListEntitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.Entity entities = 1 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >*
      mutable_entities();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& _internal_entities(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _internal_add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>& _internal_entities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>* _internal_mutable_entities();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& entities(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >&
      entities() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity > entities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class ListEntitiesOverTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest) */ {
 public:
  inline ListEntitiesOverTimeRequest() : ListEntitiesOverTimeRequest(nullptr) {}
  ~ListEntitiesOverTimeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntitiesOverTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEntitiesOverTimeRequest(const ListEntitiesOverTimeRequest& from);
  ListEntitiesOverTimeRequest(ListEntitiesOverTimeRequest&& from) noexcept
    : ListEntitiesOverTimeRequest() {
    *this = ::std::move(from);
  }

  inline ListEntitiesOverTimeRequest& operator=(const ListEntitiesOverTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntitiesOverTimeRequest& operator=(ListEntitiesOverTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntitiesOverTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEntitiesOverTimeRequest* internal_default_instance() {
    return reinterpret_cast<const ListEntitiesOverTimeRequest*>(
               &_ListEntitiesOverTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListEntitiesOverTimeRequest& a, ListEntitiesOverTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEntitiesOverTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntitiesOverTimeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntitiesOverTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEntitiesOverTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEntitiesOverTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEntitiesOverTimeRequest& from) {
    ListEntitiesOverTimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEntitiesOverTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest";
  }
  protected:
  explicit ListEntitiesOverTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 5,
    kIntervalFieldNumber = 2,
    kFilterFieldNumber = 4,
    kTypeFieldNumber = 1,
    kComputeCartesianCoordinatesFieldNumber = 3,
    kDiffFieldNumber = 6,
  };
  // repeated string ids = 5 [json_name = "ids"];
  int ids_size() const;
  private:
  int _internal_ids_size() const;

  public:
  void clear_ids() ;
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, std::size_t size);
  void set_ids(int index, absl::string_view value);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const char* value, std::size_t size);
  void add_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();

  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_ids();

  public:
  // optional .aalyria.spacetime.api.common.TimeInterval interval = 2 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::aalyria::spacetime::api::common::TimeInterval& interval() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TimeInterval* release_interval();
  ::aalyria::spacetime::api::common::TimeInterval* mutable_interval();
  void set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval);
  private:
  const ::aalyria::spacetime::api::common::TimeInterval& _internal_interval() const;
  ::aalyria::spacetime::api::common::TimeInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::aalyria::spacetime::api::common::TimeInterval* interval);
  ::aalyria::spacetime::api::common::TimeInterval* unsafe_arena_release_interval();
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityFilter filter = 4 [json_name = "filter"];
  bool has_filter() const;
  void clear_filter() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& filter() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* release_filter();
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* mutable_filter();
  void set_allocated_filter(::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& _internal_filter() const;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter);
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* unsafe_arena_release_filter();
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  public:
  // optional bool compute_cartesian_coordinates = 3 [json_name = "computeCartesianCoordinates"];
  bool has_compute_cartesian_coordinates() const;
  void clear_compute_cartesian_coordinates() ;
  bool compute_cartesian_coordinates() const;
  void set_compute_cartesian_coordinates(bool value);

  private:
  bool _internal_compute_cartesian_coordinates() const;
  void _internal_set_compute_cartesian_coordinates(bool value);

  public:
  // optional bool diff = 6 [json_name = "diff"];
  bool has_diff() const;
  void clear_diff() ;
  bool diff() const;
  void set_diff(bool value);

  private:
  bool _internal_diff() const;
  void _internal_set_diff(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
    ::aalyria::spacetime::api::common::TimeInterval* interval_;
    ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter_;
    int type_;
    bool compute_cartesian_coordinates_;
    bool diff_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class ListEntitiesOverTimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse) */ {
 public:
  inline ListEntitiesOverTimeResponse() : ListEntitiesOverTimeResponse(nullptr) {}
  ~ListEntitiesOverTimeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListEntitiesOverTimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEntitiesOverTimeResponse(const ListEntitiesOverTimeResponse& from);
  ListEntitiesOverTimeResponse(ListEntitiesOverTimeResponse&& from) noexcept
    : ListEntitiesOverTimeResponse() {
    *this = ::std::move(from);
  }

  inline ListEntitiesOverTimeResponse& operator=(const ListEntitiesOverTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEntitiesOverTimeResponse& operator=(ListEntitiesOverTimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEntitiesOverTimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEntitiesOverTimeResponse* internal_default_instance() {
    return reinterpret_cast<const ListEntitiesOverTimeResponse*>(
               &_ListEntitiesOverTimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListEntitiesOverTimeResponse& a, ListEntitiesOverTimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEntitiesOverTimeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEntitiesOverTimeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEntitiesOverTimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEntitiesOverTimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEntitiesOverTimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEntitiesOverTimeResponse& from) {
    ListEntitiesOverTimeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEntitiesOverTimeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse";
  }
  protected:
  explicit ListEntitiesOverTimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.Entity entities = 1 [json_name = "entities"];
  int entities_size() const;
  private:
  int _internal_entities_size() const;

  public:
  void clear_entities() ;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >*
      mutable_entities();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& _internal_entities(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _internal_add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>& _internal_entities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>* _internal_mutable_entities();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity& entities(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >&
      entities() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity > entities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class EntityFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.EntityFilter) */ {
 public:
  inline EntityFilter() : EntityFilter(nullptr) {}
  ~EntityFilter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntityFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityFilter(const EntityFilter& from);
  EntityFilter(EntityFilter&& from) noexcept
    : EntityFilter() {
    *this = ::std::move(from);
  }

  inline EntityFilter& operator=(const EntityFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityFilter& operator=(EntityFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityFilter* internal_default_instance() {
    return reinterpret_cast<const EntityFilter*>(
               &_EntityFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EntityFilter& a, EntityFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntityFilter& from) {
    EntityFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.EntityFilter";
  }
  protected:
  explicit EntityFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferencesNodeFieldNumber = 1,
    kReferencesServiceRequestFieldNumber = 2,
    kIncludeIntentStatesFieldNumber = 3,
  };
  // repeated string references_node = 1 [json_name = "referencesNode"];
  int references_node_size() const;
  private:
  int _internal_references_node_size() const;

  public:
  void clear_references_node() ;
  const std::string& references_node(int index) const;
  std::string* mutable_references_node(int index);
  void set_references_node(int index, const std::string& value);
  void set_references_node(int index, std::string&& value);
  void set_references_node(int index, const char* value);
  void set_references_node(int index, const char* value, std::size_t size);
  void set_references_node(int index, absl::string_view value);
  std::string* add_references_node();
  void add_references_node(const std::string& value);
  void add_references_node(std::string&& value);
  void add_references_node(const char* value);
  void add_references_node(const char* value, std::size_t size);
  void add_references_node(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& references_node() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_references_node();

  private:
  const std::string& _internal_references_node(int index) const;
  std::string* _internal_add_references_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_references_node() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_references_node();

  public:
  // repeated string references_service_request = 2 [json_name = "referencesServiceRequest"];
  int references_service_request_size() const;
  private:
  int _internal_references_service_request_size() const;

  public:
  void clear_references_service_request() ;
  const std::string& references_service_request(int index) const;
  std::string* mutable_references_service_request(int index);
  void set_references_service_request(int index, const std::string& value);
  void set_references_service_request(int index, std::string&& value);
  void set_references_service_request(int index, const char* value);
  void set_references_service_request(int index, const char* value, std::size_t size);
  void set_references_service_request(int index, absl::string_view value);
  std::string* add_references_service_request();
  void add_references_service_request(const std::string& value);
  void add_references_service_request(std::string&& value);
  void add_references_service_request(const char* value);
  void add_references_service_request(const char* value, std::size_t size);
  void add_references_service_request(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& references_service_request() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_references_service_request();

  private:
  const std::string& _internal_references_service_request(int index) const;
  std::string* _internal_add_references_service_request();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_references_service_request() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_references_service_request();

  public:
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState include_intent_states = 3 [json_name = "includeIntentStates"];
  int include_intent_states_size() const;
  private:
  int _internal_include_intent_states_size() const;

  public:
  void clear_include_intent_states() ;
  public:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState include_intent_states(int index) const;
  void set_include_intent_states(int index, ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value);
  void add_include_intent_states(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& include_intent_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_include_intent_states();

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState _internal_include_intent_states(int index) const;
  void _internal_add_include_intent_states(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_include_intent_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_include_intent_states();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.EntityFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> references_node_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> references_service_request_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> include_intent_states_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class DeleteEntityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest) */ {
 public:
  inline DeleteEntityRequest() : DeleteEntityRequest(nullptr) {}
  ~DeleteEntityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteEntityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteEntityRequest(const DeleteEntityRequest& from);
  DeleteEntityRequest(DeleteEntityRequest&& from) noexcept
    : DeleteEntityRequest() {
    *this = ::std::move(from);
  }

  inline DeleteEntityRequest& operator=(const DeleteEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEntityRequest& operator=(DeleteEntityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEntityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteEntityRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteEntityRequest*>(
               &_DeleteEntityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteEntityRequest& a, DeleteEntityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteEntityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEntityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteEntityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteEntityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteEntityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteEntityRequest& from) {
    DeleteEntityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteEntityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest";
  }
  protected:
  explicit DeleteEntityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIgnoreConsistencyCheckFieldNumber = 4,
    kLastCommitTimestampFieldNumber = 3,
  };
  // optional string id = 2 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::EntityType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value);

  public:
  // optional bool ignore_consistency_check = 4 [json_name = "ignoreConsistencyCheck"];
  bool has_ignore_consistency_check() const;
  void clear_ignore_consistency_check() ;
  bool ignore_consistency_check() const;
  void set_ignore_consistency_check(bool value);

  private:
  bool _internal_ignore_consistency_check() const;
  void _internal_set_ignore_consistency_check(bool value);

  public:
  // optional int64 last_commit_timestamp = 3 [json_name = "lastCommitTimestamp"];
  bool has_last_commit_timestamp() const;
  void clear_last_commit_timestamp() ;
  ::int64_t last_commit_timestamp() const;
  void set_last_commit_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_commit_timestamp() const;
  void _internal_set_last_commit_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int type_;
    bool ignore_consistency_check_;
    ::int64_t last_commit_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class DeleteEntityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityResponse) */ {
 public:
  inline DeleteEntityResponse() : DeleteEntityResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteEntityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteEntityResponse(const DeleteEntityResponse& from);
  DeleteEntityResponse(DeleteEntityResponse&& from) noexcept
    : DeleteEntityResponse() {
    *this = ::std::move(from);
  }

  inline DeleteEntityResponse& operator=(const DeleteEntityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteEntityResponse& operator=(DeleteEntityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteEntityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteEntityResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteEntityResponse*>(
               &_DeleteEntityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteEntityResponse& a, DeleteEntityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteEntityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteEntityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteEntityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteEntityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteEntityResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteEntityResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.DeleteEntityResponse";
  }
  protected:
  explicit DeleteEntityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class LoadScenarioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest) */ {
 public:
  inline LoadScenarioRequest() : LoadScenarioRequest(nullptr) {}
  ~LoadScenarioRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadScenarioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadScenarioRequest(const LoadScenarioRequest& from);
  LoadScenarioRequest(LoadScenarioRequest&& from) noexcept
    : LoadScenarioRequest() {
    *this = ::std::move(from);
  }

  inline LoadScenarioRequest& operator=(const LoadScenarioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScenarioRequest& operator=(LoadScenarioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadScenarioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadScenarioRequest* internal_default_instance() {
    return reinterpret_cast<const LoadScenarioRequest*>(
               &_LoadScenarioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LoadScenarioRequest& a, LoadScenarioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScenarioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScenarioRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadScenarioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadScenarioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadScenarioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadScenarioRequest& from) {
    LoadScenarioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadScenarioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest";
  }
  protected:
  explicit LoadScenarioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioSettingsFieldNumber = 1,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ScenarioSettings scenario_settings = 1 [json_name = "scenarioSettings"];
  bool has_scenario_settings() const;
  void clear_scenario_settings() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings& scenario_settings() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* release_scenario_settings();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* mutable_scenario_settings();
  void set_allocated_scenario_settings(::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* scenario_settings);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings& _internal_scenario_settings() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* _internal_mutable_scenario_settings();
  public:
  void unsafe_arena_set_allocated_scenario_settings(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* scenario_settings);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* unsafe_arena_release_scenario_settings();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* scenario_settings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};// -------------------------------------------------------------------

class LoadScenarioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioResponse) */ {
 public:
  inline LoadScenarioResponse() : LoadScenarioResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadScenarioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadScenarioResponse(const LoadScenarioResponse& from);
  LoadScenarioResponse(LoadScenarioResponse&& from) noexcept
    : LoadScenarioResponse() {
    *this = ::std::move(from);
  }

  inline LoadScenarioResponse& operator=(const LoadScenarioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScenarioResponse& operator=(LoadScenarioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadScenarioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadScenarioResponse* internal_default_instance() {
    return reinterpret_cast<const LoadScenarioResponse*>(
               &_LoadScenarioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LoadScenarioResponse& a, LoadScenarioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScenarioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScenarioResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadScenarioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadScenarioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoadScenarioResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoadScenarioResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.LoadScenarioResponse";
  }
  protected:
  explicit LoadScenarioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fnbi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EntityGroup

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
inline bool EntityGroup::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EntityGroup::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType EntityGroup::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.type)
  return _internal_type();
}
inline void EntityGroup::set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType EntityGroup::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::EntityType>(_impl_.type_);
}
inline void EntityGroup::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::EntityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string app_id = 3 [json_name = "appId"];
inline bool EntityGroup::has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EntityGroup::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntityGroup::app_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityGroup::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.app_id)
}
inline std::string* EntityGroup::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.app_id)
  return _s;
}
inline const std::string& EntityGroup::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void EntityGroup::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityGroup::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EntityGroup::release_app_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.app_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EntityGroup::set_allocated_app_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.EntityGroup.app_id)
}

// -------------------------------------------------------------------

// ResourceOrigin

// optional string provider_endpoint = 1 [json_name = "providerEndpoint"];
inline bool ResourceOrigin::has_provider_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResourceOrigin::clear_provider_endpoint() {
  _impl_.provider_endpoint_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceOrigin::provider_endpoint() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin.provider_endpoint)
  return _internal_provider_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResourceOrigin::set_provider_endpoint(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.provider_endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin.provider_endpoint)
}
inline std::string* ResourceOrigin::mutable_provider_endpoint() {
  std::string* _s = _internal_mutable_provider_endpoint();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin.provider_endpoint)
  return _s;
}
inline const std::string& ResourceOrigin::_internal_provider_endpoint() const {
  return _impl_.provider_endpoint_.Get();
}
inline void ResourceOrigin::_internal_set_provider_endpoint(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.provider_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceOrigin::_internal_mutable_provider_endpoint() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.provider_endpoint_.Mutable( GetArenaForAllocation());
}
inline std::string* ResourceOrigin::release_provider_endpoint() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin.provider_endpoint)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.provider_endpoint_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.provider_endpoint_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResourceOrigin::set_allocated_provider_endpoint(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.provider_endpoint_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.provider_endpoint_.IsDefault()) {
          _impl_.provider_endpoint_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin.provider_endpoint)
}

// -------------------------------------------------------------------

// Entity

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityGroup group = 1 [json_name = "group"];
inline bool Entity::has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline void Entity::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup& Entity::_internal_group() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_EntityGroup_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup& Entity::group() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.group)
  return _internal_group();
}
inline void Entity::unsafe_arena_set_allocated_group(
    ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.group)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* Entity::release_group() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* Entity::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.group)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* Entity::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::EntityGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* Entity::mutable_group() {
  ::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.group)
  return _msg;
}
inline void Entity::set_allocated_group(::aalyria::spacetime::api::nbi::v1alpha::EntityGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.group)
}

// optional string id = 2 [json_name = "id"];
inline bool Entity::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Entity::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Entity::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.Entity.id)
}
inline std::string* Entity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.id)
  return _s;
}
inline const std::string& Entity::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Entity::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Entity::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Entity::release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Entity::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.id)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.ResourceOrigin resource_origin = 34 [json_name = "resourceOrigin"];
inline bool Entity::has_resource_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resource_origin_ != nullptr);
  return value;
}
inline void Entity::clear_resource_origin() {
  if (_impl_.resource_origin_ != nullptr) _impl_.resource_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin& Entity::_internal_resource_origin() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* p = _impl_.resource_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_ResourceOrigin_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin& Entity::resource_origin() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.resource_origin)
  return _internal_resource_origin();
}
inline void Entity::unsafe_arena_set_allocated_resource_origin(
    ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* resource_origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_origin_);
  }
  _impl_.resource_origin_ = resource_origin;
  if (resource_origin) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.resource_origin)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* Entity::release_resource_origin() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* temp = _impl_.resource_origin_;
  _impl_.resource_origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* Entity::unsafe_arena_release_resource_origin() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.resource_origin)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* temp = _impl_.resource_origin_;
  _impl_.resource_origin_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* Entity::_internal_mutable_resource_origin() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.resource_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin>(GetArenaForAllocation());
    _impl_.resource_origin_ = p;
  }
  return _impl_.resource_origin_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* Entity::mutable_resource_origin() {
  ::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* _msg = _internal_mutable_resource_origin();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.resource_origin)
  return _msg;
}
inline void Entity::set_allocated_resource_origin(::aalyria::spacetime::api::nbi::v1alpha::ResourceOrigin* resource_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_origin_;
  }
  if (resource_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource_origin);
    if (message_arena != submessage_arena) {
      resource_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource_origin, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.resource_origin_ = resource_origin;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.resource_origin)
}

// optional int64 commit_timestamp = 3 [json_name = "commitTimestamp"];
inline bool Entity::has_commit_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Entity::clear_commit_timestamp() {
  _impl_.commit_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t Entity::commit_timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.commit_timestamp)
  return _internal_commit_timestamp();
}
inline void Entity::set_commit_timestamp(::int64_t value) {
  _internal_set_commit_timestamp(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.Entity.commit_timestamp)
}
inline ::int64_t Entity::_internal_commit_timestamp() const {
  return _impl_.commit_timestamp_;
}
inline void Entity::_internal_set_commit_timestamp(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.commit_timestamp_ = value;
}

// optional int64 next_commit_timestamp = 33 [json_name = "nextCommitTimestamp"];
inline bool Entity::has_next_commit_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Entity::clear_next_commit_timestamp() {
  _impl_.next_commit_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t Entity::next_commit_timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.next_commit_timestamp)
  return _internal_next_commit_timestamp();
}
inline void Entity::set_next_commit_timestamp(::int64_t value) {
  _internal_set_next_commit_timestamp(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.Entity.next_commit_timestamp)
}
inline ::int64_t Entity::_internal_next_commit_timestamp() const {
  return _impl_.next_commit_timestamp_;
}
inline void Entity::_internal_set_next_commit_timestamp(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.next_commit_timestamp_ = value;
}

// optional string last_modified_by = 22 [json_name = "lastModifiedBy"];
inline bool Entity::has_last_modified_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Entity::clear_last_modified_by() {
  _impl_.last_modified_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Entity::last_modified_by() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.last_modified_by)
  return _internal_last_modified_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_last_modified_by(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_modified_by_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.Entity.last_modified_by)
}
inline std::string* Entity::mutable_last_modified_by() {
  std::string* _s = _internal_mutable_last_modified_by();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.last_modified_by)
  return _s;
}
inline const std::string& Entity::_internal_last_modified_by() const {
  return _impl_.last_modified_by_.Get();
}
inline void Entity::_internal_set_last_modified_by(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.last_modified_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Entity::_internal_mutable_last_modified_by() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.last_modified_by_.Mutable( GetArenaForAllocation());
}
inline std::string* Entity::release_last_modified_by() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.last_modified_by)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.last_modified_by_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_modified_by_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Entity::set_allocated_last_modified_by(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.last_modified_by_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.last_modified_by_.IsDefault()) {
          _impl_.last_modified_by_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.last_modified_by)
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.AntennaPattern antenna_pattern = 15 [json_name = "antennaPattern"];
inline bool Entity::has_antenna_pattern() const {
  return value_case() == kAntennaPattern;
}
inline bool Entity::_internal_has_antenna_pattern() const {
  return value_case() == kAntennaPattern;
}
inline void Entity::set_has_antenna_pattern() {
  _impl_._oneof_case_[0] = kAntennaPattern;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* Entity::release_antenna_pattern() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.antenna_pattern)
  if (value_case() == kAntennaPattern) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* temp = _impl_.value_.antenna_pattern_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.antenna_pattern_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern& Entity::_internal_antenna_pattern() const {
  return value_case() == kAntennaPattern
      ? *_impl_.value_.antenna_pattern_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_AntennaPattern_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern& Entity::antenna_pattern() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.antenna_pattern)
  return _internal_antenna_pattern();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* Entity::unsafe_arena_release_antenna_pattern() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.antenna_pattern)
  if (value_case() == kAntennaPattern) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* temp = _impl_.value_.antenna_pattern_;
    _impl_.value_.antenna_pattern_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_antenna_pattern(::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* antenna_pattern) {
  clear_value();
  if (antenna_pattern) {
    set_has_antenna_pattern();
    _impl_.value_.antenna_pattern_ = antenna_pattern;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.antenna_pattern)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* Entity::_internal_mutable_antenna_pattern() {
  if (value_case() != kAntennaPattern) {
    clear_value();
    set_has_antenna_pattern();
    _impl_.value_.antenna_pattern_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern >(GetArenaForAllocation());
  }
  return _impl_.value_.antenna_pattern_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* Entity::mutable_antenna_pattern() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::AntennaPattern* _msg = _internal_mutable_antenna_pattern();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.antenna_pattern)
  return _msg;
}

// .aalyria.spacetime.api.common.BandProfile band_profile = 20 [json_name = "bandProfile"];
inline bool Entity::has_band_profile() const {
  return value_case() == kBandProfile;
}
inline bool Entity::_internal_has_band_profile() const {
  return value_case() == kBandProfile;
}
inline void Entity::set_has_band_profile() {
  _impl_._oneof_case_[0] = kBandProfile;
}
inline ::aalyria::spacetime::api::common::BandProfile* Entity::release_band_profile() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.band_profile)
  if (value_case() == kBandProfile) {
    clear_has_value();
    ::aalyria::spacetime::api::common::BandProfile* temp = _impl_.value_.band_profile_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.band_profile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::BandProfile& Entity::_internal_band_profile() const {
  return value_case() == kBandProfile
      ? *_impl_.value_.band_profile_
      : reinterpret_cast<::aalyria::spacetime::api::common::BandProfile&>(::aalyria::spacetime::api::common::_BandProfile_default_instance_);
}
inline const ::aalyria::spacetime::api::common::BandProfile& Entity::band_profile() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.band_profile)
  return _internal_band_profile();
}
inline ::aalyria::spacetime::api::common::BandProfile* Entity::unsafe_arena_release_band_profile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.band_profile)
  if (value_case() == kBandProfile) {
    clear_has_value();
    ::aalyria::spacetime::api::common::BandProfile* temp = _impl_.value_.band_profile_;
    _impl_.value_.band_profile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_band_profile(::aalyria::spacetime::api::common::BandProfile* band_profile) {
  clear_value();
  if (band_profile) {
    set_has_band_profile();
    _impl_.value_.band_profile_ = band_profile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.band_profile)
}
inline ::aalyria::spacetime::api::common::BandProfile* Entity::_internal_mutable_band_profile() {
  if (value_case() != kBandProfile) {
    clear_value();
    set_has_band_profile();
    _impl_.value_.band_profile_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::BandProfile >(GetArenaForAllocation());
  }
  return _impl_.value_.band_profile_;
}
inline ::aalyria::spacetime::api::common::BandProfile* Entity::mutable_band_profile() {
  ::aalyria::spacetime::api::common::BandProfile* _msg = _internal_mutable_band_profile();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.band_profile)
  return _msg;
}

// .aalyria.spacetime.api.common.CdpiStreamInfo cdpi_stream_info = 23 [json_name = "cdpiStreamInfo"];
inline bool Entity::has_cdpi_stream_info() const {
  return value_case() == kCdpiStreamInfo;
}
inline bool Entity::_internal_has_cdpi_stream_info() const {
  return value_case() == kCdpiStreamInfo;
}
inline void Entity::set_has_cdpi_stream_info() {
  _impl_._oneof_case_[0] = kCdpiStreamInfo;
}
inline ::aalyria::spacetime::api::common::CdpiStreamInfo* Entity::release_cdpi_stream_info() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.cdpi_stream_info)
  if (value_case() == kCdpiStreamInfo) {
    clear_has_value();
    ::aalyria::spacetime::api::common::CdpiStreamInfo* temp = _impl_.value_.cdpi_stream_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.cdpi_stream_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::CdpiStreamInfo& Entity::_internal_cdpi_stream_info() const {
  return value_case() == kCdpiStreamInfo
      ? *_impl_.value_.cdpi_stream_info_
      : reinterpret_cast<::aalyria::spacetime::api::common::CdpiStreamInfo&>(::aalyria::spacetime::api::common::_CdpiStreamInfo_default_instance_);
}
inline const ::aalyria::spacetime::api::common::CdpiStreamInfo& Entity::cdpi_stream_info() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.cdpi_stream_info)
  return _internal_cdpi_stream_info();
}
inline ::aalyria::spacetime::api::common::CdpiStreamInfo* Entity::unsafe_arena_release_cdpi_stream_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.cdpi_stream_info)
  if (value_case() == kCdpiStreamInfo) {
    clear_has_value();
    ::aalyria::spacetime::api::common::CdpiStreamInfo* temp = _impl_.value_.cdpi_stream_info_;
    _impl_.value_.cdpi_stream_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_cdpi_stream_info(::aalyria::spacetime::api::common::CdpiStreamInfo* cdpi_stream_info) {
  clear_value();
  if (cdpi_stream_info) {
    set_has_cdpi_stream_info();
    _impl_.value_.cdpi_stream_info_ = cdpi_stream_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.cdpi_stream_info)
}
inline ::aalyria::spacetime::api::common::CdpiStreamInfo* Entity::_internal_mutable_cdpi_stream_info() {
  if (value_case() != kCdpiStreamInfo) {
    clear_value();
    set_has_cdpi_stream_info();
    _impl_.value_.cdpi_stream_info_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::CdpiStreamInfo >(GetArenaForAllocation());
  }
  return _impl_.value_.cdpi_stream_info_;
}
inline ::aalyria::spacetime::api::common::CdpiStreamInfo* Entity::mutable_cdpi_stream_info() {
  ::aalyria::spacetime::api::common::CdpiStreamInfo* _msg = _internal_mutable_cdpi_stream_info();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.cdpi_stream_info)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.ComputedMotion computed_motion = 10 [json_name = "computedMotion"];
inline bool Entity::has_computed_motion() const {
  return value_case() == kComputedMotion;
}
inline bool Entity::_internal_has_computed_motion() const {
  return value_case() == kComputedMotion;
}
inline void Entity::set_has_computed_motion() {
  _impl_._oneof_case_[0] = kComputedMotion;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* Entity::release_computed_motion() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.computed_motion)
  if (value_case() == kComputedMotion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* temp = _impl_.value_.computed_motion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.computed_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion& Entity::_internal_computed_motion() const {
  return value_case() == kComputedMotion
      ? *_impl_.value_.computed_motion_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_ComputedMotion_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion& Entity::computed_motion() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.computed_motion)
  return _internal_computed_motion();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* Entity::unsafe_arena_release_computed_motion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.computed_motion)
  if (value_case() == kComputedMotion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* temp = _impl_.value_.computed_motion_;
    _impl_.value_.computed_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_computed_motion(::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* computed_motion) {
  clear_value();
  if (computed_motion) {
    set_has_computed_motion();
    _impl_.value_.computed_motion_ = computed_motion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.computed_motion)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* Entity::_internal_mutable_computed_motion() {
  if (value_case() != kComputedMotion) {
    clear_value();
    set_has_computed_motion();
    _impl_.value_.computed_motion_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion >(GetArenaForAllocation());
  }
  return _impl_.value_.computed_motion_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* Entity::mutable_computed_motion() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ComputedMotion* _msg = _internal_mutable_computed_motion();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.computed_motion)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.DevicesInRegion devices_in_region = 30 [json_name = "devicesInRegion"];
inline bool Entity::has_devices_in_region() const {
  return value_case() == kDevicesInRegion;
}
inline bool Entity::_internal_has_devices_in_region() const {
  return value_case() == kDevicesInRegion;
}
inline void Entity::set_has_devices_in_region() {
  _impl_._oneof_case_[0] = kDevicesInRegion;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* Entity::release_devices_in_region() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.devices_in_region)
  if (value_case() == kDevicesInRegion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* temp = _impl_.value_.devices_in_region_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.devices_in_region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion& Entity::_internal_devices_in_region() const {
  return value_case() == kDevicesInRegion
      ? *_impl_.value_.devices_in_region_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_DevicesInRegion_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion& Entity::devices_in_region() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.devices_in_region)
  return _internal_devices_in_region();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* Entity::unsafe_arena_release_devices_in_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.devices_in_region)
  if (value_case() == kDevicesInRegion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* temp = _impl_.value_.devices_in_region_;
    _impl_.value_.devices_in_region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_devices_in_region(::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* devices_in_region) {
  clear_value();
  if (devices_in_region) {
    set_has_devices_in_region();
    _impl_.value_.devices_in_region_ = devices_in_region;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.devices_in_region)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* Entity::_internal_mutable_devices_in_region() {
  if (value_case() != kDevicesInRegion) {
    clear_value();
    set_has_devices_in_region();
    _impl_.value_.devices_in_region_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion >(GetArenaForAllocation());
  }
  return _impl_.value_.devices_in_region_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* Entity::mutable_devices_in_region() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DevicesInRegion* _msg = _internal_mutable_devices_in_region();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.devices_in_region)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.StationSet station_set = 27 [json_name = "stationSet"];
inline bool Entity::has_station_set() const {
  return value_case() == kStationSet;
}
inline bool Entity::_internal_has_station_set() const {
  return value_case() == kStationSet;
}
inline void Entity::set_has_station_set() {
  _impl_._oneof_case_[0] = kStationSet;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* Entity::release_station_set() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.station_set)
  if (value_case() == kStationSet) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* temp = _impl_.value_.station_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.station_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet& Entity::_internal_station_set() const {
  return value_case() == kStationSet
      ? *_impl_.value_.station_set_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_StationSet_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet& Entity::station_set() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.station_set)
  return _internal_station_set();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* Entity::unsafe_arena_release_station_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.station_set)
  if (value_case() == kStationSet) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* temp = _impl_.value_.station_set_;
    _impl_.value_.station_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_station_set(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* station_set) {
  clear_value();
  if (station_set) {
    set_has_station_set();
    _impl_.value_.station_set_ = station_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.station_set)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* Entity::_internal_mutable_station_set() {
  if (value_case() != kStationSet) {
    clear_value();
    set_has_station_set();
    _impl_.value_.station_set_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet >(GetArenaForAllocation());
  }
  return _impl_.value_.station_set_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* Entity::mutable_station_set() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* _msg = _internal_mutable_station_set();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.station_set)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion surface_region = 28 [json_name = "surfaceRegion"];
inline bool Entity::has_surface_region() const {
  return value_case() == kSurfaceRegion;
}
inline bool Entity::_internal_has_surface_region() const {
  return value_case() == kSurfaceRegion;
}
inline void Entity::set_has_surface_region() {
  _impl_._oneof_case_[0] = kSurfaceRegion;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* Entity::release_surface_region() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.surface_region)
  if (value_case() == kSurfaceRegion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* temp = _impl_.value_.surface_region_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.surface_region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion& Entity::_internal_surface_region() const {
  return value_case() == kSurfaceRegion
      ? *_impl_.value_.surface_region_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_SurfaceRegion_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion& Entity::surface_region() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.surface_region)
  return _internal_surface_region();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* Entity::unsafe_arena_release_surface_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.surface_region)
  if (value_case() == kSurfaceRegion) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* temp = _impl_.value_.surface_region_;
    _impl_.value_.surface_region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_surface_region(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* surface_region) {
  clear_value();
  if (surface_region) {
    set_has_surface_region();
    _impl_.value_.surface_region_ = surface_region;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.surface_region)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* Entity::_internal_mutable_surface_region() {
  if (value_case() != kSurfaceRegion) {
    clear_value();
    set_has_surface_region();
    _impl_.value_.surface_region_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion >(GetArenaForAllocation());
  }
  return _impl_.value_.surface_region_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* Entity::mutable_surface_region() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* _msg = _internal_mutable_surface_region();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.surface_region)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision drain_provision = 26 [json_name = "drainProvision"];
inline bool Entity::has_drain_provision() const {
  return value_case() == kDrainProvision;
}
inline bool Entity::_internal_has_drain_provision() const {
  return value_case() == kDrainProvision;
}
inline void Entity::set_has_drain_provision() {
  _impl_._oneof_case_[0] = kDrainProvision;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* Entity::release_drain_provision() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.drain_provision)
  if (value_case() == kDrainProvision) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* temp = _impl_.value_.drain_provision_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.drain_provision_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision& Entity::_internal_drain_provision() const {
  return value_case() == kDrainProvision
      ? *_impl_.value_.drain_provision_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_DrainProvision_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision& Entity::drain_provision() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.drain_provision)
  return _internal_drain_provision();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* Entity::unsafe_arena_release_drain_provision() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.drain_provision)
  if (value_case() == kDrainProvision) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* temp = _impl_.value_.drain_provision_;
    _impl_.value_.drain_provision_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_drain_provision(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* drain_provision) {
  clear_value();
  if (drain_provision) {
    set_has_drain_provision();
    _impl_.value_.drain_provision_ = drain_provision;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.drain_provision)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* Entity::_internal_mutable_drain_provision() {
  if (value_case() != kDrainProvision) {
    clear_value();
    set_has_drain_provision();
    _impl_.value_.drain_provision_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision >(GetArenaForAllocation());
  }
  return _impl_.value_.drain_provision_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* Entity::mutable_drain_provision() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* _msg = _internal_mutable_drain_provision();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.drain_provision)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.Intent intent = 9 [json_name = "intent"];
inline bool Entity::has_intent() const {
  return value_case() == kIntent;
}
inline bool Entity::_internal_has_intent() const {
  return value_case() == kIntent;
}
inline void Entity::set_has_intent() {
  _impl_._oneof_case_[0] = kIntent;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* Entity::release_intent() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.intent)
  if (value_case() == kIntent) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* temp = _impl_.value_.intent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent& Entity::_internal_intent() const {
  return value_case() == kIntent
      ? *_impl_.value_.intent_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_Intent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent& Entity::intent() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.intent)
  return _internal_intent();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* Entity::unsafe_arena_release_intent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.intent)
  if (value_case() == kIntent) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* temp = _impl_.value_.intent_;
    _impl_.value_.intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_intent(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* intent) {
  clear_value();
  if (intent) {
    set_has_intent();
    _impl_.value_.intent_ = intent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.intent)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* Entity::_internal_mutable_intent() {
  if (value_case() != kIntent) {
    clear_value();
    set_has_intent();
    _impl_.value_.intent_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent >(GetArenaForAllocation());
  }
  return _impl_.value_.intent_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* Entity::mutable_intent() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* _msg = _internal_mutable_intent();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.intent)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport interface_link_report = 8 [json_name = "interfaceLinkReport"];
inline bool Entity::has_interface_link_report() const {
  return value_case() == kInterfaceLinkReport;
}
inline bool Entity::_internal_has_interface_link_report() const {
  return value_case() == kInterfaceLinkReport;
}
inline void Entity::set_has_interface_link_report() {
  _impl_._oneof_case_[0] = kInterfaceLinkReport;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* Entity::release_interface_link_report() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.interface_link_report)
  if (value_case() == kInterfaceLinkReport) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* temp = _impl_.value_.interface_link_report_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.interface_link_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport& Entity::_internal_interface_link_report() const {
  return value_case() == kInterfaceLinkReport
      ? *_impl_.value_.interface_link_report_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_InterfaceLinkReport_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport& Entity::interface_link_report() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.interface_link_report)
  return _internal_interface_link_report();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* Entity::unsafe_arena_release_interface_link_report() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.interface_link_report)
  if (value_case() == kInterfaceLinkReport) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* temp = _impl_.value_.interface_link_report_;
    _impl_.value_.interface_link_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_interface_link_report(::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* interface_link_report) {
  clear_value();
  if (interface_link_report) {
    set_has_interface_link_report();
    _impl_.value_.interface_link_report_ = interface_link_report;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.interface_link_report)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* Entity::_internal_mutable_interface_link_report() {
  if (value_case() != kInterfaceLinkReport) {
    clear_value();
    set_has_interface_link_report();
    _impl_.value_.interface_link_report_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport >(GetArenaForAllocation());
  }
  return _impl_.value_.interface_link_report_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* Entity::mutable_interface_link_report() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* _msg = _internal_mutable_interface_link_report();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.interface_link_report)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint interference_constraint = 29 [json_name = "interferenceConstraint"];
inline bool Entity::has_interference_constraint() const {
  return value_case() == kInterferenceConstraint;
}
inline bool Entity::_internal_has_interference_constraint() const {
  return value_case() == kInterferenceConstraint;
}
inline void Entity::set_has_interference_constraint() {
  _impl_._oneof_case_[0] = kInterferenceConstraint;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* Entity::release_interference_constraint() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.interference_constraint)
  if (value_case() == kInterferenceConstraint) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* temp = _impl_.value_.interference_constraint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.interference_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint& Entity::_internal_interference_constraint() const {
  return value_case() == kInterferenceConstraint
      ? *_impl_.value_.interference_constraint_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_InterferenceConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint& Entity::interference_constraint() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.interference_constraint)
  return _internal_interference_constraint();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* Entity::unsafe_arena_release_interference_constraint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.interference_constraint)
  if (value_case() == kInterferenceConstraint) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* temp = _impl_.value_.interference_constraint_;
    _impl_.value_.interference_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_interference_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* interference_constraint) {
  clear_value();
  if (interference_constraint) {
    set_has_interference_constraint();
    _impl_.value_.interference_constraint_ = interference_constraint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.interference_constraint)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* Entity::_internal_mutable_interference_constraint() {
  if (value_case() != kInterferenceConstraint) {
    clear_value();
    set_has_interference_constraint();
    _impl_.value_.interference_constraint_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint >(GetArenaForAllocation());
  }
  return _impl_.value_.interference_constraint_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* Entity::mutable_interference_constraint() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* _msg = _internal_mutable_interference_constraint();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.interference_constraint)
  return _msg;
}

// .aalyria.spacetime.api.common.MotionDefinition motion_definition = 7 [json_name = "motionDefinition"];
inline bool Entity::has_motion_definition() const {
  return value_case() == kMotionDefinition;
}
inline bool Entity::_internal_has_motion_definition() const {
  return value_case() == kMotionDefinition;
}
inline void Entity::set_has_motion_definition() {
  _impl_._oneof_case_[0] = kMotionDefinition;
}
inline ::aalyria::spacetime::api::common::MotionDefinition* Entity::release_motion_definition() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.motion_definition)
  if (value_case() == kMotionDefinition) {
    clear_has_value();
    ::aalyria::spacetime::api::common::MotionDefinition* temp = _impl_.value_.motion_definition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.motion_definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::MotionDefinition& Entity::_internal_motion_definition() const {
  return value_case() == kMotionDefinition
      ? *_impl_.value_.motion_definition_
      : reinterpret_cast<::aalyria::spacetime::api::common::MotionDefinition&>(::aalyria::spacetime::api::common::_MotionDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::MotionDefinition& Entity::motion_definition() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.motion_definition)
  return _internal_motion_definition();
}
inline ::aalyria::spacetime::api::common::MotionDefinition* Entity::unsafe_arena_release_motion_definition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.motion_definition)
  if (value_case() == kMotionDefinition) {
    clear_has_value();
    ::aalyria::spacetime::api::common::MotionDefinition* temp = _impl_.value_.motion_definition_;
    _impl_.value_.motion_definition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_motion_definition(::aalyria::spacetime::api::common::MotionDefinition* motion_definition) {
  clear_value();
  if (motion_definition) {
    set_has_motion_definition();
    _impl_.value_.motion_definition_ = motion_definition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.motion_definition)
}
inline ::aalyria::spacetime::api::common::MotionDefinition* Entity::_internal_mutable_motion_definition() {
  if (value_case() != kMotionDefinition) {
    clear_value();
    set_has_motion_definition();
    _impl_.value_.motion_definition_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::MotionDefinition >(GetArenaForAllocation());
  }
  return _impl_.value_.motion_definition_;
}
inline ::aalyria::spacetime::api::common::MotionDefinition* Entity::mutable_motion_definition() {
  ::aalyria::spacetime::api::common::MotionDefinition* _msg = _internal_mutable_motion_definition();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.motion_definition)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode network_node = 6 [json_name = "networkNode"];
inline bool Entity::has_network_node() const {
  return value_case() == kNetworkNode;
}
inline bool Entity::_internal_has_network_node() const {
  return value_case() == kNetworkNode;
}
inline void Entity::set_has_network_node() {
  _impl_._oneof_case_[0] = kNetworkNode;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* Entity::release_network_node() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.network_node)
  if (value_case() == kNetworkNode) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* temp = _impl_.value_.network_node_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.network_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode& Entity::_internal_network_node() const {
  return value_case() == kNetworkNode
      ? *_impl_.value_.network_node_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_NetworkNode_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode& Entity::network_node() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.network_node)
  return _internal_network_node();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* Entity::unsafe_arena_release_network_node() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.network_node)
  if (value_case() == kNetworkNode) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* temp = _impl_.value_.network_node_;
    _impl_.value_.network_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_network_node(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* network_node) {
  clear_value();
  if (network_node) {
    set_has_network_node();
    _impl_.value_.network_node_ = network_node;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.network_node)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* Entity::_internal_mutable_network_node() {
  if (value_case() != kNetworkNode) {
    clear_value();
    set_has_network_node();
    _impl_.value_.network_node_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode >(GetArenaForAllocation());
  }
  return _impl_.value_.network_node_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* Entity::mutable_network_node() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* _msg = _internal_mutable_network_node();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.network_node)
  return _msg;
}

// .aalyria.spacetime.api.common.NetworkStatsReport network_stats_report = 11 [json_name = "networkStatsReport"];
inline bool Entity::has_network_stats_report() const {
  return value_case() == kNetworkStatsReport;
}
inline bool Entity::_internal_has_network_stats_report() const {
  return value_case() == kNetworkStatsReport;
}
inline void Entity::set_has_network_stats_report() {
  _impl_._oneof_case_[0] = kNetworkStatsReport;
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* Entity::release_network_stats_report() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.network_stats_report)
  if (value_case() == kNetworkStatsReport) {
    clear_has_value();
    ::aalyria::spacetime::api::common::NetworkStatsReport* temp = _impl_.value_.network_stats_report_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.network_stats_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::NetworkStatsReport& Entity::_internal_network_stats_report() const {
  return value_case() == kNetworkStatsReport
      ? *_impl_.value_.network_stats_report_
      : reinterpret_cast<::aalyria::spacetime::api::common::NetworkStatsReport&>(::aalyria::spacetime::api::common::_NetworkStatsReport_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkStatsReport& Entity::network_stats_report() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.network_stats_report)
  return _internal_network_stats_report();
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* Entity::unsafe_arena_release_network_stats_report() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.network_stats_report)
  if (value_case() == kNetworkStatsReport) {
    clear_has_value();
    ::aalyria::spacetime::api::common::NetworkStatsReport* temp = _impl_.value_.network_stats_report_;
    _impl_.value_.network_stats_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_network_stats_report(::aalyria::spacetime::api::common::NetworkStatsReport* network_stats_report) {
  clear_value();
  if (network_stats_report) {
    set_has_network_stats_report();
    _impl_.value_.network_stats_report_ = network_stats_report;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.network_stats_report)
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* Entity::_internal_mutable_network_stats_report() {
  if (value_case() != kNetworkStatsReport) {
    clear_value();
    set_has_network_stats_report();
    _impl_.value_.network_stats_report_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport >(GetArenaForAllocation());
  }
  return _impl_.value_.network_stats_report_;
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* Entity::mutable_network_stats_report() {
  ::aalyria::spacetime::api::common::NetworkStatsReport* _msg = _internal_mutable_network_stats_report();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.network_stats_report)
  return _msg;
}

// .aalyria.spacetime.api.common.PlatformDefinition platform = 4 [json_name = "platform"];
inline bool Entity::has_platform() const {
  return value_case() == kPlatform;
}
inline bool Entity::_internal_has_platform() const {
  return value_case() == kPlatform;
}
inline void Entity::set_has_platform() {
  _impl_._oneof_case_[0] = kPlatform;
}
inline ::aalyria::spacetime::api::common::PlatformDefinition* Entity::release_platform() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.platform)
  if (value_case() == kPlatform) {
    clear_has_value();
    ::aalyria::spacetime::api::common::PlatformDefinition* temp = _impl_.value_.platform_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.platform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::PlatformDefinition& Entity::_internal_platform() const {
  return value_case() == kPlatform
      ? *_impl_.value_.platform_
      : reinterpret_cast<::aalyria::spacetime::api::common::PlatformDefinition&>(::aalyria::spacetime::api::common::_PlatformDefinition_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PlatformDefinition& Entity::platform() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.platform)
  return _internal_platform();
}
inline ::aalyria::spacetime::api::common::PlatformDefinition* Entity::unsafe_arena_release_platform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.platform)
  if (value_case() == kPlatform) {
    clear_has_value();
    ::aalyria::spacetime::api::common::PlatformDefinition* temp = _impl_.value_.platform_;
    _impl_.value_.platform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_platform(::aalyria::spacetime::api::common::PlatformDefinition* platform) {
  clear_value();
  if (platform) {
    set_has_platform();
    _impl_.value_.platform_ = platform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.platform)
}
inline ::aalyria::spacetime::api::common::PlatformDefinition* Entity::_internal_mutable_platform() {
  if (value_case() != kPlatform) {
    clear_value();
    set_has_platform();
    _impl_.value_.platform_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::PlatformDefinition >(GetArenaForAllocation());
  }
  return _impl_.value_.platform_;
}
inline ::aalyria::spacetime::api::common::PlatformDefinition* Entity::mutable_platform() {
  ::aalyria::spacetime::api::common::PlatformDefinition* _msg = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.platform)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest service_request = 5 [json_name = "serviceRequest"];
inline bool Entity::has_service_request() const {
  return value_case() == kServiceRequest;
}
inline bool Entity::_internal_has_service_request() const {
  return value_case() == kServiceRequest;
}
inline void Entity::set_has_service_request() {
  _impl_._oneof_case_[0] = kServiceRequest;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* Entity::release_service_request() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.service_request)
  if (value_case() == kServiceRequest) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* temp = _impl_.value_.service_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.service_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest& Entity::_internal_service_request() const {
  return value_case() == kServiceRequest
      ? *_impl_.value_.service_request_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest& Entity::service_request() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.service_request)
  return _internal_service_request();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* Entity::unsafe_arena_release_service_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.service_request)
  if (value_case() == kServiceRequest) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* temp = _impl_.value_.service_request_;
    _impl_.value_.service_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_service_request(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* service_request) {
  clear_value();
  if (service_request) {
    set_has_service_request();
    _impl_.value_.service_request_ = service_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.service_request)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* Entity::_internal_mutable_service_request() {
  if (value_case() != kServiceRequest) {
    clear_value();
    set_has_service_request();
    _impl_.value_.service_request_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest >(GetArenaForAllocation());
  }
  return _impl_.value_.service_request_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* Entity::mutable_service_request() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* _msg = _internal_mutable_service_request();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.service_request)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport transceiver_link_report = 25 [json_name = "transceiverLinkReport"];
inline bool Entity::has_transceiver_link_report() const {
  return value_case() == kTransceiverLinkReport;
}
inline bool Entity::_internal_has_transceiver_link_report() const {
  return value_case() == kTransceiverLinkReport;
}
inline void Entity::set_has_transceiver_link_report() {
  _impl_._oneof_case_[0] = kTransceiverLinkReport;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* Entity::release_transceiver_link_report() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.Entity.transceiver_link_report)
  if (value_case() == kTransceiverLinkReport) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* temp = _impl_.value_.transceiver_link_report_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.transceiver_link_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport& Entity::_internal_transceiver_link_report() const {
  return value_case() == kTransceiverLinkReport
      ? *_impl_.value_.transceiver_link_report_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_TransceiverLinkReport_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport& Entity::transceiver_link_report() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.Entity.transceiver_link_report)
  return _internal_transceiver_link_report();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* Entity::unsafe_arena_release_transceiver_link_report() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.Entity.transceiver_link_report)
  if (value_case() == kTransceiverLinkReport) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* temp = _impl_.value_.transceiver_link_report_;
    _impl_.value_.transceiver_link_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Entity::unsafe_arena_set_allocated_transceiver_link_report(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* transceiver_link_report) {
  clear_value();
  if (transceiver_link_report) {
    set_has_transceiver_link_report();
    _impl_.value_.transceiver_link_report_ = transceiver_link_report;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.Entity.transceiver_link_report)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* Entity::_internal_mutable_transceiver_link_report() {
  if (value_case() != kTransceiverLinkReport) {
    clear_value();
    set_has_transceiver_link_report();
    _impl_.value_.transceiver_link_report_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport >(GetArenaForAllocation());
  }
  return _impl_.value_.transceiver_link_report_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* Entity::mutable_transceiver_link_report() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* _msg = _internal_mutable_transceiver_link_report();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.Entity.transceiver_link_report)
  return _msg;
}

inline bool Entity::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Entity::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Entity::ValueCase Entity::value_case() const {
  return Entity::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetEntityRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
inline bool GetEntityRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetEntityRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType GetEntityRequest::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.type)
  return _internal_type();
}
inline void GetEntityRequest::set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType GetEntityRequest::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::EntityType>(_impl_.type_);
}
inline void GetEntityRequest::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::EntityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string id = 2 [json_name = "id"];
inline bool GetEntityRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetEntityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetEntityRequest::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetEntityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.id)
}
inline std::string* GetEntityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.id)
  return _s;
}
inline const std::string& GetEntityRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetEntityRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetEntityRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetEntityRequest::release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetEntityRequest::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.GetEntityRequest.id)
}

// -------------------------------------------------------------------

// CreateEntityRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.Entity entity = 1 [json_name = "entity"];
inline bool CreateEntityRequest::has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_ != nullptr);
  return value;
}
inline void CreateEntityRequest::clear_entity() {
  if (_impl_.entity_ != nullptr) _impl_.entity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& CreateEntityRequest::_internal_entity() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::Entity&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_Entity_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& CreateEntityRequest::entity() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest.entity)
  return _internal_entity();
}
inline void CreateEntityRequest::unsafe_arena_set_allocated_entity(
    ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = entity;
  if (entity) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest.entity)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* CreateEntityRequest::release_entity() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* CreateEntityRequest::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest.entity)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* CreateEntityRequest::_internal_mutable_entity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.entity_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::Entity>(GetArenaForAllocation());
    _impl_.entity_ = p;
  }
  return _impl_.entity_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* CreateEntityRequest::mutable_entity() {
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest.entity)
  return _msg;
}
inline void CreateEntityRequest::set_allocated_entity(::aalyria::spacetime::api::nbi::v1alpha::Entity* entity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.entity_;
  }
  if (entity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entity);
    if (message_arena != submessage_arena) {
      entity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_ = entity;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.CreateEntityRequest.entity)
}

// -------------------------------------------------------------------

// UpdateEntityRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.Entity entity = 1 [json_name = "entity"];
inline bool UpdateEntityRequest::has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_ != nullptr);
  return value;
}
inline void UpdateEntityRequest::clear_entity() {
  if (_impl_.entity_ != nullptr) _impl_.entity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& UpdateEntityRequest::_internal_entity() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::Entity* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::Entity&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_Entity_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& UpdateEntityRequest::entity() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.entity)
  return _internal_entity();
}
inline void UpdateEntityRequest::unsafe_arena_set_allocated_entity(
    ::aalyria::spacetime::api::nbi::v1alpha::Entity* entity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = entity;
  if (entity) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.entity)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* UpdateEntityRequest::release_entity() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* UpdateEntityRequest::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.entity)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* UpdateEntityRequest::_internal_mutable_entity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.entity_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::Entity>(GetArenaForAllocation());
    _impl_.entity_ = p;
  }
  return _impl_.entity_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* UpdateEntityRequest::mutable_entity() {
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.entity)
  return _msg;
}
inline void UpdateEntityRequest::set_allocated_entity(::aalyria::spacetime::api::nbi::v1alpha::Entity* entity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.entity_;
  }
  if (entity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entity);
    if (message_arena != submessage_arena) {
      entity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_ = entity;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.entity)
}

// optional bool ignore_consistency_check = 2 [json_name = "ignoreConsistencyCheck"];
inline bool UpdateEntityRequest::has_ignore_consistency_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpdateEntityRequest::clear_ignore_consistency_check() {
  _impl_.ignore_consistency_check_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateEntityRequest::ignore_consistency_check() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.ignore_consistency_check)
  return _internal_ignore_consistency_check();
}
inline void UpdateEntityRequest::set_ignore_consistency_check(bool value) {
  _internal_set_ignore_consistency_check(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.UpdateEntityRequest.ignore_consistency_check)
}
inline bool UpdateEntityRequest::_internal_ignore_consistency_check() const {
  return _impl_.ignore_consistency_check_;
}
inline void UpdateEntityRequest::_internal_set_ignore_consistency_check(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ignore_consistency_check_ = value;
}

// -------------------------------------------------------------------

// ListEntitiesRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
inline bool ListEntitiesRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ListEntitiesRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType ListEntitiesRequest::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.type)
  return _internal_type();
}
inline void ListEntitiesRequest::set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType ListEntitiesRequest::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::EntityType>(_impl_.type_);
}
inline void ListEntitiesRequest::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::EntityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .google.type.Interval interval = 3 [json_name = "interval"];
inline bool ListEntitiesRequest::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::google::type::Interval& ListEntitiesRequest::_internal_interval() const {
  const ::google::type::Interval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::type::Interval&>(
      ::google::type::_Interval_default_instance_);
}
inline const ::google::type::Interval& ListEntitiesRequest::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.interval)
  return _internal_interval();
}
inline void ListEntitiesRequest::unsafe_arena_set_allocated_interval(
    ::google::type::Interval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.interval)
}
inline ::google::type::Interval* ListEntitiesRequest::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::type::Interval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::type::Interval* ListEntitiesRequest::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::type::Interval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::google::type::Interval* ListEntitiesRequest::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::type::Interval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::google::type::Interval* ListEntitiesRequest::mutable_interval() {
  ::google::type::Interval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.interval)
  return _msg;
}
inline void ListEntitiesRequest::set_allocated_interval(::google::type::Interval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.interval)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityFilter filter = 5 [json_name = "filter"];
inline bool ListEntitiesRequest::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void ListEntitiesRequest::clear_filter() {
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& ListEntitiesRequest::_internal_filter() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_EntityFilter_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& ListEntitiesRequest::filter() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.filter)
  return _internal_filter();
}
inline void ListEntitiesRequest::unsafe_arena_set_allocated_filter(
    ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.filter)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesRequest::release_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesRequest::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::EntityFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesRequest::mutable_filter() {
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.filter)
  return _msg;
}
inline void ListEntitiesRequest::set_allocated_filter(::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.filter)
}

// optional bool compute_cartesian_coordinates = 6 [json_name = "computeCartesianCoordinates"];
inline bool ListEntitiesRequest::has_compute_cartesian_coordinates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ListEntitiesRequest::clear_compute_cartesian_coordinates() {
  _impl_.compute_cartesian_coordinates_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ListEntitiesRequest::compute_cartesian_coordinates() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.compute_cartesian_coordinates)
  return _internal_compute_cartesian_coordinates();
}
inline void ListEntitiesRequest::set_compute_cartesian_coordinates(bool value) {
  _internal_set_compute_cartesian_coordinates(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesRequest.compute_cartesian_coordinates)
}
inline bool ListEntitiesRequest::_internal_compute_cartesian_coordinates() const {
  return _impl_.compute_cartesian_coordinates_;
}
inline void ListEntitiesRequest::_internal_set_compute_cartesian_coordinates(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compute_cartesian_coordinates_ = value;
}

// -------------------------------------------------------------------

// ListEntitiesResponse

// repeated .aalyria.spacetime.api.nbi.v1alpha.Entity entities = 1 [json_name = "entities"];
inline int ListEntitiesResponse::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int ListEntitiesResponse::entities_size() const {
  return _internal_entities_size();
}
inline void ListEntitiesResponse::clear_entities() {
  _internal_mutable_entities()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse.entities)
  return _internal_mutable_entities()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >*
ListEntitiesResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse.entities)
  return _internal_mutable_entities();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& ListEntitiesResponse::_internal_entities(int index) const {
  return _internal_entities().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& ListEntitiesResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse.entities)
  return _internal_entities(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesResponse::_internal_add_entities() {
  return _internal_mutable_entities()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesResponse::add_entities() {
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >&
ListEntitiesResponse::entities() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesResponse.entities)
  return _internal_entities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>&
ListEntitiesResponse::_internal_entities() const {
  return _impl_.entities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>*
ListEntitiesResponse::_internal_mutable_entities() {
  return &_impl_.entities_;
}

// -------------------------------------------------------------------

// ListEntitiesOverTimeRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
inline bool ListEntitiesOverTimeRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ListEntitiesOverTimeRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType ListEntitiesOverTimeRequest::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.type)
  return _internal_type();
}
inline void ListEntitiesOverTimeRequest::set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType ListEntitiesOverTimeRequest::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::EntityType>(_impl_.type_);
}
inline void ListEntitiesOverTimeRequest::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::EntityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .aalyria.spacetime.api.common.TimeInterval interval = 2 [json_name = "interval"];
inline bool ListEntitiesOverTimeRequest::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TimeInterval& ListEntitiesOverTimeRequest::_internal_interval() const {
  const ::aalyria::spacetime::api::common::TimeInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TimeInterval&>(
      ::aalyria::spacetime::api::common::_TimeInterval_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TimeInterval& ListEntitiesOverTimeRequest::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.interval)
  return _internal_interval();
}
inline void ListEntitiesOverTimeRequest::unsafe_arena_set_allocated_interval(
    ::aalyria::spacetime::api::common::TimeInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.interval)
}
inline ::aalyria::spacetime::api::common::TimeInterval* ListEntitiesOverTimeRequest::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ListEntitiesOverTimeRequest::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ListEntitiesOverTimeRequest::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TimeInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ListEntitiesOverTimeRequest::mutable_interval() {
  ::aalyria::spacetime::api::common::TimeInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.interval)
  return _msg;
}
inline void ListEntitiesOverTimeRequest::set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.interval)
}

// optional bool compute_cartesian_coordinates = 3 [json_name = "computeCartesianCoordinates"];
inline bool ListEntitiesOverTimeRequest::has_compute_cartesian_coordinates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ListEntitiesOverTimeRequest::clear_compute_cartesian_coordinates() {
  _impl_.compute_cartesian_coordinates_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ListEntitiesOverTimeRequest::compute_cartesian_coordinates() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.compute_cartesian_coordinates)
  return _internal_compute_cartesian_coordinates();
}
inline void ListEntitiesOverTimeRequest::set_compute_cartesian_coordinates(bool value) {
  _internal_set_compute_cartesian_coordinates(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.compute_cartesian_coordinates)
}
inline bool ListEntitiesOverTimeRequest::_internal_compute_cartesian_coordinates() const {
  return _impl_.compute_cartesian_coordinates_;
}
inline void ListEntitiesOverTimeRequest::_internal_set_compute_cartesian_coordinates(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compute_cartesian_coordinates_ = value;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityFilter filter = 4 [json_name = "filter"];
inline bool ListEntitiesOverTimeRequest::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void ListEntitiesOverTimeRequest::clear_filter() {
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& ListEntitiesOverTimeRequest::_internal_filter() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter&>(
      ::aalyria::spacetime::api::nbi::v1alpha::_EntityFilter_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter& ListEntitiesOverTimeRequest::filter() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.filter)
  return _internal_filter();
}
inline void ListEntitiesOverTimeRequest::unsafe_arena_set_allocated_filter(
    ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.filter)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesOverTimeRequest::release_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesOverTimeRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesOverTimeRequest::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::EntityFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* ListEntitiesOverTimeRequest::mutable_filter() {
  ::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.filter)
  return _msg;
}
inline void ListEntitiesOverTimeRequest::set_allocated_filter(::aalyria::spacetime::api::nbi::v1alpha::EntityFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.filter)
}

// repeated string ids = 5 [json_name = "ids"];
inline int ListEntitiesOverTimeRequest::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int ListEntitiesOverTimeRequest::ids_size() const {
  return _internal_ids_size();
}
inline void ListEntitiesOverTimeRequest::clear_ids() {
  _internal_mutable_ids()->Clear();
}
inline std::string* ListEntitiesOverTimeRequest::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
  return _s;
}
inline const std::string& ListEntitiesOverTimeRequest::ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
  return _internal_ids(index);
}
inline std::string* ListEntitiesOverTimeRequest::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
  return _internal_mutable_ids()->Mutable(index);
}
inline void ListEntitiesOverTimeRequest::set_ids(int index, const std::string& value) {
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::set_ids(int index, std::string&& value) {
  _internal_mutable_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::set_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::set_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::set_ids(int index, absl::string_view value) {
  _internal_mutable_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::add_ids(const std::string& value) {
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::add_ids(std::string&& value) {
  _internal_mutable_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::add_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::add_ids(const char* value, std::size_t size) {
  _internal_mutable_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline void ListEntitiesOverTimeRequest::add_ids(absl::string_view value) {
  _internal_mutable_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListEntitiesOverTimeRequest::ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ListEntitiesOverTimeRequest::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.ids)
  return _internal_mutable_ids();
}
inline const std::string& ListEntitiesOverTimeRequest::_internal_ids(int index) const {
  return _internal_ids().Get(index);
}
inline std::string* ListEntitiesOverTimeRequest::_internal_add_ids() {
  return _internal_mutable_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListEntitiesOverTimeRequest::_internal_ids() const {
  return _impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListEntitiesOverTimeRequest::_internal_mutable_ids() {
  return &_impl_.ids_;
}

// optional bool diff = 6 [json_name = "diff"];
inline bool ListEntitiesOverTimeRequest::has_diff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ListEntitiesOverTimeRequest::clear_diff() {
  _impl_.diff_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ListEntitiesOverTimeRequest::diff() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.diff)
  return _internal_diff();
}
inline void ListEntitiesOverTimeRequest::set_diff(bool value) {
  _internal_set_diff(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeRequest.diff)
}
inline bool ListEntitiesOverTimeRequest::_internal_diff() const {
  return _impl_.diff_;
}
inline void ListEntitiesOverTimeRequest::_internal_set_diff(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.diff_ = value;
}

// -------------------------------------------------------------------

// ListEntitiesOverTimeResponse

// repeated .aalyria.spacetime.api.nbi.v1alpha.Entity entities = 1 [json_name = "entities"];
inline int ListEntitiesOverTimeResponse::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int ListEntitiesOverTimeResponse::entities_size() const {
  return _internal_entities_size();
}
inline void ListEntitiesOverTimeResponse::clear_entities() {
  _internal_mutable_entities()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesOverTimeResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse.entities)
  return _internal_mutable_entities()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >*
ListEntitiesOverTimeResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse.entities)
  return _internal_mutable_entities();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& ListEntitiesOverTimeResponse::_internal_entities(int index) const {
  return _internal_entities().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::Entity& ListEntitiesOverTimeResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse.entities)
  return _internal_entities(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesOverTimeResponse::_internal_add_entities() {
  return _internal_mutable_entities()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::Entity* ListEntitiesOverTimeResponse::add_entities() {
  ::aalyria::spacetime::api::nbi::v1alpha::Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::Entity >&
ListEntitiesOverTimeResponse::entities() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.ListEntitiesOverTimeResponse.entities)
  return _internal_entities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>&
ListEntitiesOverTimeResponse::_internal_entities() const {
  return _impl_.entities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::Entity>*
ListEntitiesOverTimeResponse::_internal_mutable_entities() {
  return &_impl_.entities_;
}

// -------------------------------------------------------------------

// EntityFilter

// repeated string references_node = 1 [json_name = "referencesNode"];
inline int EntityFilter::_internal_references_node_size() const {
  return _impl_.references_node_.size();
}
inline int EntityFilter::references_node_size() const {
  return _internal_references_node_size();
}
inline void EntityFilter::clear_references_node() {
  _internal_mutable_references_node()->Clear();
}
inline std::string* EntityFilter::add_references_node() {
  std::string* _s = _internal_add_references_node();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
  return _s;
}
inline const std::string& EntityFilter::references_node(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
  return _internal_references_node(index);
}
inline std::string* EntityFilter::mutable_references_node(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
  return _internal_mutable_references_node()->Mutable(index);
}
inline void EntityFilter::set_references_node(int index, const std::string& value) {
  _internal_mutable_references_node()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::set_references_node(int index, std::string&& value) {
  _internal_mutable_references_node()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::set_references_node(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_references_node()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::set_references_node(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_references_node()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::set_references_node(int index, absl::string_view value) {
  _internal_mutable_references_node()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::add_references_node(const std::string& value) {
  _internal_mutable_references_node()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::add_references_node(std::string&& value) {
  _internal_mutable_references_node()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::add_references_node(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_references_node()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::add_references_node(const char* value, std::size_t size) {
  _internal_mutable_references_node()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline void EntityFilter::add_references_node(absl::string_view value) {
  _internal_mutable_references_node()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EntityFilter::references_node() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
  return _internal_references_node();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* EntityFilter::mutable_references_node() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_node)
  return _internal_mutable_references_node();
}
inline const std::string& EntityFilter::_internal_references_node(int index) const {
  return _internal_references_node().Get(index);
}
inline std::string* EntityFilter::_internal_add_references_node() {
  return _internal_mutable_references_node()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EntityFilter::_internal_references_node() const {
  return _impl_.references_node_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EntityFilter::_internal_mutable_references_node() {
  return &_impl_.references_node_;
}

// repeated string references_service_request = 2 [json_name = "referencesServiceRequest"];
inline int EntityFilter::_internal_references_service_request_size() const {
  return _impl_.references_service_request_.size();
}
inline int EntityFilter::references_service_request_size() const {
  return _internal_references_service_request_size();
}
inline void EntityFilter::clear_references_service_request() {
  _internal_mutable_references_service_request()->Clear();
}
inline std::string* EntityFilter::add_references_service_request() {
  std::string* _s = _internal_add_references_service_request();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
  return _s;
}
inline const std::string& EntityFilter::references_service_request(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
  return _internal_references_service_request(index);
}
inline std::string* EntityFilter::mutable_references_service_request(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
  return _internal_mutable_references_service_request()->Mutable(index);
}
inline void EntityFilter::set_references_service_request(int index, const std::string& value) {
  _internal_mutable_references_service_request()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::set_references_service_request(int index, std::string&& value) {
  _internal_mutable_references_service_request()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::set_references_service_request(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_references_service_request()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::set_references_service_request(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_references_service_request()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::set_references_service_request(int index, absl::string_view value) {
  _internal_mutable_references_service_request()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::add_references_service_request(const std::string& value) {
  _internal_mutable_references_service_request()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::add_references_service_request(std::string&& value) {
  _internal_mutable_references_service_request()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::add_references_service_request(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_references_service_request()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::add_references_service_request(const char* value, std::size_t size) {
  _internal_mutable_references_service_request()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline void EntityFilter::add_references_service_request(absl::string_view value) {
  _internal_mutable_references_service_request()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EntityFilter::references_service_request() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
  return _internal_references_service_request();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* EntityFilter::mutable_references_service_request() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.references_service_request)
  return _internal_mutable_references_service_request();
}
inline const std::string& EntityFilter::_internal_references_service_request(int index) const {
  return _internal_references_service_request().Get(index);
}
inline std::string* EntityFilter::_internal_add_references_service_request() {
  return _internal_mutable_references_service_request()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EntityFilter::_internal_references_service_request() const {
  return _impl_.references_service_request_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EntityFilter::_internal_mutable_references_service_request() {
  return &_impl_.references_service_request_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState include_intent_states = 3 [json_name = "includeIntentStates"];
inline int EntityFilter::_internal_include_intent_states_size() const {
  return _impl_.include_intent_states_.size();
}
inline int EntityFilter::include_intent_states_size() const {
  return _internal_include_intent_states_size();
}
inline void EntityFilter::clear_include_intent_states() {
  _internal_mutable_include_intent_states()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState EntityFilter::include_intent_states(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.include_intent_states)
  return _internal_include_intent_states(index);
}
inline void EntityFilter::set_include_intent_states(int index, ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState_IsValid(value));
  _internal_mutable_include_intent_states()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.include_intent_states)
}
inline void EntityFilter::add_include_intent_states(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value) {
  _internal_add_include_intent_states(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.include_intent_states)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& EntityFilter::include_intent_states() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.include_intent_states)
  return _internal_include_intent_states();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* EntityFilter::mutable_include_intent_states() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.EntityFilter.include_intent_states)
  return _internal_mutable_include_intent_states();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState EntityFilter::_internal_include_intent_states(int index) const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState>(_internal_include_intent_states().Get(index));
}
inline void EntityFilter::_internal_add_include_intent_states(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState_IsValid(value));
  _internal_mutable_include_intent_states()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& EntityFilter::_internal_include_intent_states() const {
  return _impl_.include_intent_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* EntityFilter::_internal_mutable_include_intent_states() {
  return &_impl_.include_intent_states_;
}

// -------------------------------------------------------------------

// DeleteEntityRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.EntityType type = 1 [json_name = "type"];
inline bool DeleteEntityRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeleteEntityRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType DeleteEntityRequest::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.type)
  return _internal_type();
}
inline void DeleteEntityRequest::set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::EntityType DeleteEntityRequest::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::EntityType>(_impl_.type_);
}
inline void DeleteEntityRequest::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::EntityType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::EntityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string id = 2 [json_name = "id"];
inline bool DeleteEntityRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeleteEntityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteEntityRequest::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteEntityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.id)
}
inline std::string* DeleteEntityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.id)
  return _s;
}
inline const std::string& DeleteEntityRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeleteEntityRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteEntityRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteEntityRequest::release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DeleteEntityRequest::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.id)
}

// optional int64 last_commit_timestamp = 3 [json_name = "lastCommitTimestamp"];
inline bool DeleteEntityRequest::has_last_commit_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DeleteEntityRequest::clear_last_commit_timestamp() {
  _impl_.last_commit_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t DeleteEntityRequest::last_commit_timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.last_commit_timestamp)
  return _internal_last_commit_timestamp();
}
inline void DeleteEntityRequest::set_last_commit_timestamp(::int64_t value) {
  _internal_set_last_commit_timestamp(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.last_commit_timestamp)
}
inline ::int64_t DeleteEntityRequest::_internal_last_commit_timestamp() const {
  return _impl_.last_commit_timestamp_;
}
inline void DeleteEntityRequest::_internal_set_last_commit_timestamp(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.last_commit_timestamp_ = value;
}

// optional bool ignore_consistency_check = 4 [json_name = "ignoreConsistencyCheck"];
inline bool DeleteEntityRequest::has_ignore_consistency_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DeleteEntityRequest::clear_ignore_consistency_check() {
  _impl_.ignore_consistency_check_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DeleteEntityRequest::ignore_consistency_check() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.ignore_consistency_check)
  return _internal_ignore_consistency_check();
}
inline void DeleteEntityRequest::set_ignore_consistency_check(bool value) {
  _internal_set_ignore_consistency_check(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.DeleteEntityRequest.ignore_consistency_check)
}
inline bool DeleteEntityRequest::_internal_ignore_consistency_check() const {
  return _impl_.ignore_consistency_check_;
}
inline void DeleteEntityRequest::_internal_set_ignore_consistency_check(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ignore_consistency_check_ = value;
}

// -------------------------------------------------------------------

// DeleteEntityResponse

// -------------------------------------------------------------------

// LoadScenarioRequest

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.ScenarioSettings scenario_settings = 1 [json_name = "scenarioSettings"];
inline bool LoadScenarioRequest::has_scenario_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scenario_settings_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings& LoadScenarioRequest::_internal_scenario_settings() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* p = _impl_.scenario_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_ScenarioSettings_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings& LoadScenarioRequest::scenario_settings() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest.scenario_settings)
  return _internal_scenario_settings();
}
inline void LoadScenarioRequest::unsafe_arena_set_allocated_scenario_settings(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* scenario_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scenario_settings_);
  }
  _impl_.scenario_settings_ = scenario_settings;
  if (scenario_settings) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest.scenario_settings)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* LoadScenarioRequest::release_scenario_settings() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* temp = _impl_.scenario_settings_;
  _impl_.scenario_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* LoadScenarioRequest::unsafe_arena_release_scenario_settings() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest.scenario_settings)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* temp = _impl_.scenario_settings_;
  _impl_.scenario_settings_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* LoadScenarioRequest::_internal_mutable_scenario_settings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scenario_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings>(GetArenaForAllocation());
    _impl_.scenario_settings_ = p;
  }
  return _impl_.scenario_settings_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* LoadScenarioRequest::mutable_scenario_settings() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* _msg = _internal_mutable_scenario_settings();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest.scenario_settings)
  return _msg;
}
inline void LoadScenarioRequest::set_allocated_scenario_settings(::aalyria::spacetime::api::nbi::v1alpha::resources::ScenarioSettings* scenario_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scenario_settings_);
  }
  if (scenario_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario_settings));
    if (message_arena != submessage_arena) {
      scenario_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario_settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scenario_settings_ = scenario_settings;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.LoadScenarioRequest.scenario_settings)
}

// -------------------------------------------------------------------

// LoadScenarioResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::EntityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::EntityType>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::EntityType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fnbi_2eproto_2epb_2eh
