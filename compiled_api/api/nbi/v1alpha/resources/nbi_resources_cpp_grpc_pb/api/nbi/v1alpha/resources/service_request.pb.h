// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/service_request.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/network.pb.h"
#include "api/common/time.pb.h"
#include "api/common/tunnel.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/type/interval.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class DrainProvision;
struct DrainProvisionDefaultTypeInternal;
extern DrainProvisionDefaultTypeInternal _DrainProvision_default_instance_;
class ServiceRequest;
struct ServiceRequestDefaultTypeInternal;
extern ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
class ServiceRequest_FlowRequirements;
struct ServiceRequest_FlowRequirementsDefaultTypeInternal;
extern ServiceRequest_FlowRequirementsDefaultTypeInternal _ServiceRequest_FlowRequirements_default_instance_;
class ServiceRequest_IntentAndIntervals;
struct ServiceRequest_IntentAndIntervalsDefaultTypeInternal;
extern ServiceRequest_IntentAndIntervalsDefaultTypeInternal _ServiceRequest_IntentAndIntervals_default_instance_;
class ServiceRequest_RedundancyGroup;
struct ServiceRequest_RedundancyGroupDefaultTypeInternal;
extern ServiceRequest_RedundancyGroupDefaultTypeInternal _ServiceRequest_RedundancyGroup_default_instance_;
class TunnelConfiguration;
struct TunnelConfigurationDefaultTypeInternal;
extern TunnelConfigurationDefaultTypeInternal _TunnelConfiguration_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
enum ServiceRequest_FlowType : int {
  ServiceRequest_FlowType_FLOW_TYPE_UNSPECIFIED = 0,
  ServiceRequest_FlowType_SDN_CONTROL_MANAGEMENT = 1,
  ServiceRequest_FlowType_SDN_FORWARDING = 2,
};

bool ServiceRequest_FlowType_IsValid(int value);
constexpr ServiceRequest_FlowType ServiceRequest_FlowType_FlowType_MIN = static_cast<ServiceRequest_FlowType>(0);
constexpr ServiceRequest_FlowType ServiceRequest_FlowType_FlowType_MAX = static_cast<ServiceRequest_FlowType>(2);
constexpr int ServiceRequest_FlowType_FlowType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ServiceRequest_FlowType_descriptor();
template <typename T>
const std::string& ServiceRequest_FlowType_Name(T value) {
  static_assert(std::is_same<T, ServiceRequest_FlowType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FlowType_Name().");
  return ServiceRequest_FlowType_Name(static_cast<ServiceRequest_FlowType>(value));
}
template <>
inline const std::string& ServiceRequest_FlowType_Name(ServiceRequest_FlowType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ServiceRequest_FlowType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ServiceRequest_FlowType_Parse(absl::string_view name, ServiceRequest_FlowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceRequest_FlowType>(
      ServiceRequest_FlowType_descriptor(), name, value);
}
enum DrainProvision_State : int {
  DrainProvision_State_STATE_UNSPECIFIED = 0,
  DrainProvision_State_PENDING = 1,
  DrainProvision_State_UNSATISFIED = 2,
  DrainProvision_State_ENACTING = 3,
  DrainProvision_State_ENACTED = 4,
  DrainProvision_State_DELETING = 5,
  DrainProvision_State_DELETED = 6,
};

bool DrainProvision_State_IsValid(int value);
constexpr DrainProvision_State DrainProvision_State_State_MIN = static_cast<DrainProvision_State>(0);
constexpr DrainProvision_State DrainProvision_State_State_MAX = static_cast<DrainProvision_State>(6);
constexpr int DrainProvision_State_State_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DrainProvision_State_descriptor();
template <typename T>
const std::string& DrainProvision_State_Name(T value) {
  static_assert(std::is_same<T, DrainProvision_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return DrainProvision_State_Name(static_cast<DrainProvision_State>(value));
}
template <>
inline const std::string& DrainProvision_State_Name(DrainProvision_State value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DrainProvision_State_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool DrainProvision_State_Parse(absl::string_view name, DrainProvision_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DrainProvision_State>(
      DrainProvision_State_descriptor(), name, value);
}
enum DrainProvision_Method : int {
  DrainProvision_Method_METHOD_UNSPECIFIED = 0,
  DrainProvision_Method_WAIT = 1,
  DrainProvision_Method_FORCE = 2,
};

bool DrainProvision_Method_IsValid(int value);
constexpr DrainProvision_Method DrainProvision_Method_Method_MIN = static_cast<DrainProvision_Method>(0);
constexpr DrainProvision_Method DrainProvision_Method_Method_MAX = static_cast<DrainProvision_Method>(2);
constexpr int DrainProvision_Method_Method_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DrainProvision_Method_descriptor();
template <typename T>
const std::string& DrainProvision_Method_Name(T value) {
  static_assert(std::is_same<T, DrainProvision_Method>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Method_Name().");
  return DrainProvision_Method_Name(static_cast<DrainProvision_Method>(value));
}
template <>
inline const std::string& DrainProvision_Method_Name(DrainProvision_Method value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DrainProvision_Method_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DrainProvision_Method_Parse(absl::string_view name, DrainProvision_Method* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DrainProvision_Method>(
      DrainProvision_Method_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TunnelConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration) */ {
 public:
  inline TunnelConfiguration() : TunnelConfiguration(nullptr) {}
  ~TunnelConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TunnelConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelConfiguration(const TunnelConfiguration& from);
  TunnelConfiguration(TunnelConfiguration&& from) noexcept
    : TunnelConfiguration() {
    *this = ::std::move(from);
  }

  inline TunnelConfiguration& operator=(const TunnelConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelConfiguration& operator=(TunnelConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelConfiguration* internal_default_instance() {
    return reinterpret_cast<const TunnelConfiguration*>(
               &_TunnelConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TunnelConfiguration& a, TunnelConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelConfiguration& from) {
    TunnelConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration";
  }
  protected:
  explicit TunnelConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcInterfaceIdFieldNumber = 1,
    kDstInterfaceIdFieldNumber = 2,
    kMethodFieldNumber = 3,
    kClassifierFieldNumber = 4,
  };
  // optional string src_interface_id = 1 [json_name = "srcInterfaceId"];
  bool has_src_interface_id() const;
  void clear_src_interface_id() ;
  const std::string& src_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_interface_id();
  PROTOBUF_NODISCARD std::string* release_src_interface_id();
  void set_allocated_src_interface_id(std::string* ptr);

  private:
  const std::string& _internal_src_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_interface_id(
      const std::string& value);
  std::string* _internal_mutable_src_interface_id();

  public:
  // optional string dst_interface_id = 2 [json_name = "dstInterfaceId"];
  bool has_dst_interface_id() const;
  void clear_dst_interface_id() ;
  const std::string& dst_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_interface_id();
  PROTOBUF_NODISCARD std::string* release_dst_interface_id();
  void set_allocated_dst_interface_id(std::string* ptr);

  private:
  const std::string& _internal_dst_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_interface_id(
      const std::string& value);
  std::string* _internal_mutable_dst_interface_id();

  public:
  // optional .aalyria.spacetime.api.common.TunnelMethod method = 3 [json_name = "method"];
  bool has_method() const;
  void clear_method() ;
  const ::aalyria::spacetime::api::common::TunnelMethod& method() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TunnelMethod* release_method();
  ::aalyria::spacetime::api::common::TunnelMethod* mutable_method();
  void set_allocated_method(::aalyria::spacetime::api::common::TunnelMethod* method);
  private:
  const ::aalyria::spacetime::api::common::TunnelMethod& _internal_method() const;
  ::aalyria::spacetime::api::common::TunnelMethod* _internal_mutable_method();
  public:
  void unsafe_arena_set_allocated_method(
      ::aalyria::spacetime::api::common::TunnelMethod* method);
  ::aalyria::spacetime::api::common::TunnelMethod* unsafe_arena_release_method();
  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 4 [json_name = "classifier"];
  bool has_classifier() const;
  void clear_classifier() ;
  const ::aalyria::spacetime::api::common::FlowClassifier& classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowClassifier* release_classifier();
  ::aalyria::spacetime::api::common::FlowClassifier* mutable_classifier();
  void set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier);
  private:
  const ::aalyria::spacetime::api::common::FlowClassifier& _internal_classifier() const;
  ::aalyria::spacetime::api::common::FlowClassifier* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::aalyria::spacetime::api::common::FlowClassifier* classifier);
  ::aalyria::spacetime::api::common::FlowClassifier* unsafe_arena_release_classifier();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_interface_id_;
    ::aalyria::spacetime::api::common::TunnelMethod* method_;
    ::aalyria::spacetime::api::common::FlowClassifier* classifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};// -------------------------------------------------------------------

class ServiceRequest_FlowRequirements final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements) */ {
 public:
  inline ServiceRequest_FlowRequirements() : ServiceRequest_FlowRequirements(nullptr) {}
  ~ServiceRequest_FlowRequirements() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceRequest_FlowRequirements(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRequest_FlowRequirements(const ServiceRequest_FlowRequirements& from);
  ServiceRequest_FlowRequirements(ServiceRequest_FlowRequirements&& from) noexcept
    : ServiceRequest_FlowRequirements() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_FlowRequirements& operator=(const ServiceRequest_FlowRequirements& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRequest_FlowRequirements& operator=(ServiceRequest_FlowRequirements&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceRequest_FlowRequirements& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceRequest_FlowRequirements* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_FlowRequirements*>(
               &_ServiceRequest_FlowRequirements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServiceRequest_FlowRequirements& a, ServiceRequest_FlowRequirements& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRequest_FlowRequirements* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRequest_FlowRequirements* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRequest_FlowRequirements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRequest_FlowRequirements>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceRequest_FlowRequirements& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceRequest_FlowRequirements& from) {
    ServiceRequest_FlowRequirements::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceRequest_FlowRequirements* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements";
  }
  protected:
  explicit ServiceRequest_FlowRequirements(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeIntervalFieldNumber = 1,
    kLatencyMaximumFieldNumber = 5,
    kBandwidthBpsMinimumFieldNumber = 2,
    kBandwidthBpsRequestedFieldNumber = 3,
    kIsDisruptionTolerantFieldNumber = 6,
  };
  // optional .aalyria.spacetime.api.common.TimeInterval time_interval = 1 [json_name = "timeInterval"];
  bool has_time_interval() const;
  void clear_time_interval() ;
  const ::aalyria::spacetime::api::common::TimeInterval& time_interval() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TimeInterval* release_time_interval();
  ::aalyria::spacetime::api::common::TimeInterval* mutable_time_interval();
  void set_allocated_time_interval(::aalyria::spacetime::api::common::TimeInterval* time_interval);
  private:
  const ::aalyria::spacetime::api::common::TimeInterval& _internal_time_interval() const;
  ::aalyria::spacetime::api::common::TimeInterval* _internal_mutable_time_interval();
  public:
  void unsafe_arena_set_allocated_time_interval(
      ::aalyria::spacetime::api::common::TimeInterval* time_interval);
  ::aalyria::spacetime::api::common::TimeInterval* unsafe_arena_release_time_interval();
  // optional .google.protobuf.Duration latency_maximum = 5 [json_name = "latencyMaximum"];
  bool has_latency_maximum() const;
  void clear_latency_maximum() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& latency_maximum() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_latency_maximum();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_latency_maximum();
  void set_allocated_latency_maximum(::PROTOBUF_NAMESPACE_ID::Duration* latency_maximum);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_latency_maximum() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_latency_maximum();
  public:
  void unsafe_arena_set_allocated_latency_maximum(
      ::PROTOBUF_NAMESPACE_ID::Duration* latency_maximum);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_latency_maximum();
  // optional double bandwidth_bps_minimum = 2 [json_name = "bandwidthBpsMinimum"];
  bool has_bandwidth_bps_minimum() const;
  void clear_bandwidth_bps_minimum() ;
  double bandwidth_bps_minimum() const;
  void set_bandwidth_bps_minimum(double value);

  private:
  double _internal_bandwidth_bps_minimum() const;
  void _internal_set_bandwidth_bps_minimum(double value);

  public:
  // optional double bandwidth_bps_requested = 3 [json_name = "bandwidthBpsRequested"];
  bool has_bandwidth_bps_requested() const;
  void clear_bandwidth_bps_requested() ;
  double bandwidth_bps_requested() const;
  void set_bandwidth_bps_requested(double value);

  private:
  double _internal_bandwidth_bps_requested() const;
  void _internal_set_bandwidth_bps_requested(double value);

  public:
  // optional bool is_disruption_tolerant = 6 [json_name = "isDisruptionTolerant"];
  bool has_is_disruption_tolerant() const;
  void clear_is_disruption_tolerant() ;
  bool is_disruption_tolerant() const;
  void set_is_disruption_tolerant(bool value);

  private:
  bool _internal_is_disruption_tolerant() const;
  void _internal_set_is_disruption_tolerant(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TimeInterval* time_interval_;
    ::PROTOBUF_NAMESPACE_ID::Duration* latency_maximum_;
    double bandwidth_bps_minimum_;
    double bandwidth_bps_requested_;
    bool is_disruption_tolerant_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};// -------------------------------------------------------------------

class ServiceRequest_RedundancyGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup) */ {
 public:
  inline ServiceRequest_RedundancyGroup() : ServiceRequest_RedundancyGroup(nullptr) {}
  ~ServiceRequest_RedundancyGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceRequest_RedundancyGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRequest_RedundancyGroup(const ServiceRequest_RedundancyGroup& from);
  ServiceRequest_RedundancyGroup(ServiceRequest_RedundancyGroup&& from) noexcept
    : ServiceRequest_RedundancyGroup() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_RedundancyGroup& operator=(const ServiceRequest_RedundancyGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRequest_RedundancyGroup& operator=(ServiceRequest_RedundancyGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceRequest_RedundancyGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceRequest_RedundancyGroup* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_RedundancyGroup*>(
               &_ServiceRequest_RedundancyGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServiceRequest_RedundancyGroup& a, ServiceRequest_RedundancyGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRequest_RedundancyGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRequest_RedundancyGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRequest_RedundancyGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRequest_RedundancyGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceRequest_RedundancyGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceRequest_RedundancyGroup& from) {
    ServiceRequest_RedundancyGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceRequest_RedundancyGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup";
  }
  protected:
  explicit ServiceRequest_RedundancyGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional string id = 1 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};// -------------------------------------------------------------------

class ServiceRequest_IntentAndIntervals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals) */ {
 public:
  inline ServiceRequest_IntentAndIntervals() : ServiceRequest_IntentAndIntervals(nullptr) {}
  ~ServiceRequest_IntentAndIntervals() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceRequest_IntentAndIntervals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRequest_IntentAndIntervals(const ServiceRequest_IntentAndIntervals& from);
  ServiceRequest_IntentAndIntervals(ServiceRequest_IntentAndIntervals&& from) noexcept
    : ServiceRequest_IntentAndIntervals() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_IntentAndIntervals& operator=(const ServiceRequest_IntentAndIntervals& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRequest_IntentAndIntervals& operator=(ServiceRequest_IntentAndIntervals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceRequest_IntentAndIntervals& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceRequest_IntentAndIntervals* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_IntentAndIntervals*>(
               &_ServiceRequest_IntentAndIntervals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServiceRequest_IntentAndIntervals& a, ServiceRequest_IntentAndIntervals& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRequest_IntentAndIntervals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRequest_IntentAndIntervals* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRequest_IntentAndIntervals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRequest_IntentAndIntervals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceRequest_IntentAndIntervals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceRequest_IntentAndIntervals& from) {
    ServiceRequest_IntentAndIntervals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceRequest_IntentAndIntervals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals";
  }
  protected:
  explicit ServiceRequest_IntentAndIntervals(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 2,
    kIntentIdFieldNumber = 1,
  };
  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  int interval_size() const;
  private:
  int _internal_interval_size() const;

  public:
  void clear_interval() ;
  ::google::type::Interval* mutable_interval(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
      mutable_interval();
  private:
  const ::google::type::Interval& _internal_interval(int index) const;
  ::google::type::Interval* _internal_add_interval();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>& _internal_interval() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>* _internal_mutable_interval();
  public:
  const ::google::type::Interval& interval(int index) const;
  ::google::type::Interval* add_interval();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
      interval() const;
  // optional string intent_id = 1 [json_name = "intentId"];
  bool has_intent_id() const;
  void clear_intent_id() ;
  const std::string& intent_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_intent_id(Arg_&& arg, Args_... args);
  std::string* mutable_intent_id();
  PROTOBUF_NODISCARD std::string* release_intent_id();
  void set_allocated_intent_id(std::string* ptr);

  private:
  const std::string& _internal_intent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_intent_id(
      const std::string& value);
  std::string* _internal_mutable_intent_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval > interval_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr intent_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};// -------------------------------------------------------------------

class ServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest) */ {
 public:
  inline ServiceRequest() : ServiceRequest(nullptr) {}
  ~ServiceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRequest(const ServiceRequest& from);
  ServiceRequest(ServiceRequest&& from) noexcept
    : ServiceRequest() {
    *this = ::std::move(from);
  }

  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRequest& operator=(ServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  enum SrcTypeCase {
    kSrcNodeId = 2,
    kSrcDevicesInRegionId = 8,
    SRC_TYPE_NOT_SET = 0,
  };

  enum DstTypeCase {
    kDstNodeId = 16,
    kDstDevicesInRegionId = 18,
    DST_TYPE_NOT_SET = 0,
  };

  static inline const ServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest*>(
               &_ServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServiceRequest& a, ServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceRequest& from) {
    ServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest";
  }
  protected:
  explicit ServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServiceRequest_FlowRequirements FlowRequirements;
  typedef ServiceRequest_RedundancyGroup RedundancyGroup;
  typedef ServiceRequest_IntentAndIntervals IntentAndIntervals;

  using FlowType = ServiceRequest_FlowType;
  static constexpr FlowType FLOW_TYPE_UNSPECIFIED = ServiceRequest_FlowType_FLOW_TYPE_UNSPECIFIED;
  static constexpr FlowType SDN_CONTROL_MANAGEMENT = ServiceRequest_FlowType_SDN_CONTROL_MANAGEMENT;
  static constexpr FlowType SDN_FORWARDING = ServiceRequest_FlowType_SDN_FORWARDING;
  static inline bool FlowType_IsValid(int value) {
    return ServiceRequest_FlowType_IsValid(value);
  }
  static constexpr FlowType FlowType_MIN = ServiceRequest_FlowType_FlowType_MIN;
  static constexpr FlowType FlowType_MAX = ServiceRequest_FlowType_FlowType_MAX;
  static constexpr int FlowType_ARRAYSIZE = ServiceRequest_FlowType_FlowType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlowType_descriptor() {
    return ServiceRequest_FlowType_descriptor();
  }
  template <typename T>
  static inline const std::string& FlowType_Name(T value) {
    return ServiceRequest_FlowType_Name(value);
  }
  static inline bool FlowType_Parse(absl::string_view name, FlowType* value) {
    return ServiceRequest_FlowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequirementsFieldNumber = 4,
    kTunnelsFieldNumber = 10,
    kIntentDependenciesFieldNumber = 14,
    kProvisionedIntervalsFieldNumber = 15,
    kTypeFieldNumber = 13,
    kClassifierFieldNumber = 9,
    kRedundancyGroupFieldNumber = 12,
    kPriorityFieldNumber = 6,
    kIsProvisionedNowFieldNumber = 5,
    kFlowTypeFieldNumber = 11,
    kSrcNodeIdFieldNumber = 2,
    kSrcDevicesInRegionIdFieldNumber = 8,
    kDstNodeIdFieldNumber = 16,
    kDstDevicesInRegionIdFieldNumber = 18,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements requirements = 4 [json_name = "requirements"];
  int requirements_size() const;
  private:
  int _internal_requirements_size() const;

  public:
  void clear_requirements() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* mutable_requirements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >*
      mutable_requirements();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements& _internal_requirements(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* _internal_add_requirements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements>& _internal_requirements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements>* _internal_mutable_requirements();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements& requirements(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* add_requirements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >&
      requirements() const;
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration tunnels = 10 [json_name = "tunnels"];
  int tunnels_size() const;
  private:
  int _internal_tunnels_size() const;

  public:
  void clear_tunnels() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* mutable_tunnels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >*
      mutable_tunnels();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration& _internal_tunnels(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* _internal_add_tunnels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration>& _internal_tunnels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration>* _internal_mutable_tunnels();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration& tunnels(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* add_tunnels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >&
      tunnels() const;
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals intent_dependencies = 14 [json_name = "intentDependencies"];
  int intent_dependencies_size() const;
  private:
  int _internal_intent_dependencies_size() const;

  public:
  void clear_intent_dependencies() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* mutable_intent_dependencies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >*
      mutable_intent_dependencies();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals& _internal_intent_dependencies(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* _internal_add_intent_dependencies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals>& _internal_intent_dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals>* _internal_mutable_intent_dependencies();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals& intent_dependencies(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* add_intent_dependencies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >&
      intent_dependencies() const;
  // repeated .google.type.Interval provisioned_intervals = 15 [json_name = "provisionedIntervals"];
  int provisioned_intervals_size() const;
  private:
  int _internal_provisioned_intervals_size() const;

  public:
  void clear_provisioned_intervals() ;
  ::google::type::Interval* mutable_provisioned_intervals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
      mutable_provisioned_intervals();
  private:
  const ::google::type::Interval& _internal_provisioned_intervals(int index) const;
  ::google::type::Interval* _internal_add_provisioned_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>& _internal_provisioned_intervals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>* _internal_mutable_provisioned_intervals();
  public:
  const ::google::type::Interval& provisioned_intervals(int index) const;
  ::google::type::Interval* add_provisioned_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
      provisioned_intervals() const;
  // optional string type = 13 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 9 [json_name = "classifier"];
  bool has_classifier() const;
  void clear_classifier() ;
  const ::aalyria::spacetime::api::common::FlowClassifier& classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowClassifier* release_classifier();
  ::aalyria::spacetime::api::common::FlowClassifier* mutable_classifier();
  void set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier);
  private:
  const ::aalyria::spacetime::api::common::FlowClassifier& _internal_classifier() const;
  ::aalyria::spacetime::api::common::FlowClassifier* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::aalyria::spacetime::api::common::FlowClassifier* classifier);
  ::aalyria::spacetime::api::common::FlowClassifier* unsafe_arena_release_classifier();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup redundancy_group = 12 [json_name = "redundancyGroup"];
  bool has_redundancy_group() const;
  void clear_redundancy_group() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup& redundancy_group() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* release_redundancy_group();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* mutable_redundancy_group();
  void set_allocated_redundancy_group(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* redundancy_group);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup& _internal_redundancy_group() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* _internal_mutable_redundancy_group();
  public:
  void unsafe_arena_set_allocated_redundancy_group(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* redundancy_group);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* unsafe_arena_release_redundancy_group();
  // optional double priority = 6 [json_name = "priority"];
  bool has_priority() const;
  void clear_priority() ;
  double priority() const;
  void set_priority(double value);

  private:
  double _internal_priority() const;
  void _internal_set_priority(double value);

  public:
  // optional bool is_provisioned_now = 5 [json_name = "isProvisionedNow"];
  bool has_is_provisioned_now() const;
  void clear_is_provisioned_now() ;
  bool is_provisioned_now() const;
  void set_is_provisioned_now(bool value);

  private:
  bool _internal_is_provisioned_now() const;
  void _internal_set_is_provisioned_now(bool value);

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowType flow_type = 11 [json_name = "flowType"];
  bool has_flow_type() const;
  void clear_flow_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType flow_type() const;
  void set_flow_type(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType _internal_flow_type() const;
  void _internal_set_flow_type(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType value);

  public:
  // string src_node_id = 2 [json_name = "srcNodeId"];
  bool has_src_node_id() const;
  void clear_src_node_id() ;
  const std::string& src_node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* ptr);

  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(
      const std::string& value);
  std::string* _internal_mutable_src_node_id();

  public:
  // string src_devices_in_region_id = 8 [json_name = "srcDevicesInRegionId"];
  bool has_src_devices_in_region_id() const;
  void clear_src_devices_in_region_id() ;
  const std::string& src_devices_in_region_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_devices_in_region_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_devices_in_region_id();
  PROTOBUF_NODISCARD std::string* release_src_devices_in_region_id();
  void set_allocated_src_devices_in_region_id(std::string* ptr);

  private:
  const std::string& _internal_src_devices_in_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_devices_in_region_id(
      const std::string& value);
  std::string* _internal_mutable_src_devices_in_region_id();

  public:
  // string dst_node_id = 16 [json_name = "dstNodeId"];
  bool has_dst_node_id() const;
  void clear_dst_node_id() ;
  const std::string& dst_node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_node_id();
  PROTOBUF_NODISCARD std::string* release_dst_node_id();
  void set_allocated_dst_node_id(std::string* ptr);

  private:
  const std::string& _internal_dst_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_node_id(
      const std::string& value);
  std::string* _internal_mutable_dst_node_id();

  public:
  // string dst_devices_in_region_id = 18 [json_name = "dstDevicesInRegionId"];
  bool has_dst_devices_in_region_id() const;
  void clear_dst_devices_in_region_id() ;
  const std::string& dst_devices_in_region_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_devices_in_region_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_devices_in_region_id();
  PROTOBUF_NODISCARD std::string* release_dst_devices_in_region_id();
  void set_allocated_dst_devices_in_region_id(std::string* ptr);

  private:
  const std::string& _internal_dst_devices_in_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_devices_in_region_id(
      const std::string& value);
  std::string* _internal_mutable_dst_devices_in_region_id();

  public:
  void clear_src_type();
  SrcTypeCase src_type_case() const;
  void clear_dst_type();
  DstTypeCase dst_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
 private:
  class _Internal;
  void set_has_src_node_id();
  void set_has_src_devices_in_region_id();
  void set_has_dst_node_id();
  void set_has_dst_devices_in_region_id();

  inline bool has_src_type() const;
  inline void clear_has_src_type();

  inline bool has_dst_type() const;
  inline void clear_has_dst_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements > requirements_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration > tunnels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals > intent_dependencies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval > provisioned_intervals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::aalyria::spacetime::api::common::FlowClassifier* classifier_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* redundancy_group_;
    double priority_;
    bool is_provisioned_now_;
    int flow_type_;
    union SrcTypeUnion {
      constexpr SrcTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_devices_in_region_id_;
    } src_type_;
    union DstTypeUnion {
      constexpr DstTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_node_id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_devices_in_region_id_;
    } dst_type_;
    ::uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};// -------------------------------------------------------------------

class DrainProvision final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision) */ {
 public:
  inline DrainProvision() : DrainProvision(nullptr) {}
  ~DrainProvision() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DrainProvision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrainProvision(const DrainProvision& from);
  DrainProvision(DrainProvision&& from) noexcept
    : DrainProvision() {
    *this = ::std::move(from);
  }

  inline DrainProvision& operator=(const DrainProvision& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrainProvision& operator=(DrainProvision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrainProvision& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrainProvision* internal_default_instance() {
    return reinterpret_cast<const DrainProvision*>(
               &_DrainProvision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DrainProvision& a, DrainProvision& b) {
    a.Swap(&b);
  }
  inline void Swap(DrainProvision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrainProvision* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrainProvision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrainProvision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrainProvision& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrainProvision& from) {
    DrainProvision::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrainProvision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision";
  }
  protected:
  explicit DrainProvision(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using State = DrainProvision_State;
  static constexpr State STATE_UNSPECIFIED = DrainProvision_State_STATE_UNSPECIFIED;
  static constexpr State PENDING = DrainProvision_State_PENDING;
  static constexpr State UNSATISFIED = DrainProvision_State_UNSATISFIED;
  static constexpr State ENACTING = DrainProvision_State_ENACTING;
  static constexpr State ENACTED = DrainProvision_State_ENACTED;
  static constexpr State DELETING = DrainProvision_State_DELETING;
  static constexpr State DELETED = DrainProvision_State_DELETED;
  static inline bool State_IsValid(int value) {
    return DrainProvision_State_IsValid(value);
  }
  static constexpr State State_MIN = DrainProvision_State_State_MIN;
  static constexpr State State_MAX = DrainProvision_State_State_MAX;
  static constexpr int State_ARRAYSIZE = DrainProvision_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* State_descriptor() {
    return DrainProvision_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return DrainProvision_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return DrainProvision_State_Parse(name, value);
  }

  using Method = DrainProvision_Method;
  static constexpr Method METHOD_UNSPECIFIED = DrainProvision_Method_METHOD_UNSPECIFIED;
  static constexpr Method WAIT = DrainProvision_Method_WAIT;
  static constexpr Method FORCE = DrainProvision_Method_FORCE;
  static inline bool Method_IsValid(int value) {
    return DrainProvision_Method_IsValid(value);
  }
  static constexpr Method Method_MIN = DrainProvision_Method_Method_MIN;
  static constexpr Method Method_MAX = DrainProvision_Method_Method_MAX;
  static constexpr int Method_ARRAYSIZE = DrainProvision_Method_Method_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Method_descriptor() {
    return DrainProvision_Method_descriptor();
  }
  template <typename T>
  static inline const std::string& Method_Name(T value) {
    return DrainProvision_Method_Name(value);
  }
  static inline bool Method_Parse(absl::string_view name, Method* value) {
    return DrainProvision_Method_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kReasonFieldNumber = 2,
    kOpportunisticStartTimeFieldNumber = 4,
    kDeterStartTimeFieldNumber = 5,
    kForceTimeFieldNumber = 6,
    kCreateTimeFieldNumber = 9,
    kEnactingTimeFieldNumber = 10,
    kEnactedTimeFieldNumber = 11,
    kDeletingTimeFieldNumber = 12,
    kDeletedTimeFieldNumber = 13,
    kSolverSatisfactionTimeFieldNumber = 14,
    kStateFieldNumber = 3,
    kMethodFieldNumber = 7,
    kAllowControlManagementForNodeFieldNumber = 8,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional string reason = 2 [json_name = "reason"];
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* ptr);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // optional .google.protobuf.Timestamp opportunistic_start_time = 4 [json_name = "opportunisticStartTime"];
  bool has_opportunistic_start_time() const;
  void clear_opportunistic_start_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& opportunistic_start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_opportunistic_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_opportunistic_start_time();
  void set_allocated_opportunistic_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* opportunistic_start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_opportunistic_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_opportunistic_start_time();
  public:
  void unsafe_arena_set_allocated_opportunistic_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* opportunistic_start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_opportunistic_start_time();
  // optional .google.protobuf.Timestamp deter_start_time = 5 [json_name = "deterStartTime"];
  bool has_deter_start_time() const;
  void clear_deter_start_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deter_start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deter_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deter_start_time();
  void set_allocated_deter_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deter_start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deter_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deter_start_time();
  public:
  void unsafe_arena_set_allocated_deter_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deter_start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deter_start_time();
  // optional .google.protobuf.Timestamp force_time = 6 [json_name = "forceTime"];
  bool has_force_time() const;
  void clear_force_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& force_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_force_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_force_time();
  void set_allocated_force_time(::PROTOBUF_NAMESPACE_ID::Timestamp* force_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_force_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_force_time();
  public:
  void unsafe_arena_set_allocated_force_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* force_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_force_time();
  // optional .google.protobuf.Timestamp create_time = 9 [json_name = "createTime"];
  bool has_create_time() const;
  void clear_create_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();
  // optional .google.protobuf.Timestamp enacting_time = 10 [json_name = "enactingTime"];
  bool has_enacting_time() const;
  void clear_enacting_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& enacting_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_enacting_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_enacting_time();
  void set_allocated_enacting_time(::PROTOBUF_NAMESPACE_ID::Timestamp* enacting_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_enacting_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_enacting_time();
  public:
  void unsafe_arena_set_allocated_enacting_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* enacting_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_enacting_time();
  // optional .google.protobuf.Timestamp enacted_time = 11 [json_name = "enactedTime"];
  bool has_enacted_time() const;
  void clear_enacted_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& enacted_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_enacted_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_enacted_time();
  void set_allocated_enacted_time(::PROTOBUF_NAMESPACE_ID::Timestamp* enacted_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_enacted_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_enacted_time();
  public:
  void unsafe_arena_set_allocated_enacted_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* enacted_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_enacted_time();
  // optional .google.protobuf.Timestamp deleting_time = 12 [json_name = "deletingTime"];
  bool has_deleting_time() const;
  void clear_deleting_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleting_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleting_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleting_time();
  void set_allocated_deleting_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deleting_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleting_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleting_time();
  public:
  void unsafe_arena_set_allocated_deleting_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleting_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleting_time();
  // optional .google.protobuf.Timestamp deleted_time = 13 [json_name = "deletedTime"];
  bool has_deleted_time() const;
  void clear_deleted_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_time();
  void set_allocated_deleted_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_time();
  public:
  void unsafe_arena_set_allocated_deleted_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_time();
  // optional .google.protobuf.Timestamp solver_satisfaction_time = 14 [json_name = "solverSatisfactionTime"];
  bool has_solver_satisfaction_time() const;
  void clear_solver_satisfaction_time() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& solver_satisfaction_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_solver_satisfaction_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_solver_satisfaction_time();
  void set_allocated_solver_satisfaction_time(::PROTOBUF_NAMESPACE_ID::Timestamp* solver_satisfaction_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_solver_satisfaction_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_solver_satisfaction_time();
  public:
  void unsafe_arena_set_allocated_solver_satisfaction_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* solver_satisfaction_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_solver_satisfaction_time();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.State state = 3 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State state() const;
  void set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State _internal_state() const;
  void _internal_set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State value);

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.Method method = 7 [json_name = "method"];
  bool has_method() const;
  void clear_method() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method method() const;
  void set_method(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method _internal_method() const;
  void _internal_set_method(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method value);

  public:
  // optional bool allow_control_management_for_node = 8 [json_name = "allowControlManagementForNode"];
  bool has_allow_control_management_for_node() const;
  void clear_allow_control_management_for_node() ;
  bool allow_control_management_for_node() const;
  void set_allow_control_management_for_node(bool value);

  private:
  bool _internal_allow_control_management_for_node() const;
  void _internal_set_allow_control_management_for_node(bool value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* opportunistic_start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deter_start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* force_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* enacting_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* enacted_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleting_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* solver_satisfaction_time_;
    int state_;
    int method_;
    bool allow_control_management_for_node_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TunnelConfiguration

// optional string src_interface_id = 1 [json_name = "srcInterfaceId"];
inline bool TunnelConfiguration::has_src_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TunnelConfiguration::clear_src_interface_id() {
  _impl_.src_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TunnelConfiguration::src_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id)
  return _internal_src_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TunnelConfiguration::set_src_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id)
}
inline std::string* TunnelConfiguration::mutable_src_interface_id() {
  std::string* _s = _internal_mutable_src_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id)
  return _s;
}
inline const std::string& TunnelConfiguration::_internal_src_interface_id() const {
  return _impl_.src_interface_id_.Get();
}
inline void TunnelConfiguration::_internal_set_src_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.src_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelConfiguration::_internal_mutable_src_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TunnelConfiguration::release_src_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.src_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TunnelConfiguration::set_allocated_src_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_interface_id_.IsDefault()) {
          _impl_.src_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id)
}

// optional string dst_interface_id = 2 [json_name = "dstInterfaceId"];
inline bool TunnelConfiguration::has_dst_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TunnelConfiguration::clear_dst_interface_id() {
  _impl_.dst_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TunnelConfiguration::dst_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id)
  return _internal_dst_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TunnelConfiguration::set_dst_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dst_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id)
}
inline std::string* TunnelConfiguration::mutable_dst_interface_id() {
  std::string* _s = _internal_mutable_dst_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id)
  return _s;
}
inline const std::string& TunnelConfiguration::_internal_dst_interface_id() const {
  return _impl_.dst_interface_id_.Get();
}
inline void TunnelConfiguration::_internal_set_dst_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.dst_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelConfiguration::_internal_mutable_dst_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dst_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TunnelConfiguration::release_dst_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dst_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TunnelConfiguration::set_allocated_dst_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_interface_id_.IsDefault()) {
          _impl_.dst_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id)
}

// optional .aalyria.spacetime.api.common.TunnelMethod method = 3 [json_name = "method"];
inline bool TunnelConfiguration::has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.method_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TunnelMethod& TunnelConfiguration::_internal_method() const {
  const ::aalyria::spacetime::api::common::TunnelMethod* p = _impl_.method_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TunnelMethod&>(
      ::aalyria::spacetime::api::common::_TunnelMethod_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TunnelMethod& TunnelConfiguration::method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.method)
  return _internal_method();
}
inline void TunnelConfiguration::unsafe_arena_set_allocated_method(
    ::aalyria::spacetime::api::common::TunnelMethod* method) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_);
  }
  _impl_.method_ = method;
  if (method) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.method)
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelConfiguration::release_method() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::TunnelMethod* temp = _impl_.method_;
  _impl_.method_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelConfiguration::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.method)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::TunnelMethod* temp = _impl_.method_;
  _impl_.method_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelConfiguration::_internal_mutable_method() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.method_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TunnelMethod>(GetArenaForAllocation());
    _impl_.method_ = p;
  }
  return _impl_.method_;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelConfiguration::mutable_method() {
  ::aalyria::spacetime::api::common::TunnelMethod* _msg = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.method)
  return _msg;
}
inline void TunnelConfiguration::set_allocated_method(::aalyria::spacetime::api::common::TunnelMethod* method) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_);
  }
  if (method) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(method));
    if (message_arena != submessage_arena) {
      method = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.method_ = method;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.method)
}

// optional .aalyria.spacetime.api.common.FlowClassifier classifier = 4 [json_name = "classifier"];
inline bool TunnelConfiguration::has_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classifier_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& TunnelConfiguration::_internal_classifier() const {
  const ::aalyria::spacetime::api::common::FlowClassifier* p = _impl_.classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowClassifier&>(
      ::aalyria::spacetime::api::common::_FlowClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& TunnelConfiguration::classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.classifier)
  return _internal_classifier();
}
inline void TunnelConfiguration::unsafe_arena_set_allocated_classifier(
    ::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  _impl_.classifier_ = classifier;
  if (classifier) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.classifier)
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelConfiguration::release_classifier() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelConfiguration::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.classifier)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelConfiguration::_internal_mutable_classifier() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowClassifier>(GetArenaForAllocation());
    _impl_.classifier_ = p;
  }
  return _impl_.classifier_;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelConfiguration::mutable_classifier() {
  ::aalyria::spacetime::api::common::FlowClassifier* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.classifier)
  return _msg;
}
inline void TunnelConfiguration::set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier));
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.classifier)
}

// -------------------------------------------------------------------

// ServiceRequest_FlowRequirements

// optional .aalyria.spacetime.api.common.TimeInterval time_interval = 1 [json_name = "timeInterval"];
inline bool ServiceRequest_FlowRequirements::has_time_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_interval_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TimeInterval& ServiceRequest_FlowRequirements::_internal_time_interval() const {
  const ::aalyria::spacetime::api::common::TimeInterval* p = _impl_.time_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TimeInterval&>(
      ::aalyria::spacetime::api::common::_TimeInterval_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TimeInterval& ServiceRequest_FlowRequirements::time_interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.time_interval)
  return _internal_time_interval();
}
inline void ServiceRequest_FlowRequirements::unsafe_arena_set_allocated_time_interval(
    ::aalyria::spacetime::api::common::TimeInterval* time_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_interval_);
  }
  _impl_.time_interval_ = time_interval;
  if (time_interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.time_interval)
}
inline ::aalyria::spacetime::api::common::TimeInterval* ServiceRequest_FlowRequirements::release_time_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.time_interval_;
  _impl_.time_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ServiceRequest_FlowRequirements::unsafe_arena_release_time_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.time_interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.time_interval_;
  _impl_.time_interval_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ServiceRequest_FlowRequirements::_internal_mutable_time_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TimeInterval>(GetArenaForAllocation());
    _impl_.time_interval_ = p;
  }
  return _impl_.time_interval_;
}
inline ::aalyria::spacetime::api::common::TimeInterval* ServiceRequest_FlowRequirements::mutable_time_interval() {
  ::aalyria::spacetime::api::common::TimeInterval* _msg = _internal_mutable_time_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.time_interval)
  return _msg;
}
inline void ServiceRequest_FlowRequirements::set_allocated_time_interval(::aalyria::spacetime::api::common::TimeInterval* time_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_interval_);
  }
  if (time_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_interval));
    if (message_arena != submessage_arena) {
      time_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.time_interval_ = time_interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.time_interval)
}

// optional double bandwidth_bps_minimum = 2 [json_name = "bandwidthBpsMinimum"];
inline bool ServiceRequest_FlowRequirements::has_bandwidth_bps_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ServiceRequest_FlowRequirements::clear_bandwidth_bps_minimum() {
  _impl_.bandwidth_bps_minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ServiceRequest_FlowRequirements::bandwidth_bps_minimum() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.bandwidth_bps_minimum)
  return _internal_bandwidth_bps_minimum();
}
inline void ServiceRequest_FlowRequirements::set_bandwidth_bps_minimum(double value) {
  _internal_set_bandwidth_bps_minimum(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.bandwidth_bps_minimum)
}
inline double ServiceRequest_FlowRequirements::_internal_bandwidth_bps_minimum() const {
  return _impl_.bandwidth_bps_minimum_;
}
inline void ServiceRequest_FlowRequirements::_internal_set_bandwidth_bps_minimum(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bandwidth_bps_minimum_ = value;
}

// optional double bandwidth_bps_requested = 3 [json_name = "bandwidthBpsRequested"];
inline bool ServiceRequest_FlowRequirements::has_bandwidth_bps_requested() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServiceRequest_FlowRequirements::clear_bandwidth_bps_requested() {
  _impl_.bandwidth_bps_requested_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ServiceRequest_FlowRequirements::bandwidth_bps_requested() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.bandwidth_bps_requested)
  return _internal_bandwidth_bps_requested();
}
inline void ServiceRequest_FlowRequirements::set_bandwidth_bps_requested(double value) {
  _internal_set_bandwidth_bps_requested(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.bandwidth_bps_requested)
}
inline double ServiceRequest_FlowRequirements::_internal_bandwidth_bps_requested() const {
  return _impl_.bandwidth_bps_requested_;
}
inline void ServiceRequest_FlowRequirements::_internal_set_bandwidth_bps_requested(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bandwidth_bps_requested_ = value;
}

// optional .google.protobuf.Duration latency_maximum = 5 [json_name = "latencyMaximum"];
inline bool ServiceRequest_FlowRequirements::has_latency_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latency_maximum_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceRequest_FlowRequirements::_internal_latency_maximum() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.latency_maximum_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceRequest_FlowRequirements::latency_maximum() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.latency_maximum)
  return _internal_latency_maximum();
}
inline void ServiceRequest_FlowRequirements::unsafe_arena_set_allocated_latency_maximum(
    ::PROTOBUF_NAMESPACE_ID::Duration* latency_maximum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latency_maximum_);
  }
  _impl_.latency_maximum_ = latency_maximum;
  if (latency_maximum) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.latency_maximum)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceRequest_FlowRequirements::release_latency_maximum() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.latency_maximum_;
  _impl_.latency_maximum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceRequest_FlowRequirements::unsafe_arena_release_latency_maximum() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.latency_maximum)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.latency_maximum_;
  _impl_.latency_maximum_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceRequest_FlowRequirements::_internal_mutable_latency_maximum() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.latency_maximum_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.latency_maximum_ = p;
  }
  return _impl_.latency_maximum_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceRequest_FlowRequirements::mutable_latency_maximum() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_latency_maximum();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.latency_maximum)
  return _msg;
}
inline void ServiceRequest_FlowRequirements::set_allocated_latency_maximum(::PROTOBUF_NAMESPACE_ID::Duration* latency_maximum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latency_maximum_);
  }
  if (latency_maximum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_maximum));
    if (message_arena != submessage_arena) {
      latency_maximum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latency_maximum, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.latency_maximum_ = latency_maximum;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.latency_maximum)
}

// optional bool is_disruption_tolerant = 6 [json_name = "isDisruptionTolerant"];
inline bool ServiceRequest_FlowRequirements::has_is_disruption_tolerant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ServiceRequest_FlowRequirements::clear_is_disruption_tolerant() {
  _impl_.is_disruption_tolerant_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ServiceRequest_FlowRequirements::is_disruption_tolerant() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.is_disruption_tolerant)
  return _internal_is_disruption_tolerant();
}
inline void ServiceRequest_FlowRequirements::set_is_disruption_tolerant(bool value) {
  _internal_set_is_disruption_tolerant(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements.is_disruption_tolerant)
}
inline bool ServiceRequest_FlowRequirements::_internal_is_disruption_tolerant() const {
  return _impl_.is_disruption_tolerant_;
}
inline void ServiceRequest_FlowRequirements::_internal_set_is_disruption_tolerant(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_disruption_tolerant_ = value;
}

// -------------------------------------------------------------------

// ServiceRequest_RedundancyGroup

// optional string id = 1 [json_name = "id"];
inline bool ServiceRequest_RedundancyGroup::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServiceRequest_RedundancyGroup::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceRequest_RedundancyGroup::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest_RedundancyGroup::set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id)
}
inline std::string* ServiceRequest_RedundancyGroup::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id)
  return _s;
}
inline const std::string& ServiceRequest_RedundancyGroup::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ServiceRequest_RedundancyGroup::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest_RedundancyGroup::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest_RedundancyGroup::release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceRequest_RedundancyGroup::set_allocated_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id)
}

// -------------------------------------------------------------------

// ServiceRequest_IntentAndIntervals

// optional string intent_id = 1 [json_name = "intentId"];
inline bool ServiceRequest_IntentAndIntervals::has_intent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServiceRequest_IntentAndIntervals::clear_intent_id() {
  _impl_.intent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceRequest_IntentAndIntervals::intent_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id)
  return _internal_intent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest_IntentAndIntervals::set_intent_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.intent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id)
}
inline std::string* ServiceRequest_IntentAndIntervals::mutable_intent_id() {
  std::string* _s = _internal_mutable_intent_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id)
  return _s;
}
inline const std::string& ServiceRequest_IntentAndIntervals::_internal_intent_id() const {
  return _impl_.intent_id_.Get();
}
inline void ServiceRequest_IntentAndIntervals::_internal_set_intent_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.intent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest_IntentAndIntervals::_internal_mutable_intent_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.intent_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest_IntentAndIntervals::release_intent_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.intent_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.intent_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceRequest_IntentAndIntervals::set_allocated_intent_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.intent_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.intent_id_.IsDefault()) {
          _impl_.intent_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id)
}

// repeated .google.type.Interval interval = 2 [json_name = "interval"];
inline int ServiceRequest_IntentAndIntervals::_internal_interval_size() const {
  return _impl_.interval_.size();
}
inline int ServiceRequest_IntentAndIntervals::interval_size() const {
  return _internal_interval_size();
}
inline ::google::type::Interval* ServiceRequest_IntentAndIntervals::mutable_interval(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.interval)
  return _internal_mutable_interval()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
ServiceRequest_IntentAndIntervals::mutable_interval() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.interval)
  return _internal_mutable_interval();
}
inline const ::google::type::Interval& ServiceRequest_IntentAndIntervals::_internal_interval(int index) const {
  return _internal_interval().Get(index);
}
inline const ::google::type::Interval& ServiceRequest_IntentAndIntervals::interval(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.interval)
  return _internal_interval(index);
}
inline ::google::type::Interval* ServiceRequest_IntentAndIntervals::_internal_add_interval() {
  return _internal_mutable_interval()->Add();
}
inline ::google::type::Interval* ServiceRequest_IntentAndIntervals::add_interval() {
  ::google::type::Interval* _add = _internal_add_interval();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.interval)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
ServiceRequest_IntentAndIntervals::interval() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.interval)
  return _internal_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>&
ServiceRequest_IntentAndIntervals::_internal_interval() const {
  return _impl_.interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>*
ServiceRequest_IntentAndIntervals::_internal_mutable_interval() {
  return &_impl_.interval_;
}

// -------------------------------------------------------------------

// ServiceRequest

// optional string type = 13 [json_name = "type"];
inline bool ServiceRequest::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServiceRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceRequest::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest::set_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type)
}
inline std::string* ServiceRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type)
  return _s;
}
inline const std::string& ServiceRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ServiceRequest::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_type() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServiceRequest::set_allocated_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type)
}

// string src_node_id = 2 [json_name = "srcNodeId"];
inline bool ServiceRequest::has_src_node_id() const {
  return src_type_case() == kSrcNodeId;
}
inline void ServiceRequest::set_has_src_node_id() {
  _impl_._oneof_case_[0] = kSrcNodeId;
}
inline void ServiceRequest::clear_src_node_id() {
  if (src_type_case() == kSrcNodeId) {
    _impl_.src_type_.src_node_id_.Destroy();
    clear_has_src_type();
  }
}
inline const std::string& ServiceRequest::src_node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id)
  return _internal_src_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest::set_src_node_id(Arg_&& arg,
                                                     Args_... args) {
  if (src_type_case() != kSrcNodeId) {
    clear_src_type();

    set_has_src_node_id();
    _impl_.src_type_.src_node_id_.InitDefault();
  }
  _impl_.src_type_.src_node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id)
}
inline std::string* ServiceRequest::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id)
  return _s;
}
inline const std::string& ServiceRequest::_internal_src_node_id() const {
  if (src_type_case() != kSrcNodeId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.src_type_.src_node_id_.Get();
}
inline void ServiceRequest::_internal_set_src_node_id(const std::string& value) {
  if (src_type_case() != kSrcNodeId) {
    clear_src_type();

    set_has_src_node_id();
    _impl_.src_type_.src_node_id_.InitDefault();
  }


  _impl_.src_type_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_src_node_id() {
  if (src_type_case() != kSrcNodeId) {
    clear_src_type();

    set_has_src_node_id();
    _impl_.src_type_.src_node_id_.InitDefault();
  }
  return _impl_.src_type_.src_node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_src_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id)
  if (src_type_case() != kSrcNodeId) {
    return nullptr;
  }
  clear_has_src_type();
  return _impl_.src_type_.src_node_id_.Release();
}
inline void ServiceRequest::set_allocated_src_node_id(std::string* value) {
  if (has_src_type()) {
    clear_src_type();
  }
  if (value != nullptr) {
    set_has_src_node_id();
    _impl_.src_type_.src_node_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id)
}

// string src_devices_in_region_id = 8 [json_name = "srcDevicesInRegionId"];
inline bool ServiceRequest::has_src_devices_in_region_id() const {
  return src_type_case() == kSrcDevicesInRegionId;
}
inline void ServiceRequest::set_has_src_devices_in_region_id() {
  _impl_._oneof_case_[0] = kSrcDevicesInRegionId;
}
inline void ServiceRequest::clear_src_devices_in_region_id() {
  if (src_type_case() == kSrcDevicesInRegionId) {
    _impl_.src_type_.src_devices_in_region_id_.Destroy();
    clear_has_src_type();
  }
}
inline const std::string& ServiceRequest::src_devices_in_region_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id)
  return _internal_src_devices_in_region_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest::set_src_devices_in_region_id(Arg_&& arg,
                                                     Args_... args) {
  if (src_type_case() != kSrcDevicesInRegionId) {
    clear_src_type();

    set_has_src_devices_in_region_id();
    _impl_.src_type_.src_devices_in_region_id_.InitDefault();
  }
  _impl_.src_type_.src_devices_in_region_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id)
}
inline std::string* ServiceRequest::mutable_src_devices_in_region_id() {
  std::string* _s = _internal_mutable_src_devices_in_region_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id)
  return _s;
}
inline const std::string& ServiceRequest::_internal_src_devices_in_region_id() const {
  if (src_type_case() != kSrcDevicesInRegionId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.src_type_.src_devices_in_region_id_.Get();
}
inline void ServiceRequest::_internal_set_src_devices_in_region_id(const std::string& value) {
  if (src_type_case() != kSrcDevicesInRegionId) {
    clear_src_type();

    set_has_src_devices_in_region_id();
    _impl_.src_type_.src_devices_in_region_id_.InitDefault();
  }


  _impl_.src_type_.src_devices_in_region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_src_devices_in_region_id() {
  if (src_type_case() != kSrcDevicesInRegionId) {
    clear_src_type();

    set_has_src_devices_in_region_id();
    _impl_.src_type_.src_devices_in_region_id_.InitDefault();
  }
  return _impl_.src_type_.src_devices_in_region_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_src_devices_in_region_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id)
  if (src_type_case() != kSrcDevicesInRegionId) {
    return nullptr;
  }
  clear_has_src_type();
  return _impl_.src_type_.src_devices_in_region_id_.Release();
}
inline void ServiceRequest::set_allocated_src_devices_in_region_id(std::string* value) {
  if (has_src_type()) {
    clear_src_type();
  }
  if (value != nullptr) {
    set_has_src_devices_in_region_id();
    _impl_.src_type_.src_devices_in_region_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id)
}

// string dst_node_id = 16 [json_name = "dstNodeId"];
inline bool ServiceRequest::has_dst_node_id() const {
  return dst_type_case() == kDstNodeId;
}
inline void ServiceRequest::set_has_dst_node_id() {
  _impl_._oneof_case_[1] = kDstNodeId;
}
inline void ServiceRequest::clear_dst_node_id() {
  if (dst_type_case() == kDstNodeId) {
    _impl_.dst_type_.dst_node_id_.Destroy();
    clear_has_dst_type();
  }
}
inline const std::string& ServiceRequest::dst_node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id)
  return _internal_dst_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest::set_dst_node_id(Arg_&& arg,
                                                     Args_... args) {
  if (dst_type_case() != kDstNodeId) {
    clear_dst_type();

    set_has_dst_node_id();
    _impl_.dst_type_.dst_node_id_.InitDefault();
  }
  _impl_.dst_type_.dst_node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id)
}
inline std::string* ServiceRequest::mutable_dst_node_id() {
  std::string* _s = _internal_mutable_dst_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id)
  return _s;
}
inline const std::string& ServiceRequest::_internal_dst_node_id() const {
  if (dst_type_case() != kDstNodeId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.dst_type_.dst_node_id_.Get();
}
inline void ServiceRequest::_internal_set_dst_node_id(const std::string& value) {
  if (dst_type_case() != kDstNodeId) {
    clear_dst_type();

    set_has_dst_node_id();
    _impl_.dst_type_.dst_node_id_.InitDefault();
  }


  _impl_.dst_type_.dst_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_dst_node_id() {
  if (dst_type_case() != kDstNodeId) {
    clear_dst_type();

    set_has_dst_node_id();
    _impl_.dst_type_.dst_node_id_.InitDefault();
  }
  return _impl_.dst_type_.dst_node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_dst_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id)
  if (dst_type_case() != kDstNodeId) {
    return nullptr;
  }
  clear_has_dst_type();
  return _impl_.dst_type_.dst_node_id_.Release();
}
inline void ServiceRequest::set_allocated_dst_node_id(std::string* value) {
  if (has_dst_type()) {
    clear_dst_type();
  }
  if (value != nullptr) {
    set_has_dst_node_id();
    _impl_.dst_type_.dst_node_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id)
}

// string dst_devices_in_region_id = 18 [json_name = "dstDevicesInRegionId"];
inline bool ServiceRequest::has_dst_devices_in_region_id() const {
  return dst_type_case() == kDstDevicesInRegionId;
}
inline void ServiceRequest::set_has_dst_devices_in_region_id() {
  _impl_._oneof_case_[1] = kDstDevicesInRegionId;
}
inline void ServiceRequest::clear_dst_devices_in_region_id() {
  if (dst_type_case() == kDstDevicesInRegionId) {
    _impl_.dst_type_.dst_devices_in_region_id_.Destroy();
    clear_has_dst_type();
  }
}
inline const std::string& ServiceRequest::dst_devices_in_region_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id)
  return _internal_dst_devices_in_region_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServiceRequest::set_dst_devices_in_region_id(Arg_&& arg,
                                                     Args_... args) {
  if (dst_type_case() != kDstDevicesInRegionId) {
    clear_dst_type();

    set_has_dst_devices_in_region_id();
    _impl_.dst_type_.dst_devices_in_region_id_.InitDefault();
  }
  _impl_.dst_type_.dst_devices_in_region_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id)
}
inline std::string* ServiceRequest::mutable_dst_devices_in_region_id() {
  std::string* _s = _internal_mutable_dst_devices_in_region_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id)
  return _s;
}
inline const std::string& ServiceRequest::_internal_dst_devices_in_region_id() const {
  if (dst_type_case() != kDstDevicesInRegionId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.dst_type_.dst_devices_in_region_id_.Get();
}
inline void ServiceRequest::_internal_set_dst_devices_in_region_id(const std::string& value) {
  if (dst_type_case() != kDstDevicesInRegionId) {
    clear_dst_type();

    set_has_dst_devices_in_region_id();
    _impl_.dst_type_.dst_devices_in_region_id_.InitDefault();
  }


  _impl_.dst_type_.dst_devices_in_region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRequest::_internal_mutable_dst_devices_in_region_id() {
  if (dst_type_case() != kDstDevicesInRegionId) {
    clear_dst_type();

    set_has_dst_devices_in_region_id();
    _impl_.dst_type_.dst_devices_in_region_id_.InitDefault();
  }
  return _impl_.dst_type_.dst_devices_in_region_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ServiceRequest::release_dst_devices_in_region_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id)
  if (dst_type_case() != kDstDevicesInRegionId) {
    return nullptr;
  }
  clear_has_dst_type();
  return _impl_.dst_type_.dst_devices_in_region_id_.Release();
}
inline void ServiceRequest::set_allocated_dst_devices_in_region_id(std::string* value) {
  if (has_dst_type()) {
    clear_dst_type();
  }
  if (value != nullptr) {
    set_has_dst_devices_in_region_id();
    _impl_.dst_type_.dst_devices_in_region_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id)
}

// optional .aalyria.spacetime.api.common.FlowClassifier classifier = 9 [json_name = "classifier"];
inline bool ServiceRequest::has_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classifier_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& ServiceRequest::_internal_classifier() const {
  const ::aalyria::spacetime::api::common::FlowClassifier* p = _impl_.classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowClassifier&>(
      ::aalyria::spacetime::api::common::_FlowClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& ServiceRequest::classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.classifier)
  return _internal_classifier();
}
inline void ServiceRequest::unsafe_arena_set_allocated_classifier(
    ::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  _impl_.classifier_ = classifier;
  if (classifier) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.classifier)
}
inline ::aalyria::spacetime::api::common::FlowClassifier* ServiceRequest::release_classifier() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* ServiceRequest::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.classifier)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* ServiceRequest::_internal_mutable_classifier() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowClassifier>(GetArenaForAllocation());
    _impl_.classifier_ = p;
  }
  return _impl_.classifier_;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* ServiceRequest::mutable_classifier() {
  ::aalyria::spacetime::api::common::FlowClassifier* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.classifier)
  return _msg;
}
inline void ServiceRequest::set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier));
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.classifier)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration tunnels = 10 [json_name = "tunnels"];
inline int ServiceRequest::_internal_tunnels_size() const {
  return _impl_.tunnels_.size();
}
inline int ServiceRequest::tunnels_size() const {
  return _internal_tunnels_size();
}
inline void ServiceRequest::clear_tunnels() {
  _internal_mutable_tunnels()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* ServiceRequest::mutable_tunnels(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.tunnels)
  return _internal_mutable_tunnels()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >*
ServiceRequest::mutable_tunnels() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.tunnels)
  return _internal_mutable_tunnels();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration& ServiceRequest::_internal_tunnels(int index) const {
  return _internal_tunnels().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration& ServiceRequest::tunnels(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.tunnels)
  return _internal_tunnels(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* ServiceRequest::_internal_add_tunnels() {
  return _internal_mutable_tunnels()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* ServiceRequest::add_tunnels() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration* _add = _internal_add_tunnels();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.tunnels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >&
ServiceRequest::tunnels() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.tunnels)
  return _internal_tunnels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration>&
ServiceRequest::_internal_tunnels() const {
  return _impl_.tunnels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration>*
ServiceRequest::_internal_mutable_tunnels() {
  return &_impl_.tunnels_;
}

// optional double priority = 6 [json_name = "priority"];
inline bool ServiceRequest::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServiceRequest::clear_priority() {
  _impl_.priority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ServiceRequest::priority() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.priority)
  return _internal_priority();
}
inline void ServiceRequest::set_priority(double value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.priority)
}
inline double ServiceRequest::_internal_priority() const {
  return _impl_.priority_;
}
inline void ServiceRequest::_internal_set_priority(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.priority_ = value;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowType flow_type = 11 [json_name = "flowType"];
inline bool ServiceRequest::has_flow_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ServiceRequest::clear_flow_type() {
  _impl_.flow_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType ServiceRequest::flow_type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.flow_type)
  return _internal_flow_type();
}
inline void ServiceRequest::set_flow_type(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType value) {
   _internal_set_flow_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.flow_type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType ServiceRequest::_internal_flow_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType>(_impl_.flow_type_);
}
inline void ServiceRequest::_internal_set_flow_type(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.flow_type_ = value;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements requirements = 4 [json_name = "requirements"];
inline int ServiceRequest::_internal_requirements_size() const {
  return _impl_.requirements_.size();
}
inline int ServiceRequest::requirements_size() const {
  return _internal_requirements_size();
}
inline void ServiceRequest::clear_requirements() {
  _internal_mutable_requirements()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* ServiceRequest::mutable_requirements(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.requirements)
  return _internal_mutable_requirements()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >*
ServiceRequest::mutable_requirements() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.requirements)
  return _internal_mutable_requirements();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements& ServiceRequest::_internal_requirements(int index) const {
  return _internal_requirements().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements& ServiceRequest::requirements(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.requirements)
  return _internal_requirements(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* ServiceRequest::_internal_add_requirements() {
  return _internal_mutable_requirements()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* ServiceRequest::add_requirements() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements* _add = _internal_add_requirements();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.requirements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >&
ServiceRequest::requirements() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.requirements)
  return _internal_requirements();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements>&
ServiceRequest::_internal_requirements() const {
  return _impl_.requirements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements>*
ServiceRequest::_internal_mutable_requirements() {
  return &_impl_.requirements_;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup redundancy_group = 12 [json_name = "redundancyGroup"];
inline bool ServiceRequest::has_redundancy_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redundancy_group_ != nullptr);
  return value;
}
inline void ServiceRequest::clear_redundancy_group() {
  if (_impl_.redundancy_group_ != nullptr) _impl_.redundancy_group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup& ServiceRequest::_internal_redundancy_group() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* p = _impl_.redundancy_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_RedundancyGroup_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup& ServiceRequest::redundancy_group() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.redundancy_group)
  return _internal_redundancy_group();
}
inline void ServiceRequest::unsafe_arena_set_allocated_redundancy_group(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* redundancy_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redundancy_group_);
  }
  _impl_.redundancy_group_ = redundancy_group;
  if (redundancy_group) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.redundancy_group)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* ServiceRequest::release_redundancy_group() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* temp = _impl_.redundancy_group_;
  _impl_.redundancy_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* ServiceRequest::unsafe_arena_release_redundancy_group() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.redundancy_group)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* temp = _impl_.redundancy_group_;
  _impl_.redundancy_group_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* ServiceRequest::_internal_mutable_redundancy_group() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.redundancy_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup>(GetArenaForAllocation());
    _impl_.redundancy_group_ = p;
  }
  return _impl_.redundancy_group_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* ServiceRequest::mutable_redundancy_group() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* _msg = _internal_mutable_redundancy_group();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.redundancy_group)
  return _msg;
}
inline void ServiceRequest::set_allocated_redundancy_group(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup* redundancy_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.redundancy_group_;
  }
  if (redundancy_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(redundancy_group);
    if (message_arena != submessage_arena) {
      redundancy_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redundancy_group, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.redundancy_group_ = redundancy_group;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.redundancy_group)
}

// optional bool is_provisioned_now = 5 [json_name = "isProvisionedNow"];
inline bool ServiceRequest::has_is_provisioned_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ServiceRequest::clear_is_provisioned_now() {
  _impl_.is_provisioned_now_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ServiceRequest::is_provisioned_now() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.is_provisioned_now)
  return _internal_is_provisioned_now();
}
inline void ServiceRequest::set_is_provisioned_now(bool value) {
  _internal_set_is_provisioned_now(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.is_provisioned_now)
}
inline bool ServiceRequest::_internal_is_provisioned_now() const {
  return _impl_.is_provisioned_now_;
}
inline void ServiceRequest::_internal_set_is_provisioned_now(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_provisioned_now_ = value;
}

// repeated .google.type.Interval provisioned_intervals = 15 [json_name = "provisionedIntervals"];
inline int ServiceRequest::_internal_provisioned_intervals_size() const {
  return _impl_.provisioned_intervals_.size();
}
inline int ServiceRequest::provisioned_intervals_size() const {
  return _internal_provisioned_intervals_size();
}
inline ::google::type::Interval* ServiceRequest::mutable_provisioned_intervals(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.provisioned_intervals)
  return _internal_mutable_provisioned_intervals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
ServiceRequest::mutable_provisioned_intervals() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.provisioned_intervals)
  return _internal_mutable_provisioned_intervals();
}
inline const ::google::type::Interval& ServiceRequest::_internal_provisioned_intervals(int index) const {
  return _internal_provisioned_intervals().Get(index);
}
inline const ::google::type::Interval& ServiceRequest::provisioned_intervals(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.provisioned_intervals)
  return _internal_provisioned_intervals(index);
}
inline ::google::type::Interval* ServiceRequest::_internal_add_provisioned_intervals() {
  return _internal_mutable_provisioned_intervals()->Add();
}
inline ::google::type::Interval* ServiceRequest::add_provisioned_intervals() {
  ::google::type::Interval* _add = _internal_add_provisioned_intervals();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.provisioned_intervals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
ServiceRequest::provisioned_intervals() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.provisioned_intervals)
  return _internal_provisioned_intervals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>&
ServiceRequest::_internal_provisioned_intervals() const {
  return _impl_.provisioned_intervals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>*
ServiceRequest::_internal_mutable_provisioned_intervals() {
  return &_impl_.provisioned_intervals_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals intent_dependencies = 14 [json_name = "intentDependencies"];
inline int ServiceRequest::_internal_intent_dependencies_size() const {
  return _impl_.intent_dependencies_.size();
}
inline int ServiceRequest::intent_dependencies_size() const {
  return _internal_intent_dependencies_size();
}
inline void ServiceRequest::clear_intent_dependencies() {
  _internal_mutable_intent_dependencies()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* ServiceRequest::mutable_intent_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.intent_dependencies)
  return _internal_mutable_intent_dependencies()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >*
ServiceRequest::mutable_intent_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.intent_dependencies)
  return _internal_mutable_intent_dependencies();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals& ServiceRequest::_internal_intent_dependencies(int index) const {
  return _internal_intent_dependencies().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals& ServiceRequest::intent_dependencies(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.intent_dependencies)
  return _internal_intent_dependencies(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* ServiceRequest::_internal_add_intent_dependencies() {
  return _internal_mutable_intent_dependencies()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* ServiceRequest::add_intent_dependencies() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals* _add = _internal_add_intent_dependencies();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.intent_dependencies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >&
ServiceRequest::intent_dependencies() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.intent_dependencies)
  return _internal_intent_dependencies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals>&
ServiceRequest::_internal_intent_dependencies() const {
  return _impl_.intent_dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals>*
ServiceRequest::_internal_mutable_intent_dependencies() {
  return &_impl_.intent_dependencies_;
}

inline bool ServiceRequest::has_src_type() const {
  return src_type_case() != SRC_TYPE_NOT_SET;
}
inline void ServiceRequest::clear_has_src_type() {
  _impl_._oneof_case_[0] = SRC_TYPE_NOT_SET;
}
inline bool ServiceRequest::has_dst_type() const {
  return dst_type_case() != DST_TYPE_NOT_SET;
}
inline void ServiceRequest::clear_has_dst_type() {
  _impl_._oneof_case_[1] = DST_TYPE_NOT_SET;
}
inline ServiceRequest::SrcTypeCase ServiceRequest::src_type_case() const {
  return ServiceRequest::SrcTypeCase(_impl_._oneof_case_[0]);
}
inline ServiceRequest::DstTypeCase ServiceRequest::dst_type_case() const {
  return ServiceRequest::DstTypeCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// DrainProvision

// optional string node_id = 1 [json_name = "nodeId"];
inline bool DrainProvision::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DrainProvision::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DrainProvision::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DrainProvision::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id)
}
inline std::string* DrainProvision::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id)
  return _s;
}
inline const std::string& DrainProvision::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void DrainProvision::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DrainProvision::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DrainProvision::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DrainProvision::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id)
}

// optional string reason = 2 [json_name = "reason"];
inline bool DrainProvision::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DrainProvision::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DrainProvision::reason() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DrainProvision::set_reason(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason)
}
inline std::string* DrainProvision::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason)
  return _s;
}
inline const std::string& DrainProvision::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void DrainProvision::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DrainProvision::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reason_.Mutable( GetArenaForAllocation());
}
inline std::string* DrainProvision::release_reason() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DrainProvision::set_allocated_reason(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.State state = 3 [json_name = "state"];
inline bool DrainProvision::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void DrainProvision::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State DrainProvision::state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.state)
  return _internal_state();
}
inline void DrainProvision::set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.state)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State DrainProvision::_internal_state() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State>(_impl_.state_);
}
inline void DrainProvision::_internal_set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.state_ = value;
}

// optional .google.protobuf.Timestamp opportunistic_start_time = 4 [json_name = "opportunisticStartTime"];
inline bool DrainProvision::has_opportunistic_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opportunistic_start_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_opportunistic_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.opportunistic_start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::opportunistic_start_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.opportunistic_start_time)
  return _internal_opportunistic_start_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_opportunistic_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* opportunistic_start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opportunistic_start_time_);
  }
  _impl_.opportunistic_start_time_ = opportunistic_start_time;
  if (opportunistic_start_time) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.opportunistic_start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_opportunistic_start_time() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opportunistic_start_time_;
  _impl_.opportunistic_start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_opportunistic_start_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.opportunistic_start_time)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.opportunistic_start_time_;
  _impl_.opportunistic_start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_opportunistic_start_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.opportunistic_start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.opportunistic_start_time_ = p;
  }
  return _impl_.opportunistic_start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_opportunistic_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_opportunistic_start_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.opportunistic_start_time)
  return _msg;
}
inline void DrainProvision::set_allocated_opportunistic_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* opportunistic_start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opportunistic_start_time_);
  }
  if (opportunistic_start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opportunistic_start_time));
    if (message_arena != submessage_arena) {
      opportunistic_start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opportunistic_start_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.opportunistic_start_time_ = opportunistic_start_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.opportunistic_start_time)
}

// optional .google.protobuf.Timestamp deter_start_time = 5 [json_name = "deterStartTime"];
inline bool DrainProvision::has_deter_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deter_start_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_deter_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deter_start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::deter_start_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deter_start_time)
  return _internal_deter_start_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_deter_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deter_start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deter_start_time_);
  }
  _impl_.deter_start_time_ = deter_start_time;
  if (deter_start_time) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deter_start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_deter_start_time() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deter_start_time_;
  _impl_.deter_start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_deter_start_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deter_start_time)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deter_start_time_;
  _impl_.deter_start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_deter_start_time() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.deter_start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deter_start_time_ = p;
  }
  return _impl_.deter_start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_deter_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deter_start_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deter_start_time)
  return _msg;
}
inline void DrainProvision::set_allocated_deter_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deter_start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deter_start_time_);
  }
  if (deter_start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deter_start_time));
    if (message_arena != submessage_arena) {
      deter_start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deter_start_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.deter_start_time_ = deter_start_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deter_start_time)
}

// optional .google.protobuf.Timestamp force_time = 6 [json_name = "forceTime"];
inline bool DrainProvision::has_force_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.force_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_force_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.force_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::force_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.force_time)
  return _internal_force_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_force_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* force_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.force_time_);
  }
  _impl_.force_time_ = force_time;
  if (force_time) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.force_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_force_time() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.force_time_;
  _impl_.force_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_force_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.force_time)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.force_time_;
  _impl_.force_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_force_time() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.force_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.force_time_ = p;
  }
  return _impl_.force_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_force_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_force_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.force_time)
  return _msg;
}
inline void DrainProvision::set_allocated_force_time(::PROTOBUF_NAMESPACE_ID::Timestamp* force_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.force_time_);
  }
  if (force_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(force_time));
    if (message_arena != submessage_arena) {
      force_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.force_time_ = force_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.force_time)
}

// optional bool allow_control_management_for_node = 8 [json_name = "allowControlManagementForNode"];
inline bool DrainProvision::has_allow_control_management_for_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void DrainProvision::clear_allow_control_management_for_node() {
  _impl_.allow_control_management_for_node_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool DrainProvision::allow_control_management_for_node() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.allow_control_management_for_node)
  return _internal_allow_control_management_for_node();
}
inline void DrainProvision::set_allow_control_management_for_node(bool value) {
  _internal_set_allow_control_management_for_node(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.allow_control_management_for_node)
}
inline bool DrainProvision::_internal_allow_control_management_for_node() const {
  return _impl_.allow_control_management_for_node_;
}
inline void DrainProvision::_internal_set_allow_control_management_for_node(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.allow_control_management_for_node_ = value;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.Method method = 7 [json_name = "method"];
inline bool DrainProvision::has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void DrainProvision::clear_method() {
  _impl_.method_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method DrainProvision::method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.method)
  return _internal_method();
}
inline void DrainProvision::set_method(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method value) {
   _internal_set_method(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.method)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method DrainProvision::_internal_method() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method>(_impl_.method_);
}
inline void DrainProvision::_internal_set_method(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.method_ = value;
}

// optional .google.protobuf.Timestamp create_time = 9 [json_name = "createTime"];
inline bool DrainProvision::has_create_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.create_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::create_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.create_time)
  return _internal_create_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_create_time() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.create_time)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_create_time() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.create_time)
  return _msg;
}
inline void DrainProvision::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.create_time)
}

// optional .google.protobuf.Timestamp solver_satisfaction_time = 14 [json_name = "solverSatisfactionTime"];
inline bool DrainProvision::has_solver_satisfaction_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.solver_satisfaction_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_solver_satisfaction_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.solver_satisfaction_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::solver_satisfaction_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.solver_satisfaction_time)
  return _internal_solver_satisfaction_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_solver_satisfaction_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* solver_satisfaction_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solver_satisfaction_time_);
  }
  _impl_.solver_satisfaction_time_ = solver_satisfaction_time;
  if (solver_satisfaction_time) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.solver_satisfaction_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_solver_satisfaction_time() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.solver_satisfaction_time_;
  _impl_.solver_satisfaction_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_solver_satisfaction_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.solver_satisfaction_time)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.solver_satisfaction_time_;
  _impl_.solver_satisfaction_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_solver_satisfaction_time() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.solver_satisfaction_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.solver_satisfaction_time_ = p;
  }
  return _impl_.solver_satisfaction_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_solver_satisfaction_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_solver_satisfaction_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.solver_satisfaction_time)
  return _msg;
}
inline void DrainProvision::set_allocated_solver_satisfaction_time(::PROTOBUF_NAMESPACE_ID::Timestamp* solver_satisfaction_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.solver_satisfaction_time_);
  }
  if (solver_satisfaction_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(solver_satisfaction_time));
    if (message_arena != submessage_arena) {
      solver_satisfaction_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solver_satisfaction_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.solver_satisfaction_time_ = solver_satisfaction_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.solver_satisfaction_time)
}

// optional .google.protobuf.Timestamp enacting_time = 10 [json_name = "enactingTime"];
inline bool DrainProvision::has_enacting_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.enacting_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_enacting_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.enacting_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::enacting_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacting_time)
  return _internal_enacting_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_enacting_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* enacting_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enacting_time_);
  }
  _impl_.enacting_time_ = enacting_time;
  if (enacting_time) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacting_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_enacting_time() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.enacting_time_;
  _impl_.enacting_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_enacting_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacting_time)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.enacting_time_;
  _impl_.enacting_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_enacting_time() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.enacting_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.enacting_time_ = p;
  }
  return _impl_.enacting_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_enacting_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_enacting_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacting_time)
  return _msg;
}
inline void DrainProvision::set_allocated_enacting_time(::PROTOBUF_NAMESPACE_ID::Timestamp* enacting_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enacting_time_);
  }
  if (enacting_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enacting_time));
    if (message_arena != submessage_arena) {
      enacting_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enacting_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.enacting_time_ = enacting_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacting_time)
}

// optional .google.protobuf.Timestamp enacted_time = 11 [json_name = "enactedTime"];
inline bool DrainProvision::has_enacted_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.enacted_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_enacted_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.enacted_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::enacted_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacted_time)
  return _internal_enacted_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_enacted_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* enacted_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enacted_time_);
  }
  _impl_.enacted_time_ = enacted_time;
  if (enacted_time) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacted_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_enacted_time() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.enacted_time_;
  _impl_.enacted_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_enacted_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacted_time)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.enacted_time_;
  _impl_.enacted_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_enacted_time() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.enacted_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.enacted_time_ = p;
  }
  return _impl_.enacted_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_enacted_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_enacted_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacted_time)
  return _msg;
}
inline void DrainProvision::set_allocated_enacted_time(::PROTOBUF_NAMESPACE_ID::Timestamp* enacted_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enacted_time_);
  }
  if (enacted_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enacted_time));
    if (message_arena != submessage_arena) {
      enacted_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enacted_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.enacted_time_ = enacted_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.enacted_time)
}

// optional .google.protobuf.Timestamp deleting_time = 12 [json_name = "deletingTime"];
inline bool DrainProvision::has_deleting_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deleting_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_deleting_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleting_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::deleting_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleting_time)
  return _internal_deleting_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_deleting_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleting_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleting_time_);
  }
  _impl_.deleting_time_ = deleting_time;
  if (deleting_time) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleting_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_deleting_time() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleting_time_;
  _impl_.deleting_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_deleting_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleting_time)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleting_time_;
  _impl_.deleting_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_deleting_time() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.deleting_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleting_time_ = p;
  }
  return _impl_.deleting_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_deleting_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleting_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleting_time)
  return _msg;
}
inline void DrainProvision::set_allocated_deleting_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deleting_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleting_time_);
  }
  if (deleting_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleting_time));
    if (message_arena != submessage_arena) {
      deleting_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleting_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.deleting_time_ = deleting_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleting_time)
}

// optional .google.protobuf.Timestamp deleted_time = 13 [json_name = "deletedTime"];
inline bool DrainProvision::has_deleted_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deleted_time_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::_internal_deleted_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DrainProvision::deleted_time() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleted_time)
  return _internal_deleted_time();
}
inline void DrainProvision::unsafe_arena_set_allocated_deleted_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_time_);
  }
  _impl_.deleted_time_ = deleted_time;
  if (deleted_time) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleted_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::release_deleted_time() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_time_;
  _impl_.deleted_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::unsafe_arena_release_deleted_time() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleted_time)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_time_;
  _impl_.deleted_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::_internal_mutable_deleted_time() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.deleted_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_time_ = p;
  }
  return _impl_.deleted_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DrainProvision::mutable_deleted_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_time();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleted_time)
  return _msg;
}
inline void DrainProvision::set_allocated_deleted_time(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_time_);
  }
  if (deleted_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_time));
    if (message_arena != submessage_arena) {
      deleted_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.deleted_time_ = deleted_time;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.deleted_time)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_2epb_2eh
