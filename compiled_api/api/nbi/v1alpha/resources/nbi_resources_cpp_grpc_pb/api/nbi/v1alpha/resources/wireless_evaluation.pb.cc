// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/wireless_evaluation.proto

#include "api/nbi/v1alpha/resources/wireless_evaluation.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
template <typename>
PROTOBUF_CONSTEXPR TransceiverWithMotion::TransceiverWithMotion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.model_)*/nullptr
  , /*decltype(_impl_.motion_)*/nullptr} {}
struct TransceiverWithMotionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransceiverWithMotionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransceiverWithMotionDefaultTypeInternal() {}
  union {
    TransceiverWithMotion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransceiverWithMotionDefaultTypeInternal _TransceiverWithMotion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TransceiverProvider::TransceiverProvider(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TransceiverProviderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransceiverProviderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransceiverProviderDefaultTypeInternal() {}
  union {
    TransceiverProvider _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransceiverProviderDefaultTypeInternal _TransceiverProvider_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR NoAccessReason::NoAccessReason(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transceiver_link_end_)*/nullptr
  , /*decltype(_impl_.constraint_)*/ 1
} {}
struct NoAccessReasonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoAccessReasonDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoAccessReasonDefaultTypeInternal() {}
  union {
    NoAccessReason _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoAccessReasonDefaultTypeInternal _NoAccessReason_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AccessInterval::AccessInterval(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.no_access_reason_)*/{}
  , /*decltype(_impl_.propagation_over_time_)*/{}
  , /*decltype(_impl_.interval_)*/nullptr
  , /*decltype(_impl_.accessibility_)*/ 0
} {}
struct AccessIntervalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessIntervalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessIntervalDefaultTypeInternal() {}
  union {
    AccessInterval _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessIntervalDefaultTypeInternal _AccessInterval_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpatialPropagation::SpatialPropagation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.reception_)*/nullptr
  , /*decltype(_impl_.pointing_vector_)*/nullptr
  , /*decltype(_impl_.propagation_delay_)*/nullptr
  , /*decltype(_impl_.coverage_)*/nullptr
  , /*decltype(_impl_.range_m_)*/ 0
} {}
struct SpatialPropagationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpatialPropagationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpatialPropagationDefaultTypeInternal() {}
  union {
    SpatialPropagation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpatialPropagationDefaultTypeInternal _SpatialPropagation_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[5];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion, _impl_.model_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion, _impl_.motion_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider, _impl_.source_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason, _impl_.constraint_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason, _impl_.transceiver_link_end_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _impl_.interval_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _impl_.accessibility_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _impl_.no_access_reason_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval, _impl_.propagation_over_time_),
    0,
    1,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.reception_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.pointing_vector_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.range_m_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.propagation_delay_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation, _impl_.coverage_),
    0,
    1,
    2,
    5,
    3,
    4,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion)},
        { 12, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider)},
        { 23, 33, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason)},
        { 35, 47, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval)},
        { 51, 65, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TransceiverWithMotion_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TransceiverProvider_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_NoAccessReason_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_AccessInterval_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_SpatialPropagation_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n3api/nbi/v1alpha/resources/wireless_eva"
    "luation.proto\022+aalyria.spacetime.api.nbi"
    ".v1alpha.resources\032\034api/common/coordinat"
    "es.proto\032%api/common/wireless_transceive"
    "r.proto\032(api/nbi/v1alpha/resources/cover"
    "age.proto\032,api/nbi/v1alpha/resources/net"
    "work_link.proto\032\036google/protobuf/duratio"
    "n.proto\032\037google/protobuf/timestamp.proto"
    "\032\032google/type/interval.proto\"\233\001\n\025Transce"
    "iverWithMotion\022D\n\005model\030\001 \001(\0132..aalyria."
    "spacetime.api.common.TransceiverModelR\005m"
    "odel\022<\n\006motion\030\002 \001(\0132$.aalyria.spacetime"
    ".api.common.MotionR\006motion\"\331\001\n\023Transceiv"
    "erProvider\022R\n\013id_in_store\030\001 \001(\01320.aalyri"
    "a.spacetime.api.common.TransceiverModelI"
    "dH\000R\tidInStore\022d\n\ndefinition\030\002 \001(\0132B.aal"
    "yria.spacetime.api.nbi.v1alpha.resources"
    ".TransceiverWithMotionH\000R\ndefinitionB\010\n\006"
    "source\"\306\003\n\016NoAccessReason\022f\n\nconstraint\030"
    "\001 \001(\0162F.aalyria.spacetime.api.nbi.v1alph"
    "a.resources.NoAccessReason.ConstraintR\nc"
    "onstraint\022b\n\024transceiver_link_end\030\002 \001(\0132"
    "0.aalyria.spacetime.api.common.Transceiv"
    "erModelIdR\022transceiverLinkEnd\"\347\001\n\nConstr"
    "aint\022\026\n\022UNKNOWN_CONSTRAINT\020\001\022\036\n\032SEPARATI"
    "ON_FROM_AZ_EL_MASK\020\002\022\016\n\nLINK_RANGE\020\003\022\033\n\027"
    "FIELD_OF_VIEW_OR_REGARD\020\004\022\021\n\rSUN_EXCLUSI"
    "ON\020\005\022\030\n\024PLATFORM_OBSTRUCTION\020\006\022\027\n\023TERRAI"
    "N_OBSTRUCTION\020\007\022\030\n\024RECEIVER_CNR_TOO_LOW\020"
    "\010\022\024\n\020NO_LINE_OF_SIGHT\020\t\"\201\003\n\016AccessInterv"
    "al\0221\n\010interval\030\001 \001(\0132\025.google.type.Inter"
    "valR\010interval\022`\n\raccessibility\030\002 \001(\0162:.a"
    "alyria.spacetime.api.nbi.v1alpha.resourc"
    "es.AccessibilityR\raccessibility\022e\n\020no_ac"
    "cess_reason\030\003 \003(\0132;.aalyria.spacetime.ap"
    "i.nbi.v1alpha.resources.NoAccessReasonR\016"
    "noAccessReason\022s\n\025propagation_over_time\030"
    "\004 \003(\0132\?.aalyria.spacetime.api.nbi.v1alph"
    "a.resources.SpatialPropagationR\023propagat"
    "ionOverTime\"\303\003\n\022SpatialPropagation\0228\n\tti"
    "mestamp\030\001 \001(\0132\032.google.protobuf.Timestam"
    "pR\ttimestamp\022]\n\treception\030\002 \001(\0132\?.aalyri"
    "a.spacetime.api.nbi.v1alpha.resources.Wi"
    "relessLinkBudgetR\treception\022U\n\017pointing_"
    "vector\030\003 \001(\0132,.aalyria.spacetime.api.com"
    "mon.PointingVectorR\016pointingVector\022\027\n\007ra"
    "nge_m\030\004 \001(\001R\006rangeM\022F\n\021propagation_delay"
    "\030\005 \001(\0132\031.google.protobuf.DurationR\020propa"
    "gationDelay\022\\\n\010coverage\030\006 \001(\0132@.aalyria."
    "spacetime.api.nbi.v1alpha.resources.Sign"
    "alPowerCoverageR\010coverageBb\n/com.aalyria"
    ".spacetime.api.nbi.v1alpha.resourcesZ/aa"
    "lyria.com/spacetime/api/nbi/v1alpha/reso"
    "urces"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_deps[7] =
    {
        &::descriptor_table_api_2fcommon_2fcoordinates_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_5ftransceiver_2eproto,
        &::descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
        &::descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto,
        &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_google_2ftype_2finterval_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto = {
    false,
    false,
    2125,
    descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto,
    "api/nbi/v1alpha/resources/wireless_evaluation.proto",
    &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_deps,
    7,
    5,
    schemas,
    file_default_instances,
    TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto::offsets,
    file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto,
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto,
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter() {
  return &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NoAccessReason_Constraint_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[0];
}
bool NoAccessReason_Constraint_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr NoAccessReason_Constraint NoAccessReason::UNKNOWN_CONSTRAINT;
constexpr NoAccessReason_Constraint NoAccessReason::SEPARATION_FROM_AZ_EL_MASK;
constexpr NoAccessReason_Constraint NoAccessReason::LINK_RANGE;
constexpr NoAccessReason_Constraint NoAccessReason::FIELD_OF_VIEW_OR_REGARD;
constexpr NoAccessReason_Constraint NoAccessReason::SUN_EXCLUSION;
constexpr NoAccessReason_Constraint NoAccessReason::PLATFORM_OBSTRUCTION;
constexpr NoAccessReason_Constraint NoAccessReason::TERRAIN_OBSTRUCTION;
constexpr NoAccessReason_Constraint NoAccessReason::RECEIVER_CNR_TOO_LOW;
constexpr NoAccessReason_Constraint NoAccessReason::NO_LINE_OF_SIGHT;
constexpr NoAccessReason_Constraint NoAccessReason::Constraint_MIN;
constexpr NoAccessReason_Constraint NoAccessReason::Constraint_MAX;
constexpr int NoAccessReason::Constraint_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class TransceiverWithMotion::_Internal {
 public:
  using HasBits = decltype(std::declval<TransceiverWithMotion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TransceiverWithMotion, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::TransceiverModel& model(const TransceiverWithMotion* msg);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::Motion& motion(const TransceiverWithMotion* msg);
  static void set_has_motion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::TransceiverModel&
TransceiverWithMotion::_Internal::model(const TransceiverWithMotion* msg) {
  return *msg->_impl_.model_;
}
const ::aalyria::spacetime::api::common::Motion&
TransceiverWithMotion::_Internal::motion(const TransceiverWithMotion* msg) {
  return *msg->_impl_.motion_;
}
void TransceiverWithMotion::clear_model() {
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TransceiverWithMotion::clear_motion() {
  if (_impl_.motion_ != nullptr) _impl_.motion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TransceiverWithMotion::TransceiverWithMotion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
}
TransceiverWithMotion::TransceiverWithMotion(const TransceiverWithMotion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransceiverWithMotion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.model_){nullptr}
    , decltype(_impl_.motion_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.model_ = new ::aalyria::spacetime::api::common::TransceiverModel(*from._impl_.model_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.motion_ = new ::aalyria::spacetime::api::common::Motion(*from._impl_.motion_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
}

inline void TransceiverWithMotion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.model_){nullptr}
    , decltype(_impl_.motion_){nullptr}
  };
}

TransceiverWithMotion::~TransceiverWithMotion() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransceiverWithMotion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.model_;
  if (this != internal_default_instance()) delete _impl_.motion_;
}

void TransceiverWithMotion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransceiverWithMotion::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.model_ != nullptr);
      _impl_.model_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.motion_ != nullptr);
      _impl_.motion_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransceiverWithMotion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.TransceiverModel model = 1 [json_name = "model"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.Motion motion = 2 [json_name = "motion"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_motion(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransceiverWithMotion::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.TransceiverModel model = 1 [json_name = "model"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.Motion motion = 2 [json_name = "motion"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::motion(this),
        _Internal::motion(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  return target;
}

::size_t TransceiverWithMotion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.TransceiverModel model = 1 [json_name = "model"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.model_);
    }

    // optional .aalyria.spacetime.api.common.Motion motion = 2 [json_name = "motion"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.motion_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransceiverWithMotion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransceiverWithMotion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransceiverWithMotion::GetClassData() const { return &_class_data_; }


void TransceiverWithMotion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransceiverWithMotion*>(&to_msg);
  auto& from = static_cast<const TransceiverWithMotion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_model()->::aalyria::spacetime::api::common::TransceiverModel::MergeFrom(
          from._internal_model());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_motion()->::aalyria::spacetime::api::common::Motion::MergeFrom(
          from._internal_motion());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransceiverWithMotion::CopyFrom(const TransceiverWithMotion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransceiverWithMotion::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.model_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.motion_->IsInitialized()) return false;
  }
  return true;
}

void TransceiverWithMotion::InternalSwap(TransceiverWithMotion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransceiverWithMotion, _impl_.motion_)
      + sizeof(TransceiverWithMotion::_impl_.motion_)
      - PROTOBUF_FIELD_OFFSET(TransceiverWithMotion, _impl_.model_)>(
          reinterpret_cast<char*>(&_impl_.model_),
          reinterpret_cast<char*>(&other->_impl_.model_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransceiverWithMotion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[0]);
}
// ===================================================================

class TransceiverProvider::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::TransceiverModelId& id_in_store(const TransceiverProvider* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion& definition(const TransceiverProvider* msg);
};

const ::aalyria::spacetime::api::common::TransceiverModelId&
TransceiverProvider::_Internal::id_in_store(const TransceiverProvider* msg) {
  return *msg->_impl_.source_.id_in_store_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion&
TransceiverProvider::_Internal::definition(const TransceiverProvider* msg) {
  return *msg->_impl_.source_.definition_;
}
void TransceiverProvider::set_allocated_id_in_store(::aalyria::spacetime::api::common::TransceiverModelId* id_in_store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source();
  if (id_in_store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_in_store));
    if (message_arena != submessage_arena) {
      id_in_store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id_in_store, submessage_arena);
    }
    set_has_id_in_store();
    _impl_.source_.id_in_store_ = id_in_store;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider.id_in_store)
}
void TransceiverProvider::clear_id_in_store() {
  if (source_case() == kIdInStore) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_.id_in_store_;
    }
    clear_has_source();
  }
}
void TransceiverProvider::set_allocated_definition(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion* definition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_source();
  if (definition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(definition);
    if (message_arena != submessage_arena) {
      definition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, definition, submessage_arena);
    }
    set_has_definition();
    _impl_.source_.definition_ = definition;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider.definition)
}
TransceiverProvider::TransceiverProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
}
TransceiverProvider::TransceiverProvider(const TransceiverProvider& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransceiverProvider* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_source();
  switch (from.source_case()) {
    case kIdInStore: {
      _this->_internal_mutable_id_in_store()->::aalyria::spacetime::api::common::TransceiverModelId::MergeFrom(
          from._internal_id_in_store());
      break;
    }
    case kDefinition: {
      _this->_internal_mutable_definition()->::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion::MergeFrom(
          from._internal_definition());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
}

inline void TransceiverProvider::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_source();
}

TransceiverProvider::~TransceiverProvider() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransceiverProvider::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_source()) {
    clear_source();
  }
}

void TransceiverProvider::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransceiverProvider::clear_source() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  switch (source_case()) {
    case kIdInStore: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_.id_in_store_;
      }
      break;
    }
    case kDefinition: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.source_.definition_;
      }
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}


void TransceiverProvider::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_source();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransceiverProvider::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.TransceiverModelId id_in_store = 1 [json_name = "idInStore"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id_in_store(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion definition = 2 [json_name = "definition"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_definition(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransceiverProvider::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (source_case()) {
    case kIdInStore: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::id_in_store(this),
          _Internal::id_in_store(this).GetCachedSize(), target, stream);
      break;
    }
    case kDefinition: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::definition(this),
          _Internal::definition(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  return target;
}

::size_t TransceiverProvider::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (source_case()) {
    // .aalyria.spacetime.api.common.TransceiverModelId id_in_store = 1 [json_name = "idInStore"];
    case kIdInStore: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_.id_in_store_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverWithMotion definition = 2 [json_name = "definition"];
    case kDefinition: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_.definition_);
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransceiverProvider::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransceiverProvider::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransceiverProvider::GetClassData() const { return &_class_data_; }


void TransceiverProvider::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransceiverProvider*>(&to_msg);
  auto& from = static_cast<const TransceiverProvider&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.source_case()) {
    case kIdInStore: {
      _this->_internal_mutable_id_in_store()->::aalyria::spacetime::api::common::TransceiverModelId::MergeFrom(
          from._internal_id_in_store());
      break;
    }
    case kDefinition: {
      _this->_internal_mutable_definition()->::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion::MergeFrom(
          from._internal_definition());
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransceiverProvider::CopyFrom(const TransceiverProvider& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverProvider)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransceiverProvider::IsInitialized() const {
  switch (source_case()) {
    case kIdInStore: {
      break;
    }
    case kDefinition: {
      if (source_case() == kDefinition) {
        if (!_impl_.source_.definition_->IsInitialized()) return false;
      }
      break;
    }
    case SOURCE_NOT_SET: {
      break;
    }
  }
  return true;
}

void TransceiverProvider::InternalSwap(TransceiverProvider* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.source_, other->_impl_.source_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransceiverProvider::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[1]);
}
// ===================================================================

class NoAccessReason::_Internal {
 public:
  using HasBits = decltype(std::declval<NoAccessReason>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NoAccessReason, _impl_._has_bits_);
  static void set_has_constraint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_link_end(const NoAccessReason* msg);
  static void set_has_transceiver_link_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::aalyria::spacetime::api::common::TransceiverModelId&
NoAccessReason::_Internal::transceiver_link_end(const NoAccessReason* msg) {
  return *msg->_impl_.transceiver_link_end_;
}
void NoAccessReason::clear_transceiver_link_end() {
  if (_impl_.transceiver_link_end_ != nullptr) _impl_.transceiver_link_end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
NoAccessReason::NoAccessReason(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
}
NoAccessReason::NoAccessReason(const NoAccessReason& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoAccessReason* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transceiver_link_end_){nullptr}
    , decltype(_impl_.constraint_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.transceiver_link_end_ = new ::aalyria::spacetime::api::common::TransceiverModelId(*from._impl_.transceiver_link_end_);
  }
  _this->_impl_.constraint_ = from._impl_.constraint_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
}

inline void NoAccessReason::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transceiver_link_end_){nullptr}
    , decltype(_impl_.constraint_) { 1 }

  };
}

NoAccessReason::~NoAccessReason() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoAccessReason::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.transceiver_link_end_;
}

void NoAccessReason::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoAccessReason::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.transceiver_link_end_ != nullptr);
      _impl_.transceiver_link_end_->Clear();
    }
    _impl_.constraint_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoAccessReason::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason.Constraint constraint = 1 [json_name = "constraint"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason_Constraint_IsValid(static_cast<int>(val)))) {
            _internal_set_constraint(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason_Constraint>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_link_end = 2 [json_name = "transceiverLinkEnd"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transceiver_link_end(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* NoAccessReason::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason.Constraint constraint = 1 [json_name = "constraint"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_constraint(), target);
  }

  // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_link_end = 2 [json_name = "transceiverLinkEnd"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transceiver_link_end(this),
        _Internal::transceiver_link_end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  return target;
}

::size_t NoAccessReason::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_link_end = 2 [json_name = "transceiverLinkEnd"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transceiver_link_end_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason.Constraint constraint = 1 [json_name = "constraint"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_constraint());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoAccessReason::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoAccessReason::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoAccessReason::GetClassData() const { return &_class_data_; }


void NoAccessReason::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoAccessReason*>(&to_msg);
  auto& from = static_cast<const NoAccessReason&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_transceiver_link_end()->::aalyria::spacetime::api::common::TransceiverModelId::MergeFrom(
          from._internal_transceiver_link_end());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.constraint_ = from._impl_.constraint_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoAccessReason::CopyFrom(const NoAccessReason& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoAccessReason::IsInitialized() const {
  return true;
}

void NoAccessReason::InternalSwap(NoAccessReason* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NoAccessReason, _impl_.constraint_)
      + sizeof(NoAccessReason::_impl_.constraint_)
      - PROTOBUF_FIELD_OFFSET(NoAccessReason, _impl_.transceiver_link_end_)>(
          reinterpret_cast<char*>(&_impl_.transceiver_link_end_),
          reinterpret_cast<char*>(&other->_impl_.transceiver_link_end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NoAccessReason::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[2]);
}
// ===================================================================

class AccessInterval::_Internal {
 public:
  using HasBits = decltype(std::declval<AccessInterval>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AccessInterval, _impl_._has_bits_);
  static const ::google::type::Interval& interval(const AccessInterval* msg);
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_accessibility(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::google::type::Interval&
AccessInterval::_Internal::interval(const AccessInterval* msg) {
  return *msg->_impl_.interval_;
}
void AccessInterval::clear_interval() {
  if (_impl_.interval_ != nullptr) _impl_.interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AccessInterval::AccessInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
}
AccessInterval::AccessInterval(const AccessInterval& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccessInterval* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.no_access_reason_){from._impl_.no_access_reason_}
    , decltype(_impl_.propagation_over_time_){from._impl_.propagation_over_time_}
    , decltype(_impl_.interval_){nullptr}
    , decltype(_impl_.accessibility_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.interval_ = new ::google::type::Interval(*from._impl_.interval_);
  }
  _this->_impl_.accessibility_ = from._impl_.accessibility_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
}

inline void AccessInterval::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.no_access_reason_){arena}
    , decltype(_impl_.propagation_over_time_){arena}
    , decltype(_impl_.interval_){nullptr}
    , decltype(_impl_.accessibility_) { 0 }

  };
}

AccessInterval::~AccessInterval() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccessInterval::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_no_access_reason()->~RepeatedPtrField();
  _internal_mutable_propagation_over_time()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.interval_;
}

void AccessInterval::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccessInterval::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_no_access_reason()->Clear();
  _internal_mutable_propagation_over_time()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.interval_ != nullptr);
    _impl_.interval_->Clear();
  }
  _impl_.accessibility_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccessInterval::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .google.type.Interval interval = 1 [json_name = "interval"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_interval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility_IsValid(static_cast<int>(val)))) {
            _internal_set_accessibility(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason no_access_reason = 3 [json_name = "noAccessReason"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_no_access_reason(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation propagation_over_time = 4 [json_name = "propagationOverTime"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_propagation_over_time(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccessInterval::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.type.Interval interval = 1 [json_name = "interval"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::interval(this),
        _Internal::interval(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_accessibility(), target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason no_access_reason = 3 [json_name = "noAccessReason"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_no_access_reason_size()); i < n; i++) {
    const auto& repfield = this->_internal_no_access_reason(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation propagation_over_time = 4 [json_name = "propagationOverTime"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_propagation_over_time_size()); i < n; i++) {
    const auto& repfield = this->_internal_propagation_over_time(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  return target;
}

::size_t AccessInterval::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NoAccessReason no_access_reason = 3 [json_name = "noAccessReason"];
  total_size += 1UL * this->_internal_no_access_reason_size();
  for (const auto& msg : this->_internal_no_access_reason()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation propagation_over_time = 4 [json_name = "propagationOverTime"];
  total_size += 1UL * this->_internal_propagation_over_time_size();
  for (const auto& msg : this->_internal_propagation_over_time()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.type.Interval interval = 1 [json_name = "interval"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.interval_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_accessibility());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccessInterval::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccessInterval::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccessInterval::GetClassData() const { return &_class_data_; }


void AccessInterval::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccessInterval*>(&to_msg);
  auto& from = static_cast<const AccessInterval&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_no_access_reason()->MergeFrom(from._internal_no_access_reason());
  _this->_internal_mutable_propagation_over_time()->MergeFrom(from._internal_propagation_over_time());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_interval()->::google::type::Interval::MergeFrom(
          from._internal_interval());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accessibility_ = from._impl_.accessibility_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccessInterval::CopyFrom(const AccessInterval& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.AccessInterval)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessInterval::IsInitialized() const {
  return true;
}

void AccessInterval::InternalSwap(AccessInterval* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_no_access_reason()->InternalSwap(other->_internal_mutable_no_access_reason());
  _internal_mutable_propagation_over_time()->InternalSwap(other->_internal_mutable_propagation_over_time());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccessInterval, _impl_.accessibility_)
      + sizeof(AccessInterval::_impl_.accessibility_)
      - PROTOBUF_FIELD_OFFSET(AccessInterval, _impl_.interval_)>(
          reinterpret_cast<char*>(&_impl_.interval_),
          reinterpret_cast<char*>(&other->_impl_.interval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccessInterval::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[3]);
}
// ===================================================================

class SpatialPropagation::_Internal {
 public:
  using HasBits = decltype(std::declval<SpatialPropagation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpatialPropagation, _impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const SpatialPropagation* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget& reception(const SpatialPropagation* msg);
  static void set_has_reception(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::PointingVector& pointing_vector(const SpatialPropagation* msg);
  static void set_has_pointing_vector(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_range_m(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& propagation_delay(const SpatialPropagation* msg);
  static void set_has_propagation_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage& coverage(const SpatialPropagation* msg);
  static void set_has_coverage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
SpatialPropagation::_Internal::timestamp(const SpatialPropagation* msg) {
  return *msg->_impl_.timestamp_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget&
SpatialPropagation::_Internal::reception(const SpatialPropagation* msg) {
  return *msg->_impl_.reception_;
}
const ::aalyria::spacetime::api::common::PointingVector&
SpatialPropagation::_Internal::pointing_vector(const SpatialPropagation* msg) {
  return *msg->_impl_.pointing_vector_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
SpatialPropagation::_Internal::propagation_delay(const SpatialPropagation* msg) {
  return *msg->_impl_.propagation_delay_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage&
SpatialPropagation::_Internal::coverage(const SpatialPropagation* msg) {
  return *msg->_impl_.coverage_;
}
void SpatialPropagation::clear_timestamp() {
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SpatialPropagation::clear_reception() {
  if (_impl_.reception_ != nullptr) _impl_.reception_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SpatialPropagation::clear_pointing_vector() {
  if (_impl_.pointing_vector_ != nullptr) _impl_.pointing_vector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void SpatialPropagation::clear_propagation_delay() {
  if (_impl_.propagation_delay_ != nullptr) _impl_.propagation_delay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void SpatialPropagation::clear_coverage() {
  if (_impl_.coverage_ != nullptr) _impl_.coverage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
SpatialPropagation::SpatialPropagation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
}
SpatialPropagation::SpatialPropagation(const SpatialPropagation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpatialPropagation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.reception_){nullptr}
    , decltype(_impl_.pointing_vector_){nullptr}
    , decltype(_impl_.propagation_delay_){nullptr}
    , decltype(_impl_.coverage_){nullptr}
    , decltype(_impl_.range_m_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.reception_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget(*from._impl_.reception_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.pointing_vector_ = new ::aalyria::spacetime::api::common::PointingVector(*from._impl_.pointing_vector_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.propagation_delay_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.propagation_delay_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.coverage_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage(*from._impl_.coverage_);
  }
  _this->_impl_.range_m_ = from._impl_.range_m_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
}

inline void SpatialPropagation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.reception_){nullptr}
    , decltype(_impl_.pointing_vector_){nullptr}
    , decltype(_impl_.propagation_delay_){nullptr}
    , decltype(_impl_.coverage_){nullptr}
    , decltype(_impl_.range_m_) { 0 }

  };
}

SpatialPropagation::~SpatialPropagation() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpatialPropagation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.reception_;
  if (this != internal_default_instance()) delete _impl_.pointing_vector_;
  if (this != internal_default_instance()) delete _impl_.propagation_delay_;
  if (this != internal_default_instance()) delete _impl_.coverage_;
}

void SpatialPropagation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpatialPropagation::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.reception_ != nullptr);
      _impl_.reception_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.pointing_vector_ != nullptr);
      _impl_.pointing_vector_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.propagation_delay_ != nullptr);
      _impl_.propagation_delay_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.coverage_ != nullptr);
      _impl_.coverage_->Clear();
    }
  }
  _impl_.range_m_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpatialPropagation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget reception = 2 [json_name = "reception"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reception(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 3 [json_name = "pointingVector"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pointing_vector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double range_m = 4 [json_name = "rangeM"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_range_m(&has_bits);
          _impl_.range_m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Duration propagation_delay = 5 [json_name = "propagationDelay"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_propagation_delay(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage coverage = 6 [json_name = "coverage"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_coverage(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpatialPropagation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget reception = 2 [json_name = "reception"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reception(this),
        _Internal::reception(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 3 [json_name = "pointingVector"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pointing_vector(this),
        _Internal::pointing_vector(this).GetCachedSize(), target, stream);
  }

  // optional double range_m = 4 [json_name = "rangeM"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_range_m(), target);
  }

  // optional .google.protobuf.Duration propagation_delay = 5 [json_name = "propagationDelay"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::propagation_delay(this),
        _Internal::propagation_delay(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage coverage = 6 [json_name = "coverage"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::coverage(this),
        _Internal::coverage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  return target;
}

::size_t SpatialPropagation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .google.protobuf.Timestamp timestamp = 1 [json_name = "timestamp"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget reception = 2 [json_name = "reception"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reception_);
    }

    // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 3 [json_name = "pointingVector"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pointing_vector_);
    }

    // optional .google.protobuf.Duration propagation_delay = 5 [json_name = "propagationDelay"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.propagation_delay_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage coverage = 6 [json_name = "coverage"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.coverage_);
    }

    // optional double range_m = 4 [json_name = "rangeM"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpatialPropagation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpatialPropagation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpatialPropagation::GetClassData() const { return &_class_data_; }


void SpatialPropagation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpatialPropagation*>(&to_msg);
  auto& from = static_cast<const SpatialPropagation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_reception()->::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget::MergeFrom(
          from._internal_reception());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_pointing_vector()->::aalyria::spacetime::api::common::PointingVector::MergeFrom(
          from._internal_pointing_vector());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_propagation_delay()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_propagation_delay());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_coverage()->::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage::MergeFrom(
          from._internal_coverage());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.range_m_ = from._impl_.range_m_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpatialPropagation::CopyFrom(const SpatialPropagation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SpatialPropagation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpatialPropagation::IsInitialized() const {
  return true;
}

void SpatialPropagation::InternalSwap(SpatialPropagation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpatialPropagation, _impl_.range_m_)
      + sizeof(SpatialPropagation::_impl_.range_m_)
      - PROTOBUF_FIELD_OFFSET(SpatialPropagation, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpatialPropagation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5fevaluation_2eproto[4]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverWithMotion >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverProvider >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::NoAccessReason >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::AccessInterval >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::SpatialPropagation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
