// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/intent.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/control.pb.h"
#include "api/common/network.pb.h"
#include "api/common/time.pb.h"
#include "api/common/tunnel.pb.h"
#include "api/nbi/v1alpha/resources/network_link.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/rpc/code.pb.h"
#include "google/type/interval.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class Intent;
struct IntentDefaultTypeInternal;
extern IntentDefaultTypeInternal _Intent_default_instance_;
class IntentFailure;
struct IntentFailureDefaultTypeInternal;
extern IntentFailureDefaultTypeInternal _IntentFailure_default_instance_;
class IntentWithdrawal;
struct IntentWithdrawalDefaultTypeInternal;
extern IntentWithdrawalDefaultTypeInternal _IntentWithdrawal_default_instance_;
class Intent_ServiceRequestAndIntervals;
struct Intent_ServiceRequestAndIntervalsDefaultTypeInternal;
extern Intent_ServiceRequestAndIntervalsDefaultTypeInternal _Intent_ServiceRequestAndIntervals_default_instance_;
class LinkIntent;
struct LinkIntentDefaultTypeInternal;
extern LinkIntentDefaultTypeInternal _LinkIntent_default_instance_;
class PathIntent;
struct PathIntentDefaultTypeInternal;
extern PathIntentDefaultTypeInternal _PathIntent_default_instance_;
class RadioIntent;
struct RadioIntentDefaultTypeInternal;
extern RadioIntentDefaultTypeInternal _RadioIntent_default_instance_;
class TunnelIntent;
struct TunnelIntentDefaultTypeInternal;
extern TunnelIntentDefaultTypeInternal _TunnelIntent_default_instance_;
class TunnelIntent_TunnelEndpoint;
struct TunnelIntent_TunnelEndpointDefaultTypeInternal;
extern TunnelIntent_TunnelEndpointDefaultTypeInternal _TunnelIntent_TunnelEndpoint_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::Intent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
enum IntentFailure_IntentFailureType : int {
  IntentFailure_IntentFailureType_UNKNOWN = 0,
  IntentFailure_IntentFailureType_COMPILATION_FAILURE = 1,
  IntentFailure_IntentFailureType_AGENT_INSTALLATION_FAILURE = 2,
  IntentFailure_IntentFailureType_UNREACHABLE_AGENT = 3,
  IntentFailure_IntentFailureType_UNEXPECTED_CDPI_STATE_CHANGE = 4,
  IntentFailure_IntentFailureType_PRECONDITION_FAILED = 5,
  IntentFailure_IntentFailureType_DEADLINE_EXCEEDED = 6,
  IntentFailure_IntentFailureType_PRECONDITION_EXPIRED = 7,
  IntentFailure_IntentFailureType_SDN_INTERNAL_ERROR = 9,
};

bool IntentFailure_IntentFailureType_IsValid(int value);
constexpr IntentFailure_IntentFailureType IntentFailure_IntentFailureType_IntentFailureType_MIN = static_cast<IntentFailure_IntentFailureType>(0);
constexpr IntentFailure_IntentFailureType IntentFailure_IntentFailureType_IntentFailureType_MAX = static_cast<IntentFailure_IntentFailureType>(9);
constexpr int IntentFailure_IntentFailureType_IntentFailureType_ARRAYSIZE = 9 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
IntentFailure_IntentFailureType_descriptor();
template <typename T>
const std::string& IntentFailure_IntentFailureType_Name(T value) {
  static_assert(std::is_same<T, IntentFailure_IntentFailureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IntentFailureType_Name().");
  return IntentFailure_IntentFailureType_Name(static_cast<IntentFailure_IntentFailureType>(value));
}
template <>
inline const std::string& IntentFailure_IntentFailureType_Name(IntentFailure_IntentFailureType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<IntentFailure_IntentFailureType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool IntentFailure_IntentFailureType_Parse(absl::string_view name, IntentFailure_IntentFailureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntentFailure_IntentFailureType>(
      IntentFailure_IntentFailureType_descriptor(), name, value);
}
enum IntentWithdrawal_WithdrawType : int {
  IntentWithdrawal_WithdrawType_UNKNOWN = 0,
  IntentWithdrawal_WithdrawType_INACCESSIBLE = 1,
  IntentWithdrawal_WithdrawType_NOT_REQUIRED = 2,
};

bool IntentWithdrawal_WithdrawType_IsValid(int value);
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal_WithdrawType_WithdrawType_MIN = static_cast<IntentWithdrawal_WithdrawType>(0);
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal_WithdrawType_WithdrawType_MAX = static_cast<IntentWithdrawal_WithdrawType>(2);
constexpr int IntentWithdrawal_WithdrawType_WithdrawType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
IntentWithdrawal_WithdrawType_descriptor();
template <typename T>
const std::string& IntentWithdrawal_WithdrawType_Name(T value) {
  static_assert(std::is_same<T, IntentWithdrawal_WithdrawType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WithdrawType_Name().");
  return IntentWithdrawal_WithdrawType_Name(static_cast<IntentWithdrawal_WithdrawType>(value));
}
template <>
inline const std::string& IntentWithdrawal_WithdrawType_Name(IntentWithdrawal_WithdrawType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<IntentWithdrawal_WithdrawType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool IntentWithdrawal_WithdrawType_Parse(absl::string_view name, IntentWithdrawal_WithdrawType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntentWithdrawal_WithdrawType>(
      IntentWithdrawal_WithdrawType_descriptor(), name, value);
}
enum IntentState : int {
  UNKNOWN = 0,
  INSTALL_REQ = 1,
  PUSHING = 9,
  SCHEDULED = 10,
  SCHEDULING = 12,
  MAYBE_INSTALLED = 11,
  INSTALLING = 3,
  INSTALLED = 4,
  WITHDRAW_REQ = 5,
  WITHDRAWING = 6,
  FAILED = 8,
};

bool IntentState_IsValid(int value);
constexpr IntentState IntentState_MIN = static_cast<IntentState>(0);
constexpr IntentState IntentState_MAX = static_cast<IntentState>(12);
constexpr int IntentState_ARRAYSIZE = 12 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
IntentState_descriptor();
template <typename T>
const std::string& IntentState_Name(T value) {
  static_assert(std::is_same<T, IntentState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IntentState_Name().");
  return IntentState_Name(static_cast<IntentState>(value));
}
template <>
inline const std::string& IntentState_Name(IntentState value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<IntentState_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool IntentState_Parse(absl::string_view name, IntentState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IntentState>(
      IntentState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Intent_ServiceRequestAndIntervals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals) */ {
 public:
  inline Intent_ServiceRequestAndIntervals() : Intent_ServiceRequestAndIntervals(nullptr) {}
  ~Intent_ServiceRequestAndIntervals() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Intent_ServiceRequestAndIntervals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Intent_ServiceRequestAndIntervals(const Intent_ServiceRequestAndIntervals& from);
  Intent_ServiceRequestAndIntervals(Intent_ServiceRequestAndIntervals&& from) noexcept
    : Intent_ServiceRequestAndIntervals() {
    *this = ::std::move(from);
  }

  inline Intent_ServiceRequestAndIntervals& operator=(const Intent_ServiceRequestAndIntervals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Intent_ServiceRequestAndIntervals& operator=(Intent_ServiceRequestAndIntervals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Intent_ServiceRequestAndIntervals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Intent_ServiceRequestAndIntervals* internal_default_instance() {
    return reinterpret_cast<const Intent_ServiceRequestAndIntervals*>(
               &_Intent_ServiceRequestAndIntervals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Intent_ServiceRequestAndIntervals& a, Intent_ServiceRequestAndIntervals& b) {
    a.Swap(&b);
  }
  inline void Swap(Intent_ServiceRequestAndIntervals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Intent_ServiceRequestAndIntervals* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Intent_ServiceRequestAndIntervals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Intent_ServiceRequestAndIntervals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Intent_ServiceRequestAndIntervals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Intent_ServiceRequestAndIntervals& from) {
    Intent_ServiceRequestAndIntervals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intent_ServiceRequestAndIntervals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals";
  }
  protected:
  explicit Intent_ServiceRequestAndIntervals(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 2,
    kServiceRequestIdFieldNumber = 1,
  };
  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  int interval_size() const;
  private:
  int _internal_interval_size() const;

  public:
  void clear_interval() ;
  ::google::type::Interval* mutable_interval(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
      mutable_interval();
  private:
  const ::google::type::Interval& _internal_interval(int index) const;
  ::google::type::Interval* _internal_add_interval();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>& _internal_interval() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>* _internal_mutable_interval();
  public:
  const ::google::type::Interval& interval(int index) const;
  ::google::type::Interval* add_interval();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
      interval() const;
  // optional string service_request_id = 1 [json_name = "serviceRequestId"];
  bool has_service_request_id() const;
  void clear_service_request_id() ;
  const std::string& service_request_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_service_request_id();
  PROTOBUF_NODISCARD std::string* release_service_request_id();
  void set_allocated_service_request_id(std::string* ptr);

  private:
  const std::string& _internal_service_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_request_id(
      const std::string& value);
  std::string* _internal_mutable_service_request_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval > interval_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_request_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class Intent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.Intent) */ {
 public:
  inline Intent() : Intent(nullptr) {}
  ~Intent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Intent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Intent(const Intent& from);
  Intent(Intent&& from) noexcept
    : Intent() {
    *this = ::std::move(from);
  }

  inline Intent& operator=(const Intent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Intent& operator=(Intent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Intent& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kLink = 4,
    kRadio = 5,
    kRoute = 6,
    kTunnel = 10,
    VALUE_NOT_SET = 0,
  };

  static inline const Intent* internal_default_instance() {
    return reinterpret_cast<const Intent*>(
               &_Intent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Intent& a, Intent& b) {
    a.Swap(&b);
  }
  inline void Swap(Intent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Intent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Intent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Intent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Intent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Intent& from) {
    Intent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.Intent";
  }
  protected:
  explicit Intent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Intent_ServiceRequestAndIntervals ServiceRequestAndIntervals;

  // accessors -------------------------------------------------------

  enum : int {
    kCompiledUpdatesFieldNumber = 8,
    kDependentServiceRequestsFieldNumber = 16,
    kCompiledWithdrawalUpdatesFieldNumber = 17,
    kAppIdFieldNumber = 1,
    kTimeToEnactFieldNumber = 3,
    kFailureFieldNumber = 9,
    kWithdrawalFieldNumber = 14,
    kTimeToWithdrawFieldNumber = 15,
    kRequestTimestampUsFieldNumber = 11,
    kAutoRetryFieldNumber = 12,
    kStateFieldNumber = 7,
    kLinkFieldNumber = 4,
    kRadioFieldNumber = 5,
    kRouteFieldNumber = 6,
    kTunnelFieldNumber = 10,
  };
  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_updates = 8 [json_name = "compiledUpdates"];
  int compiled_updates_size() const;
  private:
  int _internal_compiled_updates_size() const;

  public:
  void clear_compiled_updates() ;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* mutable_compiled_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >*
      mutable_compiled_updates();
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& _internal_compiled_updates(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _internal_add_compiled_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>& _internal_compiled_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>* _internal_mutable_compiled_updates();
  public:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& compiled_updates(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* add_compiled_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >&
      compiled_updates() const;
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals dependent_service_requests = 16 [json_name = "dependentServiceRequests"];
  int dependent_service_requests_size() const;
  private:
  int _internal_dependent_service_requests_size() const;

  public:
  void clear_dependent_service_requests() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* mutable_dependent_service_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >*
      mutable_dependent_service_requests();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals& _internal_dependent_service_requests(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* _internal_add_dependent_service_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals>& _internal_dependent_service_requests() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals>* _internal_mutable_dependent_service_requests();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals& dependent_service_requests(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* add_dependent_service_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >&
      dependent_service_requests() const;
  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_withdrawal_updates = 17 [json_name = "compiledWithdrawalUpdates"];
  int compiled_withdrawal_updates_size() const;
  private:
  int _internal_compiled_withdrawal_updates_size() const;

  public:
  void clear_compiled_withdrawal_updates() ;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* mutable_compiled_withdrawal_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >*
      mutable_compiled_withdrawal_updates();
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& _internal_compiled_withdrawal_updates(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _internal_add_compiled_withdrawal_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>& _internal_compiled_withdrawal_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>* _internal_mutable_compiled_withdrawal_updates();
  public:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& compiled_withdrawal_updates(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* add_compiled_withdrawal_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >&
      compiled_withdrawal_updates() const;
  // optional string app_id = 1 [json_name = "appId", deprecated = true];
  [[deprecated]]  bool has_app_id() const;
  [[deprecated]]  void clear_app_id() ;
  [[deprecated]] const std::string& app_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_app_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_app_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_app_id();
  [[deprecated]] void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
  bool has_time_to_enact() const;
  void clear_time_to_enact() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_to_enact() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_to_enact();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_to_enact();
  void set_allocated_time_to_enact(::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_to_enact() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_to_enact();
  public:
  void unsafe_arena_set_allocated_time_to_enact(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_to_enact();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure failure = 9 [json_name = "failure"];
  bool has_failure() const;
  void clear_failure() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& failure() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* release_failure();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* mutable_failure();
  void set_allocated_failure(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* failure);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& _internal_failure() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* _internal_mutable_failure();
  public:
  void unsafe_arena_set_allocated_failure(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* failure);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* unsafe_arena_release_failure();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal withdrawal = 14 [json_name = "withdrawal"];
  bool has_withdrawal() const;
  void clear_withdrawal() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal& withdrawal() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* release_withdrawal();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* mutable_withdrawal();
  void set_allocated_withdrawal(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* withdrawal);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal& _internal_withdrawal() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* _internal_mutable_withdrawal();
  public:
  void unsafe_arena_set_allocated_withdrawal(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* withdrawal);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* unsafe_arena_release_withdrawal();
  // optional .aalyria.spacetime.api.common.DateTime time_to_withdraw = 15 [json_name = "timeToWithdraw"];
  bool has_time_to_withdraw() const;
  void clear_time_to_withdraw() ;
  const ::aalyria::spacetime::api::common::DateTime& time_to_withdraw() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_time_to_withdraw();
  ::aalyria::spacetime::api::common::DateTime* mutable_time_to_withdraw();
  void set_allocated_time_to_withdraw(::aalyria::spacetime::api::common::DateTime* time_to_withdraw);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_time_to_withdraw() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_time_to_withdraw();
  public:
  void unsafe_arena_set_allocated_time_to_withdraw(
      ::aalyria::spacetime::api::common::DateTime* time_to_withdraw);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_time_to_withdraw();
  // optional int64 request_timestamp_us = 11 [json_name = "requestTimestampUs"];
  bool has_request_timestamp_us() const;
  void clear_request_timestamp_us() ;
  ::int64_t request_timestamp_us() const;
  void set_request_timestamp_us(::int64_t value);

  private:
  ::int64_t _internal_request_timestamp_us() const;
  void _internal_set_request_timestamp_us(::int64_t value);

  public:
  // optional bool auto_retry = 12 [json_name = "autoRetry"];
  bool has_auto_retry() const;
  void clear_auto_retry() ;
  bool auto_retry() const;
  void set_auto_retry(bool value);

  private:
  bool _internal_auto_retry() const;
  void _internal_set_auto_retry(bool value);

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState state = 7 [default = INSTALL_REQ, json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState state() const;
  void set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState _internal_state() const;
  void _internal_set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value);

  public:
  // .aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent link = 4 [json_name = "link"];
  bool has_link() const;
  private:
  bool _internal_has_link() const;

  public:
  void clear_link() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent& link() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* release_link();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* mutable_link();
  void set_allocated_link(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* link);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent& _internal_link() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* link);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* unsafe_arena_release_link();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent radio = 5 [json_name = "radio"];
  bool has_radio() const;
  private:
  bool _internal_has_radio() const;

  public:
  void clear_radio() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent& radio() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* release_radio();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* mutable_radio();
  void set_allocated_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* radio);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent& _internal_radio() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* _internal_mutable_radio();
  public:
  void unsafe_arena_set_allocated_radio(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* radio);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* unsafe_arena_release_radio();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent route = 6 [json_name = "route"];
  bool has_route() const;
  private:
  bool _internal_has_route() const;

  public:
  void clear_route() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent& route() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* release_route();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* mutable_route();
  void set_allocated_route(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* route);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent& _internal_route() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* route);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* unsafe_arena_release_route();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent tunnel = 10 [json_name = "tunnel"];
  bool has_tunnel() const;
  private:
  bool _internal_has_tunnel() const;

  public:
  void clear_tunnel() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent& tunnel() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* release_tunnel();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* mutable_tunnel();
  void set_allocated_tunnel(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* tunnel);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent& _internal_tunnel() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* _internal_mutable_tunnel();
  public:
  void unsafe_arena_set_allocated_tunnel(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* tunnel);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* unsafe_arena_release_tunnel();
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
 private:
  class _Internal;
  void set_has_link();
  void set_has_radio();
  void set_has_route();
  void set_has_tunnel();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate > compiled_updates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals > dependent_service_requests_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate > compiled_withdrawal_updates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* failure_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* withdrawal_;
    ::aalyria::spacetime::api::common::DateTime* time_to_withdraw_;
    ::int64_t request_timestamp_us_;
    bool auto_retry_;
    int state_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* link_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* radio_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* route_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* tunnel_;
    } value_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class LinkIntent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent) */ {
 public:
  inline LinkIntent() : LinkIntent(nullptr) {}
  ~LinkIntent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LinkIntent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkIntent(const LinkIntent& from);
  LinkIntent(LinkIntent&& from) noexcept
    : LinkIntent() {
    *this = ::std::move(from);
  }

  inline LinkIntent& operator=(const LinkIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkIntent& operator=(LinkIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkIntent& default_instance() {
    return *internal_default_instance();
  }
  enum LinkTypeCase {
    kDirectionalLink = 3,
    kBidirectionalLink = 2,
    LINK_TYPE_NOT_SET = 0,
  };

  static inline const LinkIntent* internal_default_instance() {
    return reinterpret_cast<const LinkIntent*>(
               &_LinkIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LinkIntent& a, LinkIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkIntent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkIntent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkIntent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkIntent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkIntent& from) {
    LinkIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkIntent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent";
  }
  protected:
  explicit LinkIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionalLinkFieldNumber = 3,
    kBidirectionalLinkFieldNumber = 2,
  };
  // .aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink directional_link = 3 [json_name = "directionalLink"];
  bool has_directional_link() const;
  private:
  bool _internal_has_directional_link() const;

  public:
  void clear_directional_link() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink& directional_link() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* release_directional_link();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* mutable_directional_link();
  void set_allocated_directional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* directional_link);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink& _internal_directional_link() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* _internal_mutable_directional_link();
  public:
  void unsafe_arena_set_allocated_directional_link(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* directional_link);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* unsafe_arena_release_directional_link();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink bidirectional_link = 2 [json_name = "bidirectionalLink"];
  bool has_bidirectional_link() const;
  private:
  bool _internal_has_bidirectional_link() const;

  public:
  void clear_bidirectional_link() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink& bidirectional_link() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* release_bidirectional_link();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* mutable_bidirectional_link();
  void set_allocated_bidirectional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* bidirectional_link);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink& _internal_bidirectional_link() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* _internal_mutable_bidirectional_link();
  public:
  void unsafe_arena_set_allocated_bidirectional_link(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* bidirectional_link);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* unsafe_arena_release_bidirectional_link();
  void clear_link_type();
  LinkTypeCase link_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
 private:
  class _Internal;
  void set_has_directional_link();
  void set_has_bidirectional_link();

  inline bool has_link_type() const;
  inline void clear_has_link_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LinkTypeUnion {
      constexpr LinkTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* directional_link_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* bidirectional_link_;
    } link_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class RadioIntent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent) */ {
 public:
  inline RadioIntent() : RadioIntent(nullptr) {}
  ~RadioIntent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioIntent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioIntent(const RadioIntent& from);
  RadioIntent(RadioIntent&& from) noexcept
    : RadioIntent() {
    *this = ::std::move(from);
  }

  inline RadioIntent& operator=(const RadioIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioIntent& operator=(RadioIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioIntent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioIntent* internal_default_instance() {
    return reinterpret_cast<const RadioIntent*>(
               &_RadioIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RadioIntent& a, RadioIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioIntent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioIntent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioIntent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioIntent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioIntent& from) {
    RadioIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioIntent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent";
  }
  protected:
  explicit RadioIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationsFieldNumber = 2,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration configurations = 2 [json_name = "configurations"];
  int configurations_size() const;
  private:
  int _internal_configurations_size() const;

  public:
  void clear_configurations() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* mutable_configurations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration >*
      mutable_configurations();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration& _internal_configurations(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* _internal_add_configurations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration>& _internal_configurations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration>* _internal_mutable_configurations();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration& configurations(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* add_configurations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration >&
      configurations() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration > configurations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class PathIntent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent) */ {
 public:
  inline PathIntent() : PathIntent(nullptr) {}
  ~PathIntent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PathIntent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathIntent(const PathIntent& from);
  PathIntent(PathIntent&& from) noexcept
    : PathIntent() {
    *this = ::std::move(from);
  }

  inline PathIntent& operator=(const PathIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathIntent& operator=(PathIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathIntent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathIntent* internal_default_instance() {
    return reinterpret_cast<const PathIntent*>(
               &_PathIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PathIntent& a, PathIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(PathIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathIntent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathIntent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathIntent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathIntent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathIntent& from) {
    PathIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathIntent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent";
  }
  protected:
  explicit PathIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathSegmentsFieldNumber = 3,
    kSrcElementIdFieldNumber = 1,
    kDstElementIdFieldNumber = 2,
    kClassifierFieldNumber = 10,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink path_segments = 3 [json_name = "pathSegments"];
  int path_segments_size() const;
  private:
  int _internal_path_segments_size() const;

  public:
  void clear_path_segments() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* mutable_path_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink >*
      mutable_path_segments();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink& _internal_path_segments(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* _internal_add_path_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink>& _internal_path_segments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink>* _internal_mutable_path_segments();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink& path_segments(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* add_path_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink >&
      path_segments() const;
  // optional string src_element_id = 1 [json_name = "srcElementId", deprecated = true];
  [[deprecated]]  bool has_src_element_id() const;
  [[deprecated]]  void clear_src_element_id() ;
  [[deprecated]] const std::string& src_element_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_src_element_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_src_element_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_src_element_id();
  [[deprecated]] void set_allocated_src_element_id(std::string* ptr);

  private:
  const std::string& _internal_src_element_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_element_id(
      const std::string& value);
  std::string* _internal_mutable_src_element_id();

  public:
  // optional string dst_element_id = 2 [json_name = "dstElementId", deprecated = true];
  [[deprecated]]  bool has_dst_element_id() const;
  [[deprecated]]  void clear_dst_element_id() ;
  [[deprecated]] const std::string& dst_element_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_dst_element_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_dst_element_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_dst_element_id();
  [[deprecated]] void set_allocated_dst_element_id(std::string* ptr);

  private:
  const std::string& _internal_dst_element_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_element_id(
      const std::string& value);
  std::string* _internal_mutable_dst_element_id();

  public:
  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 10 [json_name = "classifier"];
  bool has_classifier() const;
  void clear_classifier() ;
  const ::aalyria::spacetime::api::common::FlowClassifier& classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowClassifier* release_classifier();
  ::aalyria::spacetime::api::common::FlowClassifier* mutable_classifier();
  void set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier);
  private:
  const ::aalyria::spacetime::api::common::FlowClassifier& _internal_classifier() const;
  ::aalyria::spacetime::api::common::FlowClassifier* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::aalyria::spacetime::api::common::FlowClassifier* classifier);
  ::aalyria::spacetime::api::common::FlowClassifier* unsafe_arena_release_classifier();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink > path_segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_element_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_element_id_;
    ::aalyria::spacetime::api::common::FlowClassifier* classifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class TunnelIntent_TunnelEndpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint) */ {
 public:
  inline TunnelIntent_TunnelEndpoint() : TunnelIntent_TunnelEndpoint(nullptr) {}
  ~TunnelIntent_TunnelEndpoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TunnelIntent_TunnelEndpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelIntent_TunnelEndpoint(const TunnelIntent_TunnelEndpoint& from);
  TunnelIntent_TunnelEndpoint(TunnelIntent_TunnelEndpoint&& from) noexcept
    : TunnelIntent_TunnelEndpoint() {
    *this = ::std::move(from);
  }

  inline TunnelIntent_TunnelEndpoint& operator=(const TunnelIntent_TunnelEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelIntent_TunnelEndpoint& operator=(TunnelIntent_TunnelEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelIntent_TunnelEndpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelIntent_TunnelEndpoint* internal_default_instance() {
    return reinterpret_cast<const TunnelIntent_TunnelEndpoint*>(
               &_TunnelIntent_TunnelEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TunnelIntent_TunnelEndpoint& a, TunnelIntent_TunnelEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelIntent_TunnelEndpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelIntent_TunnelEndpoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelIntent_TunnelEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelIntent_TunnelEndpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelIntent_TunnelEndpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelIntent_TunnelEndpoint& from) {
    TunnelIntent_TunnelEndpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelIntent_TunnelEndpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint";
  }
  protected:
  explicit TunnelIntent_TunnelEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kEncapsulatedSrcInterfaceIdFieldNumber = 6,
    kClassifierFieldNumber = 5,
    kEncapsulatedSrcPortFieldNumber = 3,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional string encapsulated_src_interface_id = 6 [json_name = "encapsulatedSrcInterfaceId"];
  bool has_encapsulated_src_interface_id() const;
  void clear_encapsulated_src_interface_id() ;
  const std::string& encapsulated_src_interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encapsulated_src_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_encapsulated_src_interface_id();
  PROTOBUF_NODISCARD std::string* release_encapsulated_src_interface_id();
  void set_allocated_encapsulated_src_interface_id(std::string* ptr);

  private:
  const std::string& _internal_encapsulated_src_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encapsulated_src_interface_id(
      const std::string& value);
  std::string* _internal_mutable_encapsulated_src_interface_id();

  public:
  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 5 [json_name = "classifier"];
  bool has_classifier() const;
  void clear_classifier() ;
  const ::aalyria::spacetime::api::common::FlowClassifier& classifier() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::FlowClassifier* release_classifier();
  ::aalyria::spacetime::api::common::FlowClassifier* mutable_classifier();
  void set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier);
  private:
  const ::aalyria::spacetime::api::common::FlowClassifier& _internal_classifier() const;
  ::aalyria::spacetime::api::common::FlowClassifier* _internal_mutable_classifier();
  public:
  void unsafe_arena_set_allocated_classifier(
      ::aalyria::spacetime::api::common::FlowClassifier* classifier);
  ::aalyria::spacetime::api::common::FlowClassifier* unsafe_arena_release_classifier();
  // optional int32 encapsulated_src_port = 3 [json_name = "encapsulatedSrcPort"];
  bool has_encapsulated_src_port() const;
  void clear_encapsulated_src_port() ;
  ::int32_t encapsulated_src_port() const;
  void set_encapsulated_src_port(::int32_t value);

  private:
  ::int32_t _internal_encapsulated_src_port() const;
  void _internal_set_encapsulated_src_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encapsulated_src_interface_id_;
    ::aalyria::spacetime::api::common::FlowClassifier* classifier_;
    ::int32_t encapsulated_src_port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class TunnelIntent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent) */ {
 public:
  inline TunnelIntent() : TunnelIntent(nullptr) {}
  ~TunnelIntent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TunnelIntent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TunnelIntent(const TunnelIntent& from);
  TunnelIntent(TunnelIntent&& from) noexcept
    : TunnelIntent() {
    *this = ::std::move(from);
  }

  inline TunnelIntent& operator=(const TunnelIntent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TunnelIntent& operator=(TunnelIntent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TunnelIntent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TunnelIntent* internal_default_instance() {
    return reinterpret_cast<const TunnelIntent*>(
               &_TunnelIntent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TunnelIntent& a, TunnelIntent& b) {
    a.Swap(&b);
  }
  inline void Swap(TunnelIntent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TunnelIntent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TunnelIntent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TunnelIntent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TunnelIntent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TunnelIntent& from) {
    TunnelIntent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TunnelIntent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent";
  }
  protected:
  explicit TunnelIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TunnelIntent_TunnelEndpoint TunnelEndpoint;

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 5,
    kAFieldNumber = 10,
    kBFieldNumber = 11,
  };
  // optional .aalyria.spacetime.api.common.TunnelMethod method = 5 [json_name = "method"];
  bool has_method() const;
  void clear_method() ;
  const ::aalyria::spacetime::api::common::TunnelMethod& method() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TunnelMethod* release_method();
  ::aalyria::spacetime::api::common::TunnelMethod* mutable_method();
  void set_allocated_method(::aalyria::spacetime::api::common::TunnelMethod* method);
  private:
  const ::aalyria::spacetime::api::common::TunnelMethod& _internal_method() const;
  ::aalyria::spacetime::api::common::TunnelMethod* _internal_mutable_method();
  public:
  void unsafe_arena_set_allocated_method(
      ::aalyria::spacetime::api::common::TunnelMethod* method);
  ::aalyria::spacetime::api::common::TunnelMethod* unsafe_arena_release_method();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint a = 10 [json_name = "a"];
  bool has_a() const;
  void clear_a() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& a() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* release_a();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* mutable_a();
  void set_allocated_a(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* a);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& _internal_a() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* a);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* unsafe_arena_release_a();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint b = 11 [json_name = "b"];
  bool has_b() const;
  void clear_b() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& b() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* release_b();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* mutable_b();
  void set_allocated_b(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* b);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& _internal_b() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* b);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* unsafe_arena_release_b();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TunnelMethod* method_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* a_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* b_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class IntentFailure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure) */ {
 public:
  inline IntentFailure() : IntentFailure(nullptr) {}
  ~IntentFailure() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntentFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntentFailure(const IntentFailure& from);
  IntentFailure(IntentFailure&& from) noexcept
    : IntentFailure() {
    *this = ::std::move(from);
  }

  inline IntentFailure& operator=(const IntentFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntentFailure& operator=(IntentFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntentFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntentFailure* internal_default_instance() {
    return reinterpret_cast<const IntentFailure*>(
               &_IntentFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IntentFailure& a, IntentFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(IntentFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntentFailure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntentFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntentFailure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntentFailure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntentFailure& from) {
    IntentFailure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntentFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure";
  }
  protected:
  explicit IntentFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using IntentFailureType = IntentFailure_IntentFailureType;
  static constexpr IntentFailureType UNKNOWN = IntentFailure_IntentFailureType_UNKNOWN;
  static constexpr IntentFailureType COMPILATION_FAILURE = IntentFailure_IntentFailureType_COMPILATION_FAILURE;
  static constexpr IntentFailureType AGENT_INSTALLATION_FAILURE = IntentFailure_IntentFailureType_AGENT_INSTALLATION_FAILURE;
  static constexpr IntentFailureType UNREACHABLE_AGENT = IntentFailure_IntentFailureType_UNREACHABLE_AGENT;
  static constexpr IntentFailureType UNEXPECTED_CDPI_STATE_CHANGE = IntentFailure_IntentFailureType_UNEXPECTED_CDPI_STATE_CHANGE;
  static constexpr IntentFailureType PRECONDITION_FAILED = IntentFailure_IntentFailureType_PRECONDITION_FAILED;
  static constexpr IntentFailureType DEADLINE_EXCEEDED = IntentFailure_IntentFailureType_DEADLINE_EXCEEDED;
  static constexpr IntentFailureType PRECONDITION_EXPIRED = IntentFailure_IntentFailureType_PRECONDITION_EXPIRED;
  static constexpr IntentFailureType SDN_INTERNAL_ERROR = IntentFailure_IntentFailureType_SDN_INTERNAL_ERROR;
  static inline bool IntentFailureType_IsValid(int value) {
    return IntentFailure_IntentFailureType_IsValid(value);
  }
  static constexpr IntentFailureType IntentFailureType_MIN = IntentFailure_IntentFailureType_IntentFailureType_MIN;
  static constexpr IntentFailureType IntentFailureType_MAX = IntentFailure_IntentFailureType_IntentFailureType_MAX;
  static constexpr int IntentFailureType_ARRAYSIZE = IntentFailure_IntentFailureType_IntentFailureType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntentFailureType_descriptor() {
    return IntentFailure_IntentFailureType_descriptor();
  }
  template <typename T>
  static inline const std::string& IntentFailureType_Name(T value) {
    return IntentFailure_IntentFailureType_Name(value);
  }
  static inline bool IntentFailureType_Parse(absl::string_view name, IntentFailureType* value) {
    return IntentFailure_IntentFailureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdsFieldNumber = 4,
    kDescriptionFieldNumber = 3,
    kPreconditionFailureFieldNumber = 2,
    kTypeFieldNumber = 1,
    kAgentFailureCodeFieldNumber = 5,
  };
  // repeated string agent_ids = 4 [json_name = "agentIds"];
  int agent_ids_size() const;
  private:
  int _internal_agent_ids_size() const;

  public:
  void clear_agent_ids() ;
  const std::string& agent_ids(int index) const;
  std::string* mutable_agent_ids(int index);
  void set_agent_ids(int index, const std::string& value);
  void set_agent_ids(int index, std::string&& value);
  void set_agent_ids(int index, const char* value);
  void set_agent_ids(int index, const char* value, std::size_t size);
  void set_agent_ids(int index, absl::string_view value);
  std::string* add_agent_ids();
  void add_agent_ids(const std::string& value);
  void add_agent_ids(std::string&& value);
  void add_agent_ids(const char* value);
  void add_agent_ids(const char* value, std::size_t size);
  void add_agent_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& agent_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_agent_ids();

  private:
  const std::string& _internal_agent_ids(int index) const;
  std::string* _internal_add_agent_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_agent_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_agent_ids();

  public:
  // optional string description = 3 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure precondition_failure = 2 [json_name = "preconditionFailure"];
  bool has_precondition_failure() const;
  void clear_precondition_failure() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& precondition_failure() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* release_precondition_failure();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* mutable_precondition_failure();
  void set_allocated_precondition_failure(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* precondition_failure);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& _internal_precondition_failure() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* _internal_mutable_precondition_failure();
  public:
  void unsafe_arena_set_allocated_precondition_failure(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* precondition_failure);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* unsafe_arena_release_precondition_failure();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.IntentFailureType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType value);

  public:
  // optional .google.rpc.Code agent_failure_code = 5 [json_name = "agentFailureCode"];
  bool has_agent_failure_code() const;
  void clear_agent_failure_code() ;
  ::google::rpc::Code agent_failure_code() const;
  void set_agent_failure_code(::google::rpc::Code value);

  private:
  ::google::rpc::Code _internal_agent_failure_code() const;
  void _internal_set_agent_failure_code(::google::rpc::Code value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> agent_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* precondition_failure_;
    int type_;
    int agent_failure_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};// -------------------------------------------------------------------

class IntentWithdrawal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal) */ {
 public:
  inline IntentWithdrawal() : IntentWithdrawal(nullptr) {}
  ~IntentWithdrawal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntentWithdrawal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntentWithdrawal(const IntentWithdrawal& from);
  IntentWithdrawal(IntentWithdrawal&& from) noexcept
    : IntentWithdrawal() {
    *this = ::std::move(from);
  }

  inline IntentWithdrawal& operator=(const IntentWithdrawal& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntentWithdrawal& operator=(IntentWithdrawal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntentWithdrawal& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntentWithdrawal* internal_default_instance() {
    return reinterpret_cast<const IntentWithdrawal*>(
               &_IntentWithdrawal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntentWithdrawal& a, IntentWithdrawal& b) {
    a.Swap(&b);
  }
  inline void Swap(IntentWithdrawal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntentWithdrawal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntentWithdrawal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntentWithdrawal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntentWithdrawal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntentWithdrawal& from) {
    IntentWithdrawal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntentWithdrawal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal";
  }
  protected:
  explicit IntentWithdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using WithdrawType = IntentWithdrawal_WithdrawType;
  static constexpr WithdrawType UNKNOWN = IntentWithdrawal_WithdrawType_UNKNOWN;
  static constexpr WithdrawType INACCESSIBLE = IntentWithdrawal_WithdrawType_INACCESSIBLE;
  static constexpr WithdrawType NOT_REQUIRED = IntentWithdrawal_WithdrawType_NOT_REQUIRED;
  static inline bool WithdrawType_IsValid(int value) {
    return IntentWithdrawal_WithdrawType_IsValid(value);
  }
  static constexpr WithdrawType WithdrawType_MIN = IntentWithdrawal_WithdrawType_WithdrawType_MIN;
  static constexpr WithdrawType WithdrawType_MAX = IntentWithdrawal_WithdrawType_WithdrawType_MAX;
  static constexpr int WithdrawType_ARRAYSIZE = IntentWithdrawal_WithdrawType_WithdrawType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WithdrawType_descriptor() {
    return IntentWithdrawal_WithdrawType_descriptor();
  }
  template <typename T>
  static inline const std::string& WithdrawType_Name(T value) {
    return IntentWithdrawal_WithdrawType_Name(value);
  }
  static inline bool WithdrawType_Parse(absl::string_view name, WithdrawType* value) {
    return IntentWithdrawal_WithdrawType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string description = 2 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.WithdrawType type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Intent_ServiceRequestAndIntervals

// optional string service_request_id = 1 [json_name = "serviceRequestId"];
inline bool Intent_ServiceRequestAndIntervals::has_service_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Intent_ServiceRequestAndIntervals::clear_service_request_id() {
  _impl_.service_request_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Intent_ServiceRequestAndIntervals::service_request_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id)
  return _internal_service_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Intent_ServiceRequestAndIntervals::set_service_request_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.service_request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id)
}
inline std::string* Intent_ServiceRequestAndIntervals::mutable_service_request_id() {
  std::string* _s = _internal_mutable_service_request_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id)
  return _s;
}
inline const std::string& Intent_ServiceRequestAndIntervals::_internal_service_request_id() const {
  return _impl_.service_request_id_.Get();
}
inline void Intent_ServiceRequestAndIntervals::_internal_set_service_request_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.service_request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Intent_ServiceRequestAndIntervals::_internal_mutable_service_request_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.service_request_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Intent_ServiceRequestAndIntervals::release_service_request_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.service_request_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_request_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Intent_ServiceRequestAndIntervals::set_allocated_service_request_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.service_request_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_request_id_.IsDefault()) {
          _impl_.service_request_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id)
}

// repeated .google.type.Interval interval = 2 [json_name = "interval"];
inline int Intent_ServiceRequestAndIntervals::_internal_interval_size() const {
  return _impl_.interval_.size();
}
inline int Intent_ServiceRequestAndIntervals::interval_size() const {
  return _internal_interval_size();
}
inline ::google::type::Interval* Intent_ServiceRequestAndIntervals::mutable_interval(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.interval)
  return _internal_mutable_interval()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >*
Intent_ServiceRequestAndIntervals::mutable_interval() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.interval)
  return _internal_mutable_interval();
}
inline const ::google::type::Interval& Intent_ServiceRequestAndIntervals::_internal_interval(int index) const {
  return _internal_interval().Get(index);
}
inline const ::google::type::Interval& Intent_ServiceRequestAndIntervals::interval(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.interval)
  return _internal_interval(index);
}
inline ::google::type::Interval* Intent_ServiceRequestAndIntervals::_internal_add_interval() {
  return _internal_mutable_interval()->Add();
}
inline ::google::type::Interval* Intent_ServiceRequestAndIntervals::add_interval() {
  ::google::type::Interval* _add = _internal_add_interval();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.interval)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::type::Interval >&
Intent_ServiceRequestAndIntervals::interval() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.interval)
  return _internal_interval();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>&
Intent_ServiceRequestAndIntervals::_internal_interval() const {
  return _impl_.interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::google::type::Interval>*
Intent_ServiceRequestAndIntervals::_internal_mutable_interval() {
  return &_impl_.interval_;
}

// -------------------------------------------------------------------

// Intent

// optional string app_id = 1 [json_name = "appId", deprecated = true];
inline bool Intent::has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Intent::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Intent::app_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Intent::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id)
}
inline std::string* Intent::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id)
  return _s;
}
inline const std::string& Intent::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void Intent::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Intent::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Intent::release_app_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Intent::set_allocated_app_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id)
}

// optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
inline bool Intent::has_time_to_enact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_to_enact_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Intent::_internal_time_to_enact() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_to_enact_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Intent::time_to_enact() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_enact)
  return _internal_time_to_enact();
}
inline void Intent::unsafe_arena_set_allocated_time_to_enact(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_enact_);
  }
  _impl_.time_to_enact_ = time_to_enact;
  if (time_to_enact) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_enact)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Intent::release_time_to_enact() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_to_enact_;
  _impl_.time_to_enact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Intent::unsafe_arena_release_time_to_enact() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_enact)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_to_enact_;
  _impl_.time_to_enact_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Intent::_internal_mutable_time_to_enact() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.time_to_enact_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_to_enact_ = p;
  }
  return _impl_.time_to_enact_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Intent::mutable_time_to_enact() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_to_enact();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_enact)
  return _msg;
}
inline void Intent::set_allocated_time_to_enact(::PROTOBUF_NAMESPACE_ID::Timestamp* time_to_enact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_enact_);
  }
  if (time_to_enact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_to_enact));
    if (message_arena != submessage_arena) {
      time_to_enact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_to_enact, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.time_to_enact_ = time_to_enact;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_enact)
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent link = 4 [json_name = "link"];
inline bool Intent::has_link() const {
  return value_case() == kLink;
}
inline bool Intent::_internal_has_link() const {
  return value_case() == kLink;
}
inline void Intent::set_has_link() {
  _impl_._oneof_case_[0] = kLink;
}
inline void Intent::clear_link() {
  if (value_case() == kLink) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.link_;
    }
    clear_has_value();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* Intent::release_link() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
  if (value_case() == kLink) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* temp = _impl_.value_.link_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent& Intent::_internal_link() const {
  return value_case() == kLink
      ? *_impl_.value_.link_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_LinkIntent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent& Intent::link() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
  return _internal_link();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* Intent::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
  if (value_case() == kLink) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* temp = _impl_.value_.link_;
    _impl_.value_.link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Intent::unsafe_arena_set_allocated_link(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* link) {
  clear_value();
  if (link) {
    set_has_link();
    _impl_.value_.link_ = link;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* Intent::_internal_mutable_link() {
  if (value_case() != kLink) {
    clear_value();
    set_has_link();
    _impl_.value_.link_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent >(GetArenaForAllocation());
  }
  return _impl_.value_.link_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* Intent::mutable_link() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent radio = 5 [json_name = "radio"];
inline bool Intent::has_radio() const {
  return value_case() == kRadio;
}
inline bool Intent::_internal_has_radio() const {
  return value_case() == kRadio;
}
inline void Intent::set_has_radio() {
  _impl_._oneof_case_[0] = kRadio;
}
inline void Intent::clear_radio() {
  if (value_case() == kRadio) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.radio_;
    }
    clear_has_value();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* Intent::release_radio() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
  if (value_case() == kRadio) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* temp = _impl_.value_.radio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.radio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent& Intent::_internal_radio() const {
  return value_case() == kRadio
      ? *_impl_.value_.radio_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_RadioIntent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent& Intent::radio() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
  return _internal_radio();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* Intent::unsafe_arena_release_radio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
  if (value_case() == kRadio) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* temp = _impl_.value_.radio_;
    _impl_.value_.radio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Intent::unsafe_arena_set_allocated_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* radio) {
  clear_value();
  if (radio) {
    set_has_radio();
    _impl_.value_.radio_ = radio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* Intent::_internal_mutable_radio() {
  if (value_case() != kRadio) {
    clear_value();
    set_has_radio();
    _impl_.value_.radio_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent >(GetArenaForAllocation());
  }
  return _impl_.value_.radio_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* Intent::mutable_radio() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* _msg = _internal_mutable_radio();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent route = 6 [json_name = "route"];
inline bool Intent::has_route() const {
  return value_case() == kRoute;
}
inline bool Intent::_internal_has_route() const {
  return value_case() == kRoute;
}
inline void Intent::set_has_route() {
  _impl_._oneof_case_[0] = kRoute;
}
inline void Intent::clear_route() {
  if (value_case() == kRoute) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.route_;
    }
    clear_has_value();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* Intent::release_route() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
  if (value_case() == kRoute) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* temp = _impl_.value_.route_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent& Intent::_internal_route() const {
  return value_case() == kRoute
      ? *_impl_.value_.route_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PathIntent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent& Intent::route() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
  return _internal_route();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* Intent::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
  if (value_case() == kRoute) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* temp = _impl_.value_.route_;
    _impl_.value_.route_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Intent::unsafe_arena_set_allocated_route(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* route) {
  clear_value();
  if (route) {
    set_has_route();
    _impl_.value_.route_ = route;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* Intent::_internal_mutable_route() {
  if (value_case() != kRoute) {
    clear_value();
    set_has_route();
    _impl_.value_.route_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent >(GetArenaForAllocation());
  }
  return _impl_.value_.route_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* Intent::mutable_route() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent tunnel = 10 [json_name = "tunnel"];
inline bool Intent::has_tunnel() const {
  return value_case() == kTunnel;
}
inline bool Intent::_internal_has_tunnel() const {
  return value_case() == kTunnel;
}
inline void Intent::set_has_tunnel() {
  _impl_._oneof_case_[0] = kTunnel;
}
inline void Intent::clear_tunnel() {
  if (value_case() == kTunnel) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.tunnel_;
    }
    clear_has_value();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* Intent::release_tunnel() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
  if (value_case() == kTunnel) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* temp = _impl_.value_.tunnel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent& Intent::_internal_tunnel() const {
  return value_case() == kTunnel
      ? *_impl_.value_.tunnel_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelIntent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent& Intent::tunnel() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
  return _internal_tunnel();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* Intent::unsafe_arena_release_tunnel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
  if (value_case() == kTunnel) {
    clear_has_value();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* temp = _impl_.value_.tunnel_;
    _impl_.value_.tunnel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Intent::unsafe_arena_set_allocated_tunnel(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* tunnel) {
  clear_value();
  if (tunnel) {
    set_has_tunnel();
    _impl_.value_.tunnel_ = tunnel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* Intent::_internal_mutable_tunnel() {
  if (value_case() != kTunnel) {
    clear_value();
    set_has_tunnel();
    _impl_.value_.tunnel_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent >(GetArenaForAllocation());
  }
  return _impl_.value_.tunnel_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* Intent::mutable_tunnel() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* _msg = _internal_mutable_tunnel();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
  return _msg;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState state = 7 [default = INSTALL_REQ, json_name = "state"];
inline bool Intent::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Intent::clear_state() {
  _impl_.state_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState Intent::state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.state)
  return _internal_state();
}
inline void Intent::set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.state)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState Intent::_internal_state() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState>(_impl_.state_);
}
inline void Intent::_internal_set_state(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.state_ = value;
}

// optional int64 request_timestamp_us = 11 [json_name = "requestTimestampUs"];
inline bool Intent::has_request_timestamp_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Intent::clear_request_timestamp_us() {
  _impl_.request_timestamp_us_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t Intent::request_timestamp_us() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.request_timestamp_us)
  return _internal_request_timestamp_us();
}
inline void Intent::set_request_timestamp_us(::int64_t value) {
  _internal_set_request_timestamp_us(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.request_timestamp_us)
}
inline ::int64_t Intent::_internal_request_timestamp_us() const {
  return _impl_.request_timestamp_us_;
}
inline void Intent::_internal_set_request_timestamp_us(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.request_timestamp_us_ = value;
}

// repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_updates = 8 [json_name = "compiledUpdates"];
inline int Intent::_internal_compiled_updates_size() const {
  return _impl_.compiled_updates_.size();
}
inline int Intent::compiled_updates_size() const {
  return _internal_compiled_updates_size();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::mutable_compiled_updates(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_updates)
  return _internal_mutable_compiled_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >*
Intent::mutable_compiled_updates() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_updates)
  return _internal_mutable_compiled_updates();
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& Intent::_internal_compiled_updates(int index) const {
  return _internal_compiled_updates().Get(index);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& Intent::compiled_updates(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_updates)
  return _internal_compiled_updates(index);
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::_internal_add_compiled_updates() {
  return _internal_mutable_compiled_updates()->Add();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::add_compiled_updates() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _add = _internal_add_compiled_updates();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >&
Intent::compiled_updates() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_updates)
  return _internal_compiled_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>&
Intent::_internal_compiled_updates() const {
  return _impl_.compiled_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>*
Intent::_internal_mutable_compiled_updates() {
  return &_impl_.compiled_updates_;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure failure = 9 [json_name = "failure"];
inline bool Intent::has_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.failure_ != nullptr);
  return value;
}
inline void Intent::clear_failure() {
  if (_impl_.failure_ != nullptr) _impl_.failure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& Intent::_internal_failure() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* p = _impl_.failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_IntentFailure_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& Intent::failure() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.failure)
  return _internal_failure();
}
inline void Intent::unsafe_arena_set_allocated_failure(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.failure_);
  }
  _impl_.failure_ = failure;
  if (failure) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.failure)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* Intent::release_failure() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* temp = _impl_.failure_;
  _impl_.failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* Intent::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.failure)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* temp = _impl_.failure_;
  _impl_.failure_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* Intent::_internal_mutable_failure() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure>(GetArenaForAllocation());
    _impl_.failure_ = p;
  }
  return _impl_.failure_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* Intent::mutable_failure() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* _msg = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.failure)
  return _msg;
}
inline void Intent::set_allocated_failure(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.failure_;
  }
  if (failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(failure);
    if (message_arena != submessage_arena) {
      failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.failure)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal withdrawal = 14 [json_name = "withdrawal"];
inline bool Intent::has_withdrawal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.withdrawal_ != nullptr);
  return value;
}
inline void Intent::clear_withdrawal() {
  if (_impl_.withdrawal_ != nullptr) _impl_.withdrawal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal& Intent::_internal_withdrawal() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* p = _impl_.withdrawal_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_IntentWithdrawal_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal& Intent::withdrawal() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.withdrawal)
  return _internal_withdrawal();
}
inline void Intent::unsafe_arena_set_allocated_withdrawal(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* withdrawal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.withdrawal_);
  }
  _impl_.withdrawal_ = withdrawal;
  if (withdrawal) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.withdrawal)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* Intent::release_withdrawal() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* temp = _impl_.withdrawal_;
  _impl_.withdrawal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* Intent::unsafe_arena_release_withdrawal() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.withdrawal)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* temp = _impl_.withdrawal_;
  _impl_.withdrawal_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* Intent::_internal_mutable_withdrawal() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.withdrawal_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal>(GetArenaForAllocation());
    _impl_.withdrawal_ = p;
  }
  return _impl_.withdrawal_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* Intent::mutable_withdrawal() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* _msg = _internal_mutable_withdrawal();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.withdrawal)
  return _msg;
}
inline void Intent::set_allocated_withdrawal(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal* withdrawal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.withdrawal_;
  }
  if (withdrawal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(withdrawal);
    if (message_arena != submessage_arena) {
      withdrawal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, withdrawal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.withdrawal_ = withdrawal;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.withdrawal)
}

// optional .aalyria.spacetime.api.common.DateTime time_to_withdraw = 15 [json_name = "timeToWithdraw"];
inline bool Intent::has_time_to_withdraw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_to_withdraw_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& Intent::_internal_time_to_withdraw() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.time_to_withdraw_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& Intent::time_to_withdraw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_withdraw)
  return _internal_time_to_withdraw();
}
inline void Intent::unsafe_arena_set_allocated_time_to_withdraw(
    ::aalyria::spacetime::api::common::DateTime* time_to_withdraw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_withdraw_);
  }
  _impl_.time_to_withdraw_ = time_to_withdraw;
  if (time_to_withdraw) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_withdraw)
}
inline ::aalyria::spacetime::api::common::DateTime* Intent::release_time_to_withdraw() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.time_to_withdraw_;
  _impl_.time_to_withdraw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* Intent::unsafe_arena_release_time_to_withdraw() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_withdraw)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.time_to_withdraw_;
  _impl_.time_to_withdraw_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* Intent::_internal_mutable_time_to_withdraw() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.time_to_withdraw_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.time_to_withdraw_ = p;
  }
  return _impl_.time_to_withdraw_;
}
inline ::aalyria::spacetime::api::common::DateTime* Intent::mutable_time_to_withdraw() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_time_to_withdraw();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_withdraw)
  return _msg;
}
inline void Intent::set_allocated_time_to_withdraw(::aalyria::spacetime::api::common::DateTime* time_to_withdraw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_to_withdraw_);
  }
  if (time_to_withdraw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_to_withdraw));
    if (message_arena != submessage_arena) {
      time_to_withdraw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_to_withdraw, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.time_to_withdraw_ = time_to_withdraw;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.time_to_withdraw)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals dependent_service_requests = 16 [json_name = "dependentServiceRequests"];
inline int Intent::_internal_dependent_service_requests_size() const {
  return _impl_.dependent_service_requests_.size();
}
inline int Intent::dependent_service_requests_size() const {
  return _internal_dependent_service_requests_size();
}
inline void Intent::clear_dependent_service_requests() {
  _internal_mutable_dependent_service_requests()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* Intent::mutable_dependent_service_requests(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.dependent_service_requests)
  return _internal_mutable_dependent_service_requests()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >*
Intent::mutable_dependent_service_requests() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.dependent_service_requests)
  return _internal_mutable_dependent_service_requests();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals& Intent::_internal_dependent_service_requests(int index) const {
  return _internal_dependent_service_requests().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals& Intent::dependent_service_requests(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.dependent_service_requests)
  return _internal_dependent_service_requests(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* Intent::_internal_add_dependent_service_requests() {
  return _internal_mutable_dependent_service_requests()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* Intent::add_dependent_service_requests() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals* _add = _internal_add_dependent_service_requests();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.dependent_service_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >&
Intent::dependent_service_requests() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.dependent_service_requests)
  return _internal_dependent_service_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals>&
Intent::_internal_dependent_service_requests() const {
  return _impl_.dependent_service_requests_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals>*
Intent::_internal_mutable_dependent_service_requests() {
  return &_impl_.dependent_service_requests_;
}

// repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_withdrawal_updates = 17 [json_name = "compiledWithdrawalUpdates"];
inline int Intent::_internal_compiled_withdrawal_updates_size() const {
  return _impl_.compiled_withdrawal_updates_.size();
}
inline int Intent::compiled_withdrawal_updates_size() const {
  return _internal_compiled_withdrawal_updates_size();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::mutable_compiled_withdrawal_updates(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_withdrawal_updates)
  return _internal_mutable_compiled_withdrawal_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >*
Intent::mutable_compiled_withdrawal_updates() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_withdrawal_updates)
  return _internal_mutable_compiled_withdrawal_updates();
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& Intent::_internal_compiled_withdrawal_updates(int index) const {
  return _internal_compiled_withdrawal_updates().Get(index);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& Intent::compiled_withdrawal_updates(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_withdrawal_updates)
  return _internal_compiled_withdrawal_updates(index);
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::_internal_add_compiled_withdrawal_updates() {
  return _internal_mutable_compiled_withdrawal_updates()->Add();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* Intent::add_compiled_withdrawal_updates() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _add = _internal_add_compiled_withdrawal_updates();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_withdrawal_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdate >&
Intent::compiled_withdrawal_updates() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.compiled_withdrawal_updates)
  return _internal_compiled_withdrawal_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>&
Intent::_internal_compiled_withdrawal_updates() const {
  return _impl_.compiled_withdrawal_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdate>*
Intent::_internal_mutable_compiled_withdrawal_updates() {
  return &_impl_.compiled_withdrawal_updates_;
}

// optional bool auto_retry = 12 [json_name = "autoRetry"];
inline bool Intent::has_auto_retry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Intent::clear_auto_retry() {
  _impl_.auto_retry_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Intent::auto_retry() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.auto_retry)
  return _internal_auto_retry();
}
inline void Intent::set_auto_retry(bool value) {
  _internal_set_auto_retry(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.auto_retry)
}
inline bool Intent::_internal_auto_retry() const {
  return _impl_.auto_retry_;
}
inline void Intent::_internal_set_auto_retry(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.auto_retry_ = value;
}

inline bool Intent::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Intent::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Intent::ValueCase Intent::value_case() const {
  return Intent::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinkIntent

// .aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink directional_link = 3 [json_name = "directionalLink"];
inline bool LinkIntent::has_directional_link() const {
  return link_type_case() == kDirectionalLink;
}
inline bool LinkIntent::_internal_has_directional_link() const {
  return link_type_case() == kDirectionalLink;
}
inline void LinkIntent::set_has_directional_link() {
  _impl_._oneof_case_[0] = kDirectionalLink;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* LinkIntent::release_directional_link() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
  if (link_type_case() == kDirectionalLink) {
    clear_has_link_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* temp = _impl_.link_type_.directional_link_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.link_type_.directional_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink& LinkIntent::_internal_directional_link() const {
  return link_type_case() == kDirectionalLink
      ? *_impl_.link_type_.directional_link_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_DirectionalLink_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink& LinkIntent::directional_link() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
  return _internal_directional_link();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* LinkIntent::unsafe_arena_release_directional_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
  if (link_type_case() == kDirectionalLink) {
    clear_has_link_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* temp = _impl_.link_type_.directional_link_;
    _impl_.link_type_.directional_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LinkIntent::unsafe_arena_set_allocated_directional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* directional_link) {
  clear_link_type();
  if (directional_link) {
    set_has_directional_link();
    _impl_.link_type_.directional_link_ = directional_link;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* LinkIntent::_internal_mutable_directional_link() {
  if (link_type_case() != kDirectionalLink) {
    clear_link_type();
    set_has_directional_link();
    _impl_.link_type_.directional_link_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink >(GetArenaForAllocation());
  }
  return _impl_.link_type_.directional_link_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* LinkIntent::mutable_directional_link() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* _msg = _internal_mutable_directional_link();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink bidirectional_link = 2 [json_name = "bidirectionalLink"];
inline bool LinkIntent::has_bidirectional_link() const {
  return link_type_case() == kBidirectionalLink;
}
inline bool LinkIntent::_internal_has_bidirectional_link() const {
  return link_type_case() == kBidirectionalLink;
}
inline void LinkIntent::set_has_bidirectional_link() {
  _impl_._oneof_case_[0] = kBidirectionalLink;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* LinkIntent::release_bidirectional_link() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
  if (link_type_case() == kBidirectionalLink) {
    clear_has_link_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* temp = _impl_.link_type_.bidirectional_link_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.link_type_.bidirectional_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink& LinkIntent::_internal_bidirectional_link() const {
  return link_type_case() == kBidirectionalLink
      ? *_impl_.link_type_.bidirectional_link_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_BidirectionalLink_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink& LinkIntent::bidirectional_link() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
  return _internal_bidirectional_link();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* LinkIntent::unsafe_arena_release_bidirectional_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
  if (link_type_case() == kBidirectionalLink) {
    clear_has_link_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* temp = _impl_.link_type_.bidirectional_link_;
    _impl_.link_type_.bidirectional_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LinkIntent::unsafe_arena_set_allocated_bidirectional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* bidirectional_link) {
  clear_link_type();
  if (bidirectional_link) {
    set_has_bidirectional_link();
    _impl_.link_type_.bidirectional_link_ = bidirectional_link;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* LinkIntent::_internal_mutable_bidirectional_link() {
  if (link_type_case() != kBidirectionalLink) {
    clear_link_type();
    set_has_bidirectional_link();
    _impl_.link_type_.bidirectional_link_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink >(GetArenaForAllocation());
  }
  return _impl_.link_type_.bidirectional_link_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* LinkIntent::mutable_bidirectional_link() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* _msg = _internal_mutable_bidirectional_link();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
  return _msg;
}

inline bool LinkIntent::has_link_type() const {
  return link_type_case() != LINK_TYPE_NOT_SET;
}
inline void LinkIntent::clear_has_link_type() {
  _impl_._oneof_case_[0] = LINK_TYPE_NOT_SET;
}
inline LinkIntent::LinkTypeCase LinkIntent::link_type_case() const {
  return LinkIntent::LinkTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RadioIntent

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration configurations = 2 [json_name = "configurations"];
inline int RadioIntent::_internal_configurations_size() const {
  return _impl_.configurations_.size();
}
inline int RadioIntent::configurations_size() const {
  return _internal_configurations_size();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* RadioIntent::mutable_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent.configurations)
  return _internal_mutable_configurations()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration >*
RadioIntent::mutable_configurations() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent.configurations)
  return _internal_mutable_configurations();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration& RadioIntent::_internal_configurations(int index) const {
  return _internal_configurations().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration& RadioIntent::configurations(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent.configurations)
  return _internal_configurations(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* RadioIntent::_internal_add_configurations() {
  return _internal_mutable_configurations()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* RadioIntent::add_configurations() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* _add = _internal_add_configurations();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent.configurations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration >&
RadioIntent::configurations() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent.configurations)
  return _internal_configurations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration>&
RadioIntent::_internal_configurations() const {
  return _impl_.configurations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration>*
RadioIntent::_internal_mutable_configurations() {
  return &_impl_.configurations_;
}

// -------------------------------------------------------------------

// PathIntent

// optional string src_element_id = 1 [json_name = "srcElementId", deprecated = true];
inline bool PathIntent::has_src_element_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PathIntent::clear_src_element_id() {
  _impl_.src_element_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PathIntent::src_element_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id)
  return _internal_src_element_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PathIntent::set_src_element_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.src_element_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id)
}
inline std::string* PathIntent::mutable_src_element_id() {
  std::string* _s = _internal_mutable_src_element_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id)
  return _s;
}
inline const std::string& PathIntent::_internal_src_element_id() const {
  return _impl_.src_element_id_.Get();
}
inline void PathIntent::_internal_set_src_element_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.src_element_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PathIntent::_internal_mutable_src_element_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.src_element_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PathIntent::release_src_element_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.src_element_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PathIntent::set_allocated_src_element_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_element_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_element_id_.IsDefault()) {
          _impl_.src_element_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id)
}

// optional string dst_element_id = 2 [json_name = "dstElementId", deprecated = true];
inline bool PathIntent::has_dst_element_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PathIntent::clear_dst_element_id() {
  _impl_.dst_element_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PathIntent::dst_element_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id)
  return _internal_dst_element_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PathIntent::set_dst_element_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dst_element_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id)
}
inline std::string* PathIntent::mutable_dst_element_id() {
  std::string* _s = _internal_mutable_dst_element_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id)
  return _s;
}
inline const std::string& PathIntent::_internal_dst_element_id() const {
  return _impl_.dst_element_id_.Get();
}
inline void PathIntent::_internal_set_dst_element_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.dst_element_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PathIntent::_internal_mutable_dst_element_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dst_element_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PathIntent::release_dst_element_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dst_element_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PathIntent::set_allocated_dst_element_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_element_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_element_id_.IsDefault()) {
          _impl_.dst_element_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id)
}

// optional .aalyria.spacetime.api.common.FlowClassifier classifier = 10 [json_name = "classifier"];
inline bool PathIntent::has_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classifier_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& PathIntent::_internal_classifier() const {
  const ::aalyria::spacetime::api::common::FlowClassifier* p = _impl_.classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowClassifier&>(
      ::aalyria::spacetime::api::common::_FlowClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& PathIntent::classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.classifier)
  return _internal_classifier();
}
inline void PathIntent::unsafe_arena_set_allocated_classifier(
    ::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  _impl_.classifier_ = classifier;
  if (classifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.classifier)
}
inline ::aalyria::spacetime::api::common::FlowClassifier* PathIntent::release_classifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* PathIntent::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.classifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* PathIntent::_internal_mutable_classifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowClassifier>(GetArenaForAllocation());
    _impl_.classifier_ = p;
  }
  return _impl_.classifier_;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* PathIntent::mutable_classifier() {
  ::aalyria::spacetime::api::common::FlowClassifier* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.classifier)
  return _msg;
}
inline void PathIntent::set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier));
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.classifier)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink path_segments = 3 [json_name = "pathSegments"];
inline int PathIntent::_internal_path_segments_size() const {
  return _impl_.path_segments_.size();
}
inline int PathIntent::path_segments_size() const {
  return _internal_path_segments_size();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* PathIntent::mutable_path_segments(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.path_segments)
  return _internal_mutable_path_segments()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink >*
PathIntent::mutable_path_segments() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.path_segments)
  return _internal_mutable_path_segments();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink& PathIntent::_internal_path_segments(int index) const {
  return _internal_path_segments().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink& PathIntent::path_segments(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.path_segments)
  return _internal_path_segments(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* PathIntent::_internal_add_path_segments() {
  return _internal_mutable_path_segments()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* PathIntent::add_path_segments() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* _add = _internal_add_path_segments();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.path_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink >&
PathIntent::path_segments() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.path_segments)
  return _internal_path_segments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink>&
PathIntent::_internal_path_segments() const {
  return _impl_.path_segments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink>*
PathIntent::_internal_mutable_path_segments() {
  return &_impl_.path_segments_;
}

// -------------------------------------------------------------------

// TunnelIntent_TunnelEndpoint

// optional string node_id = 1 [json_name = "nodeId"];
inline bool TunnelIntent_TunnelEndpoint::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TunnelIntent_TunnelEndpoint::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TunnelIntent_TunnelEndpoint::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TunnelIntent_TunnelEndpoint::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id)
}
inline std::string* TunnelIntent_TunnelEndpoint::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id)
  return _s;
}
inline const std::string& TunnelIntent_TunnelEndpoint::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void TunnelIntent_TunnelEndpoint::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelIntent_TunnelEndpoint::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TunnelIntent_TunnelEndpoint::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TunnelIntent_TunnelEndpoint::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id)
}

// optional .aalyria.spacetime.api.common.FlowClassifier classifier = 5 [json_name = "classifier"];
inline bool TunnelIntent_TunnelEndpoint::has_classifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classifier_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& TunnelIntent_TunnelEndpoint::_internal_classifier() const {
  const ::aalyria::spacetime::api::common::FlowClassifier* p = _impl_.classifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::FlowClassifier&>(
      ::aalyria::spacetime::api::common::_FlowClassifier_default_instance_);
}
inline const ::aalyria::spacetime::api::common::FlowClassifier& TunnelIntent_TunnelEndpoint::classifier() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.classifier)
  return _internal_classifier();
}
inline void TunnelIntent_TunnelEndpoint::unsafe_arena_set_allocated_classifier(
    ::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  _impl_.classifier_ = classifier;
  if (classifier) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.classifier)
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelIntent_TunnelEndpoint::release_classifier() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelIntent_TunnelEndpoint::unsafe_arena_release_classifier() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.classifier)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::FlowClassifier* temp = _impl_.classifier_;
  _impl_.classifier_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelIntent_TunnelEndpoint::_internal_mutable_classifier() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::FlowClassifier>(GetArenaForAllocation());
    _impl_.classifier_ = p;
  }
  return _impl_.classifier_;
}
inline ::aalyria::spacetime::api::common::FlowClassifier* TunnelIntent_TunnelEndpoint::mutable_classifier() {
  ::aalyria::spacetime::api::common::FlowClassifier* _msg = _internal_mutable_classifier();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.classifier)
  return _msg;
}
inline void TunnelIntent_TunnelEndpoint::set_allocated_classifier(::aalyria::spacetime::api::common::FlowClassifier* classifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_);
  }
  if (classifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier));
    if (message_arena != submessage_arena) {
      classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.classifier)
}

// optional string encapsulated_src_interface_id = 6 [json_name = "encapsulatedSrcInterfaceId"];
inline bool TunnelIntent_TunnelEndpoint::has_encapsulated_src_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TunnelIntent_TunnelEndpoint::clear_encapsulated_src_interface_id() {
  _impl_.encapsulated_src_interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TunnelIntent_TunnelEndpoint::encapsulated_src_interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id)
  return _internal_encapsulated_src_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TunnelIntent_TunnelEndpoint::set_encapsulated_src_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encapsulated_src_interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id)
}
inline std::string* TunnelIntent_TunnelEndpoint::mutable_encapsulated_src_interface_id() {
  std::string* _s = _internal_mutable_encapsulated_src_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id)
  return _s;
}
inline const std::string& TunnelIntent_TunnelEndpoint::_internal_encapsulated_src_interface_id() const {
  return _impl_.encapsulated_src_interface_id_.Get();
}
inline void TunnelIntent_TunnelEndpoint::_internal_set_encapsulated_src_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.encapsulated_src_interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TunnelIntent_TunnelEndpoint::_internal_mutable_encapsulated_src_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.encapsulated_src_interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TunnelIntent_TunnelEndpoint::release_encapsulated_src_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.encapsulated_src_interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encapsulated_src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TunnelIntent_TunnelEndpoint::set_allocated_encapsulated_src_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encapsulated_src_interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encapsulated_src_interface_id_.IsDefault()) {
          _impl_.encapsulated_src_interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id)
}

// optional int32 encapsulated_src_port = 3 [json_name = "encapsulatedSrcPort"];
inline bool TunnelIntent_TunnelEndpoint::has_encapsulated_src_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TunnelIntent_TunnelEndpoint::clear_encapsulated_src_port() {
  _impl_.encapsulated_src_port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t TunnelIntent_TunnelEndpoint::encapsulated_src_port() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_port)
  return _internal_encapsulated_src_port();
}
inline void TunnelIntent_TunnelEndpoint::set_encapsulated_src_port(::int32_t value) {
  _internal_set_encapsulated_src_port(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_port)
}
inline ::int32_t TunnelIntent_TunnelEndpoint::_internal_encapsulated_src_port() const {
  return _impl_.encapsulated_src_port_;
}
inline void TunnelIntent_TunnelEndpoint::_internal_set_encapsulated_src_port(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.encapsulated_src_port_ = value;
}

// -------------------------------------------------------------------

// TunnelIntent

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint a = 10 [json_name = "a"];
inline bool TunnelIntent::has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_ != nullptr);
  return value;
}
inline void TunnelIntent::clear_a() {
  if (_impl_.a_ != nullptr) _impl_.a_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& TunnelIntent::_internal_a() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelIntent_TunnelEndpoint_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& TunnelIntent::a() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.a)
  return _internal_a();
}
inline void TunnelIntent::unsafe_arena_set_allocated_a(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = a;
  if (a) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.a)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::release_a() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* temp = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.a)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::_internal_mutable_a() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint>(GetArenaForAllocation());
    _impl_.a_ = p;
  }
  return _impl_.a_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::mutable_a() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.a)
  return _msg;
}
inline void TunnelIntent::set_allocated_a(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a_;
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a);
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.a)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint b = 11 [json_name = "b"];
inline bool TunnelIntent::has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.b_ != nullptr);
  return value;
}
inline void TunnelIntent::clear_b() {
  if (_impl_.b_ != nullptr) _impl_.b_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& TunnelIntent::_internal_b() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* p = _impl_.b_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelIntent_TunnelEndpoint_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& TunnelIntent::b() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.b)
  return _internal_b();
}
inline void TunnelIntent::unsafe_arena_set_allocated_b(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.b_);
  }
  _impl_.b_ = b;
  if (b) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.b)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::release_b() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* temp = _impl_.b_;
  _impl_.b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.b)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* temp = _impl_.b_;
  _impl_.b_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::_internal_mutable_b() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.b_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint>(GetArenaForAllocation());
    _impl_.b_ = p;
  }
  return _impl_.b_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* TunnelIntent::mutable_b() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.b)
  return _msg;
}
inline void TunnelIntent::set_allocated_b(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.b_;
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(b);
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.b_ = b;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.b)
}

// optional .aalyria.spacetime.api.common.TunnelMethod method = 5 [json_name = "method"];
inline bool TunnelIntent::has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.method_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TunnelMethod& TunnelIntent::_internal_method() const {
  const ::aalyria::spacetime::api::common::TunnelMethod* p = _impl_.method_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TunnelMethod&>(
      ::aalyria::spacetime::api::common::_TunnelMethod_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TunnelMethod& TunnelIntent::method() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.method)
  return _internal_method();
}
inline void TunnelIntent::unsafe_arena_set_allocated_method(
    ::aalyria::spacetime::api::common::TunnelMethod* method) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_);
  }
  _impl_.method_ = method;
  if (method) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.method)
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelIntent::release_method() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TunnelMethod* temp = _impl_.method_;
  _impl_.method_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelIntent::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.method)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TunnelMethod* temp = _impl_.method_;
  _impl_.method_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelIntent::_internal_mutable_method() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.method_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TunnelMethod>(GetArenaForAllocation());
    _impl_.method_ = p;
  }
  return _impl_.method_;
}
inline ::aalyria::spacetime::api::common::TunnelMethod* TunnelIntent::mutable_method() {
  ::aalyria::spacetime::api::common::TunnelMethod* _msg = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.method)
  return _msg;
}
inline void TunnelIntent::set_allocated_method(::aalyria::spacetime::api::common::TunnelMethod* method) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.method_);
  }
  if (method) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(method));
    if (message_arena != submessage_arena) {
      method = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.method_ = method;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.method)
}

// -------------------------------------------------------------------

// IntentFailure

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.IntentFailureType type = 1 [json_name = "type"];
inline bool IntentFailure::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IntentFailure::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType IntentFailure::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.type)
  return _internal_type();
}
inline void IntentFailure::set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType IntentFailure::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType>(_impl_.type_);
}
inline void IntentFailure::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure precondition_failure = 2 [json_name = "preconditionFailure"];
inline bool IntentFailure::has_precondition_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.precondition_failure_ != nullptr);
  return value;
}
inline void IntentFailure::clear_precondition_failure() {
  if (_impl_.precondition_failure_ != nullptr) _impl_.precondition_failure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& IntentFailure::_internal_precondition_failure() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* p = _impl_.precondition_failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_IntentFailure_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& IntentFailure::precondition_failure() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.precondition_failure)
  return _internal_precondition_failure();
}
inline void IntentFailure::unsafe_arena_set_allocated_precondition_failure(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* precondition_failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.precondition_failure_);
  }
  _impl_.precondition_failure_ = precondition_failure;
  if (precondition_failure) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.precondition_failure)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* IntentFailure::release_precondition_failure() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* temp = _impl_.precondition_failure_;
  _impl_.precondition_failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* IntentFailure::unsafe_arena_release_precondition_failure() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.precondition_failure)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* temp = _impl_.precondition_failure_;
  _impl_.precondition_failure_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* IntentFailure::_internal_mutable_precondition_failure() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.precondition_failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure>(GetArenaForAllocation());
    _impl_.precondition_failure_ = p;
  }
  return _impl_.precondition_failure_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* IntentFailure::mutable_precondition_failure() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* _msg = _internal_mutable_precondition_failure();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.precondition_failure)
  return _msg;
}
inline void IntentFailure::set_allocated_precondition_failure(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure* precondition_failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.precondition_failure_;
  }
  if (precondition_failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(precondition_failure);
    if (message_arena != submessage_arena) {
      precondition_failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, precondition_failure, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.precondition_failure_ = precondition_failure;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.precondition_failure)
}

// optional string description = 3 [json_name = "description"];
inline bool IntentFailure::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IntentFailure::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IntentFailure::description() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntentFailure::set_description(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description)
}
inline std::string* IntentFailure::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description)
  return _s;
}
inline const std::string& IntentFailure::_internal_description() const {
  return _impl_.description_.Get();
}
inline void IntentFailure::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* IntentFailure::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* IntentFailure::release_description() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IntentFailure::set_allocated_description(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description)
}

// repeated string agent_ids = 4 [json_name = "agentIds"];
inline int IntentFailure::_internal_agent_ids_size() const {
  return _impl_.agent_ids_.size();
}
inline int IntentFailure::agent_ids_size() const {
  return _internal_agent_ids_size();
}
inline void IntentFailure::clear_agent_ids() {
  _internal_mutable_agent_ids()->Clear();
}
inline std::string* IntentFailure::add_agent_ids() {
  std::string* _s = _internal_add_agent_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
  return _s;
}
inline const std::string& IntentFailure::agent_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
  return _internal_agent_ids(index);
}
inline std::string* IntentFailure::mutable_agent_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
  return _internal_mutable_agent_ids()->Mutable(index);
}
inline void IntentFailure::set_agent_ids(int index, const std::string& value) {
  _internal_mutable_agent_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::set_agent_ids(int index, std::string&& value) {
  _internal_mutable_agent_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::set_agent_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_agent_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::set_agent_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_agent_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::set_agent_ids(int index, absl::string_view value) {
  _internal_mutable_agent_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::add_agent_ids(const std::string& value) {
  _internal_mutable_agent_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::add_agent_ids(std::string&& value) {
  _internal_mutable_agent_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::add_agent_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_agent_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::add_agent_ids(const char* value, std::size_t size) {
  _internal_mutable_agent_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline void IntentFailure::add_agent_ids(absl::string_view value) {
  _internal_mutable_agent_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IntentFailure::agent_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
  return _internal_agent_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* IntentFailure::mutable_agent_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids)
  return _internal_mutable_agent_ids();
}
inline const std::string& IntentFailure::_internal_agent_ids(int index) const {
  return _internal_agent_ids().Get(index);
}
inline std::string* IntentFailure::_internal_add_agent_ids() {
  return _internal_mutable_agent_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IntentFailure::_internal_agent_ids() const {
  return _impl_.agent_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IntentFailure::_internal_mutable_agent_ids() {
  return &_impl_.agent_ids_;
}

// optional .google.rpc.Code agent_failure_code = 5 [json_name = "agentFailureCode"];
inline bool IntentFailure::has_agent_failure_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IntentFailure::clear_agent_failure_code() {
  _impl_.agent_failure_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::google::rpc::Code IntentFailure::agent_failure_code() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_failure_code)
  return _internal_agent_failure_code();
}
inline void IntentFailure::set_agent_failure_code(::google::rpc::Code value) {
   _internal_set_agent_failure_code(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_failure_code)
}
inline ::google::rpc::Code IntentFailure::_internal_agent_failure_code() const {
  return static_cast<::google::rpc::Code>(_impl_.agent_failure_code_);
}
inline void IntentFailure::_internal_set_agent_failure_code(::google::rpc::Code value) {
  assert(::google::rpc::Code_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.agent_failure_code_ = value;
}

// -------------------------------------------------------------------

// IntentWithdrawal

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.WithdrawType type = 1 [json_name = "type"];
inline bool IntentWithdrawal::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IntentWithdrawal::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType IntentWithdrawal::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.type)
  return _internal_type();
}
inline void IntentWithdrawal::set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType IntentWithdrawal::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType>(_impl_.type_);
}
inline void IntentWithdrawal::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string description = 2 [json_name = "description"];
inline bool IntentWithdrawal::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IntentWithdrawal::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IntentWithdrawal::description() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntentWithdrawal::set_description(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description)
}
inline std::string* IntentWithdrawal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description)
  return _s;
}
inline const std::string& IntentWithdrawal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void IntentWithdrawal::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* IntentWithdrawal::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* IntentWithdrawal::release_description() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IntentWithdrawal::set_allocated_description(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_2epb_2eh
