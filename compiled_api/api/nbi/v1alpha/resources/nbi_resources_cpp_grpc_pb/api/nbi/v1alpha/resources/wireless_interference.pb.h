// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/wireless_interference.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "api/nbi/v1alpha/resources/coverage.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class InterferenceConstraint;
struct InterferenceConstraintDefaultTypeInternal;
extern InterferenceConstraintDefaultTypeInternal _InterferenceConstraint_default_instance_;
class PfdConstraint;
struct PfdConstraintDefaultTypeInternal;
extern PfdConstraintDefaultTypeInternal _PfdConstraint_default_instance_;
class PfdConstraint_Band;
struct PfdConstraint_BandDefaultTypeInternal;
extern PfdConstraint_BandDefaultTypeInternal _PfdConstraint_Band_default_instance_;
class PfdConstraints;
struct PfdConstraintsDefaultTypeInternal;
extern PfdConstraintsDefaultTypeInternal _PfdConstraints_default_instance_;
class PointingConstraint;
struct PointingConstraintDefaultTypeInternal;
extern PointingConstraintDefaultTypeInternal _PointingConstraint_default_instance_;
class PsdConstraint;
struct PsdConstraintDefaultTypeInternal;
extern PsdConstraintDefaultTypeInternal _PsdConstraint_default_instance_;
class PsdConstraint_ControlPoint;
struct PsdConstraint_ControlPointDefaultTypeInternal;
extern PsdConstraint_ControlPointDefaultTypeInternal _PsdConstraint_ControlPoint_default_instance_;
class PsdConstraint_ScmMask;
struct PsdConstraint_ScmMaskDefaultTypeInternal;
extern PsdConstraint_ScmMaskDefaultTypeInternal _PsdConstraint_ScmMask_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {

// ===================================================================


// -------------------------------------------------------------------

class InterferenceConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint) */ {
 public:
  inline InterferenceConstraint() : InterferenceConstraint(nullptr) {}
  ~InterferenceConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterferenceConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterferenceConstraint(const InterferenceConstraint& from);
  InterferenceConstraint(InterferenceConstraint&& from) noexcept
    : InterferenceConstraint() {
    *this = ::std::move(from);
  }

  inline InterferenceConstraint& operator=(const InterferenceConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterferenceConstraint& operator=(InterferenceConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterferenceConstraint& default_instance() {
    return *internal_default_instance();
  }
  enum ConstraintsCase {
    kPfdConstraints = 4,
    kEpfdConstraints = 5,
    kApfdConstraints = 6,
    kPsdConstraint = 7,
    kPointingConstraint = 8,
    CONSTRAINTS_NOT_SET = 0,
  };

  static inline const InterferenceConstraint* internal_default_instance() {
    return reinterpret_cast<const InterferenceConstraint*>(
               &_InterferenceConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InterferenceConstraint& a, InterferenceConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(InterferenceConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterferenceConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterferenceConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterferenceConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterferenceConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterferenceConstraint& from) {
    InterferenceConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterferenceConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint";
  }
  protected:
  explicit InterferenceConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimsFieldNumber = 2,
    kInterferersFieldNumber = 3,
    kDescriptionFieldNumber = 1,
    kUseReceiverOrientationFieldNumber = 9,
    kPfdConstraintsFieldNumber = 4,
    kEpfdConstraintsFieldNumber = 5,
    kApfdConstraintsFieldNumber = 6,
    kPsdConstraintFieldNumber = 7,
    kPointingConstraintFieldNumber = 8,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray victims = 2 [json_name = "victims"];
  int victims_size() const;
  private:
  int _internal_victims_size() const;

  public:
  void clear_victims() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* mutable_victims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >*
      mutable_victims();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray& _internal_victims(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* _internal_add_victims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray>& _internal_victims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray>* _internal_mutable_victims();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray& victims(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* add_victims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >&
      victims() const;
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset interferers = 3 [json_name = "interferers"];
  int interferers_size() const;
  private:
  int _internal_interferers_size() const;

  public:
  void clear_interferers() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* mutable_interferers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >*
      mutable_interferers();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& _internal_interferers(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* _internal_add_interferers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset>& _internal_interferers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset>* _internal_mutable_interferers();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& interferers(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* add_interferers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >&
      interferers() const;
  // optional string description = 1 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional bool use_receiver_orientation = 9 [json_name = "useReceiverOrientation"];
  bool has_use_receiver_orientation() const;
  void clear_use_receiver_orientation() ;
  bool use_receiver_orientation() const;
  void set_use_receiver_orientation(bool value);

  private:
  bool _internal_use_receiver_orientation() const;
  void _internal_set_use_receiver_orientation(bool value);

  public:
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints pfd_constraints = 4 [json_name = "pfdConstraints"];
  bool has_pfd_constraints() const;
  private:
  bool _internal_has_pfd_constraints() const;

  public:
  void clear_pfd_constraints() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& pfd_constraints() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* release_pfd_constraints();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* mutable_pfd_constraints();
  void set_allocated_pfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* pfd_constraints);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& _internal_pfd_constraints() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _internal_mutable_pfd_constraints();
  public:
  void unsafe_arena_set_allocated_pfd_constraints(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* pfd_constraints);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* unsafe_arena_release_pfd_constraints();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints epfd_constraints = 5 [json_name = "epfdConstraints"];
  bool has_epfd_constraints() const;
  private:
  bool _internal_has_epfd_constraints() const;

  public:
  void clear_epfd_constraints() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& epfd_constraints() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* release_epfd_constraints();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* mutable_epfd_constraints();
  void set_allocated_epfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* epfd_constraints);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& _internal_epfd_constraints() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _internal_mutable_epfd_constraints();
  public:
  void unsafe_arena_set_allocated_epfd_constraints(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* epfd_constraints);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* unsafe_arena_release_epfd_constraints();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints apfd_constraints = 6 [json_name = "apfdConstraints"];
  bool has_apfd_constraints() const;
  private:
  bool _internal_has_apfd_constraints() const;

  public:
  void clear_apfd_constraints() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& apfd_constraints() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* release_apfd_constraints();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* mutable_apfd_constraints();
  void set_allocated_apfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* apfd_constraints);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& _internal_apfd_constraints() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _internal_mutable_apfd_constraints();
  public:
  void unsafe_arena_set_allocated_apfd_constraints(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* apfd_constraints);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* unsafe_arena_release_apfd_constraints();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint psd_constraint = 7 [json_name = "psdConstraint"];
  bool has_psd_constraint() const;
  private:
  bool _internal_has_psd_constraint() const;

  public:
  void clear_psd_constraint() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint& psd_constraint() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* release_psd_constraint();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* mutable_psd_constraint();
  void set_allocated_psd_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* psd_constraint);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint& _internal_psd_constraint() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* _internal_mutable_psd_constraint();
  public:
  void unsafe_arena_set_allocated_psd_constraint(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* psd_constraint);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* unsafe_arena_release_psd_constraint();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint pointing_constraint = 8 [json_name = "pointingConstraint"];
  bool has_pointing_constraint() const;
  private:
  bool _internal_has_pointing_constraint() const;

  public:
  void clear_pointing_constraint() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint& pointing_constraint() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* release_pointing_constraint();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* mutable_pointing_constraint();
  void set_allocated_pointing_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* pointing_constraint);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint& _internal_pointing_constraint() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* _internal_mutable_pointing_constraint();
  public:
  void unsafe_arena_set_allocated_pointing_constraint(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* pointing_constraint);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* unsafe_arena_release_pointing_constraint();
  void clear_constraints();
  ConstraintsCase constraints_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
 private:
  class _Internal;
  void set_has_pfd_constraints();
  void set_has_epfd_constraints();
  void set_has_apfd_constraints();
  void set_has_psd_constraint();
  void set_has_pointing_constraint();

  inline bool has_constraints() const;
  inline void clear_has_constraints();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray > victims_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset > interferers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool use_receiver_orientation_;
    union ConstraintsUnion {
      constexpr ConstraintsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* pfd_constraints_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* epfd_constraints_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* apfd_constraints_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* psd_constraint_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* pointing_constraint_;
    } constraints_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PfdConstraint_Band final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band) */ {
 public:
  inline PfdConstraint_Band() : PfdConstraint_Band(nullptr) {}
  ~PfdConstraint_Band() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdConstraint_Band(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdConstraint_Band(const PfdConstraint_Band& from);
  PfdConstraint_Band(PfdConstraint_Band&& from) noexcept
    : PfdConstraint_Band() {
    *this = ::std::move(from);
  }

  inline PfdConstraint_Band& operator=(const PfdConstraint_Band& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdConstraint_Band& operator=(PfdConstraint_Band&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdConstraint_Band& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdConstraint_Band* internal_default_instance() {
    return reinterpret_cast<const PfdConstraint_Band*>(
               &_PfdConstraint_Band_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PfdConstraint_Band& a, PfdConstraint_Band& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdConstraint_Band* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdConstraint_Band* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdConstraint_Band* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdConstraint_Band>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdConstraint_Band& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdConstraint_Band& from) {
    PfdConstraint_Band::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdConstraint_Band* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band";
  }
  protected:
  explicit PfdConstraint_Band(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFrequencyMhzFieldNumber = 1,
    kEndFrequencyMhzFieldNumber = 2,
  };
  // required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
  bool has_start_frequency_mhz() const;
  void clear_start_frequency_mhz() ;
  double start_frequency_mhz() const;
  void set_start_frequency_mhz(double value);

  private:
  double _internal_start_frequency_mhz() const;
  void _internal_set_start_frequency_mhz(double value);

  public:
  // required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
  bool has_end_frequency_mhz() const;
  void clear_end_frequency_mhz() ;
  double end_frequency_mhz() const;
  void set_end_frequency_mhz(double value);

  private:
  double _internal_end_frequency_mhz() const;
  void _internal_set_end_frequency_mhz(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double start_frequency_mhz_;
    double end_frequency_mhz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PfdConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint) */ {
 public:
  inline PfdConstraint() : PfdConstraint(nullptr) {}
  ~PfdConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdConstraint(const PfdConstraint& from);
  PfdConstraint(PfdConstraint&& from) noexcept
    : PfdConstraint() {
    *this = ::std::move(from);
  }

  inline PfdConstraint& operator=(const PfdConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdConstraint& operator=(PfdConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdConstraint* internal_default_instance() {
    return reinterpret_cast<const PfdConstraint*>(
               &_PfdConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PfdConstraint& a, PfdConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdConstraint& from) {
    PfdConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint";
  }
  protected:
  explicit PfdConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PfdConstraint_Band Band;

  // accessors -------------------------------------------------------

  enum : int {
    kBandFieldNumber = 1,
    kReceivedPfdDbwPerSqmFieldNumber = 2,
    kResolutionBwMhzFieldNumber = 3,
    kTimeFractionFieldNumber = 4,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band band = 1 [json_name = "band"];
  bool has_band() const;
  void clear_band() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band& band() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* release_band();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* mutable_band();
  void set_allocated_band(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* band);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band& _internal_band() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* _internal_mutable_band();
  public:
  void unsafe_arena_set_allocated_band(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* band);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* unsafe_arena_release_band();
  // optional double received_pfd_dbw_per_sqm = 2 [json_name = "receivedPfdDbwPerSqm"];
  bool has_received_pfd_dbw_per_sqm() const;
  void clear_received_pfd_dbw_per_sqm() ;
  double received_pfd_dbw_per_sqm() const;
  void set_received_pfd_dbw_per_sqm(double value);

  private:
  double _internal_received_pfd_dbw_per_sqm() const;
  void _internal_set_received_pfd_dbw_per_sqm(double value);

  public:
  // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
  bool has_resolution_bw_mhz() const;
  void clear_resolution_bw_mhz() ;
  double resolution_bw_mhz() const;
  void set_resolution_bw_mhz(double value);

  private:
  double _internal_resolution_bw_mhz() const;
  void _internal_set_resolution_bw_mhz(double value);

  public:
  // optional double time_fraction = 4 [json_name = "timeFraction"];
  bool has_time_fraction() const;
  void clear_time_fraction() ;
  double time_fraction() const;
  void set_time_fraction(double value);

  private:
  double _internal_time_fraction() const;
  void _internal_set_time_fraction(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* band_;
    double received_pfd_dbw_per_sqm_;
    double resolution_bw_mhz_;
    double time_fraction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PfdConstraints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints) */ {
 public:
  inline PfdConstraints() : PfdConstraints(nullptr) {}
  ~PfdConstraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdConstraints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdConstraints(const PfdConstraints& from);
  PfdConstraints(PfdConstraints&& from) noexcept
    : PfdConstraints() {
    *this = ::std::move(from);
  }

  inline PfdConstraints& operator=(const PfdConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdConstraints& operator=(PfdConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdConstraints* internal_default_instance() {
    return reinterpret_cast<const PfdConstraints*>(
               &_PfdConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PfdConstraints& a, PfdConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdConstraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdConstraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdConstraints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdConstraints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdConstraints& from) {
    PfdConstraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdConstraints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints";
  }
  protected:
  explicit PfdConstraints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPfdConstraintsFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint pfd_constraints = 1 [json_name = "pfdConstraints"];
  int pfd_constraints_size() const;
  private:
  int _internal_pfd_constraints_size() const;

  public:
  void clear_pfd_constraints() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* mutable_pfd_constraints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >*
      mutable_pfd_constraints();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint& _internal_pfd_constraints(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* _internal_add_pfd_constraints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint>& _internal_pfd_constraints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint>* _internal_mutable_pfd_constraints();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint& pfd_constraints(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* add_pfd_constraints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >&
      pfd_constraints() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint > pfd_constraints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PsdConstraint_ScmMask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask) */ {
 public:
  inline PsdConstraint_ScmMask() : PsdConstraint_ScmMask(nullptr) {}
  ~PsdConstraint_ScmMask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PsdConstraint_ScmMask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PsdConstraint_ScmMask(const PsdConstraint_ScmMask& from);
  PsdConstraint_ScmMask(PsdConstraint_ScmMask&& from) noexcept
    : PsdConstraint_ScmMask() {
    *this = ::std::move(from);
  }

  inline PsdConstraint_ScmMask& operator=(const PsdConstraint_ScmMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline PsdConstraint_ScmMask& operator=(PsdConstraint_ScmMask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PsdConstraint_ScmMask& default_instance() {
    return *internal_default_instance();
  }
  static inline const PsdConstraint_ScmMask* internal_default_instance() {
    return reinterpret_cast<const PsdConstraint_ScmMask*>(
               &_PsdConstraint_ScmMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PsdConstraint_ScmMask& a, PsdConstraint_ScmMask& b) {
    a.Swap(&b);
  }
  inline void Swap(PsdConstraint_ScmMask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PsdConstraint_ScmMask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PsdConstraint_ScmMask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PsdConstraint_ScmMask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PsdConstraint_ScmMask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PsdConstraint_ScmMask& from) {
    PsdConstraint_ScmMask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PsdConstraint_ScmMask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask";
  }
  protected:
  explicit PsdConstraint_ScmMask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlPointsFieldNumber = 2,
    kRefFrequencyMhzFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint control_points = 2 [json_name = "controlPoints"];
  int control_points_size() const;
  private:
  int _internal_control_points_size() const;

  public:
  void clear_control_points() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* mutable_control_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >*
      mutable_control_points();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint& _internal_control_points(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* _internal_add_control_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint>& _internal_control_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint>* _internal_mutable_control_points();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint& control_points(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* add_control_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >&
      control_points() const;
  // required double ref_frequency_mhz = 1 [json_name = "refFrequencyMhz"];
  bool has_ref_frequency_mhz() const;
  void clear_ref_frequency_mhz() ;
  double ref_frequency_mhz() const;
  void set_ref_frequency_mhz(double value);

  private:
  double _internal_ref_frequency_mhz() const;
  void _internal_set_ref_frequency_mhz(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint > control_points_;
    double ref_frequency_mhz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PsdConstraint_ControlPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint) */ {
 public:
  inline PsdConstraint_ControlPoint() : PsdConstraint_ControlPoint(nullptr) {}
  ~PsdConstraint_ControlPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PsdConstraint_ControlPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PsdConstraint_ControlPoint(const PsdConstraint_ControlPoint& from);
  PsdConstraint_ControlPoint(PsdConstraint_ControlPoint&& from) noexcept
    : PsdConstraint_ControlPoint() {
    *this = ::std::move(from);
  }

  inline PsdConstraint_ControlPoint& operator=(const PsdConstraint_ControlPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PsdConstraint_ControlPoint& operator=(PsdConstraint_ControlPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PsdConstraint_ControlPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PsdConstraint_ControlPoint* internal_default_instance() {
    return reinterpret_cast<const PsdConstraint_ControlPoint*>(
               &_PsdConstraint_ControlPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PsdConstraint_ControlPoint& a, PsdConstraint_ControlPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PsdConstraint_ControlPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PsdConstraint_ControlPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PsdConstraint_ControlPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PsdConstraint_ControlPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PsdConstraint_ControlPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PsdConstraint_ControlPoint& from) {
    PsdConstraint_ControlPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PsdConstraint_ControlPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint";
  }
  protected:
  explicit PsdConstraint_ControlPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyMhzFieldNumber = 1,
    kRelativePowerDbFieldNumber = 2,
  };
  // required double frequency_mhz = 1 [json_name = "frequencyMhz"];
  bool has_frequency_mhz() const;
  void clear_frequency_mhz() ;
  double frequency_mhz() const;
  void set_frequency_mhz(double value);

  private:
  double _internal_frequency_mhz() const;
  void _internal_set_frequency_mhz(double value);

  public:
  // required double relative_power_db = 2 [json_name = "relativePowerDb"];
  bool has_relative_power_db() const;
  void clear_relative_power_db() ;
  double relative_power_db() const;
  void set_relative_power_db(double value);

  private:
  double _internal_relative_power_db() const;
  void _internal_set_relative_power_db(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double frequency_mhz_;
    double relative_power_db_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PsdConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint) */ {
 public:
  inline PsdConstraint() : PsdConstraint(nullptr) {}
  ~PsdConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PsdConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PsdConstraint(const PsdConstraint& from);
  PsdConstraint(PsdConstraint&& from) noexcept
    : PsdConstraint() {
    *this = ::std::move(from);
  }

  inline PsdConstraint& operator=(const PsdConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PsdConstraint& operator=(PsdConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PsdConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PsdConstraint* internal_default_instance() {
    return reinterpret_cast<const PsdConstraint*>(
               &_PsdConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PsdConstraint& a, PsdConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(PsdConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PsdConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PsdConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PsdConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PsdConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PsdConstraint& from) {
    PsdConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PsdConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint";
  }
  protected:
  explicit PsdConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PsdConstraint_ScmMask ScmMask;
  typedef PsdConstraint_ControlPoint ControlPoint;

  // accessors -------------------------------------------------------

  enum : int {
    kPsdMaskFieldNumber = 2,
    kReferencePowerDbwFieldNumber = 1,
    kResolutionBwMhzFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask psd_mask = 2 [json_name = "psdMask"];
  bool has_psd_mask() const;
  void clear_psd_mask() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask& psd_mask() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* release_psd_mask();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* mutable_psd_mask();
  void set_allocated_psd_mask(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* psd_mask);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask& _internal_psd_mask() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* _internal_mutable_psd_mask();
  public:
  void unsafe_arena_set_allocated_psd_mask(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* psd_mask);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* unsafe_arena_release_psd_mask();
  // optional double reference_power_dbw = 1 [json_name = "referencePowerDbw"];
  bool has_reference_power_dbw() const;
  void clear_reference_power_dbw() ;
  double reference_power_dbw() const;
  void set_reference_power_dbw(double value);

  private:
  double _internal_reference_power_dbw() const;
  void _internal_set_reference_power_dbw(double value);

  public:
  // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
  bool has_resolution_bw_mhz() const;
  void clear_resolution_bw_mhz() ;
  double resolution_bw_mhz() const;
  void set_resolution_bw_mhz(double value);

  private:
  double _internal_resolution_bw_mhz() const;
  void _internal_set_resolution_bw_mhz(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* psd_mask_;
    double reference_power_dbw_;
    double resolution_bw_mhz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};// -------------------------------------------------------------------

class PointingConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint) */ {
 public:
  inline PointingConstraint() : PointingConstraint(nullptr) {}
  ~PointingConstraint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointingConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointingConstraint(const PointingConstraint& from);
  PointingConstraint(PointingConstraint&& from) noexcept
    : PointingConstraint() {
    *this = ::std::move(from);
  }

  inline PointingConstraint& operator=(const PointingConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointingConstraint& operator=(PointingConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointingConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointingConstraint* internal_default_instance() {
    return reinterpret_cast<const PointingConstraint*>(
               &_PointingConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PointingConstraint& a, PointingConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(PointingConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointingConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointingConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointingConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointingConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointingConstraint& from) {
    PointingConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointingConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint";
  }
  protected:
  explicit PointingConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinAngleDegFieldNumber = 1,
  };
  // optional double min_angle_deg = 1 [json_name = "minAngleDeg"];
  bool has_min_angle_deg() const;
  void clear_min_angle_deg() ;
  double min_angle_deg() const;
  void set_min_angle_deg(double value);

  private:
  double _internal_min_angle_deg() const;
  void _internal_set_min_angle_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double min_angle_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InterferenceConstraint

// optional string description = 1 [json_name = "description"];
inline bool InterferenceConstraint::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InterferenceConstraint::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InterferenceConstraint::description() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InterferenceConstraint::set_description(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description)
}
inline std::string* InterferenceConstraint::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description)
  return _s;
}
inline const std::string& InterferenceConstraint::_internal_description() const {
  return _impl_.description_.Get();
}
inline void InterferenceConstraint::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* InterferenceConstraint::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* InterferenceConstraint::release_description() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InterferenceConstraint::set_allocated_description(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray victims = 2 [json_name = "victims"];
inline int InterferenceConstraint::_internal_victims_size() const {
  return _impl_.victims_.size();
}
inline int InterferenceConstraint::victims_size() const {
  return _internal_victims_size();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* InterferenceConstraint::mutable_victims(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.victims)
  return _internal_mutable_victims()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >*
InterferenceConstraint::mutable_victims() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.victims)
  return _internal_mutable_victims();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray& InterferenceConstraint::_internal_victims(int index) const {
  return _internal_victims().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray& InterferenceConstraint::victims(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.victims)
  return _internal_victims(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* InterferenceConstraint::_internal_add_victims() {
  return _internal_mutable_victims()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* InterferenceConstraint::add_victims() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* _add = _internal_add_victims();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.victims)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >&
InterferenceConstraint::victims() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.victims)
  return _internal_victims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray>&
InterferenceConstraint::_internal_victims() const {
  return _impl_.victims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray>*
InterferenceConstraint::_internal_mutable_victims() {
  return &_impl_.victims_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset interferers = 3 [json_name = "interferers"];
inline int InterferenceConstraint::_internal_interferers_size() const {
  return _impl_.interferers_.size();
}
inline int InterferenceConstraint::interferers_size() const {
  return _internal_interferers_size();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* InterferenceConstraint::mutable_interferers(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.interferers)
  return _internal_mutable_interferers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >*
InterferenceConstraint::mutable_interferers() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.interferers)
  return _internal_mutable_interferers();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& InterferenceConstraint::_internal_interferers(int index) const {
  return _internal_interferers().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& InterferenceConstraint::interferers(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.interferers)
  return _internal_interferers(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* InterferenceConstraint::_internal_add_interferers() {
  return _internal_mutable_interferers()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* InterferenceConstraint::add_interferers() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* _add = _internal_add_interferers();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.interferers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >&
InterferenceConstraint::interferers() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.interferers)
  return _internal_interferers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset>&
InterferenceConstraint::_internal_interferers() const {
  return _impl_.interferers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset>*
InterferenceConstraint::_internal_mutable_interferers() {
  return &_impl_.interferers_;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints pfd_constraints = 4 [json_name = "pfdConstraints"];
inline bool InterferenceConstraint::has_pfd_constraints() const {
  return constraints_case() == kPfdConstraints;
}
inline bool InterferenceConstraint::_internal_has_pfd_constraints() const {
  return constraints_case() == kPfdConstraints;
}
inline void InterferenceConstraint::set_has_pfd_constraints() {
  _impl_._oneof_case_[0] = kPfdConstraints;
}
inline void InterferenceConstraint::clear_pfd_constraints() {
  if (constraints_case() == kPfdConstraints) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraints_.pfd_constraints_;
    }
    clear_has_constraints();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::release_pfd_constraints() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
  if (constraints_case() == kPfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.pfd_constraints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraints_.pfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::_internal_pfd_constraints() const {
  return constraints_case() == kPfdConstraints
      ? *_impl_.constraints_.pfd_constraints_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraints_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::pfd_constraints() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
  return _internal_pfd_constraints();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::unsafe_arena_release_pfd_constraints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
  if (constraints_case() == kPfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.pfd_constraints_;
    _impl_.constraints_.pfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterferenceConstraint::unsafe_arena_set_allocated_pfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* pfd_constraints) {
  clear_constraints();
  if (pfd_constraints) {
    set_has_pfd_constraints();
    _impl_.constraints_.pfd_constraints_ = pfd_constraints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::_internal_mutable_pfd_constraints() {
  if (constraints_case() != kPfdConstraints) {
    clear_constraints();
    set_has_pfd_constraints();
    _impl_.constraints_.pfd_constraints_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints >(GetArenaForAllocation());
  }
  return _impl_.constraints_.pfd_constraints_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::mutable_pfd_constraints() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _msg = _internal_mutable_pfd_constraints();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints epfd_constraints = 5 [json_name = "epfdConstraints"];
inline bool InterferenceConstraint::has_epfd_constraints() const {
  return constraints_case() == kEpfdConstraints;
}
inline bool InterferenceConstraint::_internal_has_epfd_constraints() const {
  return constraints_case() == kEpfdConstraints;
}
inline void InterferenceConstraint::set_has_epfd_constraints() {
  _impl_._oneof_case_[0] = kEpfdConstraints;
}
inline void InterferenceConstraint::clear_epfd_constraints() {
  if (constraints_case() == kEpfdConstraints) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraints_.epfd_constraints_;
    }
    clear_has_constraints();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::release_epfd_constraints() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
  if (constraints_case() == kEpfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.epfd_constraints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraints_.epfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::_internal_epfd_constraints() const {
  return constraints_case() == kEpfdConstraints
      ? *_impl_.constraints_.epfd_constraints_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraints_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::epfd_constraints() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
  return _internal_epfd_constraints();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::unsafe_arena_release_epfd_constraints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
  if (constraints_case() == kEpfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.epfd_constraints_;
    _impl_.constraints_.epfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterferenceConstraint::unsafe_arena_set_allocated_epfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* epfd_constraints) {
  clear_constraints();
  if (epfd_constraints) {
    set_has_epfd_constraints();
    _impl_.constraints_.epfd_constraints_ = epfd_constraints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::_internal_mutable_epfd_constraints() {
  if (constraints_case() != kEpfdConstraints) {
    clear_constraints();
    set_has_epfd_constraints();
    _impl_.constraints_.epfd_constraints_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints >(GetArenaForAllocation());
  }
  return _impl_.constraints_.epfd_constraints_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::mutable_epfd_constraints() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _msg = _internal_mutable_epfd_constraints();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints apfd_constraints = 6 [json_name = "apfdConstraints"];
inline bool InterferenceConstraint::has_apfd_constraints() const {
  return constraints_case() == kApfdConstraints;
}
inline bool InterferenceConstraint::_internal_has_apfd_constraints() const {
  return constraints_case() == kApfdConstraints;
}
inline void InterferenceConstraint::set_has_apfd_constraints() {
  _impl_._oneof_case_[0] = kApfdConstraints;
}
inline void InterferenceConstraint::clear_apfd_constraints() {
  if (constraints_case() == kApfdConstraints) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraints_.apfd_constraints_;
    }
    clear_has_constraints();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::release_apfd_constraints() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
  if (constraints_case() == kApfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.apfd_constraints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraints_.apfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::_internal_apfd_constraints() const {
  return constraints_case() == kApfdConstraints
      ? *_impl_.constraints_.apfd_constraints_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraints_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& InterferenceConstraint::apfd_constraints() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
  return _internal_apfd_constraints();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::unsafe_arena_release_apfd_constraints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
  if (constraints_case() == kApfdConstraints) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* temp = _impl_.constraints_.apfd_constraints_;
    _impl_.constraints_.apfd_constraints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterferenceConstraint::unsafe_arena_set_allocated_apfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* apfd_constraints) {
  clear_constraints();
  if (apfd_constraints) {
    set_has_apfd_constraints();
    _impl_.constraints_.apfd_constraints_ = apfd_constraints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::_internal_mutable_apfd_constraints() {
  if (constraints_case() != kApfdConstraints) {
    clear_constraints();
    set_has_apfd_constraints();
    _impl_.constraints_.apfd_constraints_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints >(GetArenaForAllocation());
  }
  return _impl_.constraints_.apfd_constraints_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* InterferenceConstraint::mutable_apfd_constraints() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* _msg = _internal_mutable_apfd_constraints();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint psd_constraint = 7 [json_name = "psdConstraint"];
inline bool InterferenceConstraint::has_psd_constraint() const {
  return constraints_case() == kPsdConstraint;
}
inline bool InterferenceConstraint::_internal_has_psd_constraint() const {
  return constraints_case() == kPsdConstraint;
}
inline void InterferenceConstraint::set_has_psd_constraint() {
  _impl_._oneof_case_[0] = kPsdConstraint;
}
inline void InterferenceConstraint::clear_psd_constraint() {
  if (constraints_case() == kPsdConstraint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraints_.psd_constraint_;
    }
    clear_has_constraints();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* InterferenceConstraint::release_psd_constraint() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
  if (constraints_case() == kPsdConstraint) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* temp = _impl_.constraints_.psd_constraint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraints_.psd_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint& InterferenceConstraint::_internal_psd_constraint() const {
  return constraints_case() == kPsdConstraint
      ? *_impl_.constraints_.psd_constraint_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PsdConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint& InterferenceConstraint::psd_constraint() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
  return _internal_psd_constraint();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* InterferenceConstraint::unsafe_arena_release_psd_constraint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
  if (constraints_case() == kPsdConstraint) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* temp = _impl_.constraints_.psd_constraint_;
    _impl_.constraints_.psd_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterferenceConstraint::unsafe_arena_set_allocated_psd_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* psd_constraint) {
  clear_constraints();
  if (psd_constraint) {
    set_has_psd_constraint();
    _impl_.constraints_.psd_constraint_ = psd_constraint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* InterferenceConstraint::_internal_mutable_psd_constraint() {
  if (constraints_case() != kPsdConstraint) {
    clear_constraints();
    set_has_psd_constraint();
    _impl_.constraints_.psd_constraint_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint >(GetArenaForAllocation());
  }
  return _impl_.constraints_.psd_constraint_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* InterferenceConstraint::mutable_psd_constraint() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* _msg = _internal_mutable_psd_constraint();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint pointing_constraint = 8 [json_name = "pointingConstraint"];
inline bool InterferenceConstraint::has_pointing_constraint() const {
  return constraints_case() == kPointingConstraint;
}
inline bool InterferenceConstraint::_internal_has_pointing_constraint() const {
  return constraints_case() == kPointingConstraint;
}
inline void InterferenceConstraint::set_has_pointing_constraint() {
  _impl_._oneof_case_[0] = kPointingConstraint;
}
inline void InterferenceConstraint::clear_pointing_constraint() {
  if (constraints_case() == kPointingConstraint) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.constraints_.pointing_constraint_;
    }
    clear_has_constraints();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* InterferenceConstraint::release_pointing_constraint() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
  if (constraints_case() == kPointingConstraint) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* temp = _impl_.constraints_.pointing_constraint_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraints_.pointing_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint& InterferenceConstraint::_internal_pointing_constraint() const {
  return constraints_case() == kPointingConstraint
      ? *_impl_.constraints_.pointing_constraint_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PointingConstraint_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint& InterferenceConstraint::pointing_constraint() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
  return _internal_pointing_constraint();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* InterferenceConstraint::unsafe_arena_release_pointing_constraint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
  if (constraints_case() == kPointingConstraint) {
    clear_has_constraints();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* temp = _impl_.constraints_.pointing_constraint_;
    _impl_.constraints_.pointing_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterferenceConstraint::unsafe_arena_set_allocated_pointing_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* pointing_constraint) {
  clear_constraints();
  if (pointing_constraint) {
    set_has_pointing_constraint();
    _impl_.constraints_.pointing_constraint_ = pointing_constraint;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* InterferenceConstraint::_internal_mutable_pointing_constraint() {
  if (constraints_case() != kPointingConstraint) {
    clear_constraints();
    set_has_pointing_constraint();
    _impl_.constraints_.pointing_constraint_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint >(GetArenaForAllocation());
  }
  return _impl_.constraints_.pointing_constraint_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* InterferenceConstraint::mutable_pointing_constraint() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* _msg = _internal_mutable_pointing_constraint();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
  return _msg;
}

// optional bool use_receiver_orientation = 9 [json_name = "useReceiverOrientation"];
inline bool InterferenceConstraint::has_use_receiver_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InterferenceConstraint::clear_use_receiver_orientation() {
  _impl_.use_receiver_orientation_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool InterferenceConstraint::use_receiver_orientation() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.use_receiver_orientation)
  return _internal_use_receiver_orientation();
}
inline void InterferenceConstraint::set_use_receiver_orientation(bool value) {
  _internal_set_use_receiver_orientation(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.use_receiver_orientation)
}
inline bool InterferenceConstraint::_internal_use_receiver_orientation() const {
  return _impl_.use_receiver_orientation_;
}
inline void InterferenceConstraint::_internal_set_use_receiver_orientation(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_receiver_orientation_ = value;
}

inline bool InterferenceConstraint::has_constraints() const {
  return constraints_case() != CONSTRAINTS_NOT_SET;
}
inline void InterferenceConstraint::clear_has_constraints() {
  _impl_._oneof_case_[0] = CONSTRAINTS_NOT_SET;
}
inline InterferenceConstraint::ConstraintsCase InterferenceConstraint::constraints_case() const {
  return InterferenceConstraint::ConstraintsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PfdConstraint_Band

// required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
inline bool PfdConstraint_Band::has_start_frequency_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PfdConstraint_Band::clear_start_frequency_mhz() {
  _impl_.start_frequency_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PfdConstraint_Band::start_frequency_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band.start_frequency_mhz)
  return _internal_start_frequency_mhz();
}
inline void PfdConstraint_Band::set_start_frequency_mhz(double value) {
  _internal_set_start_frequency_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band.start_frequency_mhz)
}
inline double PfdConstraint_Band::_internal_start_frequency_mhz() const {
  return _impl_.start_frequency_mhz_;
}
inline void PfdConstraint_Band::_internal_set_start_frequency_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_frequency_mhz_ = value;
}

// required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
inline bool PfdConstraint_Band::has_end_frequency_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PfdConstraint_Band::clear_end_frequency_mhz() {
  _impl_.end_frequency_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PfdConstraint_Band::end_frequency_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band.end_frequency_mhz)
  return _internal_end_frequency_mhz();
}
inline void PfdConstraint_Band::set_end_frequency_mhz(double value) {
  _internal_set_end_frequency_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band.end_frequency_mhz)
}
inline double PfdConstraint_Band::_internal_end_frequency_mhz() const {
  return _impl_.end_frequency_mhz_;
}
inline void PfdConstraint_Band::_internal_set_end_frequency_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_frequency_mhz_ = value;
}

// -------------------------------------------------------------------

// PfdConstraint

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band band = 1 [json_name = "band"];
inline bool PfdConstraint::has_band() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.band_ != nullptr);
  return value;
}
inline void PfdConstraint::clear_band() {
  if (_impl_.band_ != nullptr) _impl_.band_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band& PfdConstraint::_internal_band() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* p = _impl_.band_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraint_Band_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band& PfdConstraint::band() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.band)
  return _internal_band();
}
inline void PfdConstraint::unsafe_arena_set_allocated_band(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* band) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.band_);
  }
  _impl_.band_ = band;
  if (band) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.band)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* PfdConstraint::release_band() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* temp = _impl_.band_;
  _impl_.band_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* PfdConstraint::unsafe_arena_release_band() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.band)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* temp = _impl_.band_;
  _impl_.band_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* PfdConstraint::_internal_mutable_band() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.band_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band>(GetArenaForAllocation());
    _impl_.band_ = p;
  }
  return _impl_.band_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* PfdConstraint::mutable_band() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* _msg = _internal_mutable_band();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.band)
  return _msg;
}
inline void PfdConstraint::set_allocated_band(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band* band) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.band_;
  }
  if (band) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(band);
    if (message_arena != submessage_arena) {
      band = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.band_ = band;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.band)
}

// optional double received_pfd_dbw_per_sqm = 2 [json_name = "receivedPfdDbwPerSqm"];
inline bool PfdConstraint::has_received_pfd_dbw_per_sqm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PfdConstraint::clear_received_pfd_dbw_per_sqm() {
  _impl_.received_pfd_dbw_per_sqm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PfdConstraint::received_pfd_dbw_per_sqm() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.received_pfd_dbw_per_sqm)
  return _internal_received_pfd_dbw_per_sqm();
}
inline void PfdConstraint::set_received_pfd_dbw_per_sqm(double value) {
  _internal_set_received_pfd_dbw_per_sqm(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.received_pfd_dbw_per_sqm)
}
inline double PfdConstraint::_internal_received_pfd_dbw_per_sqm() const {
  return _impl_.received_pfd_dbw_per_sqm_;
}
inline void PfdConstraint::_internal_set_received_pfd_dbw_per_sqm(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.received_pfd_dbw_per_sqm_ = value;
}

// optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
inline bool PfdConstraint::has_resolution_bw_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PfdConstraint::clear_resolution_bw_mhz() {
  _impl_.resolution_bw_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PfdConstraint::resolution_bw_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.resolution_bw_mhz)
  return _internal_resolution_bw_mhz();
}
inline void PfdConstraint::set_resolution_bw_mhz(double value) {
  _internal_set_resolution_bw_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.resolution_bw_mhz)
}
inline double PfdConstraint::_internal_resolution_bw_mhz() const {
  return _impl_.resolution_bw_mhz_;
}
inline void PfdConstraint::_internal_set_resolution_bw_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resolution_bw_mhz_ = value;
}

// optional double time_fraction = 4 [json_name = "timeFraction"];
inline bool PfdConstraint::has_time_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PfdConstraint::clear_time_fraction() {
  _impl_.time_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PfdConstraint::time_fraction() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.time_fraction)
  return _internal_time_fraction();
}
inline void PfdConstraint::set_time_fraction(double value) {
  _internal_set_time_fraction(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.time_fraction)
}
inline double PfdConstraint::_internal_time_fraction() const {
  return _impl_.time_fraction_;
}
inline void PfdConstraint::_internal_set_time_fraction(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.time_fraction_ = value;
}

// -------------------------------------------------------------------

// PfdConstraints

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint pfd_constraints = 1 [json_name = "pfdConstraints"];
inline int PfdConstraints::_internal_pfd_constraints_size() const {
  return _impl_.pfd_constraints_.size();
}
inline int PfdConstraints::pfd_constraints_size() const {
  return _internal_pfd_constraints_size();
}
inline void PfdConstraints::clear_pfd_constraints() {
  _internal_mutable_pfd_constraints()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* PfdConstraints::mutable_pfd_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints.pfd_constraints)
  return _internal_mutable_pfd_constraints()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >*
PfdConstraints::mutable_pfd_constraints() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints.pfd_constraints)
  return _internal_mutable_pfd_constraints();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint& PfdConstraints::_internal_pfd_constraints(int index) const {
  return _internal_pfd_constraints().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint& PfdConstraints::pfd_constraints(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints.pfd_constraints)
  return _internal_pfd_constraints(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* PfdConstraints::_internal_add_pfd_constraints() {
  return _internal_mutable_pfd_constraints()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* PfdConstraints::add_pfd_constraints() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint* _add = _internal_add_pfd_constraints();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints.pfd_constraints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >&
PfdConstraints::pfd_constraints() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints.pfd_constraints)
  return _internal_pfd_constraints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint>&
PfdConstraints::_internal_pfd_constraints() const {
  return _impl_.pfd_constraints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint>*
PfdConstraints::_internal_mutable_pfd_constraints() {
  return &_impl_.pfd_constraints_;
}

// -------------------------------------------------------------------

// PsdConstraint_ScmMask

// required double ref_frequency_mhz = 1 [json_name = "refFrequencyMhz"];
inline bool PsdConstraint_ScmMask::has_ref_frequency_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PsdConstraint_ScmMask::clear_ref_frequency_mhz() {
  _impl_.ref_frequency_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PsdConstraint_ScmMask::ref_frequency_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.ref_frequency_mhz)
  return _internal_ref_frequency_mhz();
}
inline void PsdConstraint_ScmMask::set_ref_frequency_mhz(double value) {
  _internal_set_ref_frequency_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.ref_frequency_mhz)
}
inline double PsdConstraint_ScmMask::_internal_ref_frequency_mhz() const {
  return _impl_.ref_frequency_mhz_;
}
inline void PsdConstraint_ScmMask::_internal_set_ref_frequency_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ref_frequency_mhz_ = value;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint control_points = 2 [json_name = "controlPoints"];
inline int PsdConstraint_ScmMask::_internal_control_points_size() const {
  return _impl_.control_points_.size();
}
inline int PsdConstraint_ScmMask::control_points_size() const {
  return _internal_control_points_size();
}
inline void PsdConstraint_ScmMask::clear_control_points() {
  _internal_mutable_control_points()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* PsdConstraint_ScmMask::mutable_control_points(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.control_points)
  return _internal_mutable_control_points()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >*
PsdConstraint_ScmMask::mutable_control_points() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.control_points)
  return _internal_mutable_control_points();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint& PsdConstraint_ScmMask::_internal_control_points(int index) const {
  return _internal_control_points().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint& PsdConstraint_ScmMask::control_points(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.control_points)
  return _internal_control_points(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* PsdConstraint_ScmMask::_internal_add_control_points() {
  return _internal_mutable_control_points()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* PsdConstraint_ScmMask::add_control_points() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint* _add = _internal_add_control_points();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.control_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >&
PsdConstraint_ScmMask::control_points() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask.control_points)
  return _internal_control_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint>&
PsdConstraint_ScmMask::_internal_control_points() const {
  return _impl_.control_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint>*
PsdConstraint_ScmMask::_internal_mutable_control_points() {
  return &_impl_.control_points_;
}

// -------------------------------------------------------------------

// PsdConstraint_ControlPoint

// required double frequency_mhz = 1 [json_name = "frequencyMhz"];
inline bool PsdConstraint_ControlPoint::has_frequency_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PsdConstraint_ControlPoint::clear_frequency_mhz() {
  _impl_.frequency_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PsdConstraint_ControlPoint::frequency_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint.frequency_mhz)
  return _internal_frequency_mhz();
}
inline void PsdConstraint_ControlPoint::set_frequency_mhz(double value) {
  _internal_set_frequency_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint.frequency_mhz)
}
inline double PsdConstraint_ControlPoint::_internal_frequency_mhz() const {
  return _impl_.frequency_mhz_;
}
inline void PsdConstraint_ControlPoint::_internal_set_frequency_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.frequency_mhz_ = value;
}

// required double relative_power_db = 2 [json_name = "relativePowerDb"];
inline bool PsdConstraint_ControlPoint::has_relative_power_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PsdConstraint_ControlPoint::clear_relative_power_db() {
  _impl_.relative_power_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PsdConstraint_ControlPoint::relative_power_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint.relative_power_db)
  return _internal_relative_power_db();
}
inline void PsdConstraint_ControlPoint::set_relative_power_db(double value) {
  _internal_set_relative_power_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint.relative_power_db)
}
inline double PsdConstraint_ControlPoint::_internal_relative_power_db() const {
  return _impl_.relative_power_db_;
}
inline void PsdConstraint_ControlPoint::_internal_set_relative_power_db(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.relative_power_db_ = value;
}

// -------------------------------------------------------------------

// PsdConstraint

// optional double reference_power_dbw = 1 [json_name = "referencePowerDbw"];
inline bool PsdConstraint::has_reference_power_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PsdConstraint::clear_reference_power_dbw() {
  _impl_.reference_power_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PsdConstraint::reference_power_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.reference_power_dbw)
  return _internal_reference_power_dbw();
}
inline void PsdConstraint::set_reference_power_dbw(double value) {
  _internal_set_reference_power_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.reference_power_dbw)
}
inline double PsdConstraint::_internal_reference_power_dbw() const {
  return _impl_.reference_power_dbw_;
}
inline void PsdConstraint::_internal_set_reference_power_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reference_power_dbw_ = value;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask psd_mask = 2 [json_name = "psdMask"];
inline bool PsdConstraint::has_psd_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.psd_mask_ != nullptr);
  return value;
}
inline void PsdConstraint::clear_psd_mask() {
  if (_impl_.psd_mask_ != nullptr) _impl_.psd_mask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask& PsdConstraint::_internal_psd_mask() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* p = _impl_.psd_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_PsdConstraint_ScmMask_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask& PsdConstraint::psd_mask() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.psd_mask)
  return _internal_psd_mask();
}
inline void PsdConstraint::unsafe_arena_set_allocated_psd_mask(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* psd_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.psd_mask_);
  }
  _impl_.psd_mask_ = psd_mask;
  if (psd_mask) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.psd_mask)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* PsdConstraint::release_psd_mask() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* temp = _impl_.psd_mask_;
  _impl_.psd_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* PsdConstraint::unsafe_arena_release_psd_mask() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.psd_mask)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* temp = _impl_.psd_mask_;
  _impl_.psd_mask_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* PsdConstraint::_internal_mutable_psd_mask() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.psd_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask>(GetArenaForAllocation());
    _impl_.psd_mask_ = p;
  }
  return _impl_.psd_mask_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* PsdConstraint::mutable_psd_mask() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* _msg = _internal_mutable_psd_mask();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.psd_mask)
  return _msg;
}
inline void PsdConstraint::set_allocated_psd_mask(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask* psd_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.psd_mask_;
  }
  if (psd_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(psd_mask);
    if (message_arena != submessage_arena) {
      psd_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, psd_mask, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.psd_mask_ = psd_mask;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.psd_mask)
}

// optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
inline bool PsdConstraint::has_resolution_bw_mhz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PsdConstraint::clear_resolution_bw_mhz() {
  _impl_.resolution_bw_mhz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PsdConstraint::resolution_bw_mhz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.resolution_bw_mhz)
  return _internal_resolution_bw_mhz();
}
inline void PsdConstraint::set_resolution_bw_mhz(double value) {
  _internal_set_resolution_bw_mhz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.resolution_bw_mhz)
}
inline double PsdConstraint::_internal_resolution_bw_mhz() const {
  return _impl_.resolution_bw_mhz_;
}
inline void PsdConstraint::_internal_set_resolution_bw_mhz(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resolution_bw_mhz_ = value;
}

// -------------------------------------------------------------------

// PointingConstraint

// optional double min_angle_deg = 1 [json_name = "minAngleDeg"];
inline bool PointingConstraint::has_min_angle_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PointingConstraint::clear_min_angle_deg() {
  _impl_.min_angle_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PointingConstraint::min_angle_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint.min_angle_deg)
  return _internal_min_angle_deg();
}
inline void PointingConstraint::set_min_angle_deg(double value) {
  _internal_set_min_angle_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint.min_angle_deg)
}
inline double PointingConstraint::_internal_min_angle_deg() const {
  return _impl_.min_angle_deg_;
}
inline void PointingConstraint::_internal_set_min_angle_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_angle_deg_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_2epb_2eh
