// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/network_element.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/time.pb.h"
#include "api/common/wireless_transceiver.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class NetworkInterface;
struct NetworkInterfaceDefaultTypeInternal;
extern NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
class NetworkInterface_Impairment;
struct NetworkInterface_ImpairmentDefaultTypeInternal;
extern NetworkInterface_ImpairmentDefaultTypeInternal _NetworkInterface_Impairment_default_instance_;
class NetworkInterface_LocalId;
struct NetworkInterface_LocalIdDefaultTypeInternal;
extern NetworkInterface_LocalIdDefaultTypeInternal _NetworkInterface_LocalId_default_instance_;
class NetworkNode;
struct NetworkNodeDefaultTypeInternal;
extern NetworkNodeDefaultTypeInternal _NetworkNode_default_instance_;
class NetworkNode_SignalPowerBudget;
struct NetworkNode_SignalPowerBudgetDefaultTypeInternal;
extern NetworkNode_SignalPowerBudgetDefaultTypeInternal _NetworkNode_SignalPowerBudget_default_instance_;
class NetworkNode_Storage;
struct NetworkNode_StorageDefaultTypeInternal;
extern NetworkNode_StorageDefaultTypeInternal _NetworkNode_Storage_default_instance_;
class SdnAgent;
struct SdnAgentDefaultTypeInternal;
extern SdnAgentDefaultTypeInternal _SdnAgent_default_instance_;
class SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse;
struct SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUseDefaultTypeInternal;
extern SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUseDefaultTypeInternal _SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse_default_instance_;
class WiredDevice;
struct WiredDeviceDefaultTypeInternal;
extern WiredDeviceDefaultTypeInternal _WiredDevice_default_instance_;
class WirelessDevice;
struct WirelessDeviceDefaultTypeInternal;
extern WirelessDeviceDefaultTypeInternal _WirelessDevice_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
enum SdnAgent_CdpiProtocol : int {
  SdnAgent_CdpiProtocol_UNKNOWN = 0,
  SdnAgent_CdpiProtocol_AIRFLOW = 1,
};

bool SdnAgent_CdpiProtocol_IsValid(int value);
constexpr SdnAgent_CdpiProtocol SdnAgent_CdpiProtocol_CdpiProtocol_MIN = static_cast<SdnAgent_CdpiProtocol>(0);
constexpr SdnAgent_CdpiProtocol SdnAgent_CdpiProtocol_CdpiProtocol_MAX = static_cast<SdnAgent_CdpiProtocol>(1);
constexpr int SdnAgent_CdpiProtocol_CdpiProtocol_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SdnAgent_CdpiProtocol_descriptor();
template <typename T>
const std::string& SdnAgent_CdpiProtocol_Name(T value) {
  static_assert(std::is_same<T, SdnAgent_CdpiProtocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CdpiProtocol_Name().");
  return SdnAgent_CdpiProtocol_Name(static_cast<SdnAgent_CdpiProtocol>(value));
}
template <>
inline const std::string& SdnAgent_CdpiProtocol_Name(SdnAgent_CdpiProtocol value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SdnAgent_CdpiProtocol_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SdnAgent_CdpiProtocol_Parse(absl::string_view name, SdnAgent_CdpiProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SdnAgent_CdpiProtocol>(
      SdnAgent_CdpiProtocol_descriptor(), name, value);
}
enum NetworkInterface_Impairment_Type : int {
  NetworkInterface_Impairment_Type_DEFAULT_UNUSABLE = 0,
  NetworkInterface_Impairment_Type_UNRELIABLE = 1,
};

bool NetworkInterface_Impairment_Type_IsValid(int value);
constexpr NetworkInterface_Impairment_Type NetworkInterface_Impairment_Type_Type_MIN = static_cast<NetworkInterface_Impairment_Type>(0);
constexpr NetworkInterface_Impairment_Type NetworkInterface_Impairment_Type_Type_MAX = static_cast<NetworkInterface_Impairment_Type>(1);
constexpr int NetworkInterface_Impairment_Type_Type_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NetworkInterface_Impairment_Type_descriptor();
template <typename T>
const std::string& NetworkInterface_Impairment_Type_Name(T value) {
  static_assert(std::is_same<T, NetworkInterface_Impairment_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return NetworkInterface_Impairment_Type_Name(static_cast<NetworkInterface_Impairment_Type>(value));
}
template <>
inline const std::string& NetworkInterface_Impairment_Type_Name(NetworkInterface_Impairment_Type value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<NetworkInterface_Impairment_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NetworkInterface_Impairment_Type_Parse(absl::string_view name, NetworkInterface_Impairment_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkInterface_Impairment_Type>(
      NetworkInterface_Impairment_Type_descriptor(), name, value);
}
enum NetworkInterface_Mode : int {
  NetworkInterface_Mode_PROMISCUOUS = 0,
  NetworkInterface_Mode_NON_PROMISCUOUS = 1,
};

bool NetworkInterface_Mode_IsValid(int value);
constexpr NetworkInterface_Mode NetworkInterface_Mode_Mode_MIN = static_cast<NetworkInterface_Mode>(0);
constexpr NetworkInterface_Mode NetworkInterface_Mode_Mode_MAX = static_cast<NetworkInterface_Mode>(1);
constexpr int NetworkInterface_Mode_Mode_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NetworkInterface_Mode_descriptor();
template <typename T>
const std::string& NetworkInterface_Mode_Name(T value) {
  static_assert(std::is_same<T, NetworkInterface_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return NetworkInterface_Mode_Name(static_cast<NetworkInterface_Mode>(value));
}
template <>
inline const std::string& NetworkInterface_Mode_Name(NetworkInterface_Mode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<NetworkInterface_Mode_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NetworkInterface_Mode_Parse(absl::string_view name, NetworkInterface_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkInterface_Mode>(
      NetworkInterface_Mode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NetworkNode_SignalPowerBudget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget) */ {
 public:
  inline NetworkNode_SignalPowerBudget() : NetworkNode_SignalPowerBudget(nullptr) {}
  ~NetworkNode_SignalPowerBudget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkNode_SignalPowerBudget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkNode_SignalPowerBudget(const NetworkNode_SignalPowerBudget& from);
  NetworkNode_SignalPowerBudget(NetworkNode_SignalPowerBudget&& from) noexcept
    : NetworkNode_SignalPowerBudget() {
    *this = ::std::move(from);
  }

  inline NetworkNode_SignalPowerBudget& operator=(const NetworkNode_SignalPowerBudget& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkNode_SignalPowerBudget& operator=(NetworkNode_SignalPowerBudget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkNode_SignalPowerBudget& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkNode_SignalPowerBudget* internal_default_instance() {
    return reinterpret_cast<const NetworkNode_SignalPowerBudget*>(
               &_NetworkNode_SignalPowerBudget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetworkNode_SignalPowerBudget& a, NetworkNode_SignalPowerBudget& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkNode_SignalPowerBudget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkNode_SignalPowerBudget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkNode_SignalPowerBudget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkNode_SignalPowerBudget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkNode_SignalPowerBudget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkNode_SignalPowerBudget& from) {
    NetworkNode_SignalPowerBudget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkNode_SignalPowerBudget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget";
  }
  protected:
  explicit NetworkNode_SignalPowerBudget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
    kAvailableSignalPowerWattsFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::aalyria::spacetime::api::common::TimeInterval& interval() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TimeInterval* release_interval();
  ::aalyria::spacetime::api::common::TimeInterval* mutable_interval();
  void set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval);
  private:
  const ::aalyria::spacetime::api::common::TimeInterval& _internal_interval() const;
  ::aalyria::spacetime::api::common::TimeInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::aalyria::spacetime::api::common::TimeInterval* interval);
  ::aalyria::spacetime::api::common::TimeInterval* unsafe_arena_release_interval();
  // optional double available_signal_power_watts = 2 [json_name = "availableSignalPowerWatts"];
  bool has_available_signal_power_watts() const;
  void clear_available_signal_power_watts() ;
  double available_signal_power_watts() const;
  void set_available_signal_power_watts(double value);

  private:
  double _internal_available_signal_power_watts() const;
  void _internal_set_available_signal_power_watts(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TimeInterval* interval_;
    double available_signal_power_watts_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class NetworkNode_Storage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage) */ {
 public:
  inline NetworkNode_Storage() : NetworkNode_Storage(nullptr) {}
  ~NetworkNode_Storage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkNode_Storage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkNode_Storage(const NetworkNode_Storage& from);
  NetworkNode_Storage(NetworkNode_Storage&& from) noexcept
    : NetworkNode_Storage() {
    *this = ::std::move(from);
  }

  inline NetworkNode_Storage& operator=(const NetworkNode_Storage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkNode_Storage& operator=(NetworkNode_Storage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkNode_Storage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkNode_Storage* internal_default_instance() {
    return reinterpret_cast<const NetworkNode_Storage*>(
               &_NetworkNode_Storage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NetworkNode_Storage& a, NetworkNode_Storage& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkNode_Storage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkNode_Storage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkNode_Storage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkNode_Storage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkNode_Storage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkNode_Storage& from) {
    NetworkNode_Storage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkNode_Storage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage";
  }
  protected:
  explicit NetworkNode_Storage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableBytesFieldNumber = 1,
  };
  // optional int64 available_bytes = 1 [json_name = "availableBytes"];
  bool has_available_bytes() const;
  void clear_available_bytes() ;
  ::int64_t available_bytes() const;
  void set_available_bytes(::int64_t value);

  private:
  ::int64_t _internal_available_bytes() const;
  void _internal_set_available_bytes(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t available_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class NetworkNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode) */ {
 public:
  inline NetworkNode() : NetworkNode(nullptr) {}
  ~NetworkNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkNode(const NetworkNode& from);
  NetworkNode(NetworkNode&& from) noexcept
    : NetworkNode() {
    *this = ::std::move(from);
  }

  inline NetworkNode& operator=(const NetworkNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkNode& operator=(NetworkNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkNode* internal_default_instance() {
    return reinterpret_cast<const NetworkNode*>(
               &_NetworkNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NetworkNode& a, NetworkNode& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkNode& from) {
    NetworkNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode";
  }
  protected:
  explicit NetworkNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkNode_SignalPowerBudget SignalPowerBudget;
  typedef NetworkNode_Storage Storage;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeInterfaceFieldNumber = 4,
    kSubnetFieldNumber = 8,
    kPowerBudgetFieldNumber = 9,
    kNodeIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 7,
    kAgentFieldNumber = 5,
    kStorageFieldNumber = 10,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface node_interface = 4 [json_name = "nodeInterface"];
  int node_interface_size() const;
  private:
  int _internal_node_interface_size() const;

  public:
  void clear_node_interface() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* mutable_node_interface(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface >*
      mutable_node_interface();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface& _internal_node_interface(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* _internal_add_node_interface();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface>& _internal_node_interface() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface>* _internal_mutable_node_interface();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface& node_interface(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* add_node_interface();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface >&
      node_interface() const;
  // repeated string subnet = 8 [json_name = "subnet"];
  int subnet_size() const;
  private:
  int _internal_subnet_size() const;

  public:
  void clear_subnet() ;
  const std::string& subnet(int index) const;
  std::string* mutable_subnet(int index);
  void set_subnet(int index, const std::string& value);
  void set_subnet(int index, std::string&& value);
  void set_subnet(int index, const char* value);
  void set_subnet(int index, const char* value, std::size_t size);
  void set_subnet(int index, absl::string_view value);
  std::string* add_subnet();
  void add_subnet(const std::string& value);
  void add_subnet(std::string&& value);
  void add_subnet(const char* value);
  void add_subnet(const char* value, std::size_t size);
  void add_subnet(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subnet() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subnet();

  private:
  const std::string& _internal_subnet(int index) const;
  std::string* _internal_add_subnet();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subnet() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subnet();

  public:
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget power_budget = 9 [json_name = "powerBudget"];
  int power_budget_size() const;
  private:
  int _internal_power_budget_size() const;

  public:
  void clear_power_budget() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* mutable_power_budget(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget >*
      mutable_power_budget();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget& _internal_power_budget(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* _internal_add_power_budget();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget>& _internal_power_budget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget>* _internal_mutable_power_budget();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget& power_budget(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* add_power_budget();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget >&
      power_budget() const;
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string type = 7 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent agent = 5 [json_name = "agent"];
  bool has_agent() const;
  void clear_agent() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent& agent() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* release_agent();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* mutable_agent();
  void set_allocated_agent(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* agent);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent& _internal_agent() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* _internal_mutable_agent();
  public:
  void unsafe_arena_set_allocated_agent(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* agent);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* unsafe_arena_release_agent();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage storage = 10 [json_name = "storage"];
  bool has_storage() const;
  void clear_storage() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage& storage() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* release_storage();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* mutable_storage();
  void set_allocated_storage(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* storage);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage& _internal_storage() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* storage);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* unsafe_arena_release_storage();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface > node_interface_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subnet_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget > power_budget_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* agent_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* storage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse, 
    ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse, 
    ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse& other);
  static const SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse*>(&_SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};
// -------------------------------------------------------------------

class SdnAgent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent) */ {
 public:
  inline SdnAgent() : SdnAgent(nullptr) {}
  ~SdnAgent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SdnAgent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdnAgent(const SdnAgent& from);
  SdnAgent(SdnAgent&& from) noexcept
    : SdnAgent() {
    *this = ::std::move(from);
  }

  inline SdnAgent& operator=(const SdnAgent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdnAgent& operator=(SdnAgent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdnAgent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdnAgent* internal_default_instance() {
    return reinterpret_cast<const SdnAgent*>(
               &_SdnAgent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SdnAgent& a, SdnAgent& b) {
    a.Swap(&b);
  }
  inline void Swap(SdnAgent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdnAgent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdnAgent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdnAgent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdnAgent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdnAgent& from) {
    SdnAgent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdnAgent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent";
  }
  protected:
  explicit SdnAgent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  using CdpiProtocol = SdnAgent_CdpiProtocol;
  static constexpr CdpiProtocol UNKNOWN = SdnAgent_CdpiProtocol_UNKNOWN;
  static constexpr CdpiProtocol AIRFLOW = SdnAgent_CdpiProtocol_AIRFLOW;
  static inline bool CdpiProtocol_IsValid(int value) {
    return SdnAgent_CdpiProtocol_IsValid(value);
  }
  static constexpr CdpiProtocol CdpiProtocol_MIN = SdnAgent_CdpiProtocol_CdpiProtocol_MIN;
  static constexpr CdpiProtocol CdpiProtocol_MAX = SdnAgent_CdpiProtocol_CdpiProtocol_MAX;
  static constexpr int CdpiProtocol_ARRAYSIZE = SdnAgent_CdpiProtocol_CdpiProtocol_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CdpiProtocol_descriptor() {
    return SdnAgent_CdpiProtocol_descriptor();
  }
  template <typename T>
  static inline const std::string& CdpiProtocol_Name(T value) {
    return SdnAgent_CdpiProtocol_Name(value);
  }
  static inline bool CdpiProtocol_Parse(absl::string_view name, CdpiProtocol* value) {
    return SdnAgent_CdpiProtocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumControlPlaneLatencyFieldNumber = 3,
    kGoogleUserIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // map<uint32, .google.protobuf.Duration> maximum_control_plane_latency = 3 [json_name = "maximumControlPlaneLatency"];
  int maximum_control_plane_latency_size() const;
  private:
  int _internal_maximum_control_plane_latency_size() const;

  public:
  void clear_maximum_control_plane_latency() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >&
      _internal_maximum_control_plane_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >*
      _internal_mutable_maximum_control_plane_latency();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >&
      maximum_control_plane_latency() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >*
      mutable_maximum_control_plane_latency();
  // optional string google_user_id = 2 [json_name = "googleUserId"];
  bool has_google_user_id() const;
  void clear_google_user_id() ;
  const std::string& google_user_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_google_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_google_user_id();
  PROTOBUF_NODISCARD std::string* release_google_user_id();
  void set_allocated_google_user_id(std::string* ptr);

  private:
  const std::string& _internal_google_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_google_user_id(
      const std::string& value);
  std::string* _internal_mutable_google_user_id();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.CdpiProtocol type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SdnAgent_MaximumControlPlaneLatencyEntry_DoNotUse,
        ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> maximum_control_plane_latency_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr google_user_id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class NetworkInterface_LocalId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId) */ {
 public:
  inline NetworkInterface_LocalId() : NetworkInterface_LocalId(nullptr) {}
  ~NetworkInterface_LocalId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkInterface_LocalId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkInterface_LocalId(const NetworkInterface_LocalId& from);
  NetworkInterface_LocalId(NetworkInterface_LocalId&& from) noexcept
    : NetworkInterface_LocalId() {
    *this = ::std::move(from);
  }

  inline NetworkInterface_LocalId& operator=(const NetworkInterface_LocalId& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkInterface_LocalId& operator=(NetworkInterface_LocalId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkInterface_LocalId& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkInterface_LocalId* internal_default_instance() {
    return reinterpret_cast<const NetworkInterface_LocalId*>(
               &_NetworkInterface_LocalId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NetworkInterface_LocalId& a, NetworkInterface_LocalId& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkInterface_LocalId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkInterface_LocalId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkInterface_LocalId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkInterface_LocalId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkInterface_LocalId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkInterface_LocalId& from) {
    NetworkInterface_LocalId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkInterface_LocalId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId";
  }
  protected:
  explicit NetworkInterface_LocalId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // optional string type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional int32 index = 2 [json_name = "index"];
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class NetworkInterface_Impairment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment) */ {
 public:
  inline NetworkInterface_Impairment() : NetworkInterface_Impairment(nullptr) {}
  ~NetworkInterface_Impairment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkInterface_Impairment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkInterface_Impairment(const NetworkInterface_Impairment& from);
  NetworkInterface_Impairment(NetworkInterface_Impairment&& from) noexcept
    : NetworkInterface_Impairment() {
    *this = ::std::move(from);
  }

  inline NetworkInterface_Impairment& operator=(const NetworkInterface_Impairment& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkInterface_Impairment& operator=(NetworkInterface_Impairment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkInterface_Impairment& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkInterface_Impairment* internal_default_instance() {
    return reinterpret_cast<const NetworkInterface_Impairment*>(
               &_NetworkInterface_Impairment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NetworkInterface_Impairment& a, NetworkInterface_Impairment& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkInterface_Impairment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkInterface_Impairment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkInterface_Impairment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkInterface_Impairment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkInterface_Impairment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkInterface_Impairment& from) {
    NetworkInterface_Impairment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkInterface_Impairment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment";
  }
  protected:
  explicit NetworkInterface_Impairment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = NetworkInterface_Impairment_Type;
  static constexpr Type DEFAULT_UNUSABLE = NetworkInterface_Impairment_Type_DEFAULT_UNUSABLE;
  static constexpr Type UNRELIABLE = NetworkInterface_Impairment_Type_UNRELIABLE;
  static inline bool Type_IsValid(int value) {
    return NetworkInterface_Impairment_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = NetworkInterface_Impairment_Type_Type_MIN;
  static constexpr Type Type_MAX = NetworkInterface_Impairment_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = NetworkInterface_Impairment_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
    return NetworkInterface_Impairment_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return NetworkInterface_Impairment_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return NetworkInterface_Impairment_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 2,
    kReasonFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kTimestampUsecFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string app_id = 2 [json_name = "appId"];
  bool has_app_id() const;
  void clear_app_id() ;
  const std::string& app_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // optional string reason = 4 [json_name = "reason"];
  bool has_reason() const;
  void clear_reason() ;
  const std::string& reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* ptr);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // optional .google.protobuf.Any details = 5 [json_name = "details"];
  bool has_details() const;
  void clear_details() ;
  const ::PROTOBUF_NAMESPACE_ID::Any& details() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_details();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_details();
  void set_allocated_details(::PROTOBUF_NAMESPACE_ID::Any* details);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::PROTOBUF_NAMESPACE_ID::Any* details);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_details();
  // optional int64 timestamp_usec = 3 [json_name = "timestampUsec"];
  bool has_timestamp_usec() const;
  void clear_timestamp_usec() ;
  ::int64_t timestamp_usec() const;
  void set_timestamp_usec(::int64_t value);

  private:
  ::int64_t _internal_timestamp_usec() const;
  void _internal_set_timestamp_usec(::int64_t value);

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.Type type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type type() const;
  void set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type _internal_type() const;
  void _internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::Any* details_;
    ::int64_t timestamp_usec_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class NetworkInterface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface) */ {
 public:
  inline NetworkInterface() : NetworkInterface(nullptr) {}
  ~NetworkInterface() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkInterface(const NetworkInterface& from);
  NetworkInterface(NetworkInterface&& from) noexcept
    : NetworkInterface() {
    *this = ::std::move(from);
  }

  inline NetworkInterface& operator=(const NetworkInterface& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkInterface& operator=(NetworkInterface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkInterface& default_instance() {
    return *internal_default_instance();
  }
  enum InterfaceMediumCase {
    kWired = 4,
    kWireless = 6,
    INTERFACE_MEDIUM_NOT_SET = 0,
  };

  static inline const NetworkInterface* internal_default_instance() {
    return reinterpret_cast<const NetworkInterface*>(
               &_NetworkInterface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NetworkInterface& a, NetworkInterface& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkInterface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkInterface* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkInterface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkInterface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkInterface& from) {
    NetworkInterface::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkInterface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface";
  }
  protected:
  explicit NetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkInterface_LocalId LocalId;
  typedef NetworkInterface_Impairment Impairment;

  using Mode = NetworkInterface_Mode;
  static constexpr Mode PROMISCUOUS = NetworkInterface_Mode_PROMISCUOUS;
  static constexpr Mode NON_PROMISCUOUS = NetworkInterface_Mode_NON_PROMISCUOUS;
  static inline bool Mode_IsValid(int value) {
    return NetworkInterface_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = NetworkInterface_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = NetworkInterface_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = NetworkInterface_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor() {
    return NetworkInterface_Mode_descriptor();
  }
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return NetworkInterface_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return NetworkInterface_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocalIdFieldNumber = 3,
    kOperationalImpairmentFieldNumber = 16,
    kInterfaceIdFieldNumber = 1,
    kIpAddressFieldNumber = 14,
    kEthernetAddressFieldNumber = 15,
    kRxModeFieldNumber = 8,
    kWiredFieldNumber = 4,
    kWirelessFieldNumber = 6,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId local_id = 3 [json_name = "localId"];
  int local_id_size() const;
  private:
  int _internal_local_id_size() const;

  public:
  void clear_local_id() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* mutable_local_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId >*
      mutable_local_id();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId& _internal_local_id(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* _internal_add_local_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId>& _internal_local_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId>* _internal_mutable_local_id();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId& local_id(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* add_local_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId >&
      local_id() const;
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment operational_impairment = 16 [json_name = "operationalImpairment"];
  int operational_impairment_size() const;
  private:
  int _internal_operational_impairment_size() const;

  public:
  void clear_operational_impairment() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* mutable_operational_impairment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment >*
      mutable_operational_impairment();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment& _internal_operational_impairment(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* _internal_add_operational_impairment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment>& _internal_operational_impairment() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment>* _internal_mutable_operational_impairment();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment& operational_impairment(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* add_operational_impairment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment >&
      operational_impairment() const;
  // optional string interface_id = 1 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const std::string& interface_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interface_id(Arg_&& arg, Args_... args);
  std::string* mutable_interface_id();
  PROTOBUF_NODISCARD std::string* release_interface_id();
  void set_allocated_interface_id(std::string* ptr);

  private:
  const std::string& _internal_interface_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_id(
      const std::string& value);
  std::string* _internal_mutable_interface_id();

  public:
  // optional string ip_address = 14 [json_name = "ipAddress"];
  bool has_ip_address() const;
  void clear_ip_address() ;
  const std::string& ip_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ptr);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // optional string ethernet_address = 15 [json_name = "ethernetAddress"];
  bool has_ethernet_address() const;
  void clear_ethernet_address() ;
  const std::string& ethernet_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ethernet_address(Arg_&& arg, Args_... args);
  std::string* mutable_ethernet_address();
  PROTOBUF_NODISCARD std::string* release_ethernet_address();
  void set_allocated_ethernet_address(std::string* ptr);

  private:
  const std::string& _internal_ethernet_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ethernet_address(
      const std::string& value);
  std::string* _internal_mutable_ethernet_address();

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Mode rx_mode = 8 [json_name = "rxMode"];
  bool has_rx_mode() const;
  void clear_rx_mode() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode rx_mode() const;
  void set_rx_mode(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode _internal_rx_mode() const;
  void _internal_set_rx_mode(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode value);

  public:
  // .aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice wired = 4 [json_name = "wired"];
  bool has_wired() const;
  private:
  bool _internal_has_wired() const;

  public:
  void clear_wired() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice& wired() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* release_wired();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* mutable_wired();
  void set_allocated_wired(::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* wired);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice& _internal_wired() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* _internal_mutable_wired();
  public:
  void unsafe_arena_set_allocated_wired(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* wired);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* unsafe_arena_release_wired();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice wireless = 6 [json_name = "wireless"];
  bool has_wireless() const;
  private:
  bool _internal_has_wireless() const;

  public:
  void clear_wireless() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice& wireless() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* release_wireless();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* mutable_wireless();
  void set_allocated_wireless(::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* wireless);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice& _internal_wireless() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* _internal_mutable_wireless();
  public:
  void unsafe_arena_set_allocated_wireless(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* wireless);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* unsafe_arena_release_wireless();
  void clear_interface_medium();
  InterfaceMediumCase interface_medium_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface)
 private:
  class _Internal;
  void set_has_wired();
  void set_has_wireless();

  inline bool has_interface_medium() const;
  inline void clear_has_interface_medium();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId > local_id_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment > operational_impairment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethernet_address_;
    int rx_mode_;
    union InterfaceMediumUnion {
      constexpr InterfaceMediumUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* wired_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* wireless_;
    } interface_medium_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class WiredDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice) */ {
 public:
  inline WiredDevice() : WiredDevice(nullptr) {}
  ~WiredDevice() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WiredDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WiredDevice(const WiredDevice& from);
  WiredDevice(WiredDevice&& from) noexcept
    : WiredDevice() {
    *this = ::std::move(from);
  }

  inline WiredDevice& operator=(const WiredDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline WiredDevice& operator=(WiredDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WiredDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const WiredDevice* internal_default_instance() {
    return reinterpret_cast<const WiredDevice*>(
               &_WiredDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WiredDevice& a, WiredDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(WiredDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WiredDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WiredDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WiredDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WiredDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WiredDevice& from) {
    WiredDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WiredDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice";
  }
  protected:
  explicit WiredDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformIdFieldNumber = 2,
    kMaxDataRateBpsFieldNumber = 1,
  };
  // optional string platform_id = 2 [json_name = "platformId"];
  bool has_platform_id() const;
  void clear_platform_id() ;
  const std::string& platform_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform_id(Arg_&& arg, Args_... args);
  std::string* mutable_platform_id();
  PROTOBUF_NODISCARD std::string* release_platform_id();
  void set_allocated_platform_id(std::string* ptr);

  private:
  const std::string& _internal_platform_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_id(
      const std::string& value);
  std::string* _internal_mutable_platform_id();

  public:
  // optional double max_data_rate_bps = 1 [json_name = "maxDataRateBps"];
  bool has_max_data_rate_bps() const;
  void clear_max_data_rate_bps() ;
  double max_data_rate_bps() const;
  void set_max_data_rate_bps(double value);

  private:
  double _internal_max_data_rate_bps() const;
  void _internal_set_max_data_rate_bps(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_id_;
    double max_data_rate_bps_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};// -------------------------------------------------------------------

class WirelessDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice) */ {
 public:
  inline WirelessDevice() : WirelessDevice(nullptr) {}
  ~WirelessDevice() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirelessDevice(const WirelessDevice& from);
  WirelessDevice(WirelessDevice&& from) noexcept
    : WirelessDevice() {
    *this = ::std::move(from);
  }

  inline WirelessDevice& operator=(const WirelessDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirelessDevice& operator=(WirelessDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirelessDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirelessDevice* internal_default_instance() {
    return reinterpret_cast<const WirelessDevice*>(
               &_WirelessDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WirelessDevice& a, WirelessDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(WirelessDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirelessDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirelessDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirelessDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirelessDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirelessDevice& from) {
    WirelessDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirelessDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice";
  }
  protected:
  explicit WirelessDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransceiverModelIdFieldNumber = 5,
    kLinkEstablishmentTimeoutFieldNumber = 6,
  };
  // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 5 [json_name = "transceiverModelId"];
  bool has_transceiver_model_id() const;
  void clear_transceiver_model_id() ;
  const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_model_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransceiverModelId* release_transceiver_model_id();
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_transceiver_model_id();
  void set_allocated_transceiver_model_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id);
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_transceiver_model_id() const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_mutable_transceiver_model_id();
  public:
  void unsafe_arena_set_allocated_transceiver_model_id(
      ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id);
  ::aalyria::spacetime::api::common::TransceiverModelId* unsafe_arena_release_transceiver_model_id();
  // optional .google.protobuf.Duration link_establishment_timeout = 6 [json_name = "linkEstablishmentTimeout"];
  bool has_link_establishment_timeout() const;
  void clear_link_establishment_timeout() ;
  const ::PROTOBUF_NAMESPACE_ID::Duration& link_establishment_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_link_establishment_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_link_establishment_timeout();
  void set_allocated_link_establishment_timeout(::PROTOBUF_NAMESPACE_ID::Duration* link_establishment_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_link_establishment_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_link_establishment_timeout();
  public:
  void unsafe_arena_set_allocated_link_establishment_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* link_establishment_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_link_establishment_timeout();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id_;
    ::PROTOBUF_NAMESPACE_ID::Duration* link_establishment_timeout_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NetworkNode_SignalPowerBudget

// optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
inline bool NetworkNode_SignalPowerBudget::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TimeInterval& NetworkNode_SignalPowerBudget::_internal_interval() const {
  const ::aalyria::spacetime::api::common::TimeInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TimeInterval&>(
      ::aalyria::spacetime::api::common::_TimeInterval_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TimeInterval& NetworkNode_SignalPowerBudget::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.interval)
  return _internal_interval();
}
inline void NetworkNode_SignalPowerBudget::unsafe_arena_set_allocated_interval(
    ::aalyria::spacetime::api::common::TimeInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.interval)
}
inline ::aalyria::spacetime::api::common::TimeInterval* NetworkNode_SignalPowerBudget::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* NetworkNode_SignalPowerBudget::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* NetworkNode_SignalPowerBudget::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TimeInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::aalyria::spacetime::api::common::TimeInterval* NetworkNode_SignalPowerBudget::mutable_interval() {
  ::aalyria::spacetime::api::common::TimeInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.interval)
  return _msg;
}
inline void NetworkNode_SignalPowerBudget::set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.interval)
}

// optional double available_signal_power_watts = 2 [json_name = "availableSignalPowerWatts"];
inline bool NetworkNode_SignalPowerBudget::has_available_signal_power_watts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkNode_SignalPowerBudget::clear_available_signal_power_watts() {
  _impl_.available_signal_power_watts_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double NetworkNode_SignalPowerBudget::available_signal_power_watts() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.available_signal_power_watts)
  return _internal_available_signal_power_watts();
}
inline void NetworkNode_SignalPowerBudget::set_available_signal_power_watts(double value) {
  _internal_set_available_signal_power_watts(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget.available_signal_power_watts)
}
inline double NetworkNode_SignalPowerBudget::_internal_available_signal_power_watts() const {
  return _impl_.available_signal_power_watts_;
}
inline void NetworkNode_SignalPowerBudget::_internal_set_available_signal_power_watts(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.available_signal_power_watts_ = value;
}

// -------------------------------------------------------------------

// NetworkNode_Storage

// optional int64 available_bytes = 1 [json_name = "availableBytes"];
inline bool NetworkNode_Storage::has_available_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkNode_Storage::clear_available_bytes() {
  _impl_.available_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t NetworkNode_Storage::available_bytes() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage.available_bytes)
  return _internal_available_bytes();
}
inline void NetworkNode_Storage::set_available_bytes(::int64_t value) {
  _internal_set_available_bytes(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage.available_bytes)
}
inline ::int64_t NetworkNode_Storage::_internal_available_bytes() const {
  return _impl_.available_bytes_;
}
inline void NetworkNode_Storage::_internal_set_available_bytes(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.available_bytes_ = value;
}

// -------------------------------------------------------------------

// NetworkNode

// optional string node_id = 1 [json_name = "nodeId"];
inline bool NetworkNode::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkNode::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkNode::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkNode::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_id)
}
inline std::string* NetworkNode::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_id)
  return _s;
}
inline const std::string& NetworkNode::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void NetworkNode::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkNode::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkNode::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkNode::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_id)
}

// optional string name = 2 [json_name = "name"];
inline bool NetworkNode::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkNode::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkNode::name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkNode::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.name)
}
inline std::string* NetworkNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.name)
  return _s;
}
inline const std::string& NetworkNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NetworkNode::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkNode::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkNode::release_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkNode::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.name)
}

// optional string type = 7 [json_name = "type"];
inline bool NetworkNode::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NetworkNode::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkNode::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkNode::set_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.type)
}
inline std::string* NetworkNode::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.type)
  return _s;
}
inline const std::string& NetworkNode::_internal_type() const {
  return _impl_.type_.Get();
}
inline void NetworkNode::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkNode::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkNode::release_type() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkNode::set_allocated_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.type)
}

// repeated string subnet = 8 [json_name = "subnet"];
inline int NetworkNode::_internal_subnet_size() const {
  return _impl_.subnet_.size();
}
inline int NetworkNode::subnet_size() const {
  return _internal_subnet_size();
}
inline void NetworkNode::clear_subnet() {
  _internal_mutable_subnet()->Clear();
}
inline std::string* NetworkNode::add_subnet() {
  std::string* _s = _internal_add_subnet();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
  return _s;
}
inline const std::string& NetworkNode::subnet(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
  return _internal_subnet(index);
}
inline std::string* NetworkNode::mutable_subnet(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
  return _internal_mutable_subnet()->Mutable(index);
}
inline void NetworkNode::set_subnet(int index, const std::string& value) {
  _internal_mutable_subnet()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::set_subnet(int index, std::string&& value) {
  _internal_mutable_subnet()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::set_subnet(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subnet()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::set_subnet(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subnet()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::set_subnet(int index, absl::string_view value) {
  _internal_mutable_subnet()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::add_subnet(const std::string& value) {
  _internal_mutable_subnet()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::add_subnet(std::string&& value) {
  _internal_mutable_subnet()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::add_subnet(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subnet()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::add_subnet(const char* value, std::size_t size) {
  _internal_mutable_subnet()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline void NetworkNode::add_subnet(absl::string_view value) {
  _internal_mutable_subnet()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkNode::subnet() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
  return _internal_subnet();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* NetworkNode::mutable_subnet() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.subnet)
  return _internal_mutable_subnet();
}
inline const std::string& NetworkNode::_internal_subnet(int index) const {
  return _internal_subnet().Get(index);
}
inline std::string* NetworkNode::_internal_add_subnet() {
  return _internal_mutable_subnet()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetworkNode::_internal_subnet() const {
  return _impl_.subnet_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetworkNode::_internal_mutable_subnet() {
  return &_impl_.subnet_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface node_interface = 4 [json_name = "nodeInterface"];
inline int NetworkNode::_internal_node_interface_size() const {
  return _impl_.node_interface_.size();
}
inline int NetworkNode::node_interface_size() const {
  return _internal_node_interface_size();
}
inline void NetworkNode::clear_node_interface() {
  _internal_mutable_node_interface()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* NetworkNode::mutable_node_interface(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_interface)
  return _internal_mutable_node_interface()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface >*
NetworkNode::mutable_node_interface() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_interface)
  return _internal_mutable_node_interface();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface& NetworkNode::_internal_node_interface(int index) const {
  return _internal_node_interface().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface& NetworkNode::node_interface(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_interface)
  return _internal_node_interface(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* NetworkNode::_internal_add_node_interface() {
  return _internal_mutable_node_interface()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* NetworkNode::add_node_interface() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface* _add = _internal_add_node_interface();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_interface)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface >&
NetworkNode::node_interface() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.node_interface)
  return _internal_node_interface();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface>&
NetworkNode::_internal_node_interface() const {
  return _impl_.node_interface_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface>*
NetworkNode::_internal_mutable_node_interface() {
  return &_impl_.node_interface_;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent agent = 5 [json_name = "agent"];
inline bool NetworkNode::has_agent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.agent_ != nullptr);
  return value;
}
inline void NetworkNode::clear_agent() {
  if (_impl_.agent_ != nullptr) _impl_.agent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent& NetworkNode::_internal_agent() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* p = _impl_.agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_SdnAgent_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent& NetworkNode::agent() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.agent)
  return _internal_agent();
}
inline void NetworkNode::unsafe_arena_set_allocated_agent(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* agent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.agent_);
  }
  _impl_.agent_ = agent;
  if (agent) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.agent)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* NetworkNode::release_agent() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* NetworkNode::unsafe_arena_release_agent() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.agent)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* temp = _impl_.agent_;
  _impl_.agent_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* NetworkNode::_internal_mutable_agent() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.agent_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent>(GetArenaForAllocation());
    _impl_.agent_ = p;
  }
  return _impl_.agent_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* NetworkNode::mutable_agent() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* _msg = _internal_mutable_agent();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.agent)
  return _msg;
}
inline void NetworkNode::set_allocated_agent(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent* agent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.agent_;
  }
  if (agent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(agent);
    if (message_arena != submessage_arena) {
      agent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.agent_ = agent;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.agent)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.SignalPowerBudget power_budget = 9 [json_name = "powerBudget"];
inline int NetworkNode::_internal_power_budget_size() const {
  return _impl_.power_budget_.size();
}
inline int NetworkNode::power_budget_size() const {
  return _internal_power_budget_size();
}
inline void NetworkNode::clear_power_budget() {
  _internal_mutable_power_budget()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* NetworkNode::mutable_power_budget(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.power_budget)
  return _internal_mutable_power_budget()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget >*
NetworkNode::mutable_power_budget() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.power_budget)
  return _internal_mutable_power_budget();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget& NetworkNode::_internal_power_budget(int index) const {
  return _internal_power_budget().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget& NetworkNode::power_budget(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.power_budget)
  return _internal_power_budget(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* NetworkNode::_internal_add_power_budget() {
  return _internal_mutable_power_budget()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* NetworkNode::add_power_budget() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget* _add = _internal_add_power_budget();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.power_budget)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget >&
NetworkNode::power_budget() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.power_budget)
  return _internal_power_budget();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget>&
NetworkNode::_internal_power_budget() const {
  return _impl_.power_budget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_SignalPowerBudget>*
NetworkNode::_internal_mutable_power_budget() {
  return &_impl_.power_budget_;
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.Storage storage = 10 [json_name = "storage"];
inline bool NetworkNode::has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline void NetworkNode::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage& NetworkNode::_internal_storage() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_NetworkNode_Storage_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage& NetworkNode::storage() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.storage)
  return _internal_storage();
}
inline void NetworkNode::unsafe_arena_set_allocated_storage(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.storage)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* NetworkNode::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* NetworkNode::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.storage)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* NetworkNode::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* NetworkNode::mutable_storage() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.storage)
  return _msg;
}
inline void NetworkNode::set_allocated_storage(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkNode_Storage* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.storage_;
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(storage);
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkNode.storage)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SdnAgent

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.CdpiProtocol type = 1 [json_name = "type"];
inline bool SdnAgent::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SdnAgent::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol SdnAgent::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.type)
  return _internal_type();
}
inline void SdnAgent::set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol SdnAgent::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol>(_impl_.type_);
}
inline void SdnAgent::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string google_user_id = 2 [json_name = "googleUserId"];
inline bool SdnAgent::has_google_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SdnAgent::clear_google_user_id() {
  _impl_.google_user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SdnAgent::google_user_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.google_user_id)
  return _internal_google_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SdnAgent::set_google_user_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.google_user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.google_user_id)
}
inline std::string* SdnAgent::mutable_google_user_id() {
  std::string* _s = _internal_mutable_google_user_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.google_user_id)
  return _s;
}
inline const std::string& SdnAgent::_internal_google_user_id() const {
  return _impl_.google_user_id_.Get();
}
inline void SdnAgent::_internal_set_google_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.google_user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SdnAgent::_internal_mutable_google_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.google_user_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SdnAgent::release_google_user_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.google_user_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.google_user_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.google_user_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SdnAgent::set_allocated_google_user_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.google_user_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.google_user_id_.IsDefault()) {
          _impl_.google_user_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.google_user_id)
}

// map<uint32, .google.protobuf.Duration> maximum_control_plane_latency = 3 [json_name = "maximumControlPlaneLatency"];
inline int SdnAgent::_internal_maximum_control_plane_latency_size() const {
  return _impl_.maximum_control_plane_latency_.size();
}
inline int SdnAgent::maximum_control_plane_latency_size() const {
  return _internal_maximum_control_plane_latency_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >&
SdnAgent::_internal_maximum_control_plane_latency() const {
  return _impl_.maximum_control_plane_latency_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >&
SdnAgent::maximum_control_plane_latency() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.maximum_control_plane_latency)
  return _internal_maximum_control_plane_latency();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >*
SdnAgent::_internal_mutable_maximum_control_plane_latency() {
  return _impl_.maximum_control_plane_latency_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint32_t, ::PROTOBUF_NAMESPACE_ID::Duration >*
SdnAgent::mutable_maximum_control_plane_latency() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.nbi.v1alpha.resources.SdnAgent.maximum_control_plane_latency)
  return _internal_mutable_maximum_control_plane_latency();
}

// -------------------------------------------------------------------

// NetworkInterface_LocalId

// optional string type = 1 [json_name = "type"];
inline bool NetworkInterface_LocalId::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkInterface_LocalId::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface_LocalId::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface_LocalId::set_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.type)
}
inline std::string* NetworkInterface_LocalId::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.type)
  return _s;
}
inline const std::string& NetworkInterface_LocalId::_internal_type() const {
  return _impl_.type_.Get();
}
inline void NetworkInterface_LocalId::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface_LocalId::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface_LocalId::release_type() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface_LocalId::set_allocated_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.type)
}

// optional int32 index = 2 [json_name = "index"];
inline bool NetworkInterface_LocalId::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkInterface_LocalId::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NetworkInterface_LocalId::index() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.index)
  return _internal_index();
}
inline void NetworkInterface_LocalId::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId.index)
}
inline ::int32_t NetworkInterface_LocalId::_internal_index() const {
  return _impl_.index_;
}
inline void NetworkInterface_LocalId::_internal_set_index(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// NetworkInterface_Impairment

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.Type type = 1 [json_name = "type"];
inline bool NetworkInterface_Impairment::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NetworkInterface_Impairment::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type NetworkInterface_Impairment::type() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.type)
  return _internal_type();
}
inline void NetworkInterface_Impairment::set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.type)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type NetworkInterface_Impairment::_internal_type() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type>(_impl_.type_);
}
inline void NetworkInterface_Impairment::_internal_set_type(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}

// optional string app_id = 2 [json_name = "appId"];
inline bool NetworkInterface_Impairment::has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkInterface_Impairment::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface_Impairment::app_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface_Impairment::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.app_id)
}
inline std::string* NetworkInterface_Impairment::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.app_id)
  return _s;
}
inline const std::string& NetworkInterface_Impairment::_internal_app_id() const {
  return _impl_.app_id_.Get();
}
inline void NetworkInterface_Impairment::_internal_set_app_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface_Impairment::_internal_mutable_app_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface_Impairment::release_app_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.app_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface_Impairment::set_allocated_app_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.app_id)
}

// optional int64 timestamp_usec = 3 [json_name = "timestampUsec"];
inline bool NetworkInterface_Impairment::has_timestamp_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NetworkInterface_Impairment::clear_timestamp_usec() {
  _impl_.timestamp_usec_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t NetworkInterface_Impairment::timestamp_usec() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.timestamp_usec)
  return _internal_timestamp_usec();
}
inline void NetworkInterface_Impairment::set_timestamp_usec(::int64_t value) {
  _internal_set_timestamp_usec(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.timestamp_usec)
}
inline ::int64_t NetworkInterface_Impairment::_internal_timestamp_usec() const {
  return _impl_.timestamp_usec_;
}
inline void NetworkInterface_Impairment::_internal_set_timestamp_usec(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_usec_ = value;
}

// optional string reason = 4 [json_name = "reason"];
inline bool NetworkInterface_Impairment::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkInterface_Impairment::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterface_Impairment::reason() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface_Impairment::set_reason(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.reason)
}
inline std::string* NetworkInterface_Impairment::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.reason)
  return _s;
}
inline const std::string& NetworkInterface_Impairment::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void NetworkInterface_Impairment::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface_Impairment::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reason_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface_Impairment::release_reason() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.reason)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.reason_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface_Impairment::set_allocated_reason(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.reason)
}

// optional .google.protobuf.Any details = 5 [json_name = "details"];
inline bool NetworkInterface_Impairment::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkInterface_Impairment::_internal_details() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& NetworkInterface_Impairment::details() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.details)
  return _internal_details();
}
inline void NetworkInterface_Impairment::unsafe_arena_set_allocated_details(
    ::PROTOBUF_NAMESPACE_ID::Any* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = details;
  if (details) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.details)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkInterface_Impairment::release_details() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkInterface_Impairment::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.details)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkInterface_Impairment::_internal_mutable_details() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.details_ = p;
  }
  return _impl_.details_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* NetworkInterface_Impairment::mutable_details() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.details)
  return _msg;
}
inline void NetworkInterface_Impairment::set_allocated_details(::PROTOBUF_NAMESPACE_ID::Any* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(details));
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.details_ = details;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment.details)
}

// -------------------------------------------------------------------

// NetworkInterface

// optional string interface_id = 1 [json_name = "interfaceId"];
inline bool NetworkInterface::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetworkInterface::clear_interface_id() {
  _impl_.interface_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.interface_id)
  return _internal_interface_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_interface_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interface_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.interface_id)
}
inline std::string* NetworkInterface::mutable_interface_id() {
  std::string* _s = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.interface_id)
  return _s;
}
inline const std::string& NetworkInterface::_internal_interface_id() const {
  return _impl_.interface_id_.Get();
}
inline void NetworkInterface::_internal_set_interface_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.interface_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.interface_id_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.interface_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.interface_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface::set_allocated_interface_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interface_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interface_id_.IsDefault()) {
          _impl_.interface_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.interface_id)
}

// optional string ip_address = 14 [json_name = "ipAddress"];
inline bool NetworkInterface::has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetworkInterface::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterface::ip_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ip_address)
}
inline std::string* NetworkInterface::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ip_address)
  return _s;
}
inline const std::string& NetworkInterface::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void NetworkInterface::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_address_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_ip_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ip_address)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.ip_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface::set_allocated_ip_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ip_address)
}

// optional string ethernet_address = 15 [json_name = "ethernetAddress"];
inline bool NetworkInterface::has_ethernet_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NetworkInterface::clear_ethernet_address() {
  _impl_.ethernet_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkInterface::ethernet_address() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ethernet_address)
  return _internal_ethernet_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_ethernet_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ethernet_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ethernet_address)
}
inline std::string* NetworkInterface::mutable_ethernet_address() {
  std::string* _s = _internal_mutable_ethernet_address();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ethernet_address)
  return _s;
}
inline const std::string& NetworkInterface::_internal_ethernet_address() const {
  return _impl_.ethernet_address_.Get();
}
inline void NetworkInterface::_internal_set_ethernet_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.ethernet_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_ethernet_address() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ethernet_address_.Mutable( GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_ethernet_address() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ethernet_address)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ethernet_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ethernet_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetworkInterface::set_allocated_ethernet_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ethernet_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ethernet_address_.IsDefault()) {
          _impl_.ethernet_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.ethernet_address)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Mode rx_mode = 8 [json_name = "rxMode"];
inline bool NetworkInterface::has_rx_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NetworkInterface::clear_rx_mode() {
  _impl_.rx_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode NetworkInterface::rx_mode() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.rx_mode)
  return _internal_rx_mode();
}
inline void NetworkInterface::set_rx_mode(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode value) {
   _internal_set_rx_mode(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.rx_mode)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode NetworkInterface::_internal_rx_mode() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode>(_impl_.rx_mode_);
}
inline void NetworkInterface::_internal_set_rx_mode(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rx_mode_ = value;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.LocalId local_id = 3 [json_name = "localId"];
inline int NetworkInterface::_internal_local_id_size() const {
  return _impl_.local_id_.size();
}
inline int NetworkInterface::local_id_size() const {
  return _internal_local_id_size();
}
inline void NetworkInterface::clear_local_id() {
  _internal_mutable_local_id()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* NetworkInterface::mutable_local_id(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.local_id)
  return _internal_mutable_local_id()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId >*
NetworkInterface::mutable_local_id() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.local_id)
  return _internal_mutable_local_id();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId& NetworkInterface::_internal_local_id(int index) const {
  return _internal_local_id().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId& NetworkInterface::local_id(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.local_id)
  return _internal_local_id(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* NetworkInterface::_internal_add_local_id() {
  return _internal_mutable_local_id()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* NetworkInterface::add_local_id() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId* _add = _internal_add_local_id();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.local_id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId >&
NetworkInterface::local_id() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.local_id)
  return _internal_local_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId>&
NetworkInterface::_internal_local_id() const {
  return _impl_.local_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_LocalId>*
NetworkInterface::_internal_mutable_local_id() {
  return &_impl_.local_id_;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice wired = 4 [json_name = "wired"];
inline bool NetworkInterface::has_wired() const {
  return interface_medium_case() == kWired;
}
inline bool NetworkInterface::_internal_has_wired() const {
  return interface_medium_case() == kWired;
}
inline void NetworkInterface::set_has_wired() {
  _impl_._oneof_case_[0] = kWired;
}
inline void NetworkInterface::clear_wired() {
  if (interface_medium_case() == kWired) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.interface_medium_.wired_;
    }
    clear_has_interface_medium();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* NetworkInterface::release_wired() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wired)
  if (interface_medium_case() == kWired) {
    clear_has_interface_medium();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* temp = _impl_.interface_medium_.wired_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.interface_medium_.wired_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice& NetworkInterface::_internal_wired() const {
  return interface_medium_case() == kWired
      ? *_impl_.interface_medium_.wired_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_WiredDevice_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice& NetworkInterface::wired() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wired)
  return _internal_wired();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* NetworkInterface::unsafe_arena_release_wired() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wired)
  if (interface_medium_case() == kWired) {
    clear_has_interface_medium();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* temp = _impl_.interface_medium_.wired_;
    _impl_.interface_medium_.wired_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkInterface::unsafe_arena_set_allocated_wired(::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* wired) {
  clear_interface_medium();
  if (wired) {
    set_has_wired();
    _impl_.interface_medium_.wired_ = wired;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wired)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* NetworkInterface::_internal_mutable_wired() {
  if (interface_medium_case() != kWired) {
    clear_interface_medium();
    set_has_wired();
    _impl_.interface_medium_.wired_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice >(GetArenaForAllocation());
  }
  return _impl_.interface_medium_.wired_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* NetworkInterface::mutable_wired() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WiredDevice* _msg = _internal_mutable_wired();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wired)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice wireless = 6 [json_name = "wireless"];
inline bool NetworkInterface::has_wireless() const {
  return interface_medium_case() == kWireless;
}
inline bool NetworkInterface::_internal_has_wireless() const {
  return interface_medium_case() == kWireless;
}
inline void NetworkInterface::set_has_wireless() {
  _impl_._oneof_case_[0] = kWireless;
}
inline void NetworkInterface::clear_wireless() {
  if (interface_medium_case() == kWireless) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.interface_medium_.wireless_;
    }
    clear_has_interface_medium();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* NetworkInterface::release_wireless() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wireless)
  if (interface_medium_case() == kWireless) {
    clear_has_interface_medium();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* temp = _impl_.interface_medium_.wireless_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.interface_medium_.wireless_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice& NetworkInterface::_internal_wireless() const {
  return interface_medium_case() == kWireless
      ? *_impl_.interface_medium_.wireless_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_WirelessDevice_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice& NetworkInterface::wireless() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wireless)
  return _internal_wireless();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* NetworkInterface::unsafe_arena_release_wireless() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wireless)
  if (interface_medium_case() == kWireless) {
    clear_has_interface_medium();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* temp = _impl_.interface_medium_.wireless_;
    _impl_.interface_medium_.wireless_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkInterface::unsafe_arena_set_allocated_wireless(::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* wireless) {
  clear_interface_medium();
  if (wireless) {
    set_has_wireless();
    _impl_.interface_medium_.wireless_ = wireless;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wireless)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* NetworkInterface::_internal_mutable_wireless() {
  if (interface_medium_case() != kWireless) {
    clear_interface_medium();
    set_has_wireless();
    _impl_.interface_medium_.wireless_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice >(GetArenaForAllocation());
  }
  return _impl_.interface_medium_.wireless_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* NetworkInterface::mutable_wireless() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessDevice* _msg = _internal_mutable_wireless();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.wireless)
  return _msg;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.Impairment operational_impairment = 16 [json_name = "operationalImpairment"];
inline int NetworkInterface::_internal_operational_impairment_size() const {
  return _impl_.operational_impairment_.size();
}
inline int NetworkInterface::operational_impairment_size() const {
  return _internal_operational_impairment_size();
}
inline void NetworkInterface::clear_operational_impairment() {
  _internal_mutable_operational_impairment()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* NetworkInterface::mutable_operational_impairment(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.operational_impairment)
  return _internal_mutable_operational_impairment()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment >*
NetworkInterface::mutable_operational_impairment() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.operational_impairment)
  return _internal_mutable_operational_impairment();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment& NetworkInterface::_internal_operational_impairment(int index) const {
  return _internal_operational_impairment().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment& NetworkInterface::operational_impairment(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.operational_impairment)
  return _internal_operational_impairment(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* NetworkInterface::_internal_add_operational_impairment() {
  return _internal_mutable_operational_impairment()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* NetworkInterface::add_operational_impairment() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment* _add = _internal_add_operational_impairment();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.operational_impairment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment >&
NetworkInterface::operational_impairment() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkInterface.operational_impairment)
  return _internal_operational_impairment();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment>&
NetworkInterface::_internal_operational_impairment() const {
  return _impl_.operational_impairment_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment>*
NetworkInterface::_internal_mutable_operational_impairment() {
  return &_impl_.operational_impairment_;
}

inline bool NetworkInterface::has_interface_medium() const {
  return interface_medium_case() != INTERFACE_MEDIUM_NOT_SET;
}
inline void NetworkInterface::clear_has_interface_medium() {
  _impl_._oneof_case_[0] = INTERFACE_MEDIUM_NOT_SET;
}
inline NetworkInterface::InterfaceMediumCase NetworkInterface::interface_medium_case() const {
  return NetworkInterface::InterfaceMediumCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WiredDevice

// optional double max_data_rate_bps = 1 [json_name = "maxDataRateBps"];
inline bool WiredDevice::has_max_data_rate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WiredDevice::clear_max_data_rate_bps() {
  _impl_.max_data_rate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double WiredDevice::max_data_rate_bps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.max_data_rate_bps)
  return _internal_max_data_rate_bps();
}
inline void WiredDevice::set_max_data_rate_bps(double value) {
  _internal_set_max_data_rate_bps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.max_data_rate_bps)
}
inline double WiredDevice::_internal_max_data_rate_bps() const {
  return _impl_.max_data_rate_bps_;
}
inline void WiredDevice::_internal_set_max_data_rate_bps(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_data_rate_bps_ = value;
}

// optional string platform_id = 2 [json_name = "platformId"];
inline bool WiredDevice::has_platform_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WiredDevice::clear_platform_id() {
  _impl_.platform_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WiredDevice::platform_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.platform_id)
  return _internal_platform_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WiredDevice::set_platform_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.platform_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.platform_id)
}
inline std::string* WiredDevice::mutable_platform_id() {
  std::string* _s = _internal_mutable_platform_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.platform_id)
  return _s;
}
inline const std::string& WiredDevice::_internal_platform_id() const {
  return _impl_.platform_id_.Get();
}
inline void WiredDevice::_internal_set_platform_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.platform_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WiredDevice::_internal_mutable_platform_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.platform_id_.Mutable( GetArenaForAllocation());
}
inline std::string* WiredDevice::release_platform_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.platform_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.platform_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WiredDevice::set_allocated_platform_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.platform_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_id_.IsDefault()) {
          _impl_.platform_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WiredDevice.platform_id)
}

// -------------------------------------------------------------------

// WirelessDevice

// optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 5 [json_name = "transceiverModelId"];
inline bool WirelessDevice::has_transceiver_model_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transceiver_model_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& WirelessDevice::_internal_transceiver_model_id() const {
  const ::aalyria::spacetime::api::common::TransceiverModelId* p = _impl_.transceiver_model_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransceiverModelId&>(
      ::aalyria::spacetime::api::common::_TransceiverModelId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& WirelessDevice::transceiver_model_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.transceiver_model_id)
  return _internal_transceiver_model_id();
}
inline void WirelessDevice::unsafe_arena_set_allocated_transceiver_model_id(
    ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transceiver_model_id_);
  }
  _impl_.transceiver_model_id_ = transceiver_model_id;
  if (transceiver_model_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.transceiver_model_id)
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessDevice::release_transceiver_model_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.transceiver_model_id_;
  _impl_.transceiver_model_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessDevice::unsafe_arena_release_transceiver_model_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.transceiver_model_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.transceiver_model_id_;
  _impl_.transceiver_model_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessDevice::_internal_mutable_transceiver_model_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transceiver_model_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransceiverModelId>(GetArenaForAllocation());
    _impl_.transceiver_model_id_ = p;
  }
  return _impl_.transceiver_model_id_;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessDevice::mutable_transceiver_model_id() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _msg = _internal_mutable_transceiver_model_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.transceiver_model_id)
  return _msg;
}
inline void WirelessDevice::set_allocated_transceiver_model_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transceiver_model_id_);
  }
  if (transceiver_model_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transceiver_model_id));
    if (message_arena != submessage_arena) {
      transceiver_model_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transceiver_model_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transceiver_model_id_ = transceiver_model_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.transceiver_model_id)
}

// optional .google.protobuf.Duration link_establishment_timeout = 6 [json_name = "linkEstablishmentTimeout"];
inline bool WirelessDevice::has_link_establishment_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_establishment_timeout_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& WirelessDevice::_internal_link_establishment_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.link_establishment_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& WirelessDevice::link_establishment_timeout() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.link_establishment_timeout)
  return _internal_link_establishment_timeout();
}
inline void WirelessDevice::unsafe_arena_set_allocated_link_establishment_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* link_establishment_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_establishment_timeout_);
  }
  _impl_.link_establishment_timeout_ = link_establishment_timeout;
  if (link_establishment_timeout) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.link_establishment_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WirelessDevice::release_link_establishment_timeout() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.link_establishment_timeout_;
  _impl_.link_establishment_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WirelessDevice::unsafe_arena_release_link_establishment_timeout() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.link_establishment_timeout)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.link_establishment_timeout_;
  _impl_.link_establishment_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WirelessDevice::_internal_mutable_link_establishment_timeout() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.link_establishment_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.link_establishment_timeout_ = p;
  }
  return _impl_.link_establishment_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WirelessDevice::mutable_link_establishment_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_link_establishment_timeout();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.link_establishment_timeout)
  return _msg;
}
inline void WirelessDevice::set_allocated_link_establishment_timeout(::PROTOBUF_NAMESPACE_ID::Duration* link_establishment_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_establishment_timeout_);
  }
  if (link_establishment_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_establishment_timeout));
    if (message_arena != submessage_arena) {
      link_establishment_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_establishment_timeout, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.link_establishment_timeout_ = link_establishment_timeout;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessDevice.link_establishment_timeout)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::SdnAgent_CdpiProtocol_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Impairment_Type_descriptor();
}
template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkInterface_Mode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5felement_2eproto_2epb_2eh
