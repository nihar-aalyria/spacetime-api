// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/network_link.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/common/control_radio.pb.h"
#include "api/common/coordinates.pb.h"
#include "api/common/network.pb.h"
#include "api/common/time.pb.h"
#include "api/common/wireless_transceiver.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class BeamTarget;
struct BeamTargetDefaultTypeInternal;
extern BeamTargetDefaultTypeInternal _BeamTarget_default_instance_;
class BidirectionalLink;
struct BidirectionalLinkDefaultTypeInternal;
extern BidirectionalLinkDefaultTypeInternal _BidirectionalLink_default_instance_;
class DirectionalLink;
struct DirectionalLinkDefaultTypeInternal;
extern DirectionalLinkDefaultTypeInternal _DirectionalLink_default_instance_;
class InterfaceLinkReport;
struct InterfaceLinkReportDefaultTypeInternal;
extern InterfaceLinkReportDefaultTypeInternal _InterfaceLinkReport_default_instance_;
class InterfaceLinkReport_AccessInterval;
struct InterfaceLinkReport_AccessIntervalDefaultTypeInternal;
extern InterfaceLinkReport_AccessIntervalDefaultTypeInternal _InterfaceLinkReport_AccessInterval_default_instance_;
class LinkEnd;
struct LinkEndDefaultTypeInternal;
extern LinkEndDefaultTypeInternal _LinkEnd_default_instance_;
class NetworkLink;
struct NetworkLinkDefaultTypeInternal;
extern NetworkLinkDefaultTypeInternal _NetworkLink_default_instance_;
class Radio;
struct RadioDefaultTypeInternal;
extern RadioDefaultTypeInternal _Radio_default_instance_;
class RadioConfiguration;
struct RadioConfigurationDefaultTypeInternal;
extern RadioConfigurationDefaultTypeInternal _RadioConfiguration_default_instance_;
class TransceiverLinkReport;
struct TransceiverLinkReportDefaultTypeInternal;
extern TransceiverLinkReportDefaultTypeInternal _TransceiverLinkReport_default_instance_;
class WirelessLinkBudget;
struct WirelessLinkBudgetDefaultTypeInternal;
extern WirelessLinkBudgetDefaultTypeInternal _WirelessLinkBudget_default_instance_;
class WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse;
struct WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUseDefaultTypeInternal;
extern WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUseDefaultTypeInternal _WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse_default_instance_;
class WirelessLinkReport;
struct WirelessLinkReportDefaultTypeInternal;
extern WirelessLinkReportDefaultTypeInternal _WirelessLinkReport_default_instance_;
class WirelessLinkReport_WirelessAccessInterval;
struct WirelessLinkReport_WirelessAccessIntervalDefaultTypeInternal;
extern WirelessLinkReport_WirelessAccessIntervalDefaultTypeInternal _WirelessLinkReport_WirelessAccessInterval_default_instance_;
class WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics;
struct WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetricsDefaultTypeInternal;
extern WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetricsDefaultTypeInternal _WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::NetworkLink>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Radio>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::RadioConfiguration>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverLinkReport>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
enum Accessibility : int {
  ACCESS_UNKNOWN = 0,
  ACCESS_EXISTS = 1,
  ACCESS_MARGINAL = 3,
  NO_ACCESS = 2,
};

bool Accessibility_IsValid(int value);
constexpr Accessibility Accessibility_MIN = static_cast<Accessibility>(0);
constexpr Accessibility Accessibility_MAX = static_cast<Accessibility>(3);
constexpr int Accessibility_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Accessibility_descriptor();
template <typename T>
const std::string& Accessibility_Name(T value) {
  static_assert(std::is_same<T, Accessibility>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Accessibility_Name().");
  return Accessibility_Name(static_cast<Accessibility>(value));
}
template <>
inline const std::string& Accessibility_Name(Accessibility value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Accessibility_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Accessibility_Parse(absl::string_view name, Accessibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Accessibility>(
      Accessibility_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NetworkLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink) */ {
 public:
  inline NetworkLink() : NetworkLink(nullptr) {}
  ~NetworkLink() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkLink(const NetworkLink& from);
  NetworkLink(NetworkLink&& from) noexcept
    : NetworkLink() {
    *this = ::std::move(from);
  }

  inline NetworkLink& operator=(const NetworkLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkLink& operator=(NetworkLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkLink* internal_default_instance() {
    return reinterpret_cast<const NetworkLink*>(
               &_NetworkLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetworkLink& a, NetworkLink& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkLink& from) {
    NetworkLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink";
  }
  protected:
  explicit NetworkLink(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 3,
    kDstFieldNumber = 4,
  };
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId src = 3 [json_name = "src"];
  bool has_src() const;
  void clear_src() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& src() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_src();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_src();
  void set_allocated_src(::aalyria::spacetime::api::common::NetworkInterfaceId* src);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_src() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* src);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_src();
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId dst = 4 [json_name = "dst"];
  bool has_dst() const;
  void clear_dst() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& dst() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_dst();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_dst();
  void set_allocated_dst(::aalyria::spacetime::api::common::NetworkInterfaceId* dst);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_dst() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_dst();
  public:
  void unsafe_arena_set_allocated_dst(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* dst);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_dst();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* src_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* dst_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class RadioConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration) */ {
 public:
  inline RadioConfiguration() : RadioConfiguration(nullptr) {}
  ~RadioConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RadioConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadioConfiguration(const RadioConfiguration& from);
  RadioConfiguration(RadioConfiguration&& from) noexcept
    : RadioConfiguration() {
    *this = ::std::move(from);
  }

  inline RadioConfiguration& operator=(const RadioConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioConfiguration& operator=(RadioConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadioConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadioConfiguration* internal_default_instance() {
    return reinterpret_cast<const RadioConfiguration*>(
               &_RadioConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RadioConfiguration& a, RadioConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadioConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadioConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadioConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadioConfiguration& from) {
    RadioConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration";
  }
  protected:
  explicit RadioConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRateTableIdFieldNumber = 5,
    kInterfaceIdFieldNumber = 1,
    kTxStateFieldNumber = 2,
    kRxStateFieldNumber = 3,
    kTdmaScheduleFieldNumber = 4,
  };
  // optional string rate_table_id = 5 [json_name = "rateTableId"];
  bool has_rate_table_id() const;
  void clear_rate_table_id() ;
  const std::string& rate_table_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rate_table_id(Arg_&& arg, Args_... args);
  std::string* mutable_rate_table_id();
  PROTOBUF_NODISCARD std::string* release_rate_table_id();
  void set_allocated_rate_table_id(std::string* ptr);

  private:
  const std::string& _internal_rate_table_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate_table_id(
      const std::string& value);
  std::string* _internal_mutable_rate_table_id();

  public:
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 1 [json_name = "interfaceId"];
  bool has_interface_id() const;
  void clear_interface_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& interface_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_interface_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_interface_id();
  void set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_interface_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_interface_id();
  public:
  void unsafe_arena_set_allocated_interface_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_interface_id();
  // optional .aalyria.spacetime.api.common.TransmitterState tx_state = 2 [json_name = "txState"];
  bool has_tx_state() const;
  void clear_tx_state() ;
  const ::aalyria::spacetime::api::common::TransmitterState& tx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransmitterState* release_tx_state();
  ::aalyria::spacetime::api::common::TransmitterState* mutable_tx_state();
  void set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state);
  private:
  const ::aalyria::spacetime::api::common::TransmitterState& _internal_tx_state() const;
  ::aalyria::spacetime::api::common::TransmitterState* _internal_mutable_tx_state();
  public:
  void unsafe_arena_set_allocated_tx_state(
      ::aalyria::spacetime::api::common::TransmitterState* tx_state);
  ::aalyria::spacetime::api::common::TransmitterState* unsafe_arena_release_tx_state();
  // optional .aalyria.spacetime.api.common.ReceiverState rx_state = 3 [json_name = "rxState"];
  bool has_rx_state() const;
  void clear_rx_state() ;
  const ::aalyria::spacetime::api::common::ReceiverState& rx_state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ReceiverState* release_rx_state();
  ::aalyria::spacetime::api::common::ReceiverState* mutable_rx_state();
  void set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state);
  private:
  const ::aalyria::spacetime::api::common::ReceiverState& _internal_rx_state() const;
  ::aalyria::spacetime::api::common::ReceiverState* _internal_mutable_rx_state();
  public:
  void unsafe_arena_set_allocated_rx_state(
      ::aalyria::spacetime::api::common::ReceiverState* rx_state);
  ::aalyria::spacetime::api::common::ReceiverState* unsafe_arena_release_rx_state();
  // optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 4 [json_name = "tdmaSchedule"];
  bool has_tdma_schedule() const;
  void clear_tdma_schedule() ;
  const ::aalyria::spacetime::api::common::TdmaSchedule& tdma_schedule() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TdmaSchedule* release_tdma_schedule();
  ::aalyria::spacetime::api::common::TdmaSchedule* mutable_tdma_schedule();
  void set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  private:
  const ::aalyria::spacetime::api::common::TdmaSchedule& _internal_tdma_schedule() const;
  ::aalyria::spacetime::api::common::TdmaSchedule* _internal_mutable_tdma_schedule();
  public:
  void unsafe_arena_set_allocated_tdma_schedule(
      ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule);
  ::aalyria::spacetime::api::common::TdmaSchedule* unsafe_arena_release_tdma_schedule();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_table_id_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id_;
    ::aalyria::spacetime::api::common::TransmitterState* tx_state_;
    ::aalyria::spacetime::api::common::ReceiverState* rx_state_;
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class Radio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.Radio) */ {
 public:
  inline Radio() : Radio(nullptr) {}
  ~Radio() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Radio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Radio(const Radio& from);
  Radio(Radio&& from) noexcept
    : Radio() {
    *this = ::std::move(from);
  }

  inline Radio& operator=(const Radio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Radio& operator=(Radio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Radio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Radio* internal_default_instance() {
    return reinterpret_cast<const Radio*>(
               &_Radio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Radio& a, Radio& b) {
    a.Swap(&b);
  }
  inline void Swap(Radio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Radio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Radio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Radio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Radio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Radio& from) {
    Radio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Radio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.Radio";
  }
  protected:
  explicit Radio(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandProfileIdFieldNumber = 2,
    kCenterFrequencyHzFieldNumber = 1,
  };
  // optional string band_profile_id = 2 [json_name = "bandProfileId"];
  bool has_band_profile_id() const;
  void clear_band_profile_id() ;
  const std::string& band_profile_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_band_profile_id(Arg_&& arg, Args_... args);
  std::string* mutable_band_profile_id();
  PROTOBUF_NODISCARD std::string* release_band_profile_id();
  void set_allocated_band_profile_id(std::string* ptr);

  private:
  const std::string& _internal_band_profile_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_band_profile_id(
      const std::string& value);
  std::string* _internal_mutable_band_profile_id();

  public:
  // optional uint64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
  bool has_center_frequency_hz() const;
  void clear_center_frequency_hz() ;
  ::uint64_t center_frequency_hz() const;
  void set_center_frequency_hz(::uint64_t value);

  private:
  ::uint64_t _internal_center_frequency_hz() const;
  void _internal_set_center_frequency_hz(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.Radio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr band_profile_id_;
    ::uint64_t center_frequency_hz_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class LinkEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd) */ {
 public:
  inline LinkEnd() : LinkEnd(nullptr) {}
  ~LinkEnd() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LinkEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkEnd(const LinkEnd& from);
  LinkEnd(LinkEnd&& from) noexcept
    : LinkEnd() {
    *this = ::std::move(from);
  }

  inline LinkEnd& operator=(const LinkEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkEnd& operator=(LinkEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkEnd* internal_default_instance() {
    return reinterpret_cast<const LinkEnd*>(
               &_LinkEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LinkEnd& a, LinkEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkEnd& from) {
    LinkEnd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd";
  }
  protected:
  explicit LinkEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId id = 3 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_id();
  void set_allocated_id(::aalyria::spacetime::api::common::NetworkInterfaceId* id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_id();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class BeamTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget) */ {
 public:
  inline BeamTarget() : BeamTarget(nullptr) {}
  ~BeamTarget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeamTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeamTarget(const BeamTarget& from);
  BeamTarget(BeamTarget&& from) noexcept
    : BeamTarget() {
    *this = ::std::move(from);
  }

  inline BeamTarget& operator=(const BeamTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeamTarget& operator=(BeamTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeamTarget& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTransceiverId = 1,
    kCoordinates = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const BeamTarget* internal_default_instance() {
    return reinterpret_cast<const BeamTarget*>(
               &_BeamTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BeamTarget& a, BeamTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(BeamTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeamTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeamTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeamTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeamTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeamTarget& from) {
    BeamTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeamTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget";
  }
  protected:
  explicit BeamTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransceiverIdFieldNumber = 1,
    kCoordinatesFieldNumber = 2,
  };
  // .aalyria.spacetime.api.common.TransceiverModelId transceiver_id = 1 [json_name = "transceiverId"];
  bool has_transceiver_id() const;
  private:
  bool _internal_has_transceiver_id() const;

  public:
  void clear_transceiver_id() ;
  const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransceiverModelId* release_transceiver_id();
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_transceiver_id();
  void set_allocated_transceiver_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_id);
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_transceiver_id() const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_mutable_transceiver_id();
  public:
  void unsafe_arena_set_allocated_transceiver_id(
      ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_id);
  ::aalyria::spacetime::api::common::TransceiverModelId* unsafe_arena_release_transceiver_id();
  // .aalyria.spacetime.api.common.Motion coordinates = 2 [json_name = "coordinates"];
  bool has_coordinates() const;
  private:
  bool _internal_has_coordinates() const;

  public:
  void clear_coordinates() ;
  const ::aalyria::spacetime::api::common::Motion& coordinates() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Motion* release_coordinates();
  ::aalyria::spacetime::api::common::Motion* mutable_coordinates();
  void set_allocated_coordinates(::aalyria::spacetime::api::common::Motion* coordinates);
  private:
  const ::aalyria::spacetime::api::common::Motion& _internal_coordinates() const;
  ::aalyria::spacetime::api::common::Motion* _internal_mutable_coordinates();
  public:
  void unsafe_arena_set_allocated_coordinates(
      ::aalyria::spacetime::api::common::Motion* coordinates);
  ::aalyria::spacetime::api::common::Motion* unsafe_arena_release_coordinates();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget)
 private:
  class _Internal;
  void set_has_transceiver_id();
  void set_has_coordinates();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_id_;
      ::aalyria::spacetime::api::common::Motion* coordinates_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class BidirectionalLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink) */ {
 public:
  inline BidirectionalLink() : BidirectionalLink(nullptr) {}
  ~BidirectionalLink() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BidirectionalLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BidirectionalLink(const BidirectionalLink& from);
  BidirectionalLink(BidirectionalLink&& from) noexcept
    : BidirectionalLink() {
    *this = ::std::move(from);
  }

  inline BidirectionalLink& operator=(const BidirectionalLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline BidirectionalLink& operator=(BidirectionalLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BidirectionalLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const BidirectionalLink* internal_default_instance() {
    return reinterpret_cast<const BidirectionalLink*>(
               &_BidirectionalLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BidirectionalLink& a, BidirectionalLink& b) {
    a.Swap(&b);
  }
  inline void Swap(BidirectionalLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BidirectionalLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BidirectionalLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BidirectionalLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BidirectionalLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BidirectionalLink& from) {
    BidirectionalLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BidirectionalLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink";
  }
  protected:
  explicit BidirectionalLink(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kBFieldNumber = 2,
    kAToBRadioFieldNumber = 3,
    kBToARadioFieldNumber = 4,
  };
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd a = 1 [json_name = "a"];
  bool has_a() const;
  void clear_a() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& a() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* release_a();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* mutable_a();
  void set_allocated_a(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* a);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& _internal_a() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* a);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* unsafe_arena_release_a();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd b = 2 [json_name = "b"];
  bool has_b() const;
  void clear_b() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& b() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* release_b();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* mutable_b();
  void set_allocated_b(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* b);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& _internal_b() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* b);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* unsafe_arena_release_b();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio a_to_b_radio = 3 [json_name = "aToBRadio"];
  bool has_a_to_b_radio() const;
  void clear_a_to_b_radio() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& a_to_b_radio() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* release_a_to_b_radio();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* mutable_a_to_b_radio();
  void set_allocated_a_to_b_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* a_to_b_radio);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& _internal_a_to_b_radio() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _internal_mutable_a_to_b_radio();
  public:
  void unsafe_arena_set_allocated_a_to_b_radio(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* a_to_b_radio);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* unsafe_arena_release_a_to_b_radio();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio b_to_a_radio = 4 [json_name = "bToARadio"];
  bool has_b_to_a_radio() const;
  void clear_b_to_a_radio() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& b_to_a_radio() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* release_b_to_a_radio();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* mutable_b_to_a_radio();
  void set_allocated_b_to_a_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* b_to_a_radio);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& _internal_b_to_a_radio() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _internal_mutable_b_to_a_radio();
  public:
  void unsafe_arena_set_allocated_b_to_a_radio(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* b_to_a_radio);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* unsafe_arena_release_b_to_a_radio();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* a_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* b_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* a_to_b_radio_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* b_to_a_radio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class DirectionalLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink) */ {
 public:
  inline DirectionalLink() : DirectionalLink(nullptr) {}
  ~DirectionalLink() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionalLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionalLink(const DirectionalLink& from);
  DirectionalLink(DirectionalLink&& from) noexcept
    : DirectionalLink() {
    *this = ::std::move(from);
  }

  inline DirectionalLink& operator=(const DirectionalLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionalLink& operator=(DirectionalLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectionalLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionalLink* internal_default_instance() {
    return reinterpret_cast<const DirectionalLink*>(
               &_DirectionalLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DirectionalLink& a, DirectionalLink& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionalLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionalLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionalLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionalLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectionalLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectionalLink& from) {
    DirectionalLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectionalLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink";
  }
  protected:
  explicit DirectionalLink(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRadioConfigurationFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId id = 1 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_id();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_id();
  void set_allocated_id(::aalyria::spacetime::api::common::NetworkInterfaceId* id);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_id() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* id);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_id();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio radio_configuration = 2 [json_name = "radioConfiguration"];
  bool has_radio_configuration() const;
  void clear_radio_configuration() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& radio_configuration() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* release_radio_configuration();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* mutable_radio_configuration();
  void set_allocated_radio_configuration(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* radio_configuration);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& _internal_radio_configuration() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _internal_mutable_radio_configuration();
  public:
  void unsafe_arena_set_allocated_radio_configuration(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* radio_configuration);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* unsafe_arena_release_radio_configuration();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget target = 3 [json_name = "target"];
  bool has_target() const;
  void clear_target() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget& target() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* release_target();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* mutable_target();
  void set_allocated_target(::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* target);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget& _internal_target() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* target);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* unsafe_arena_release_target();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* id_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* radio_configuration_;
    ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse& other);
  static const WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse*>(&_WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.ComponentPropagationLossDbEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};
// -------------------------------------------------------------------

class WirelessLinkBudget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget) */ {
 public:
  inline WirelessLinkBudget() : WirelessLinkBudget(nullptr) {}
  ~WirelessLinkBudget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessLinkBudget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirelessLinkBudget(const WirelessLinkBudget& from);
  WirelessLinkBudget(WirelessLinkBudget&& from) noexcept
    : WirelessLinkBudget() {
    *this = ::std::move(from);
  }

  inline WirelessLinkBudget& operator=(const WirelessLinkBudget& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirelessLinkBudget& operator=(WirelessLinkBudget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirelessLinkBudget& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirelessLinkBudget* internal_default_instance() {
    return reinterpret_cast<const WirelessLinkBudget*>(
               &_WirelessLinkBudget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WirelessLinkBudget& a, WirelessLinkBudget& b) {
    a.Swap(&b);
  }
  inline void Swap(WirelessLinkBudget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirelessLinkBudget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirelessLinkBudget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirelessLinkBudget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirelessLinkBudget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirelessLinkBudget& from) {
    WirelessLinkBudget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirelessLinkBudget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget";
  }
  protected:
  explicit WirelessLinkBudget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kComponentPropagationLossDbFieldNumber = 15,
    kTransmitterAntennaGainInLinkDirectionDbFieldNumber = 1,
    kEffectiveIsotropicRadiatedPowerDbwFieldNumber = 2,
    kPropagationLossDbFieldNumber = 3,
    kReceivedIsotropicPowerDbwFieldNumber = 4,
    kReceivedPowerFluxDensityDbWPerM2FieldNumber = 5,
    kReceiverAntennaGainInLinkDirectionDbFieldNumber = 6,
    kPowerAtReceiverOutputDbwFieldNumber = 7,
    kCarrierToNoiseDbFieldNumber = 8,
    kCarrierToNoiseDensityDbPerHzFieldNumber = 9,
    kCarrierToNoisePlusInterferenceDbFieldNumber = 16,
  };
  // map<string, double> component_propagation_loss_db = 15 [json_name = "componentPropagationLossDb"];
  int component_propagation_loss_db_size() const;
  private:
  int _internal_component_propagation_loss_db_size() const;

  public:
  void clear_component_propagation_loss_db() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_component_propagation_loss_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_component_propagation_loss_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      component_propagation_loss_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_component_propagation_loss_db();
  // optional double transmitter_antenna_gain_in_link_direction_db = 1 [json_name = "transmitterAntennaGainInLinkDirectionDb"];
  bool has_transmitter_antenna_gain_in_link_direction_db() const;
  void clear_transmitter_antenna_gain_in_link_direction_db() ;
  double transmitter_antenna_gain_in_link_direction_db() const;
  void set_transmitter_antenna_gain_in_link_direction_db(double value);

  private:
  double _internal_transmitter_antenna_gain_in_link_direction_db() const;
  void _internal_set_transmitter_antenna_gain_in_link_direction_db(double value);

  public:
  // optional double effective_isotropic_radiated_power_dbw = 2 [json_name = "effectiveIsotropicRadiatedPowerDbw"];
  bool has_effective_isotropic_radiated_power_dbw() const;
  void clear_effective_isotropic_radiated_power_dbw() ;
  double effective_isotropic_radiated_power_dbw() const;
  void set_effective_isotropic_radiated_power_dbw(double value);

  private:
  double _internal_effective_isotropic_radiated_power_dbw() const;
  void _internal_set_effective_isotropic_radiated_power_dbw(double value);

  public:
  // optional double propagation_loss_db = 3 [json_name = "propagationLossDb"];
  bool has_propagation_loss_db() const;
  void clear_propagation_loss_db() ;
  double propagation_loss_db() const;
  void set_propagation_loss_db(double value);

  private:
  double _internal_propagation_loss_db() const;
  void _internal_set_propagation_loss_db(double value);

  public:
  // optional double received_isotropic_power_dbw = 4 [json_name = "receivedIsotropicPowerDbw"];
  bool has_received_isotropic_power_dbw() const;
  void clear_received_isotropic_power_dbw() ;
  double received_isotropic_power_dbw() const;
  void set_received_isotropic_power_dbw(double value);

  private:
  double _internal_received_isotropic_power_dbw() const;
  void _internal_set_received_isotropic_power_dbw(double value);

  public:
  // optional double received_power_flux_density_db_w_per_m2 = 5 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  bool has_received_power_flux_density_db_w_per_m2() const;
  void clear_received_power_flux_density_db_w_per_m2() ;
  double received_power_flux_density_db_w_per_m2() const;
  void set_received_power_flux_density_db_w_per_m2(double value);

  private:
  double _internal_received_power_flux_density_db_w_per_m2() const;
  void _internal_set_received_power_flux_density_db_w_per_m2(double value);

  public:
  // optional double receiver_antenna_gain_in_link_direction_db = 6 [json_name = "receiverAntennaGainInLinkDirectionDb"];
  bool has_receiver_antenna_gain_in_link_direction_db() const;
  void clear_receiver_antenna_gain_in_link_direction_db() ;
  double receiver_antenna_gain_in_link_direction_db() const;
  void set_receiver_antenna_gain_in_link_direction_db(double value);

  private:
  double _internal_receiver_antenna_gain_in_link_direction_db() const;
  void _internal_set_receiver_antenna_gain_in_link_direction_db(double value);

  public:
  // optional double power_at_receiver_output_dbw = 7 [json_name = "powerAtReceiverOutputDbw"];
  bool has_power_at_receiver_output_dbw() const;
  void clear_power_at_receiver_output_dbw() ;
  double power_at_receiver_output_dbw() const;
  void set_power_at_receiver_output_dbw(double value);

  private:
  double _internal_power_at_receiver_output_dbw() const;
  void _internal_set_power_at_receiver_output_dbw(double value);

  public:
  // optional double carrier_to_noise_db = 8 [json_name = "carrierToNoiseDb"];
  bool has_carrier_to_noise_db() const;
  void clear_carrier_to_noise_db() ;
  double carrier_to_noise_db() const;
  void set_carrier_to_noise_db(double value);

  private:
  double _internal_carrier_to_noise_db() const;
  void _internal_set_carrier_to_noise_db(double value);

  public:
  // optional double carrier_to_noise_density_db_per_hz = 9 [json_name = "carrierToNoiseDensityDbPerHz"];
  bool has_carrier_to_noise_density_db_per_hz() const;
  void clear_carrier_to_noise_density_db_per_hz() ;
  double carrier_to_noise_density_db_per_hz() const;
  void set_carrier_to_noise_density_db_per_hz(double value);

  private:
  double _internal_carrier_to_noise_density_db_per_hz() const;
  void _internal_set_carrier_to_noise_density_db_per_hz(double value);

  public:
  // optional double carrier_to_noise_plus_interference_db = 16 [json_name = "carrierToNoisePlusInterferenceDb"];
  bool has_carrier_to_noise_plus_interference_db() const;
  void clear_carrier_to_noise_plus_interference_db() ;
  double carrier_to_noise_plus_interference_db() const;
  void set_carrier_to_noise_plus_interference_db(double value);

  private:
  double _internal_carrier_to_noise_plus_interference_db() const;
  void _internal_set_carrier_to_noise_plus_interference_db(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WirelessLinkBudget_ComponentPropagationLossDbEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> component_propagation_loss_db_;
    double transmitter_antenna_gain_in_link_direction_db_;
    double effective_isotropic_radiated_power_dbw_;
    double propagation_loss_db_;
    double received_isotropic_power_dbw_;
    double received_power_flux_density_db_w_per_m2_;
    double receiver_antenna_gain_in_link_direction_db_;
    double power_at_receiver_output_dbw_;
    double carrier_to_noise_db_;
    double carrier_to_noise_density_db_per_hz_;
    double carrier_to_noise_plus_interference_db_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics) */ {
 public:
  inline WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics() : WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics(nullptr) {}
  ~WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics(const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& from);
  WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics&& from) noexcept
    : WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics() {
    *this = ::std::move(from);
  }

  inline WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& operator=(const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& operator=(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* internal_default_instance() {
    return reinterpret_cast<const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics*>(
               &_WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& a, WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& from) {
    WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics";
  }
  protected:
  explicit WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kPropagationDelayFieldNumber = 2,
    kPointingVectorFieldNumber = 3,
    kRangeMFieldNumber = 4,
    kDataRateBpsFieldNumber = 6,
    kTransmitterAntennaGainInLinkDirectionDbFieldNumber = 7,
    kReceiverAntennaGainInLinkDirectionDbFieldNumber = 8,
  };
  // optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::aalyria::spacetime::api::common::DateTime& timestamp() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::DateTime* release_timestamp();
  ::aalyria::spacetime::api::common::DateTime* mutable_timestamp();
  void set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp);
  private:
  const ::aalyria::spacetime::api::common::DateTime& _internal_timestamp() const;
  ::aalyria::spacetime::api::common::DateTime* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aalyria::spacetime::api::common::DateTime* timestamp);
  ::aalyria::spacetime::api::common::DateTime* unsafe_arena_release_timestamp();
  // optional .aalyria.spacetime.api.common.Duration propagation_delay = 2 [json_name = "propagationDelay"];
  bool has_propagation_delay() const;
  void clear_propagation_delay() ;
  const ::aalyria::spacetime::api::common::Duration& propagation_delay() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Duration* release_propagation_delay();
  ::aalyria::spacetime::api::common::Duration* mutable_propagation_delay();
  void set_allocated_propagation_delay(::aalyria::spacetime::api::common::Duration* propagation_delay);
  private:
  const ::aalyria::spacetime::api::common::Duration& _internal_propagation_delay() const;
  ::aalyria::spacetime::api::common::Duration* _internal_mutable_propagation_delay();
  public:
  void unsafe_arena_set_allocated_propagation_delay(
      ::aalyria::spacetime::api::common::Duration* propagation_delay);
  ::aalyria::spacetime::api::common::Duration* unsafe_arena_release_propagation_delay();
  // optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 3 [json_name = "pointingVector"];
  bool has_pointing_vector() const;
  void clear_pointing_vector() ;
  const ::aalyria::spacetime::api::common::PointingVector& pointing_vector() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::PointingVector* release_pointing_vector();
  ::aalyria::spacetime::api::common::PointingVector* mutable_pointing_vector();
  void set_allocated_pointing_vector(::aalyria::spacetime::api::common::PointingVector* pointing_vector);
  private:
  const ::aalyria::spacetime::api::common::PointingVector& _internal_pointing_vector() const;
  ::aalyria::spacetime::api::common::PointingVector* _internal_mutable_pointing_vector();
  public:
  void unsafe_arena_set_allocated_pointing_vector(
      ::aalyria::spacetime::api::common::PointingVector* pointing_vector);
  ::aalyria::spacetime::api::common::PointingVector* unsafe_arena_release_pointing_vector();
  // optional double range_m = 4 [json_name = "rangeM"];
  bool has_range_m() const;
  void clear_range_m() ;
  double range_m() const;
  void set_range_m(double value);

  private:
  double _internal_range_m() const;
  void _internal_set_range_m(double value);

  public:
  // optional double data_rate_bps = 6 [json_name = "dataRateBps"];
  bool has_data_rate_bps() const;
  void clear_data_rate_bps() ;
  double data_rate_bps() const;
  void set_data_rate_bps(double value);

  private:
  double _internal_data_rate_bps() const;
  void _internal_set_data_rate_bps(double value);

  public:
  // optional double transmitter_antenna_gain_in_link_direction_db = 7 [json_name = "transmitterAntennaGainInLinkDirectionDb"];
  bool has_transmitter_antenna_gain_in_link_direction_db() const;
  void clear_transmitter_antenna_gain_in_link_direction_db() ;
  double transmitter_antenna_gain_in_link_direction_db() const;
  void set_transmitter_antenna_gain_in_link_direction_db(double value);

  private:
  double _internal_transmitter_antenna_gain_in_link_direction_db() const;
  void _internal_set_transmitter_antenna_gain_in_link_direction_db(double value);

  public:
  // optional double receiver_antenna_gain_in_link_direction_db = 8 [json_name = "receiverAntennaGainInLinkDirectionDb"];
  bool has_receiver_antenna_gain_in_link_direction_db() const;
  void clear_receiver_antenna_gain_in_link_direction_db() ;
  double receiver_antenna_gain_in_link_direction_db() const;
  void set_receiver_antenna_gain_in_link_direction_db(double value);

  private:
  double _internal_receiver_antenna_gain_in_link_direction_db() const;
  void _internal_set_receiver_antenna_gain_in_link_direction_db(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::DateTime* timestamp_;
    ::aalyria::spacetime::api::common::Duration* propagation_delay_;
    ::aalyria::spacetime::api::common::PointingVector* pointing_vector_;
    double range_m_;
    double data_rate_bps_;
    double transmitter_antenna_gain_in_link_direction_db_;
    double receiver_antenna_gain_in_link_direction_db_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class WirelessLinkReport_WirelessAccessInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval) */ {
 public:
  inline WirelessLinkReport_WirelessAccessInterval() : WirelessLinkReport_WirelessAccessInterval(nullptr) {}
  ~WirelessLinkReport_WirelessAccessInterval() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessLinkReport_WirelessAccessInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirelessLinkReport_WirelessAccessInterval(const WirelessLinkReport_WirelessAccessInterval& from);
  WirelessLinkReport_WirelessAccessInterval(WirelessLinkReport_WirelessAccessInterval&& from) noexcept
    : WirelessLinkReport_WirelessAccessInterval() {
    *this = ::std::move(from);
  }

  inline WirelessLinkReport_WirelessAccessInterval& operator=(const WirelessLinkReport_WirelessAccessInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirelessLinkReport_WirelessAccessInterval& operator=(WirelessLinkReport_WirelessAccessInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirelessLinkReport_WirelessAccessInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirelessLinkReport_WirelessAccessInterval* internal_default_instance() {
    return reinterpret_cast<const WirelessLinkReport_WirelessAccessInterval*>(
               &_WirelessLinkReport_WirelessAccessInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WirelessLinkReport_WirelessAccessInterval& a, WirelessLinkReport_WirelessAccessInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(WirelessLinkReport_WirelessAccessInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirelessLinkReport_WirelessAccessInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirelessLinkReport_WirelessAccessInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirelessLinkReport_WirelessAccessInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirelessLinkReport_WirelessAccessInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirelessLinkReport_WirelessAccessInterval& from) {
    WirelessLinkReport_WirelessAccessInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirelessLinkReport_WirelessAccessInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval";
  }
  protected:
  explicit WirelessLinkReport_WirelessAccessInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics WirelessLinkMetrics;

  // accessors -------------------------------------------------------

  enum : int {
    kNoAccessReasonFieldNumber = 3,
    kSampledMetricsFieldNumber = 4,
    kIntervalFieldNumber = 1,
    kAccessibilityFieldNumber = 2,
  };
  // repeated string no_access_reason = 3 [json_name = "noAccessReason"];
  int no_access_reason_size() const;
  private:
  int _internal_no_access_reason_size() const;

  public:
  void clear_no_access_reason() ;
  const std::string& no_access_reason(int index) const;
  std::string* mutable_no_access_reason(int index);
  void set_no_access_reason(int index, const std::string& value);
  void set_no_access_reason(int index, std::string&& value);
  void set_no_access_reason(int index, const char* value);
  void set_no_access_reason(int index, const char* value, std::size_t size);
  void set_no_access_reason(int index, absl::string_view value);
  std::string* add_no_access_reason();
  void add_no_access_reason(const std::string& value);
  void add_no_access_reason(std::string&& value);
  void add_no_access_reason(const char* value);
  void add_no_access_reason(const char* value, std::size_t size);
  void add_no_access_reason(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& no_access_reason() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_no_access_reason();

  private:
  const std::string& _internal_no_access_reason(int index) const;
  std::string* _internal_add_no_access_reason();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_no_access_reason() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_no_access_reason();

  public:
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics sampled_metrics = 4 [json_name = "sampledMetrics"];
  int sampled_metrics_size() const;
  private:
  int _internal_sampled_metrics_size() const;

  public:
  void clear_sampled_metrics() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* mutable_sampled_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics >*
      mutable_sampled_metrics();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& _internal_sampled_metrics(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* _internal_add_sampled_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>& _internal_sampled_metrics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>* _internal_mutable_sampled_metrics();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& sampled_metrics(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* add_sampled_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics >&
      sampled_metrics() const;
  // optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::aalyria::spacetime::api::common::TimeInterval& interval() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TimeInterval* release_interval();
  ::aalyria::spacetime::api::common::TimeInterval* mutable_interval();
  void set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval);
  private:
  const ::aalyria::spacetime::api::common::TimeInterval& _internal_interval() const;
  ::aalyria::spacetime::api::common::TimeInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::aalyria::spacetime::api::common::TimeInterval* interval);
  ::aalyria::spacetime::api::common::TimeInterval* unsafe_arena_release_interval();
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
  bool has_accessibility() const;
  void clear_accessibility() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility accessibility() const;
  void set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility _internal_accessibility() const;
  void _internal_set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> no_access_reason_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics > sampled_metrics_;
    ::aalyria::spacetime::api::common::TimeInterval* interval_;
    int accessibility_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class WirelessLinkReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport) */ {
 public:
  inline WirelessLinkReport() : WirelessLinkReport(nullptr) {}
  ~WirelessLinkReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WirelessLinkReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirelessLinkReport(const WirelessLinkReport& from);
  WirelessLinkReport(WirelessLinkReport&& from) noexcept
    : WirelessLinkReport() {
    *this = ::std::move(from);
  }

  inline WirelessLinkReport& operator=(const WirelessLinkReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirelessLinkReport& operator=(WirelessLinkReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirelessLinkReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirelessLinkReport* internal_default_instance() {
    return reinterpret_cast<const WirelessLinkReport*>(
               &_WirelessLinkReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WirelessLinkReport& a, WirelessLinkReport& b) {
    a.Swap(&b);
  }
  inline void Swap(WirelessLinkReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirelessLinkReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirelessLinkReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirelessLinkReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirelessLinkReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirelessLinkReport& from) {
    WirelessLinkReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirelessLinkReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport";
  }
  protected:
  explicit WirelessLinkReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WirelessLinkReport_WirelessAccessInterval WirelessAccessInterval;

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFrequenciesHzFieldNumber = 3,
    kAccessIntervalsFieldNumber = 4,
    kBandProfileIdFieldNumber = 2,
    kDstFieldNumber = 1,
  };
  // repeated uint64 center_frequencies_hz = 3 [json_name = "centerFrequenciesHz"];
  int center_frequencies_hz_size() const;
  private:
  int _internal_center_frequencies_hz_size() const;

  public:
  void clear_center_frequencies_hz() ;
  ::uint64_t center_frequencies_hz(int index) const;
  void set_center_frequencies_hz(int index, ::uint64_t value);
  void add_center_frequencies_hz(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& center_frequencies_hz() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_center_frequencies_hz();

  private:
  ::uint64_t _internal_center_frequencies_hz(int index) const;
  void _internal_add_center_frequencies_hz(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_center_frequencies_hz() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_center_frequencies_hz();

  public:
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval access_intervals = 4 [json_name = "accessIntervals"];
  int access_intervals_size() const;
  private:
  int _internal_access_intervals_size() const;

  public:
  void clear_access_intervals() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* mutable_access_intervals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval >*
      mutable_access_intervals();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval& _internal_access_intervals(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* _internal_add_access_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval>& _internal_access_intervals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval>* _internal_mutable_access_intervals();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval& access_intervals(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* add_access_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval >&
      access_intervals() const;
  // optional string band_profile_id = 2 [json_name = "bandProfileId"];
  bool has_band_profile_id() const;
  void clear_band_profile_id() ;
  const std::string& band_profile_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_band_profile_id(Arg_&& arg, Args_... args);
  std::string* mutable_band_profile_id();
  PROTOBUF_NODISCARD std::string* release_band_profile_id();
  void set_allocated_band_profile_id(std::string* ptr);

  private:
  const std::string& _internal_band_profile_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_band_profile_id(
      const std::string& value);
  std::string* _internal_mutable_band_profile_id();

  public:
  // optional .aalyria.spacetime.api.common.TransceiverModelId dst = 1 [json_name = "dst"];
  bool has_dst() const;
  void clear_dst() ;
  const ::aalyria::spacetime::api::common::TransceiverModelId& dst() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransceiverModelId* release_dst();
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_dst();
  void set_allocated_dst(::aalyria::spacetime::api::common::TransceiverModelId* dst);
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_dst() const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_mutable_dst();
  public:
  void unsafe_arena_set_allocated_dst(
      ::aalyria::spacetime::api::common::TransceiverModelId* dst);
  ::aalyria::spacetime::api::common::TransceiverModelId* unsafe_arena_release_dst();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> center_frequencies_hz_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval > access_intervals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr band_profile_id_;
    ::aalyria::spacetime::api::common::TransceiverModelId* dst_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class InterfaceLinkReport_AccessInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval) */ {
 public:
  inline InterfaceLinkReport_AccessInterval() : InterfaceLinkReport_AccessInterval(nullptr) {}
  ~InterfaceLinkReport_AccessInterval() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterfaceLinkReport_AccessInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceLinkReport_AccessInterval(const InterfaceLinkReport_AccessInterval& from);
  InterfaceLinkReport_AccessInterval(InterfaceLinkReport_AccessInterval&& from) noexcept
    : InterfaceLinkReport_AccessInterval() {
    *this = ::std::move(from);
  }

  inline InterfaceLinkReport_AccessInterval& operator=(const InterfaceLinkReport_AccessInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceLinkReport_AccessInterval& operator=(InterfaceLinkReport_AccessInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceLinkReport_AccessInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterfaceLinkReport_AccessInterval* internal_default_instance() {
    return reinterpret_cast<const InterfaceLinkReport_AccessInterval*>(
               &_InterfaceLinkReport_AccessInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InterfaceLinkReport_AccessInterval& a, InterfaceLinkReport_AccessInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceLinkReport_AccessInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceLinkReport_AccessInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceLinkReport_AccessInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceLinkReport_AccessInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceLinkReport_AccessInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterfaceLinkReport_AccessInterval& from) {
    InterfaceLinkReport_AccessInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceLinkReport_AccessInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval";
  }
  protected:
  explicit InterfaceLinkReport_AccessInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
    kFrameDelayFieldNumber = 3,
    kDataRateBpsFieldNumber = 4,
    kAccessibilityFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
  bool has_interval() const;
  void clear_interval() ;
  const ::aalyria::spacetime::api::common::TimeInterval& interval() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TimeInterval* release_interval();
  ::aalyria::spacetime::api::common::TimeInterval* mutable_interval();
  void set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval);
  private:
  const ::aalyria::spacetime::api::common::TimeInterval& _internal_interval() const;
  ::aalyria::spacetime::api::common::TimeInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::aalyria::spacetime::api::common::TimeInterval* interval);
  ::aalyria::spacetime::api::common::TimeInterval* unsafe_arena_release_interval();
  // optional .aalyria.spacetime.api.common.Duration frame_delay = 3 [json_name = "frameDelay"];
  bool has_frame_delay() const;
  void clear_frame_delay() ;
  const ::aalyria::spacetime::api::common::Duration& frame_delay() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::Duration* release_frame_delay();
  ::aalyria::spacetime::api::common::Duration* mutable_frame_delay();
  void set_allocated_frame_delay(::aalyria::spacetime::api::common::Duration* frame_delay);
  private:
  const ::aalyria::spacetime::api::common::Duration& _internal_frame_delay() const;
  ::aalyria::spacetime::api::common::Duration* _internal_mutable_frame_delay();
  public:
  void unsafe_arena_set_allocated_frame_delay(
      ::aalyria::spacetime::api::common::Duration* frame_delay);
  ::aalyria::spacetime::api::common::Duration* unsafe_arena_release_frame_delay();
  // optional double data_rate_bps = 4 [json_name = "dataRateBps"];
  bool has_data_rate_bps() const;
  void clear_data_rate_bps() ;
  double data_rate_bps() const;
  void set_data_rate_bps(double value);

  private:
  double _internal_data_rate_bps() const;
  void _internal_set_data_rate_bps(double value);

  public:
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
  bool has_accessibility() const;
  void clear_accessibility() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility accessibility() const;
  void set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value);

  private:
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility _internal_accessibility() const;
  void _internal_set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TimeInterval* interval_;
    ::aalyria::spacetime::api::common::Duration* frame_delay_;
    double data_rate_bps_;
    int accessibility_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class InterfaceLinkReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport) */ {
 public:
  inline InterfaceLinkReport() : InterfaceLinkReport(nullptr) {}
  ~InterfaceLinkReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterfaceLinkReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceLinkReport(const InterfaceLinkReport& from);
  InterfaceLinkReport(InterfaceLinkReport&& from) noexcept
    : InterfaceLinkReport() {
    *this = ::std::move(from);
  }

  inline InterfaceLinkReport& operator=(const InterfaceLinkReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceLinkReport& operator=(InterfaceLinkReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceLinkReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterfaceLinkReport* internal_default_instance() {
    return reinterpret_cast<const InterfaceLinkReport*>(
               &_InterfaceLinkReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InterfaceLinkReport& a, InterfaceLinkReport& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceLinkReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceLinkReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceLinkReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceLinkReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceLinkReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InterfaceLinkReport& from) {
    InterfaceLinkReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceLinkReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport";
  }
  protected:
  explicit InterfaceLinkReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InterfaceLinkReport_AccessInterval AccessInterval;

  // accessors -------------------------------------------------------

  enum : int {
    kAccessIntervalsFieldNumber = 6,
    kSrcFieldNumber = 4,
    kDstFieldNumber = 5,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval access_intervals = 6 [json_name = "accessIntervals"];
  int access_intervals_size() const;
  private:
  int _internal_access_intervals_size() const;

  public:
  void clear_access_intervals() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* mutable_access_intervals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval >*
      mutable_access_intervals();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval& _internal_access_intervals(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* _internal_add_access_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval>& _internal_access_intervals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval>* _internal_mutable_access_intervals();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval& access_intervals(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* add_access_intervals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval >&
      access_intervals() const;
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId src = 4 [json_name = "src"];
  bool has_src() const;
  void clear_src() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& src() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_src();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_src();
  void set_allocated_src(::aalyria::spacetime::api::common::NetworkInterfaceId* src);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_src() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* src);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_src();
  // optional .aalyria.spacetime.api.common.NetworkInterfaceId dst = 5 [json_name = "dst"];
  bool has_dst() const;
  void clear_dst() ;
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& dst() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkInterfaceId* release_dst();
  ::aalyria::spacetime::api::common::NetworkInterfaceId* mutable_dst();
  void set_allocated_dst(::aalyria::spacetime::api::common::NetworkInterfaceId* dst);
  private:
  const ::aalyria::spacetime::api::common::NetworkInterfaceId& _internal_dst() const;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _internal_mutable_dst();
  public:
  void unsafe_arena_set_allocated_dst(
      ::aalyria::spacetime::api::common::NetworkInterfaceId* dst);
  ::aalyria::spacetime::api::common::NetworkInterfaceId* unsafe_arena_release_dst();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval > access_intervals_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* src_;
    ::aalyria::spacetime::api::common::NetworkInterfaceId* dst_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};// -------------------------------------------------------------------

class TransceiverLinkReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport) */ {
 public:
  inline TransceiverLinkReport() : TransceiverLinkReport(nullptr) {}
  ~TransceiverLinkReport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransceiverLinkReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransceiverLinkReport(const TransceiverLinkReport& from);
  TransceiverLinkReport(TransceiverLinkReport&& from) noexcept
    : TransceiverLinkReport() {
    *this = ::std::move(from);
  }

  inline TransceiverLinkReport& operator=(const TransceiverLinkReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransceiverLinkReport& operator=(TransceiverLinkReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransceiverLinkReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransceiverLinkReport* internal_default_instance() {
    return reinterpret_cast<const TransceiverLinkReport*>(
               &_TransceiverLinkReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransceiverLinkReport& a, TransceiverLinkReport& b) {
    a.Swap(&b);
  }
  inline void Swap(TransceiverLinkReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransceiverLinkReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransceiverLinkReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransceiverLinkReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransceiverLinkReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransceiverLinkReport& from) {
    TransceiverLinkReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransceiverLinkReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport";
  }
  protected:
  explicit TransceiverLinkReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 2,
    kSrcFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport links = 2 [json_name = "links"];
  int links_size() const;
  private:
  int _internal_links_size() const;

  public:
  void clear_links() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport >*
      mutable_links();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport& _internal_links(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* _internal_add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport>& _internal_links() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport>* _internal_mutable_links();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport& links(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport >&
      links() const;
  // optional .aalyria.spacetime.api.common.TransceiverModelId src = 1 [json_name = "src"];
  bool has_src() const;
  void clear_src() ;
  const ::aalyria::spacetime::api::common::TransceiverModelId& src() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransceiverModelId* release_src();
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_src();
  void set_allocated_src(::aalyria::spacetime::api::common::TransceiverModelId* src);
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_src() const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_mutable_src();
  public:
  void unsafe_arena_set_allocated_src(
      ::aalyria::spacetime::api::common::TransceiverModelId* src);
  ::aalyria::spacetime::api::common::TransceiverModelId* unsafe_arena_release_src();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport > links_;
    ::aalyria::spacetime::api::common::TransceiverModelId* src_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NetworkLink

// optional .aalyria.spacetime.api.common.NetworkInterfaceId src = 3 [json_name = "src"];
inline bool NetworkLink::has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& NetworkLink::_internal_src() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.src_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& NetworkLink::src() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.src)
  return _internal_src();
}
inline void NetworkLink::unsafe_arena_set_allocated_src(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  _impl_.src_ = src;
  if (src) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.src)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::release_src() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.src)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.src_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.src_ = p;
  }
  return _impl_.src_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::mutable_src() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.src)
  return _msg;
}
inline void NetworkLink::set_allocated_src(::aalyria::spacetime::api::common::NetworkInterfaceId* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src));
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_ = src;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.src)
}

// optional .aalyria.spacetime.api.common.NetworkInterfaceId dst = 4 [json_name = "dst"];
inline bool NetworkLink::has_dst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& NetworkLink::_internal_dst() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.dst_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& NetworkLink::dst() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.dst)
  return _internal_dst();
}
inline void NetworkLink::unsafe_arena_set_allocated_dst(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* dst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  _impl_.dst_ = dst;
  if (dst) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.dst)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::release_dst() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::unsafe_arena_release_dst() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.dst)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::_internal_mutable_dst() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.dst_ = p;
  }
  return _impl_.dst_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* NetworkLink::mutable_dst() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.dst)
  return _msg;
}
inline void NetworkLink::set_allocated_dst(::aalyria::spacetime::api::common::NetworkInterfaceId* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst));
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink.dst)
}

// -------------------------------------------------------------------

// RadioConfiguration

// optional .aalyria.spacetime.api.common.NetworkInterfaceId interface_id = 1 [json_name = "interfaceId"];
inline bool RadioConfiguration::has_interface_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interface_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& RadioConfiguration::_internal_interface_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.interface_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& RadioConfiguration::interface_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.interface_id)
  return _internal_interface_id();
}
inline void RadioConfiguration::unsafe_arena_set_allocated_interface_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_id_);
  }
  _impl_.interface_id_ = interface_id;
  if (interface_id) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.interface_id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* RadioConfiguration::release_interface_id() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.interface_id_;
  _impl_.interface_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* RadioConfiguration::unsafe_arena_release_interface_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.interface_id)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.interface_id_;
  _impl_.interface_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* RadioConfiguration::_internal_mutable_interface_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.interface_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.interface_id_ = p;
  }
  return _impl_.interface_id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* RadioConfiguration::mutable_interface_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_interface_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.interface_id)
  return _msg;
}
inline void RadioConfiguration::set_allocated_interface_id(::aalyria::spacetime::api::common::NetworkInterfaceId* interface_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_id_);
  }
  if (interface_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface_id));
    if (message_arena != submessage_arena) {
      interface_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.interface_id_ = interface_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.interface_id)
}

// optional .aalyria.spacetime.api.common.TransmitterState tx_state = 2 [json_name = "txState"];
inline bool RadioConfiguration::has_tx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tx_state_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioConfiguration::_internal_tx_state() const {
  const ::aalyria::spacetime::api::common::TransmitterState* p = _impl_.tx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransmitterState&>(
      ::aalyria::spacetime::api::common::_TransmitterState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransmitterState& RadioConfiguration::tx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tx_state)
  return _internal_tx_state();
}
inline void RadioConfiguration::unsafe_arena_set_allocated_tx_state(
    ::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_state_);
  }
  _impl_.tx_state_ = tx_state;
  if (tx_state) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tx_state)
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioConfiguration::release_tx_state() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioConfiguration::unsafe_arena_release_tx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tx_state)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::TransmitterState* temp = _impl_.tx_state_;
  _impl_.tx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioConfiguration::_internal_mutable_tx_state() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.tx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransmitterState>(GetArenaForAllocation());
    _impl_.tx_state_ = p;
  }
  return _impl_.tx_state_;
}
inline ::aalyria::spacetime::api::common::TransmitterState* RadioConfiguration::mutable_tx_state() {
  ::aalyria::spacetime::api::common::TransmitterState* _msg = _internal_mutable_tx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tx_state)
  return _msg;
}
inline void RadioConfiguration::set_allocated_tx_state(::aalyria::spacetime::api::common::TransmitterState* tx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_state_);
  }
  if (tx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tx_state));
    if (message_arena != submessage_arena) {
      tx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tx_state_ = tx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tx_state)
}

// optional .aalyria.spacetime.api.common.ReceiverState rx_state = 3 [json_name = "rxState"];
inline bool RadioConfiguration::has_rx_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_state_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioConfiguration::_internal_rx_state() const {
  const ::aalyria::spacetime::api::common::ReceiverState* p = _impl_.rx_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ReceiverState&>(
      ::aalyria::spacetime::api::common::_ReceiverState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ReceiverState& RadioConfiguration::rx_state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rx_state)
  return _internal_rx_state();
}
inline void RadioConfiguration::unsafe_arena_set_allocated_rx_state(
    ::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_state_);
  }
  _impl_.rx_state_ = rx_state;
  if (rx_state) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rx_state)
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioConfiguration::release_rx_state() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioConfiguration::unsafe_arena_release_rx_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rx_state)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::common::ReceiverState* temp = _impl_.rx_state_;
  _impl_.rx_state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioConfiguration::_internal_mutable_rx_state() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rx_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ReceiverState>(GetArenaForAllocation());
    _impl_.rx_state_ = p;
  }
  return _impl_.rx_state_;
}
inline ::aalyria::spacetime::api::common::ReceiverState* RadioConfiguration::mutable_rx_state() {
  ::aalyria::spacetime::api::common::ReceiverState* _msg = _internal_mutable_rx_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rx_state)
  return _msg;
}
inline void RadioConfiguration::set_allocated_rx_state(::aalyria::spacetime::api::common::ReceiverState* rx_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rx_state_);
  }
  if (rx_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rx_state));
    if (message_arena != submessage_arena) {
      rx_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rx_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rx_state_ = rx_state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rx_state)
}

// optional string rate_table_id = 5 [json_name = "rateTableId"];
inline bool RadioConfiguration::has_rate_table_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RadioConfiguration::clear_rate_table_id() {
  _impl_.rate_table_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RadioConfiguration::rate_table_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rate_table_id)
  return _internal_rate_table_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RadioConfiguration::set_rate_table_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rate_table_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rate_table_id)
}
inline std::string* RadioConfiguration::mutable_rate_table_id() {
  std::string* _s = _internal_mutable_rate_table_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rate_table_id)
  return _s;
}
inline const std::string& RadioConfiguration::_internal_rate_table_id() const {
  return _impl_.rate_table_id_.Get();
}
inline void RadioConfiguration::_internal_set_rate_table_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.rate_table_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RadioConfiguration::_internal_mutable_rate_table_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rate_table_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RadioConfiguration::release_rate_table_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rate_table_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.rate_table_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rate_table_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RadioConfiguration::set_allocated_rate_table_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rate_table_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rate_table_id_.IsDefault()) {
          _impl_.rate_table_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.rate_table_id)
}

// optional .aalyria.spacetime.api.common.TdmaSchedule tdma_schedule = 4 [json_name = "tdmaSchedule"];
inline bool RadioConfiguration::has_tdma_schedule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tdma_schedule_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioConfiguration::_internal_tdma_schedule() const {
  const ::aalyria::spacetime::api::common::TdmaSchedule* p = _impl_.tdma_schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TdmaSchedule&>(
      ::aalyria::spacetime::api::common::_TdmaSchedule_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TdmaSchedule& RadioConfiguration::tdma_schedule() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tdma_schedule)
  return _internal_tdma_schedule();
}
inline void RadioConfiguration::unsafe_arena_set_allocated_tdma_schedule(
    ::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tdma_schedule_);
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  if (tdma_schedule) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tdma_schedule)
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioConfiguration::release_tdma_schedule() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioConfiguration::unsafe_arena_release_tdma_schedule() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tdma_schedule)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::aalyria::spacetime::api::common::TdmaSchedule* temp = _impl_.tdma_schedule_;
  _impl_.tdma_schedule_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioConfiguration::_internal_mutable_tdma_schedule() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.tdma_schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TdmaSchedule>(GetArenaForAllocation());
    _impl_.tdma_schedule_ = p;
  }
  return _impl_.tdma_schedule_;
}
inline ::aalyria::spacetime::api::common::TdmaSchedule* RadioConfiguration::mutable_tdma_schedule() {
  ::aalyria::spacetime::api::common::TdmaSchedule* _msg = _internal_mutable_tdma_schedule();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tdma_schedule)
  return _msg;
}
inline void RadioConfiguration::set_allocated_tdma_schedule(::aalyria::spacetime::api::common::TdmaSchedule* tdma_schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tdma_schedule_);
  }
  if (tdma_schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tdma_schedule));
    if (message_arena != submessage_arena) {
      tdma_schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tdma_schedule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tdma_schedule_ = tdma_schedule;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration.tdma_schedule)
}

// -------------------------------------------------------------------

// Radio

// optional uint64 center_frequency_hz = 1 [json_name = "centerFrequencyHz"];
inline bool Radio::has_center_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Radio::clear_center_frequency_hz() {
  _impl_.center_frequency_hz_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t Radio::center_frequency_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.center_frequency_hz)
  return _internal_center_frequency_hz();
}
inline void Radio::set_center_frequency_hz(::uint64_t value) {
  _internal_set_center_frequency_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.center_frequency_hz)
}
inline ::uint64_t Radio::_internal_center_frequency_hz() const {
  return _impl_.center_frequency_hz_;
}
inline void Radio::_internal_set_center_frequency_hz(::uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.center_frequency_hz_ = value;
}

// optional string band_profile_id = 2 [json_name = "bandProfileId"];
inline bool Radio::has_band_profile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Radio::clear_band_profile_id() {
  _impl_.band_profile_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Radio::band_profile_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.band_profile_id)
  return _internal_band_profile_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Radio::set_band_profile_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.band_profile_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.band_profile_id)
}
inline std::string* Radio::mutable_band_profile_id() {
  std::string* _s = _internal_mutable_band_profile_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.band_profile_id)
  return _s;
}
inline const std::string& Radio::_internal_band_profile_id() const {
  return _impl_.band_profile_id_.Get();
}
inline void Radio::_internal_set_band_profile_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.band_profile_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Radio::_internal_mutable_band_profile_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.band_profile_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Radio::release_band_profile_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.band_profile_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.band_profile_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.band_profile_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Radio::set_allocated_band_profile_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.band_profile_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.band_profile_id_.IsDefault()) {
          _impl_.band_profile_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Radio.band_profile_id)
}

// -------------------------------------------------------------------

// LinkEnd

// optional .aalyria.spacetime.api.common.NetworkInterfaceId id = 3 [json_name = "id"];
inline bool LinkEnd::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& LinkEnd::_internal_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& LinkEnd::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd.id)
  return _internal_id();
}
inline void LinkEnd::unsafe_arena_set_allocated_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd.id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* LinkEnd::release_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* LinkEnd::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd.id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* LinkEnd::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* LinkEnd::mutable_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd.id)
  return _msg;
}
inline void LinkEnd::set_allocated_id(::aalyria::spacetime::api::common::NetworkInterfaceId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd.id)
}

// -------------------------------------------------------------------

// BeamTarget

// .aalyria.spacetime.api.common.TransceiverModelId transceiver_id = 1 [json_name = "transceiverId"];
inline bool BeamTarget::has_transceiver_id() const {
  return type_case() == kTransceiverId;
}
inline bool BeamTarget::_internal_has_transceiver_id() const {
  return type_case() == kTransceiverId;
}
inline void BeamTarget::set_has_transceiver_id() {
  _impl_._oneof_case_[0] = kTransceiverId;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* BeamTarget::release_transceiver_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.transceiver_id)
  if (type_case() == kTransceiverId) {
    clear_has_type();
    ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.type_.transceiver_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.transceiver_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& BeamTarget::_internal_transceiver_id() const {
  return type_case() == kTransceiverId
      ? *_impl_.type_.transceiver_id_
      : reinterpret_cast<::aalyria::spacetime::api::common::TransceiverModelId&>(::aalyria::spacetime::api::common::_TransceiverModelId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& BeamTarget::transceiver_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.transceiver_id)
  return _internal_transceiver_id();
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* BeamTarget::unsafe_arena_release_transceiver_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.transceiver_id)
  if (type_case() == kTransceiverId) {
    clear_has_type();
    ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.type_.transceiver_id_;
    _impl_.type_.transceiver_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BeamTarget::unsafe_arena_set_allocated_transceiver_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_id) {
  clear_type();
  if (transceiver_id) {
    set_has_transceiver_id();
    _impl_.type_.transceiver_id_ = transceiver_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.transceiver_id)
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* BeamTarget::_internal_mutable_transceiver_id() {
  if (type_case() != kTransceiverId) {
    clear_type();
    set_has_transceiver_id();
    _impl_.type_.transceiver_id_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::TransceiverModelId >(GetArenaForAllocation());
  }
  return _impl_.type_.transceiver_id_;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* BeamTarget::mutable_transceiver_id() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _msg = _internal_mutable_transceiver_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.transceiver_id)
  return _msg;
}

// .aalyria.spacetime.api.common.Motion coordinates = 2 [json_name = "coordinates"];
inline bool BeamTarget::has_coordinates() const {
  return type_case() == kCoordinates;
}
inline bool BeamTarget::_internal_has_coordinates() const {
  return type_case() == kCoordinates;
}
inline void BeamTarget::set_has_coordinates() {
  _impl_._oneof_case_[0] = kCoordinates;
}
inline ::aalyria::spacetime::api::common::Motion* BeamTarget::release_coordinates() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.coordinates)
  if (type_case() == kCoordinates) {
    clear_has_type();
    ::aalyria::spacetime::api::common::Motion* temp = _impl_.type_.coordinates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::Motion& BeamTarget::_internal_coordinates() const {
  return type_case() == kCoordinates
      ? *_impl_.type_.coordinates_
      : reinterpret_cast<::aalyria::spacetime::api::common::Motion&>(::aalyria::spacetime::api::common::_Motion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Motion& BeamTarget::coordinates() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.coordinates)
  return _internal_coordinates();
}
inline ::aalyria::spacetime::api::common::Motion* BeamTarget::unsafe_arena_release_coordinates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.coordinates)
  if (type_case() == kCoordinates) {
    clear_has_type();
    ::aalyria::spacetime::api::common::Motion* temp = _impl_.type_.coordinates_;
    _impl_.type_.coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BeamTarget::unsafe_arena_set_allocated_coordinates(::aalyria::spacetime::api::common::Motion* coordinates) {
  clear_type();
  if (coordinates) {
    set_has_coordinates();
    _impl_.type_.coordinates_ = coordinates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.coordinates)
}
inline ::aalyria::spacetime::api::common::Motion* BeamTarget::_internal_mutable_coordinates() {
  if (type_case() != kCoordinates) {
    clear_type();
    set_has_coordinates();
    _impl_.type_.coordinates_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::Motion >(GetArenaForAllocation());
  }
  return _impl_.type_.coordinates_;
}
inline ::aalyria::spacetime::api::common::Motion* BeamTarget::mutable_coordinates() {
  ::aalyria::spacetime::api::common::Motion* _msg = _internal_mutable_coordinates();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget.coordinates)
  return _msg;
}

inline bool BeamTarget::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void BeamTarget::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline BeamTarget::TypeCase BeamTarget::type_case() const {
  return BeamTarget::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BidirectionalLink

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd a = 1 [json_name = "a"];
inline bool BidirectionalLink::has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_ != nullptr);
  return value;
}
inline void BidirectionalLink::clear_a() {
  if (_impl_.a_ != nullptr) _impl_.a_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& BidirectionalLink::_internal_a() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* p = _impl_.a_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_LinkEnd_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& BidirectionalLink::a() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a)
  return _internal_a();
}
inline void BidirectionalLink::unsafe_arena_set_allocated_a(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_);
  }
  _impl_.a_ = a;
  if (a) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::release_a() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* temp = _impl_.a_;
  _impl_.a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* temp = _impl_.a_;
  _impl_.a_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::_internal_mutable_a() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.a_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd>(GetArenaForAllocation());
    _impl_.a_ = p;
  }
  return _impl_.a_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::mutable_a() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a)
  return _msg;
}
inline void BidirectionalLink::set_allocated_a(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a_;
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a);
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.a_ = a;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.LinkEnd b = 2 [json_name = "b"];
inline bool BidirectionalLink::has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.b_ != nullptr);
  return value;
}
inline void BidirectionalLink::clear_b() {
  if (_impl_.b_ != nullptr) _impl_.b_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& BidirectionalLink::_internal_b() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* p = _impl_.b_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_LinkEnd_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd& BidirectionalLink::b() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b)
  return _internal_b();
}
inline void BidirectionalLink::unsafe_arena_set_allocated_b(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.b_);
  }
  _impl_.b_ = b;
  if (b) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::release_b() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* temp = _impl_.b_;
  _impl_.b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* temp = _impl_.b_;
  _impl_.b_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::_internal_mutable_b() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.b_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd>(GetArenaForAllocation());
    _impl_.b_ = p;
  }
  return _impl_.b_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* BidirectionalLink::mutable_b() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b)
  return _msg;
}
inline void BidirectionalLink::set_allocated_b(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkEnd* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.b_;
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(b);
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.b_ = b;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio a_to_b_radio = 3 [json_name = "aToBRadio"];
inline bool BidirectionalLink::has_a_to_b_radio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_to_b_radio_ != nullptr);
  return value;
}
inline void BidirectionalLink::clear_a_to_b_radio() {
  if (_impl_.a_to_b_radio_ != nullptr) _impl_.a_to_b_radio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& BidirectionalLink::_internal_a_to_b_radio() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* p = _impl_.a_to_b_radio_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_Radio_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& BidirectionalLink::a_to_b_radio() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a_to_b_radio)
  return _internal_a_to_b_radio();
}
inline void BidirectionalLink::unsafe_arena_set_allocated_a_to_b_radio(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* a_to_b_radio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_to_b_radio_);
  }
  _impl_.a_to_b_radio_ = a_to_b_radio;
  if (a_to_b_radio) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a_to_b_radio)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::release_a_to_b_radio() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.a_to_b_radio_;
  _impl_.a_to_b_radio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::unsafe_arena_release_a_to_b_radio() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a_to_b_radio)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.a_to_b_radio_;
  _impl_.a_to_b_radio_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::_internal_mutable_a_to_b_radio() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.a_to_b_radio_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Radio>(GetArenaForAllocation());
    _impl_.a_to_b_radio_ = p;
  }
  return _impl_.a_to_b_radio_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::mutable_a_to_b_radio() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _msg = _internal_mutable_a_to_b_radio();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a_to_b_radio)
  return _msg;
}
inline void BidirectionalLink::set_allocated_a_to_b_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* a_to_b_radio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a_to_b_radio_;
  }
  if (a_to_b_radio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a_to_b_radio);
    if (message_arena != submessage_arena) {
      a_to_b_radio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a_to_b_radio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.a_to_b_radio_ = a_to_b_radio;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.a_to_b_radio)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio b_to_a_radio = 4 [json_name = "bToARadio"];
inline bool BidirectionalLink::has_b_to_a_radio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.b_to_a_radio_ != nullptr);
  return value;
}
inline void BidirectionalLink::clear_b_to_a_radio() {
  if (_impl_.b_to_a_radio_ != nullptr) _impl_.b_to_a_radio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& BidirectionalLink::_internal_b_to_a_radio() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* p = _impl_.b_to_a_radio_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_Radio_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& BidirectionalLink::b_to_a_radio() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b_to_a_radio)
  return _internal_b_to_a_radio();
}
inline void BidirectionalLink::unsafe_arena_set_allocated_b_to_a_radio(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* b_to_a_radio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.b_to_a_radio_);
  }
  _impl_.b_to_a_radio_ = b_to_a_radio;
  if (b_to_a_radio) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b_to_a_radio)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::release_b_to_a_radio() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.b_to_a_radio_;
  _impl_.b_to_a_radio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::unsafe_arena_release_b_to_a_radio() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b_to_a_radio)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.b_to_a_radio_;
  _impl_.b_to_a_radio_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::_internal_mutable_b_to_a_radio() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.b_to_a_radio_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Radio>(GetArenaForAllocation());
    _impl_.b_to_a_radio_ = p;
  }
  return _impl_.b_to_a_radio_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* BidirectionalLink::mutable_b_to_a_radio() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _msg = _internal_mutable_b_to_a_radio();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b_to_a_radio)
  return _msg;
}
inline void BidirectionalLink::set_allocated_b_to_a_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* b_to_a_radio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.b_to_a_radio_;
  }
  if (b_to_a_radio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(b_to_a_radio);
    if (message_arena != submessage_arena) {
      b_to_a_radio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b_to_a_radio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.b_to_a_radio_ = b_to_a_radio;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink.b_to_a_radio)
}

// -------------------------------------------------------------------

// DirectionalLink

// optional .aalyria.spacetime.api.common.NetworkInterfaceId id = 1 [json_name = "id"];
inline bool DirectionalLink::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& DirectionalLink::_internal_id() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& DirectionalLink::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.id)
  return _internal_id();
}
inline void DirectionalLink::unsafe_arena_set_allocated_id(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.id)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* DirectionalLink::release_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* DirectionalLink::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* DirectionalLink::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* DirectionalLink::mutable_id() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.id)
  return _msg;
}
inline void DirectionalLink::set_allocated_id(::aalyria::spacetime::api::common::NetworkInterfaceId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.id)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.Radio radio_configuration = 2 [json_name = "radioConfiguration"];
inline bool DirectionalLink::has_radio_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radio_configuration_ != nullptr);
  return value;
}
inline void DirectionalLink::clear_radio_configuration() {
  if (_impl_.radio_configuration_ != nullptr) _impl_.radio_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& DirectionalLink::_internal_radio_configuration() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* p = _impl_.radio_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_Radio_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio& DirectionalLink::radio_configuration() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.radio_configuration)
  return _internal_radio_configuration();
}
inline void DirectionalLink::unsafe_arena_set_allocated_radio_configuration(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* radio_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.radio_configuration_);
  }
  _impl_.radio_configuration_ = radio_configuration;
  if (radio_configuration) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.radio_configuration)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* DirectionalLink::release_radio_configuration() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.radio_configuration_;
  _impl_.radio_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* DirectionalLink::unsafe_arena_release_radio_configuration() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.radio_configuration)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* temp = _impl_.radio_configuration_;
  _impl_.radio_configuration_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* DirectionalLink::_internal_mutable_radio_configuration() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.radio_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::Radio>(GetArenaForAllocation());
    _impl_.radio_configuration_ = p;
  }
  return _impl_.radio_configuration_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* DirectionalLink::mutable_radio_configuration() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* _msg = _internal_mutable_radio_configuration();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.radio_configuration)
  return _msg;
}
inline void DirectionalLink::set_allocated_radio_configuration(::aalyria::spacetime::api::nbi::v1alpha::resources::Radio* radio_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.radio_configuration_;
  }
  if (radio_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(radio_configuration);
    if (message_arena != submessage_arena) {
      radio_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio_configuration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.radio_configuration_ = radio_configuration;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.radio_configuration)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.BeamTarget target = 3 [json_name = "target"];
inline bool DirectionalLink::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void DirectionalLink::clear_target() {
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget& DirectionalLink::_internal_target() const {
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget&>(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::_BeamTarget_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget& DirectionalLink::target() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.target)
  return _internal_target();
}
inline void DirectionalLink::unsafe_arena_set_allocated_target(
    ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.target)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* DirectionalLink::release_target() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* DirectionalLink::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.target)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* DirectionalLink::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* DirectionalLink::mutable_target() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.target)
  return _msg;
}
inline void DirectionalLink::set_allocated_target(::aalyria::spacetime::api::nbi::v1alpha::resources::BeamTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink.target)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WirelessLinkBudget

// optional double transmitter_antenna_gain_in_link_direction_db = 1 [json_name = "transmitterAntennaGainInLinkDirectionDb"];
inline bool WirelessLinkBudget::has_transmitter_antenna_gain_in_link_direction_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_transmitter_antenna_gain_in_link_direction_db() {
  _impl_.transmitter_antenna_gain_in_link_direction_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double WirelessLinkBudget::transmitter_antenna_gain_in_link_direction_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.transmitter_antenna_gain_in_link_direction_db)
  return _internal_transmitter_antenna_gain_in_link_direction_db();
}
inline void WirelessLinkBudget::set_transmitter_antenna_gain_in_link_direction_db(double value) {
  _internal_set_transmitter_antenna_gain_in_link_direction_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.transmitter_antenna_gain_in_link_direction_db)
}
inline double WirelessLinkBudget::_internal_transmitter_antenna_gain_in_link_direction_db() const {
  return _impl_.transmitter_antenna_gain_in_link_direction_db_;
}
inline void WirelessLinkBudget::_internal_set_transmitter_antenna_gain_in_link_direction_db(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transmitter_antenna_gain_in_link_direction_db_ = value;
}

// optional double effective_isotropic_radiated_power_dbw = 2 [json_name = "effectiveIsotropicRadiatedPowerDbw"];
inline bool WirelessLinkBudget::has_effective_isotropic_radiated_power_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_effective_isotropic_radiated_power_dbw() {
  _impl_.effective_isotropic_radiated_power_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double WirelessLinkBudget::effective_isotropic_radiated_power_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.effective_isotropic_radiated_power_dbw)
  return _internal_effective_isotropic_radiated_power_dbw();
}
inline void WirelessLinkBudget::set_effective_isotropic_radiated_power_dbw(double value) {
  _internal_set_effective_isotropic_radiated_power_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.effective_isotropic_radiated_power_dbw)
}
inline double WirelessLinkBudget::_internal_effective_isotropic_radiated_power_dbw() const {
  return _impl_.effective_isotropic_radiated_power_dbw_;
}
inline void WirelessLinkBudget::_internal_set_effective_isotropic_radiated_power_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.effective_isotropic_radiated_power_dbw_ = value;
}

// map<string, double> component_propagation_loss_db = 15 [json_name = "componentPropagationLossDb"];
inline int WirelessLinkBudget::_internal_component_propagation_loss_db_size() const {
  return _impl_.component_propagation_loss_db_.size();
}
inline int WirelessLinkBudget::component_propagation_loss_db_size() const {
  return _internal_component_propagation_loss_db_size();
}
inline void WirelessLinkBudget::clear_component_propagation_loss_db() {
  _impl_.component_propagation_loss_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
WirelessLinkBudget::_internal_component_propagation_loss_db() const {
  return _impl_.component_propagation_loss_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
WirelessLinkBudget::component_propagation_loss_db() const {
  // @@protoc_insertion_point(field_map:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.component_propagation_loss_db)
  return _internal_component_propagation_loss_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
WirelessLinkBudget::_internal_mutable_component_propagation_loss_db() {
  return _impl_.component_propagation_loss_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
WirelessLinkBudget::mutable_component_propagation_loss_db() {
  // @@protoc_insertion_point(field_mutable_map:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.component_propagation_loss_db)
  return _internal_mutable_component_propagation_loss_db();
}

// optional double propagation_loss_db = 3 [json_name = "propagationLossDb"];
inline bool WirelessLinkBudget::has_propagation_loss_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_propagation_loss_db() {
  _impl_.propagation_loss_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double WirelessLinkBudget::propagation_loss_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.propagation_loss_db)
  return _internal_propagation_loss_db();
}
inline void WirelessLinkBudget::set_propagation_loss_db(double value) {
  _internal_set_propagation_loss_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.propagation_loss_db)
}
inline double WirelessLinkBudget::_internal_propagation_loss_db() const {
  return _impl_.propagation_loss_db_;
}
inline void WirelessLinkBudget::_internal_set_propagation_loss_db(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.propagation_loss_db_ = value;
}

// optional double received_isotropic_power_dbw = 4 [json_name = "receivedIsotropicPowerDbw"];
inline bool WirelessLinkBudget::has_received_isotropic_power_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_received_isotropic_power_dbw() {
  _impl_.received_isotropic_power_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double WirelessLinkBudget::received_isotropic_power_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.received_isotropic_power_dbw)
  return _internal_received_isotropic_power_dbw();
}
inline void WirelessLinkBudget::set_received_isotropic_power_dbw(double value) {
  _internal_set_received_isotropic_power_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.received_isotropic_power_dbw)
}
inline double WirelessLinkBudget::_internal_received_isotropic_power_dbw() const {
  return _impl_.received_isotropic_power_dbw_;
}
inline void WirelessLinkBudget::_internal_set_received_isotropic_power_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.received_isotropic_power_dbw_ = value;
}

// optional double received_power_flux_density_db_w_per_m2 = 5 [json_name = "receivedPowerFluxDensityDbWPerM2"];
inline bool WirelessLinkBudget::has_received_power_flux_density_db_w_per_m2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_received_power_flux_density_db_w_per_m2() {
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double WirelessLinkBudget::received_power_flux_density_db_w_per_m2() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.received_power_flux_density_db_w_per_m2)
  return _internal_received_power_flux_density_db_w_per_m2();
}
inline void WirelessLinkBudget::set_received_power_flux_density_db_w_per_m2(double value) {
  _internal_set_received_power_flux_density_db_w_per_m2(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.received_power_flux_density_db_w_per_m2)
}
inline double WirelessLinkBudget::_internal_received_power_flux_density_db_w_per_m2() const {
  return _impl_.received_power_flux_density_db_w_per_m2_;
}
inline void WirelessLinkBudget::_internal_set_received_power_flux_density_db_w_per_m2(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.received_power_flux_density_db_w_per_m2_ = value;
}

// optional double receiver_antenna_gain_in_link_direction_db = 6 [json_name = "receiverAntennaGainInLinkDirectionDb"];
inline bool WirelessLinkBudget::has_receiver_antenna_gain_in_link_direction_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_receiver_antenna_gain_in_link_direction_db() {
  _impl_.receiver_antenna_gain_in_link_direction_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double WirelessLinkBudget::receiver_antenna_gain_in_link_direction_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.receiver_antenna_gain_in_link_direction_db)
  return _internal_receiver_antenna_gain_in_link_direction_db();
}
inline void WirelessLinkBudget::set_receiver_antenna_gain_in_link_direction_db(double value) {
  _internal_set_receiver_antenna_gain_in_link_direction_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.receiver_antenna_gain_in_link_direction_db)
}
inline double WirelessLinkBudget::_internal_receiver_antenna_gain_in_link_direction_db() const {
  return _impl_.receiver_antenna_gain_in_link_direction_db_;
}
inline void WirelessLinkBudget::_internal_set_receiver_antenna_gain_in_link_direction_db(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.receiver_antenna_gain_in_link_direction_db_ = value;
}

// optional double power_at_receiver_output_dbw = 7 [json_name = "powerAtReceiverOutputDbw"];
inline bool WirelessLinkBudget::has_power_at_receiver_output_dbw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_power_at_receiver_output_dbw() {
  _impl_.power_at_receiver_output_dbw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double WirelessLinkBudget::power_at_receiver_output_dbw() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.power_at_receiver_output_dbw)
  return _internal_power_at_receiver_output_dbw();
}
inline void WirelessLinkBudget::set_power_at_receiver_output_dbw(double value) {
  _internal_set_power_at_receiver_output_dbw(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.power_at_receiver_output_dbw)
}
inline double WirelessLinkBudget::_internal_power_at_receiver_output_dbw() const {
  return _impl_.power_at_receiver_output_dbw_;
}
inline void WirelessLinkBudget::_internal_set_power_at_receiver_output_dbw(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.power_at_receiver_output_dbw_ = value;
}

// optional double carrier_to_noise_db = 8 [json_name = "carrierToNoiseDb"];
inline bool WirelessLinkBudget::has_carrier_to_noise_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_carrier_to_noise_db() {
  _impl_.carrier_to_noise_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double WirelessLinkBudget::carrier_to_noise_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_db)
  return _internal_carrier_to_noise_db();
}
inline void WirelessLinkBudget::set_carrier_to_noise_db(double value) {
  _internal_set_carrier_to_noise_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_db)
}
inline double WirelessLinkBudget::_internal_carrier_to_noise_db() const {
  return _impl_.carrier_to_noise_db_;
}
inline void WirelessLinkBudget::_internal_set_carrier_to_noise_db(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.carrier_to_noise_db_ = value;
}

// optional double carrier_to_noise_plus_interference_db = 16 [json_name = "carrierToNoisePlusInterferenceDb"];
inline bool WirelessLinkBudget::has_carrier_to_noise_plus_interference_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_carrier_to_noise_plus_interference_db() {
  _impl_.carrier_to_noise_plus_interference_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double WirelessLinkBudget::carrier_to_noise_plus_interference_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_plus_interference_db)
  return _internal_carrier_to_noise_plus_interference_db();
}
inline void WirelessLinkBudget::set_carrier_to_noise_plus_interference_db(double value) {
  _internal_set_carrier_to_noise_plus_interference_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_plus_interference_db)
}
inline double WirelessLinkBudget::_internal_carrier_to_noise_plus_interference_db() const {
  return _impl_.carrier_to_noise_plus_interference_db_;
}
inline void WirelessLinkBudget::_internal_set_carrier_to_noise_plus_interference_db(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.carrier_to_noise_plus_interference_db_ = value;
}

// optional double carrier_to_noise_density_db_per_hz = 9 [json_name = "carrierToNoiseDensityDbPerHz"];
inline bool WirelessLinkBudget::has_carrier_to_noise_density_db_per_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void WirelessLinkBudget::clear_carrier_to_noise_density_db_per_hz() {
  _impl_.carrier_to_noise_density_db_per_hz_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double WirelessLinkBudget::carrier_to_noise_density_db_per_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_density_db_per_hz)
  return _internal_carrier_to_noise_density_db_per_hz();
}
inline void WirelessLinkBudget::set_carrier_to_noise_density_db_per_hz(double value) {
  _internal_set_carrier_to_noise_density_db_per_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkBudget.carrier_to_noise_density_db_per_hz)
}
inline double WirelessLinkBudget::_internal_carrier_to_noise_density_db_per_hz() const {
  return _impl_.carrier_to_noise_density_db_per_hz_;
}
inline void WirelessLinkBudget::_internal_set_carrier_to_noise_density_db_per_hz(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.carrier_to_noise_density_db_per_hz_ = value;
}

// -------------------------------------------------------------------

// WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics

// optional .aalyria.spacetime.api.common.DateTime timestamp = 1 [json_name = "timestamp"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::DateTime& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_timestamp() const {
  const ::aalyria::spacetime::api::common::DateTime* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::DateTime&>(
      ::aalyria::spacetime::api::common::_DateTime_default_instance_);
}
inline const ::aalyria::spacetime::api::common::DateTime& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::timestamp() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.timestamp)
  return _internal_timestamp();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_set_allocated_timestamp(
    ::aalyria::spacetime::api::common::DateTime* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.timestamp)
}
inline ::aalyria::spacetime::api::common::DateTime* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::release_timestamp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.timestamp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::DateTime* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::DateTime* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_mutable_timestamp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::DateTime>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::aalyria::spacetime::api::common::DateTime* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::mutable_timestamp() {
  ::aalyria::spacetime::api::common::DateTime* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.timestamp)
  return _msg;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_allocated_timestamp(::aalyria::spacetime::api::common::DateTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.timestamp)
}

// optional .aalyria.spacetime.api.common.Duration propagation_delay = 2 [json_name = "propagationDelay"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_propagation_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.propagation_delay_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::Duration& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_propagation_delay() const {
  const ::aalyria::spacetime::api::common::Duration* p = _impl_.propagation_delay_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Duration&>(
      ::aalyria::spacetime::api::common::_Duration_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Duration& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::propagation_delay() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.propagation_delay)
  return _internal_propagation_delay();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_set_allocated_propagation_delay(
    ::aalyria::spacetime::api::common::Duration* propagation_delay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propagation_delay_);
  }
  _impl_.propagation_delay_ = propagation_delay;
  if (propagation_delay) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.propagation_delay)
}
inline ::aalyria::spacetime::api::common::Duration* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::release_propagation_delay() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.propagation_delay_;
  _impl_.propagation_delay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_release_propagation_delay() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.propagation_delay)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.propagation_delay_;
  _impl_.propagation_delay_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_mutable_propagation_delay() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.propagation_delay_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Duration>(GetArenaForAllocation());
    _impl_.propagation_delay_ = p;
  }
  return _impl_.propagation_delay_;
}
inline ::aalyria::spacetime::api::common::Duration* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::mutable_propagation_delay() {
  ::aalyria::spacetime::api::common::Duration* _msg = _internal_mutable_propagation_delay();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.propagation_delay)
  return _msg;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_allocated_propagation_delay(::aalyria::spacetime::api::common::Duration* propagation_delay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.propagation_delay_);
  }
  if (propagation_delay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(propagation_delay));
    if (message_arena != submessage_arena) {
      propagation_delay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, propagation_delay, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.propagation_delay_ = propagation_delay;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.propagation_delay)
}

// optional .aalyria.spacetime.api.common.PointingVector pointing_vector = 3 [json_name = "pointingVector"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_pointing_vector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pointing_vector_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::PointingVector& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_pointing_vector() const {
  const ::aalyria::spacetime::api::common::PointingVector* p = _impl_.pointing_vector_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::PointingVector&>(
      ::aalyria::spacetime::api::common::_PointingVector_default_instance_);
}
inline const ::aalyria::spacetime::api::common::PointingVector& WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::pointing_vector() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.pointing_vector)
  return _internal_pointing_vector();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_set_allocated_pointing_vector(
    ::aalyria::spacetime::api::common::PointingVector* pointing_vector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointing_vector_);
  }
  _impl_.pointing_vector_ = pointing_vector;
  if (pointing_vector) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.pointing_vector)
}
inline ::aalyria::spacetime::api::common::PointingVector* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::release_pointing_vector() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PointingVector* temp = _impl_.pointing_vector_;
  _impl_.pointing_vector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::PointingVector* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::unsafe_arena_release_pointing_vector() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.pointing_vector)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::common::PointingVector* temp = _impl_.pointing_vector_;
  _impl_.pointing_vector_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::PointingVector* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_mutable_pointing_vector() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.pointing_vector_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::PointingVector>(GetArenaForAllocation());
    _impl_.pointing_vector_ = p;
  }
  return _impl_.pointing_vector_;
}
inline ::aalyria::spacetime::api::common::PointingVector* WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::mutable_pointing_vector() {
  ::aalyria::spacetime::api::common::PointingVector* _msg = _internal_mutable_pointing_vector();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.pointing_vector)
  return _msg;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_allocated_pointing_vector(::aalyria::spacetime::api::common::PointingVector* pointing_vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pointing_vector_);
  }
  if (pointing_vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pointing_vector));
    if (message_arena != submessage_arena) {
      pointing_vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointing_vector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pointing_vector_ = pointing_vector;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.pointing_vector)
}

// optional double range_m = 4 [json_name = "rangeM"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_range_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::clear_range_m() {
  _impl_.range_m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::range_m() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.range_m)
  return _internal_range_m();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_range_m(double value) {
  _internal_set_range_m(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.range_m)
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_range_m() const {
  return _impl_.range_m_;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_set_range_m(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.range_m_ = value;
}

// optional double data_rate_bps = 6 [json_name = "dataRateBps"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_data_rate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::clear_data_rate_bps() {
  _impl_.data_rate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::data_rate_bps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.data_rate_bps)
  return _internal_data_rate_bps();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_data_rate_bps(double value) {
  _internal_set_data_rate_bps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.data_rate_bps)
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_data_rate_bps() const {
  return _impl_.data_rate_bps_;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_set_data_rate_bps(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.data_rate_bps_ = value;
}

// optional double transmitter_antenna_gain_in_link_direction_db = 7 [json_name = "transmitterAntennaGainInLinkDirectionDb"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_transmitter_antenna_gain_in_link_direction_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::clear_transmitter_antenna_gain_in_link_direction_db() {
  _impl_.transmitter_antenna_gain_in_link_direction_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::transmitter_antenna_gain_in_link_direction_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.transmitter_antenna_gain_in_link_direction_db)
  return _internal_transmitter_antenna_gain_in_link_direction_db();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_transmitter_antenna_gain_in_link_direction_db(double value) {
  _internal_set_transmitter_antenna_gain_in_link_direction_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.transmitter_antenna_gain_in_link_direction_db)
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_transmitter_antenna_gain_in_link_direction_db() const {
  return _impl_.transmitter_antenna_gain_in_link_direction_db_;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_set_transmitter_antenna_gain_in_link_direction_db(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.transmitter_antenna_gain_in_link_direction_db_ = value;
}

// optional double receiver_antenna_gain_in_link_direction_db = 8 [json_name = "receiverAntennaGainInLinkDirectionDb"];
inline bool WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::has_receiver_antenna_gain_in_link_direction_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::clear_receiver_antenna_gain_in_link_direction_db() {
  _impl_.receiver_antenna_gain_in_link_direction_db_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::receiver_antenna_gain_in_link_direction_db() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.receiver_antenna_gain_in_link_direction_db)
  return _internal_receiver_antenna_gain_in_link_direction_db();
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::set_receiver_antenna_gain_in_link_direction_db(double value) {
  _internal_set_receiver_antenna_gain_in_link_direction_db(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics.receiver_antenna_gain_in_link_direction_db)
}
inline double WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_receiver_antenna_gain_in_link_direction_db() const {
  return _impl_.receiver_antenna_gain_in_link_direction_db_;
}
inline void WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics::_internal_set_receiver_antenna_gain_in_link_direction_db(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.receiver_antenna_gain_in_link_direction_db_ = value;
}

// -------------------------------------------------------------------

// WirelessLinkReport_WirelessAccessInterval

// optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
inline bool WirelessLinkReport_WirelessAccessInterval::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TimeInterval& WirelessLinkReport_WirelessAccessInterval::_internal_interval() const {
  const ::aalyria::spacetime::api::common::TimeInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TimeInterval&>(
      ::aalyria::spacetime::api::common::_TimeInterval_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TimeInterval& WirelessLinkReport_WirelessAccessInterval::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.interval)
  return _internal_interval();
}
inline void WirelessLinkReport_WirelessAccessInterval::unsafe_arena_set_allocated_interval(
    ::aalyria::spacetime::api::common::TimeInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.interval)
}
inline ::aalyria::spacetime::api::common::TimeInterval* WirelessLinkReport_WirelessAccessInterval::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* WirelessLinkReport_WirelessAccessInterval::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* WirelessLinkReport_WirelessAccessInterval::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TimeInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::aalyria::spacetime::api::common::TimeInterval* WirelessLinkReport_WirelessAccessInterval::mutable_interval() {
  ::aalyria::spacetime::api::common::TimeInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.interval)
  return _msg;
}
inline void WirelessLinkReport_WirelessAccessInterval::set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.interval)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
inline bool WirelessLinkReport_WirelessAccessInterval::has_accessibility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WirelessLinkReport_WirelessAccessInterval::clear_accessibility() {
  _impl_.accessibility_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility WirelessLinkReport_WirelessAccessInterval::accessibility() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.accessibility)
  return _internal_accessibility();
}
inline void WirelessLinkReport_WirelessAccessInterval::set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value) {
   _internal_set_accessibility(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.accessibility)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility WirelessLinkReport_WirelessAccessInterval::_internal_accessibility() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility>(_impl_.accessibility_);
}
inline void WirelessLinkReport_WirelessAccessInterval::_internal_set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accessibility_ = value;
}

// repeated string no_access_reason = 3 [json_name = "noAccessReason"];
inline int WirelessLinkReport_WirelessAccessInterval::_internal_no_access_reason_size() const {
  return _impl_.no_access_reason_.size();
}
inline int WirelessLinkReport_WirelessAccessInterval::no_access_reason_size() const {
  return _internal_no_access_reason_size();
}
inline void WirelessLinkReport_WirelessAccessInterval::clear_no_access_reason() {
  _internal_mutable_no_access_reason()->Clear();
}
inline std::string* WirelessLinkReport_WirelessAccessInterval::add_no_access_reason() {
  std::string* _s = _internal_add_no_access_reason();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
  return _s;
}
inline const std::string& WirelessLinkReport_WirelessAccessInterval::no_access_reason(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
  return _internal_no_access_reason(index);
}
inline std::string* WirelessLinkReport_WirelessAccessInterval::mutable_no_access_reason(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
  return _internal_mutable_no_access_reason()->Mutable(index);
}
inline void WirelessLinkReport_WirelessAccessInterval::set_no_access_reason(int index, const std::string& value) {
  _internal_mutable_no_access_reason()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::set_no_access_reason(int index, std::string&& value) {
  _internal_mutable_no_access_reason()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::set_no_access_reason(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_no_access_reason()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::set_no_access_reason(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_no_access_reason()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::set_no_access_reason(int index, absl::string_view value) {
  _internal_mutable_no_access_reason()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::add_no_access_reason(const std::string& value) {
  _internal_mutable_no_access_reason()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::add_no_access_reason(std::string&& value) {
  _internal_mutable_no_access_reason()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::add_no_access_reason(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_no_access_reason()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::add_no_access_reason(const char* value, std::size_t size) {
  _internal_mutable_no_access_reason()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline void WirelessLinkReport_WirelessAccessInterval::add_no_access_reason(absl::string_view value) {
  _internal_mutable_no_access_reason()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WirelessLinkReport_WirelessAccessInterval::no_access_reason() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
  return _internal_no_access_reason();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* WirelessLinkReport_WirelessAccessInterval::mutable_no_access_reason() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.no_access_reason)
  return _internal_mutable_no_access_reason();
}
inline const std::string& WirelessLinkReport_WirelessAccessInterval::_internal_no_access_reason(int index) const {
  return _internal_no_access_reason().Get(index);
}
inline std::string* WirelessLinkReport_WirelessAccessInterval::_internal_add_no_access_reason() {
  return _internal_mutable_no_access_reason()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WirelessLinkReport_WirelessAccessInterval::_internal_no_access_reason() const {
  return _impl_.no_access_reason_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WirelessLinkReport_WirelessAccessInterval::_internal_mutable_no_access_reason() {
  return &_impl_.no_access_reason_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.WirelessLinkMetrics sampled_metrics = 4 [json_name = "sampledMetrics"];
inline int WirelessLinkReport_WirelessAccessInterval::_internal_sampled_metrics_size() const {
  return _impl_.sampled_metrics_.size();
}
inline int WirelessLinkReport_WirelessAccessInterval::sampled_metrics_size() const {
  return _internal_sampled_metrics_size();
}
inline void WirelessLinkReport_WirelessAccessInterval::clear_sampled_metrics() {
  _internal_mutable_sampled_metrics()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* WirelessLinkReport_WirelessAccessInterval::mutable_sampled_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.sampled_metrics)
  return _internal_mutable_sampled_metrics()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics >*
WirelessLinkReport_WirelessAccessInterval::mutable_sampled_metrics() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.sampled_metrics)
  return _internal_mutable_sampled_metrics();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& WirelessLinkReport_WirelessAccessInterval::_internal_sampled_metrics(int index) const {
  return _internal_sampled_metrics().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics& WirelessLinkReport_WirelessAccessInterval::sampled_metrics(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.sampled_metrics)
  return _internal_sampled_metrics(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* WirelessLinkReport_WirelessAccessInterval::_internal_add_sampled_metrics() {
  return _internal_mutable_sampled_metrics()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* WirelessLinkReport_WirelessAccessInterval::add_sampled_metrics() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics* _add = _internal_add_sampled_metrics();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.sampled_metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics >&
WirelessLinkReport_WirelessAccessInterval::sampled_metrics() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval.sampled_metrics)
  return _internal_sampled_metrics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>&
WirelessLinkReport_WirelessAccessInterval::_internal_sampled_metrics() const {
  return _impl_.sampled_metrics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval_WirelessLinkMetrics>*
WirelessLinkReport_WirelessAccessInterval::_internal_mutable_sampled_metrics() {
  return &_impl_.sampled_metrics_;
}

// -------------------------------------------------------------------

// WirelessLinkReport

// optional .aalyria.spacetime.api.common.TransceiverModelId dst = 1 [json_name = "dst"];
inline bool WirelessLinkReport::has_dst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& WirelessLinkReport::_internal_dst() const {
  const ::aalyria::spacetime::api::common::TransceiverModelId* p = _impl_.dst_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransceiverModelId&>(
      ::aalyria::spacetime::api::common::_TransceiverModelId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& WirelessLinkReport::dst() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.dst)
  return _internal_dst();
}
inline void WirelessLinkReport::unsafe_arena_set_allocated_dst(
    ::aalyria::spacetime::api::common::TransceiverModelId* dst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  _impl_.dst_ = dst;
  if (dst) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.dst)
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessLinkReport::release_dst() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessLinkReport::unsafe_arena_release_dst() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.dst)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessLinkReport::_internal_mutable_dst() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransceiverModelId>(GetArenaForAllocation());
    _impl_.dst_ = p;
  }
  return _impl_.dst_;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* WirelessLinkReport::mutable_dst() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _msg = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.dst)
  return _msg;
}
inline void WirelessLinkReport::set_allocated_dst(::aalyria::spacetime::api::common::TransceiverModelId* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst));
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.dst)
}

// optional string band_profile_id = 2 [json_name = "bandProfileId"];
inline bool WirelessLinkReport::has_band_profile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WirelessLinkReport::clear_band_profile_id() {
  _impl_.band_profile_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WirelessLinkReport::band_profile_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.band_profile_id)
  return _internal_band_profile_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WirelessLinkReport::set_band_profile_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.band_profile_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.band_profile_id)
}
inline std::string* WirelessLinkReport::mutable_band_profile_id() {
  std::string* _s = _internal_mutable_band_profile_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.band_profile_id)
  return _s;
}
inline const std::string& WirelessLinkReport::_internal_band_profile_id() const {
  return _impl_.band_profile_id_.Get();
}
inline void WirelessLinkReport::_internal_set_band_profile_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.band_profile_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WirelessLinkReport::_internal_mutable_band_profile_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.band_profile_id_.Mutable( GetArenaForAllocation());
}
inline std::string* WirelessLinkReport::release_band_profile_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.band_profile_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.band_profile_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.band_profile_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WirelessLinkReport::set_allocated_band_profile_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.band_profile_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.band_profile_id_.IsDefault()) {
          _impl_.band_profile_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.band_profile_id)
}

// repeated uint64 center_frequencies_hz = 3 [json_name = "centerFrequenciesHz"];
inline int WirelessLinkReport::_internal_center_frequencies_hz_size() const {
  return _impl_.center_frequencies_hz_.size();
}
inline int WirelessLinkReport::center_frequencies_hz_size() const {
  return _internal_center_frequencies_hz_size();
}
inline void WirelessLinkReport::clear_center_frequencies_hz() {
  _internal_mutable_center_frequencies_hz()->Clear();
}
inline ::uint64_t WirelessLinkReport::center_frequencies_hz(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.center_frequencies_hz)
  return _internal_center_frequencies_hz(index);
}
inline void WirelessLinkReport::set_center_frequencies_hz(int index, ::uint64_t value) {
  _internal_mutable_center_frequencies_hz()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.center_frequencies_hz)
}
inline void WirelessLinkReport::add_center_frequencies_hz(::uint64_t value) {
  _internal_add_center_frequencies_hz(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.center_frequencies_hz)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& WirelessLinkReport::center_frequencies_hz() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.center_frequencies_hz)
  return _internal_center_frequencies_hz();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* WirelessLinkReport::mutable_center_frequencies_hz() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.center_frequencies_hz)
  return _internal_mutable_center_frequencies_hz();
}

inline ::uint64_t WirelessLinkReport::_internal_center_frequencies_hz(int index) const {
  return _internal_center_frequencies_hz().Get(index);
}
inline void WirelessLinkReport::_internal_add_center_frequencies_hz(::uint64_t value) {
  _internal_mutable_center_frequencies_hz()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& WirelessLinkReport::_internal_center_frequencies_hz() const {
  return _impl_.center_frequencies_hz_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* WirelessLinkReport::_internal_mutable_center_frequencies_hz() {
  return &_impl_.center_frequencies_hz_;
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.WirelessAccessInterval access_intervals = 4 [json_name = "accessIntervals"];
inline int WirelessLinkReport::_internal_access_intervals_size() const {
  return _impl_.access_intervals_.size();
}
inline int WirelessLinkReport::access_intervals_size() const {
  return _internal_access_intervals_size();
}
inline void WirelessLinkReport::clear_access_intervals() {
  _internal_mutable_access_intervals()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* WirelessLinkReport::mutable_access_intervals(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.access_intervals)
  return _internal_mutable_access_intervals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval >*
WirelessLinkReport::mutable_access_intervals() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.access_intervals)
  return _internal_mutable_access_intervals();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval& WirelessLinkReport::_internal_access_intervals(int index) const {
  return _internal_access_intervals().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval& WirelessLinkReport::access_intervals(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.access_intervals)
  return _internal_access_intervals(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* WirelessLinkReport::_internal_add_access_intervals() {
  return _internal_mutable_access_intervals()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* WirelessLinkReport::add_access_intervals() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval* _add = _internal_add_access_intervals();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.access_intervals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval >&
WirelessLinkReport::access_intervals() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport.access_intervals)
  return _internal_access_intervals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval>&
WirelessLinkReport::_internal_access_intervals() const {
  return _impl_.access_intervals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport_WirelessAccessInterval>*
WirelessLinkReport::_internal_mutable_access_intervals() {
  return &_impl_.access_intervals_;
}

// -------------------------------------------------------------------

// InterfaceLinkReport_AccessInterval

// optional .aalyria.spacetime.api.common.TimeInterval interval = 1 [json_name = "interval"];
inline bool InterfaceLinkReport_AccessInterval::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interval_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TimeInterval& InterfaceLinkReport_AccessInterval::_internal_interval() const {
  const ::aalyria::spacetime::api::common::TimeInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TimeInterval&>(
      ::aalyria::spacetime::api::common::_TimeInterval_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TimeInterval& InterfaceLinkReport_AccessInterval::interval() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.interval)
  return _internal_interval();
}
inline void InterfaceLinkReport_AccessInterval::unsafe_arena_set_allocated_interval(
    ::aalyria::spacetime::api::common::TimeInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.interval)
}
inline ::aalyria::spacetime::api::common::TimeInterval* InterfaceLinkReport_AccessInterval::release_interval() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* InterfaceLinkReport_AccessInterval::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.interval)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TimeInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TimeInterval* InterfaceLinkReport_AccessInterval::_internal_mutable_interval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TimeInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::aalyria::spacetime::api::common::TimeInterval* InterfaceLinkReport_AccessInterval::mutable_interval() {
  ::aalyria::spacetime::api::common::TimeInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.interval)
  return _msg;
}
inline void InterfaceLinkReport_AccessInterval::set_allocated_interval(::aalyria::spacetime::api::common::TimeInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.interval)
}

// optional .aalyria.spacetime.api.nbi.v1alpha.resources.Accessibility accessibility = 2 [json_name = "accessibility"];
inline bool InterfaceLinkReport_AccessInterval::has_accessibility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InterfaceLinkReport_AccessInterval::clear_accessibility() {
  _impl_.accessibility_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility InterfaceLinkReport_AccessInterval::accessibility() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.accessibility)
  return _internal_accessibility();
}
inline void InterfaceLinkReport_AccessInterval::set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value) {
   _internal_set_accessibility(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.accessibility)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility InterfaceLinkReport_AccessInterval::_internal_accessibility() const {
  return static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility>(_impl_.accessibility_);
}
inline void InterfaceLinkReport_AccessInterval::_internal_set_accessibility(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility value) {
  assert(::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.accessibility_ = value;
}

// optional .aalyria.spacetime.api.common.Duration frame_delay = 3 [json_name = "frameDelay"];
inline bool InterfaceLinkReport_AccessInterval::has_frame_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_delay_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::Duration& InterfaceLinkReport_AccessInterval::_internal_frame_delay() const {
  const ::aalyria::spacetime::api::common::Duration* p = _impl_.frame_delay_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::Duration&>(
      ::aalyria::spacetime::api::common::_Duration_default_instance_);
}
inline const ::aalyria::spacetime::api::common::Duration& InterfaceLinkReport_AccessInterval::frame_delay() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.frame_delay)
  return _internal_frame_delay();
}
inline void InterfaceLinkReport_AccessInterval::unsafe_arena_set_allocated_frame_delay(
    ::aalyria::spacetime::api::common::Duration* frame_delay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_delay_);
  }
  _impl_.frame_delay_ = frame_delay;
  if (frame_delay) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.frame_delay)
}
inline ::aalyria::spacetime::api::common::Duration* InterfaceLinkReport_AccessInterval::release_frame_delay() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.frame_delay_;
  _impl_.frame_delay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* InterfaceLinkReport_AccessInterval::unsafe_arena_release_frame_delay() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.frame_delay)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::Duration* temp = _impl_.frame_delay_;
  _impl_.frame_delay_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::Duration* InterfaceLinkReport_AccessInterval::_internal_mutable_frame_delay() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.frame_delay_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::Duration>(GetArenaForAllocation());
    _impl_.frame_delay_ = p;
  }
  return _impl_.frame_delay_;
}
inline ::aalyria::spacetime::api::common::Duration* InterfaceLinkReport_AccessInterval::mutable_frame_delay() {
  ::aalyria::spacetime::api::common::Duration* _msg = _internal_mutable_frame_delay();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.frame_delay)
  return _msg;
}
inline void InterfaceLinkReport_AccessInterval::set_allocated_frame_delay(::aalyria::spacetime::api::common::Duration* frame_delay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_delay_);
  }
  if (frame_delay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_delay));
    if (message_arena != submessage_arena) {
      frame_delay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_delay, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.frame_delay_ = frame_delay;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.frame_delay)
}

// optional double data_rate_bps = 4 [json_name = "dataRateBps"];
inline bool InterfaceLinkReport_AccessInterval::has_data_rate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InterfaceLinkReport_AccessInterval::clear_data_rate_bps() {
  _impl_.data_rate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double InterfaceLinkReport_AccessInterval::data_rate_bps() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.data_rate_bps)
  return _internal_data_rate_bps();
}
inline void InterfaceLinkReport_AccessInterval::set_data_rate_bps(double value) {
  _internal_set_data_rate_bps(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval.data_rate_bps)
}
inline double InterfaceLinkReport_AccessInterval::_internal_data_rate_bps() const {
  return _impl_.data_rate_bps_;
}
inline void InterfaceLinkReport_AccessInterval::_internal_set_data_rate_bps(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_rate_bps_ = value;
}

// -------------------------------------------------------------------

// InterfaceLinkReport

// optional .aalyria.spacetime.api.common.NetworkInterfaceId src = 4 [json_name = "src"];
inline bool InterfaceLinkReport::has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& InterfaceLinkReport::_internal_src() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.src_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& InterfaceLinkReport::src() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.src)
  return _internal_src();
}
inline void InterfaceLinkReport::unsafe_arena_set_allocated_src(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  _impl_.src_ = src;
  if (src) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.src)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::release_src() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.src)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.src_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.src_ = p;
  }
  return _impl_.src_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::mutable_src() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.src)
  return _msg;
}
inline void InterfaceLinkReport::set_allocated_src(::aalyria::spacetime::api::common::NetworkInterfaceId* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src));
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_ = src;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.src)
}

// optional .aalyria.spacetime.api.common.NetworkInterfaceId dst = 5 [json_name = "dst"];
inline bool InterfaceLinkReport::has_dst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& InterfaceLinkReport::_internal_dst() const {
  const ::aalyria::spacetime::api::common::NetworkInterfaceId* p = _impl_.dst_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::NetworkInterfaceId&>(
      ::aalyria::spacetime::api::common::_NetworkInterfaceId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkInterfaceId& InterfaceLinkReport::dst() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.dst)
  return _internal_dst();
}
inline void InterfaceLinkReport::unsafe_arena_set_allocated_dst(
    ::aalyria::spacetime::api::common::NetworkInterfaceId* dst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  _impl_.dst_ = dst;
  if (dst) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.dst)
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::release_dst() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::unsafe_arena_release_dst() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.dst)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::NetworkInterfaceId* temp = _impl_.dst_;
  _impl_.dst_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::_internal_mutable_dst() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::NetworkInterfaceId>(GetArenaForAllocation());
    _impl_.dst_ = p;
  }
  return _impl_.dst_;
}
inline ::aalyria::spacetime::api::common::NetworkInterfaceId* InterfaceLinkReport::mutable_dst() {
  ::aalyria::spacetime::api::common::NetworkInterfaceId* _msg = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.dst)
  return _msg;
}
inline void InterfaceLinkReport::set_allocated_dst(::aalyria::spacetime::api::common::NetworkInterfaceId* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst));
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.dst)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.AccessInterval access_intervals = 6 [json_name = "accessIntervals"];
inline int InterfaceLinkReport::_internal_access_intervals_size() const {
  return _impl_.access_intervals_.size();
}
inline int InterfaceLinkReport::access_intervals_size() const {
  return _internal_access_intervals_size();
}
inline void InterfaceLinkReport::clear_access_intervals() {
  _internal_mutable_access_intervals()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* InterfaceLinkReport::mutable_access_intervals(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.access_intervals)
  return _internal_mutable_access_intervals()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval >*
InterfaceLinkReport::mutable_access_intervals() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.access_intervals)
  return _internal_mutable_access_intervals();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval& InterfaceLinkReport::_internal_access_intervals(int index) const {
  return _internal_access_intervals().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval& InterfaceLinkReport::access_intervals(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.access_intervals)
  return _internal_access_intervals(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* InterfaceLinkReport::_internal_add_access_intervals() {
  return _internal_mutable_access_intervals()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* InterfaceLinkReport::add_access_intervals() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval* _add = _internal_add_access_intervals();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.access_intervals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval >&
InterfaceLinkReport::access_intervals() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.InterfaceLinkReport.access_intervals)
  return _internal_access_intervals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval>&
InterfaceLinkReport::_internal_access_intervals() const {
  return _impl_.access_intervals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::InterfaceLinkReport_AccessInterval>*
InterfaceLinkReport::_internal_mutable_access_intervals() {
  return &_impl_.access_intervals_;
}

// -------------------------------------------------------------------

// TransceiverLinkReport

// optional .aalyria.spacetime.api.common.TransceiverModelId src = 1 [json_name = "src"];
inline bool TransceiverLinkReport::has_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& TransceiverLinkReport::_internal_src() const {
  const ::aalyria::spacetime::api::common::TransceiverModelId* p = _impl_.src_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransceiverModelId&>(
      ::aalyria::spacetime::api::common::_TransceiverModelId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& TransceiverLinkReport::src() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.src)
  return _internal_src();
}
inline void TransceiverLinkReport::unsafe_arena_set_allocated_src(
    ::aalyria::spacetime::api::common::TransceiverModelId* src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  _impl_.src_ = src;
  if (src) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.src)
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverLinkReport::release_src() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverLinkReport::unsafe_arena_release_src() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.src)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.src_;
  _impl_.src_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverLinkReport::_internal_mutable_src() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.src_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransceiverModelId>(GetArenaForAllocation());
    _impl_.src_ = p;
  }
  return _impl_.src_;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverLinkReport::mutable_src() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _msg = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.src)
  return _msg;
}
inline void TransceiverLinkReport::set_allocated_src(::aalyria::spacetime::api::common::TransceiverModelId* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src));
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_ = src;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.src)
}

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.WirelessLinkReport links = 2 [json_name = "links"];
inline int TransceiverLinkReport::_internal_links_size() const {
  return _impl_.links_.size();
}
inline int TransceiverLinkReport::links_size() const {
  return _internal_links_size();
}
inline void TransceiverLinkReport::clear_links() {
  _internal_mutable_links()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* TransceiverLinkReport::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.links)
  return _internal_mutable_links()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport >*
TransceiverLinkReport::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.links)
  return _internal_mutable_links();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport& TransceiverLinkReport::_internal_links(int index) const {
  return _internal_links().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport& TransceiverLinkReport::links(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.links)
  return _internal_links(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* TransceiverLinkReport::_internal_add_links() {
  return _internal_mutable_links()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* TransceiverLinkReport::add_links() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport >&
TransceiverLinkReport::links() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverLinkReport.links)
  return _internal_links();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport>&
TransceiverLinkReport::_internal_links() const {
  return _impl_.links_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::WirelessLinkReport>*
TransceiverLinkReport::_internal_mutable_links() {
  return &_impl_.links_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility>() {
  return ::aalyria::spacetime::api::nbi::v1alpha::resources::Accessibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto_2epb_2eh
