// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/wireless_interference.proto

#include "api/nbi/v1alpha/resources/wireless_interference.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
template <typename>
PROTOBUF_CONSTEXPR InterferenceConstraint::InterferenceConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.victims_)*/{}
  , /*decltype(_impl_.interferers_)*/{}
  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.use_receiver_orientation_)*/ false

  , /*decltype(_impl_.constraints_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct InterferenceConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterferenceConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterferenceConstraintDefaultTypeInternal() {}
  union {
    InterferenceConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterferenceConstraintDefaultTypeInternal _InterferenceConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdConstraint_Band::PfdConstraint_Band(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_frequency_mhz_)*/ 0

  , /*decltype(_impl_.end_frequency_mhz_)*/ 0
} {}
struct PfdConstraint_BandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdConstraint_BandDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdConstraint_BandDefaultTypeInternal() {}
  union {
    PfdConstraint_Band _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdConstraint_BandDefaultTypeInternal _PfdConstraint_Band_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdConstraint::PfdConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.band_)*/nullptr
  , /*decltype(_impl_.received_pfd_dbw_per_sqm_)*/ 0

  , /*decltype(_impl_.resolution_bw_mhz_)*/ 0

  , /*decltype(_impl_.time_fraction_)*/ 0
} {}
struct PfdConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdConstraintDefaultTypeInternal() {}
  union {
    PfdConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdConstraintDefaultTypeInternal _PfdConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdConstraints::PfdConstraints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pfd_constraints_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PfdConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdConstraintsDefaultTypeInternal() {}
  union {
    PfdConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdConstraintsDefaultTypeInternal _PfdConstraints_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PsdConstraint_ScmMask::PsdConstraint_ScmMask(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.control_points_)*/{}
  , /*decltype(_impl_.ref_frequency_mhz_)*/ 0
} {}
struct PsdConstraint_ScmMaskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PsdConstraint_ScmMaskDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PsdConstraint_ScmMaskDefaultTypeInternal() {}
  union {
    PsdConstraint_ScmMask _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PsdConstraint_ScmMaskDefaultTypeInternal _PsdConstraint_ScmMask_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PsdConstraint_ControlPoint::PsdConstraint_ControlPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frequency_mhz_)*/ 0

  , /*decltype(_impl_.relative_power_db_)*/ 0
} {}
struct PsdConstraint_ControlPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PsdConstraint_ControlPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PsdConstraint_ControlPointDefaultTypeInternal() {}
  union {
    PsdConstraint_ControlPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PsdConstraint_ControlPointDefaultTypeInternal _PsdConstraint_ControlPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PsdConstraint::PsdConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.psd_mask_)*/nullptr
  , /*decltype(_impl_.reference_power_dbw_)*/ 0

  , /*decltype(_impl_.resolution_bw_mhz_)*/ 0
} {}
struct PsdConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PsdConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PsdConstraintDefaultTypeInternal() {}
  union {
    PsdConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PsdConstraintDefaultTypeInternal _PsdConstraint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PointingConstraint::PointingConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.min_angle_deg_)*/ 0
} {}
struct PointingConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointingConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointingConstraintDefaultTypeInternal() {}
  union {
    PointingConstraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointingConstraintDefaultTypeInternal _PointingConstraint_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[8];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_.victims_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_.interferers_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_.use_receiver_orientation_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_.constraints_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band, _impl_.start_frequency_mhz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band, _impl_.end_frequency_mhz_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _impl_.band_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _impl_.received_pfd_dbw_per_sqm_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _impl_.resolution_bw_mhz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint, _impl_.time_fraction_),
    0,
    1,
    2,
    3,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints, _impl_.pfd_constraints_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask, _impl_.ref_frequency_mhz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask, _impl_.control_points_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint, _impl_.frequency_mhz_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint, _impl_.relative_power_db_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint, _impl_.reference_power_dbw_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint, _impl_.psd_mask_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint, _impl_.resolution_bw_mhz_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint, _impl_.min_angle_deg_),
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 18, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint)},
        { 27, 37, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band)},
        { 39, 51, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint)},
        { 55, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints)},
        { 64, 74, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask)},
        { 76, 86, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint)},
        { 88, 99, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint)},
        { 102, 111, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_InterferenceConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraint_Band_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdConstraints_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PsdConstraint_ScmMask_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PsdConstraint_ControlPoint_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PsdConstraint_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PointingConstraint_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n5api/nbi/v1alpha/resources/wireless_int"
    "erference.proto\022+aalyria.spacetime.api.n"
    "bi.v1alpha.resources\032(api/nbi/v1alpha/re"
    "sources/coverage.proto\"\316\006\n\026InterferenceC"
    "onstraint\022 \n\013description\030\001 \001(\tR\013descript"
    "ion\022V\n\007victims\030\002 \003(\0132<.aalyria.spacetime"
    ".api.nbi.v1alpha.resources.CoordinateArr"
    "ayR\007victims\022\\\n\013interferers\030\003 \003(\0132:.aalyr"
    "ia.spacetime.api.nbi.v1alpha.resources.S"
    "tationSubsetR\013interferers\022f\n\017pfd_constra"
    "ints\030\004 \001(\0132;.aalyria.spacetime.api.nbi.v"
    "1alpha.resources.PfdConstraintsH\000R\016pfdCo"
    "nstraints\022h\n\020epfd_constraints\030\005 \001(\0132;.aa"
    "lyria.spacetime.api.nbi.v1alpha.resource"
    "s.PfdConstraintsH\000R\017epfdConstraints\022h\n\020a"
    "pfd_constraints\030\006 \001(\0132;.aalyria.spacetim"
    "e.api.nbi.v1alpha.resources.PfdConstrain"
    "tsH\000R\017apfdConstraints\022c\n\016psd_constraint\030"
    "\007 \001(\0132:.aalyria.spacetime.api.nbi.v1alph"
    "a.resources.PsdConstraintH\000R\rpsdConstrai"
    "nt\022r\n\023pointing_constraint\030\010 \001(\0132\?.aalyri"
    "a.spacetime.api.nbi.v1alpha.resources.Po"
    "intingConstraintH\000R\022pointingConstraint\0228"
    "\n\030use_receiver_orientation\030\t \001(\010R\026useRec"
    "eiverOrientationB\r\n\013constraints\"\321\002\n\rPfdC"
    "onstraint\022S\n\004band\030\001 \001(\0132\?.aalyria.spacet"
    "ime.api.nbi.v1alpha.resources.PfdConstra"
    "int.BandR\004band\0226\n\030received_pfd_dbw_per_s"
    "qm\030\002 \001(\001R\024receivedPfdDbwPerSqm\022*\n\021resolu"
    "tion_bw_mhz\030\003 \001(\001R\017resolutionBwMhz\022#\n\rti"
    "me_fraction\030\004 \001(\001R\014timeFraction\032b\n\004Band\022"
    ".\n\023start_frequency_mhz\030\001 \002(\001R\021startFrequ"
    "encyMhz\022*\n\021end_frequency_mhz\030\002 \002(\001R\017endF"
    "requencyMhz\"u\n\016PfdConstraints\022c\n\017pfd_con"
    "straints\030\001 \003(\0132:.aalyria.spacetime.api.n"
    "bi.v1alpha.resources.PfdConstraintR\016pfdC"
    "onstraints\"\323\003\n\rPsdConstraint\022.\n\023referenc"
    "e_power_dbw\030\001 \001(\001R\021referencePowerDbw\022]\n\010"
    "psd_mask\030\002 \001(\0132B.aalyria.spacetime.api.n"
    "bi.v1alpha.resources.PsdConstraint.ScmMa"
    "skR\007psdMask\022*\n\021resolution_bw_mhz\030\003 \001(\001R\017"
    "resolutionBwMhz\032\245\001\n\007ScmMask\022*\n\021ref_frequ"
    "ency_mhz\030\001 \002(\001R\017refFrequencyMhz\022n\n\016contr"
    "ol_points\030\002 \003(\0132G.aalyria.spacetime.api."
    "nbi.v1alpha.resources.PsdConstraint.Cont"
    "rolPointR\rcontrolPoints\032_\n\014ControlPoint\022"
    "#\n\rfrequency_mhz\030\001 \002(\001R\014frequencyMhz\022*\n\021"
    "relative_power_db\030\002 \002(\001R\017relativePowerDb"
    "\"8\n\022PointingConstraint\022\"\n\rmin_angle_deg\030"
    "\001 \001(\001R\013minAngleDegB1Z/aalyria.com/spacet"
    "ime/api/nbi/v1alpha/resources"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_deps[1] =
    {
        &::descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto = {
    false,
    false,
    2029,
    descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto,
    "api/nbi/v1alpha/resources/wireless_interference.proto",
    &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_deps,
    1,
    8,
    schemas,
    file_default_instances,
    TableStruct_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto::offsets,
    file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto,
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto,
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter() {
  return &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
// ===================================================================

class InterferenceConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<InterferenceConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InterferenceConstraint, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint, _impl_._oneof_case_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& pfd_constraints(const InterferenceConstraint* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& epfd_constraints(const InterferenceConstraint* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints& apfd_constraints(const InterferenceConstraint* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint& psd_constraint(const InterferenceConstraint* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint& pointing_constraint(const InterferenceConstraint* msg);
  static void set_has_use_receiver_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&
InterferenceConstraint::_Internal::pfd_constraints(const InterferenceConstraint* msg) {
  return *msg->_impl_.constraints_.pfd_constraints_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&
InterferenceConstraint::_Internal::epfd_constraints(const InterferenceConstraint* msg) {
  return *msg->_impl_.constraints_.epfd_constraints_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints&
InterferenceConstraint::_Internal::apfd_constraints(const InterferenceConstraint* msg) {
  return *msg->_impl_.constraints_.apfd_constraints_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint&
InterferenceConstraint::_Internal::psd_constraint(const InterferenceConstraint* msg) {
  return *msg->_impl_.constraints_.psd_constraint_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint&
InterferenceConstraint::_Internal::pointing_constraint(const InterferenceConstraint* msg) {
  return *msg->_impl_.constraints_.pointing_constraint_;
}
void InterferenceConstraint::clear_victims() {
  _internal_mutable_victims()->Clear();
}
void InterferenceConstraint::clear_interferers() {
  _internal_mutable_interferers()->Clear();
}
void InterferenceConstraint::set_allocated_pfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* pfd_constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraints();
  if (pfd_constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pfd_constraints);
    if (message_arena != submessage_arena) {
      pfd_constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pfd_constraints, submessage_arena);
    }
    set_has_pfd_constraints();
    _impl_.constraints_.pfd_constraints_ = pfd_constraints;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pfd_constraints)
}
void InterferenceConstraint::set_allocated_epfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* epfd_constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraints();
  if (epfd_constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(epfd_constraints);
    if (message_arena != submessage_arena) {
      epfd_constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, epfd_constraints, submessage_arena);
    }
    set_has_epfd_constraints();
    _impl_.constraints_.epfd_constraints_ = epfd_constraints;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.epfd_constraints)
}
void InterferenceConstraint::set_allocated_apfd_constraints(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints* apfd_constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraints();
  if (apfd_constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apfd_constraints);
    if (message_arena != submessage_arena) {
      apfd_constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apfd_constraints, submessage_arena);
    }
    set_has_apfd_constraints();
    _impl_.constraints_.apfd_constraints_ = apfd_constraints;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.apfd_constraints)
}
void InterferenceConstraint::set_allocated_psd_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint* psd_constraint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraints();
  if (psd_constraint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(psd_constraint);
    if (message_arena != submessage_arena) {
      psd_constraint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, psd_constraint, submessage_arena);
    }
    set_has_psd_constraint();
    _impl_.constraints_.psd_constraint_ = psd_constraint;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.psd_constraint)
}
void InterferenceConstraint::set_allocated_pointing_constraint(::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint* pointing_constraint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraints();
  if (pointing_constraint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pointing_constraint);
    if (message_arena != submessage_arena) {
      pointing_constraint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pointing_constraint, submessage_arena);
    }
    set_has_pointing_constraint();
    _impl_.constraints_.pointing_constraint_ = pointing_constraint;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.pointing_constraint)
}
InterferenceConstraint::InterferenceConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
}
InterferenceConstraint::InterferenceConstraint(const InterferenceConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterferenceConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.victims_){from._impl_.victims_}
    , decltype(_impl_.interferers_){from._impl_.interferers_}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.use_receiver_orientation_) {}

    , decltype(_impl_.constraints_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  _this->_impl_.use_receiver_orientation_ = from._impl_.use_receiver_orientation_;
  clear_has_constraints();
  switch (from.constraints_case()) {
    case kPfdConstraints: {
      _this->_internal_mutable_pfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_pfd_constraints());
      break;
    }
    case kEpfdConstraints: {
      _this->_internal_mutable_epfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_epfd_constraints());
      break;
    }
    case kApfdConstraints: {
      _this->_internal_mutable_apfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_apfd_constraints());
      break;
    }
    case kPsdConstraint: {
      _this->_internal_mutable_psd_constraint()->::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint::MergeFrom(
          from._internal_psd_constraint());
      break;
    }
    case kPointingConstraint: {
      _this->_internal_mutable_pointing_constraint()->::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint::MergeFrom(
          from._internal_pointing_constraint());
      break;
    }
    case CONSTRAINTS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
}

inline void InterferenceConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.victims_){arena}
    , decltype(_impl_.interferers_){arena}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.use_receiver_orientation_) { false }

    , decltype(_impl_.constraints_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_constraints();
}

InterferenceConstraint::~InterferenceConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterferenceConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_victims()->~RepeatedPtrField();
  _internal_mutable_interferers()->~RepeatedPtrField();
  _impl_.description_.Destroy();
  if (has_constraints()) {
    clear_constraints();
  }
}

void InterferenceConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterferenceConstraint::clear_constraints() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  switch (constraints_case()) {
    case kPfdConstraints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraints_.pfd_constraints_;
      }
      break;
    }
    case kEpfdConstraints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraints_.epfd_constraints_;
      }
      break;
    }
    case kApfdConstraints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraints_.apfd_constraints_;
      }
      break;
    }
    case kPsdConstraint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraints_.psd_constraint_;
      }
      break;
    }
    case kPointingConstraint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraints_.pointing_constraint_;
      }
      break;
    }
    case CONSTRAINTS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CONSTRAINTS_NOT_SET;
}


void InterferenceConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_victims()->Clear();
  _internal_mutable_interferers()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  _impl_.use_receiver_orientation_ = false;
  clear_constraints();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterferenceConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string description = 1 [json_name = "description"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray victims = 2 [json_name = "victims"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_victims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset interferers = 3 [json_name = "interferers"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_interferers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints pfd_constraints = 4 [json_name = "pfdConstraints"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pfd_constraints(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints epfd_constraints = 5 [json_name = "epfdConstraints"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_epfd_constraints(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints apfd_constraints = 6 [json_name = "apfdConstraints"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_apfd_constraints(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint psd_constraint = 7 [json_name = "psdConstraint"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_psd_constraint(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint pointing_constraint = 8 [json_name = "pointingConstraint"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_pointing_constraint(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool use_receiver_orientation = 9 [json_name = "useReceiverOrientation"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_use_receiver_orientation(&has_bits);
          _impl_.use_receiver_orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InterferenceConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string description = 1 [json_name = "description"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint.description");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray victims = 2 [json_name = "victims"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_victims_size()); i < n; i++) {
    const auto& repfield = this->_internal_victims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset interferers = 3 [json_name = "interferers"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_interferers_size()); i < n; i++) {
    const auto& repfield = this->_internal_interferers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  switch (constraints_case()) {
    case kPfdConstraints: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::pfd_constraints(this),
          _Internal::pfd_constraints(this).GetCachedSize(), target, stream);
      break;
    }
    case kEpfdConstraints: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::epfd_constraints(this),
          _Internal::epfd_constraints(this).GetCachedSize(), target, stream);
      break;
    }
    case kApfdConstraints: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::apfd_constraints(this),
          _Internal::apfd_constraints(this).GetCachedSize(), target, stream);
      break;
    }
    case kPsdConstraint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::psd_constraint(this),
          _Internal::psd_constraint(this).GetCachedSize(), target, stream);
      break;
    }
    case kPointingConstraint: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::pointing_constraint(this),
          _Internal::pointing_constraint(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional bool use_receiver_orientation = 9 [json_name = "useReceiverOrientation"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_use_receiver_orientation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  return target;
}

::size_t InterferenceConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray victims = 2 [json_name = "victims"];
  total_size += 1UL * this->_internal_victims_size();
  for (const auto& msg : this->_internal_victims()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset interferers = 3 [json_name = "interferers"];
  total_size += 1UL * this->_internal_interferers_size();
  for (const auto& msg : this->_internal_interferers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 1 [json_name = "description"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_description());
    }

    // optional bool use_receiver_orientation = 9 [json_name = "useReceiverOrientation"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  switch (constraints_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints pfd_constraints = 4 [json_name = "pfdConstraints"];
    case kPfdConstraints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_.pfd_constraints_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints epfd_constraints = 5 [json_name = "epfdConstraints"];
    case kEpfdConstraints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_.epfd_constraints_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints apfd_constraints = 6 [json_name = "apfdConstraints"];
    case kApfdConstraints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_.apfd_constraints_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint psd_constraint = 7 [json_name = "psdConstraint"];
    case kPsdConstraint: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_.psd_constraint_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint pointing_constraint = 8 [json_name = "pointingConstraint"];
    case kPointingConstraint: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_.pointing_constraint_);
      break;
    }
    case CONSTRAINTS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterferenceConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterferenceConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterferenceConstraint::GetClassData() const { return &_class_data_; }


void InterferenceConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterferenceConstraint*>(&to_msg);
  auto& from = static_cast<const InterferenceConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_victims()->MergeFrom(from._internal_victims());
  _this->_internal_mutable_interferers()->MergeFrom(from._internal_interferers());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.use_receiver_orientation_ = from._impl_.use_receiver_orientation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.constraints_case()) {
    case kPfdConstraints: {
      _this->_internal_mutable_pfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_pfd_constraints());
      break;
    }
    case kEpfdConstraints: {
      _this->_internal_mutable_epfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_epfd_constraints());
      break;
    }
    case kApfdConstraints: {
      _this->_internal_mutable_apfd_constraints()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints::MergeFrom(
          from._internal_apfd_constraints());
      break;
    }
    case kPsdConstraint: {
      _this->_internal_mutable_psd_constraint()->::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint::MergeFrom(
          from._internal_psd_constraint());
      break;
    }
    case kPointingConstraint: {
      _this->_internal_mutable_pointing_constraint()->::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint::MergeFrom(
          from._internal_pointing_constraint());
      break;
    }
    case CONSTRAINTS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterferenceConstraint::CopyFrom(const InterferenceConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.InterferenceConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterferenceConstraint::IsInitialized() const {
  switch (constraints_case()) {
    case kPfdConstraints: {
      if (constraints_case() == kPfdConstraints) {
        if (!_impl_.constraints_.pfd_constraints_->IsInitialized()) return false;
      }
      break;
    }
    case kEpfdConstraints: {
      if (constraints_case() == kEpfdConstraints) {
        if (!_impl_.constraints_.epfd_constraints_->IsInitialized()) return false;
      }
      break;
    }
    case kApfdConstraints: {
      if (constraints_case() == kApfdConstraints) {
        if (!_impl_.constraints_.apfd_constraints_->IsInitialized()) return false;
      }
      break;
    }
    case kPsdConstraint: {
      if (constraints_case() == kPsdConstraint) {
        if (!_impl_.constraints_.psd_constraint_->IsInitialized()) return false;
      }
      break;
    }
    case kPointingConstraint: {
      break;
    }
    case CONSTRAINTS_NOT_SET: {
      break;
    }
  }
  return true;
}

void InterferenceConstraint::InternalSwap(InterferenceConstraint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_victims()->InternalSwap(other->_internal_mutable_victims());
  _internal_mutable_interferers()->InternalSwap(other->_internal_mutable_interferers());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);

  swap(_impl_.use_receiver_orientation_, other->_impl_.use_receiver_orientation_);
  swap(_impl_.constraints_, other->_impl_.constraints_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata InterferenceConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[0]);
}
// ===================================================================

class PfdConstraint_Band::_Internal {
 public:
  using HasBits = decltype(std::declval<PfdConstraint_Band>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PfdConstraint_Band, _impl_._has_bits_);
  static void set_has_start_frequency_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_frequency_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PfdConstraint_Band::PfdConstraint_Band(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
}
PfdConstraint_Band::PfdConstraint_Band(const PfdConstraint_Band& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
}

inline void PfdConstraint_Band::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_frequency_mhz_) { 0 }

    , decltype(_impl_.end_frequency_mhz_) { 0 }

  };
}

PfdConstraint_Band::~PfdConstraint_Band() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdConstraint_Band::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PfdConstraint_Band::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdConstraint_Band::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_frequency_mhz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_frequency_mhz_) -
        reinterpret_cast<char*>(&_impl_.start_frequency_mhz_)) + sizeof(_impl_.end_frequency_mhz_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdConstraint_Band::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_start_frequency_mhz(&has_bits);
          _impl_.start_frequency_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_end_frequency_mhz(&has_bits);
          _impl_.end_frequency_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdConstraint_Band::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_start_frequency_mhz(), target);
  }

  // required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_end_frequency_mhz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  return target;
}

::size_t PfdConstraint_Band::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
    total_size += 9;
  }

  return total_size;
}
::size_t PfdConstraint_Band::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double start_frequency_mhz = 1 [json_name = "startFrequencyMhz"];
    total_size += 9;

    // required double end_frequency_mhz = 2 [json_name = "endFrequencyMhz"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdConstraint_Band::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdConstraint_Band::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdConstraint_Band::GetClassData() const { return &_class_data_; }


void PfdConstraint_Band::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdConstraint_Band*>(&to_msg);
  auto& from = static_cast<const PfdConstraint_Band&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_frequency_mhz_ = from._impl_.start_frequency_mhz_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_frequency_mhz_ = from._impl_.end_frequency_mhz_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdConstraint_Band::CopyFrom(const PfdConstraint_Band& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdConstraint_Band::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PfdConstraint_Band::InternalSwap(PfdConstraint_Band* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PfdConstraint_Band, _impl_.end_frequency_mhz_)
      + sizeof(PfdConstraint_Band::_impl_.end_frequency_mhz_)
      - PROTOBUF_FIELD_OFFSET(PfdConstraint_Band, _impl_.start_frequency_mhz_)>(
          reinterpret_cast<char*>(&_impl_.start_frequency_mhz_),
          reinterpret_cast<char*>(&other->_impl_.start_frequency_mhz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdConstraint_Band::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[1]);
}
// ===================================================================

class PfdConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<PfdConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PfdConstraint, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band& band(const PfdConstraint* msg);
  static void set_has_band(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_received_pfd_dbw_per_sqm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_resolution_bw_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band&
PfdConstraint::_Internal::band(const PfdConstraint* msg) {
  return *msg->_impl_.band_;
}
PfdConstraint::PfdConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
}
PfdConstraint::PfdConstraint(const PfdConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PfdConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.band_){nullptr}
    , decltype(_impl_.received_pfd_dbw_per_sqm_) {}

    , decltype(_impl_.resolution_bw_mhz_) {}

    , decltype(_impl_.time_fraction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.band_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band(*from._impl_.band_);
  }
  ::memcpy(&_impl_.received_pfd_dbw_per_sqm_, &from._impl_.received_pfd_dbw_per_sqm_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.time_fraction_) -
    reinterpret_cast<char*>(&_impl_.received_pfd_dbw_per_sqm_)) + sizeof(_impl_.time_fraction_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
}

inline void PfdConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.band_){nullptr}
    , decltype(_impl_.received_pfd_dbw_per_sqm_) { 0 }

    , decltype(_impl_.resolution_bw_mhz_) { 0 }

    , decltype(_impl_.time_fraction_) { 0 }

  };
}

PfdConstraint::~PfdConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.band_;
}

void PfdConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.band_ != nullptr);
    _impl_.band_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.received_pfd_dbw_per_sqm_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.time_fraction_) -
        reinterpret_cast<char*>(&_impl_.received_pfd_dbw_per_sqm_)) + sizeof(_impl_.time_fraction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band band = 1 [json_name = "band"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_band(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double received_pfd_dbw_per_sqm = 2 [json_name = "receivedPfdDbwPerSqm"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_received_pfd_dbw_per_sqm(&has_bits);
          _impl_.received_pfd_dbw_per_sqm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_resolution_bw_mhz(&has_bits);
          _impl_.resolution_bw_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double time_fraction = 4 [json_name = "timeFraction"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_time_fraction(&has_bits);
          _impl_.time_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band band = 1 [json_name = "band"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::band(this),
        _Internal::band(this).GetCachedSize(), target, stream);
  }

  // optional double received_pfd_dbw_per_sqm = 2 [json_name = "receivedPfdDbwPerSqm"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_received_pfd_dbw_per_sqm(), target);
  }

  // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_resolution_bw_mhz(), target);
  }

  // optional double time_fraction = 4 [json_name = "timeFraction"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_time_fraction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  return target;
}

::size_t PfdConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint.Band band = 1 [json_name = "band"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.band_);
    }

    // optional double received_pfd_dbw_per_sqm = 2 [json_name = "receivedPfdDbwPerSqm"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double time_fraction = 4 [json_name = "timeFraction"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdConstraint::GetClassData() const { return &_class_data_; }


void PfdConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdConstraint*>(&to_msg);
  auto& from = static_cast<const PfdConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_band()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band::MergeFrom(
          from._internal_band());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.received_pfd_dbw_per_sqm_ = from._impl_.received_pfd_dbw_per_sqm_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.resolution_bw_mhz_ = from._impl_.resolution_bw_mhz_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_fraction_ = from._impl_.time_fraction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdConstraint::CopyFrom(const PfdConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdConstraint::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.band_->IsInitialized()) return false;
  }
  return true;
}

void PfdConstraint::InternalSwap(PfdConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PfdConstraint, _impl_.time_fraction_)
      + sizeof(PfdConstraint::_impl_.time_fraction_)
      - PROTOBUF_FIELD_OFFSET(PfdConstraint, _impl_.band_)>(
          reinterpret_cast<char*>(&_impl_.band_),
          reinterpret_cast<char*>(&other->_impl_.band_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[2]);
}
// ===================================================================

class PfdConstraints::_Internal {
 public:
};

PfdConstraints::PfdConstraints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
}
PfdConstraints::PfdConstraints(const PfdConstraints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PfdConstraints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pfd_constraints_){from._impl_.pfd_constraints_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
}

inline void PfdConstraints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pfd_constraints_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PfdConstraints::~PfdConstraints() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdConstraints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_pfd_constraints()->~RepeatedPtrField();
}

void PfdConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_pfd_constraints()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdConstraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint pfd_constraints = 1 [json_name = "pfdConstraints"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pfd_constraints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdConstraints::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint pfd_constraints = 1 [json_name = "pfdConstraints"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pfd_constraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_pfd_constraints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  return target;
}

::size_t PfdConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraint pfd_constraints = 1 [json_name = "pfdConstraints"];
  total_size += 1UL * this->_internal_pfd_constraints_size();
  for (const auto& msg : this->_internal_pfd_constraints()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdConstraints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdConstraints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdConstraints::GetClassData() const { return &_class_data_; }


void PfdConstraints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdConstraints*>(&to_msg);
  auto& from = static_cast<const PfdConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_pfd_constraints()->MergeFrom(from._internal_pfd_constraints());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdConstraints::CopyFrom(const PfdConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdConstraints::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_pfd_constraints()))
    return false;
  return true;
}

void PfdConstraints::InternalSwap(PfdConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_pfd_constraints()->InternalSwap(other->_internal_mutable_pfd_constraints());
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdConstraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[3]);
}
// ===================================================================

class PsdConstraint_ScmMask::_Internal {
 public:
  using HasBits = decltype(std::declval<PsdConstraint_ScmMask>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PsdConstraint_ScmMask, _impl_._has_bits_);
  static void set_has_ref_frequency_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

PsdConstraint_ScmMask::PsdConstraint_ScmMask(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
}
PsdConstraint_ScmMask::PsdConstraint_ScmMask(const PsdConstraint_ScmMask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PsdConstraint_ScmMask* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.control_points_){from._impl_.control_points_}
    , decltype(_impl_.ref_frequency_mhz_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ref_frequency_mhz_ = from._impl_.ref_frequency_mhz_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
}

inline void PsdConstraint_ScmMask::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.control_points_){arena}
    , decltype(_impl_.ref_frequency_mhz_) { 0 }

  };
}

PsdConstraint_ScmMask::~PsdConstraint_ScmMask() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PsdConstraint_ScmMask::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_control_points()->~RepeatedPtrField();
}

void PsdConstraint_ScmMask::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PsdConstraint_ScmMask::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_control_points()->Clear();
  _impl_.ref_frequency_mhz_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PsdConstraint_ScmMask::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double ref_frequency_mhz = 1 [json_name = "refFrequencyMhz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_ref_frequency_mhz(&has_bits);
          _impl_.ref_frequency_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint control_points = 2 [json_name = "controlPoints"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_control_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PsdConstraint_ScmMask::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double ref_frequency_mhz = 1 [json_name = "refFrequencyMhz"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_ref_frequency_mhz(), target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint control_points = 2 [json_name = "controlPoints"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_control_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_control_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  return target;
}

::size_t PsdConstraint_ScmMask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  ::size_t total_size = 0;

  // required double ref_frequency_mhz = 1 [json_name = "refFrequencyMhz"];
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 9;
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint control_points = 2 [json_name = "controlPoints"];
  total_size += 1UL * this->_internal_control_points_size();
  for (const auto& msg : this->_internal_control_points()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PsdConstraint_ScmMask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PsdConstraint_ScmMask::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PsdConstraint_ScmMask::GetClassData() const { return &_class_data_; }


void PsdConstraint_ScmMask::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PsdConstraint_ScmMask*>(&to_msg);
  auto& from = static_cast<const PsdConstraint_ScmMask&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_control_points()->MergeFrom(from._internal_control_points());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_ref_frequency_mhz(from._internal_ref_frequency_mhz());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PsdConstraint_ScmMask::CopyFrom(const PsdConstraint_ScmMask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PsdConstraint_ScmMask::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_control_points()))
    return false;
  return true;
}

void PsdConstraint_ScmMask::InternalSwap(PsdConstraint_ScmMask* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_control_points()->InternalSwap(other->_internal_mutable_control_points());

  swap(_impl_.ref_frequency_mhz_, other->_impl_.ref_frequency_mhz_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PsdConstraint_ScmMask::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[4]);
}
// ===================================================================

class PsdConstraint_ControlPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<PsdConstraint_ControlPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PsdConstraint_ControlPoint, _impl_._has_bits_);
  static void set_has_frequency_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_relative_power_db(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PsdConstraint_ControlPoint::PsdConstraint_ControlPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
}
PsdConstraint_ControlPoint::PsdConstraint_ControlPoint(const PsdConstraint_ControlPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
}

inline void PsdConstraint_ControlPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frequency_mhz_) { 0 }

    , decltype(_impl_.relative_power_db_) { 0 }

  };
}

PsdConstraint_ControlPoint::~PsdConstraint_ControlPoint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PsdConstraint_ControlPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PsdConstraint_ControlPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PsdConstraint_ControlPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.frequency_mhz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.relative_power_db_) -
        reinterpret_cast<char*>(&_impl_.frequency_mhz_)) + sizeof(_impl_.relative_power_db_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PsdConstraint_ControlPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double frequency_mhz = 1 [json_name = "frequencyMhz"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_frequency_mhz(&has_bits);
          _impl_.frequency_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double relative_power_db = 2 [json_name = "relativePowerDb"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_relative_power_db(&has_bits);
          _impl_.relative_power_db_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PsdConstraint_ControlPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double frequency_mhz = 1 [json_name = "frequencyMhz"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_frequency_mhz(), target);
  }

  // required double relative_power_db = 2 [json_name = "relativePowerDb"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_relative_power_db(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  return target;
}

::size_t PsdConstraint_ControlPoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double frequency_mhz = 1 [json_name = "frequencyMhz"];
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double relative_power_db = 2 [json_name = "relativePowerDb"];
    total_size += 9;
  }

  return total_size;
}
::size_t PsdConstraint_ControlPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double frequency_mhz = 1 [json_name = "frequencyMhz"];
    total_size += 9;

    // required double relative_power_db = 2 [json_name = "relativePowerDb"];
    total_size += 9;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PsdConstraint_ControlPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PsdConstraint_ControlPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PsdConstraint_ControlPoint::GetClassData() const { return &_class_data_; }


void PsdConstraint_ControlPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PsdConstraint_ControlPoint*>(&to_msg);
  auto& from = static_cast<const PsdConstraint_ControlPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.frequency_mhz_ = from._impl_.frequency_mhz_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.relative_power_db_ = from._impl_.relative_power_db_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PsdConstraint_ControlPoint::CopyFrom(const PsdConstraint_ControlPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ControlPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PsdConstraint_ControlPoint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PsdConstraint_ControlPoint::InternalSwap(PsdConstraint_ControlPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PsdConstraint_ControlPoint, _impl_.relative_power_db_)
      + sizeof(PsdConstraint_ControlPoint::_impl_.relative_power_db_)
      - PROTOBUF_FIELD_OFFSET(PsdConstraint_ControlPoint, _impl_.frequency_mhz_)>(
          reinterpret_cast<char*>(&_impl_.frequency_mhz_),
          reinterpret_cast<char*>(&other->_impl_.frequency_mhz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PsdConstraint_ControlPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[5]);
}
// ===================================================================

class PsdConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<PsdConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PsdConstraint, _impl_._has_bits_);
  static void set_has_reference_power_dbw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask& psd_mask(const PsdConstraint* msg);
  static void set_has_psd_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resolution_bw_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask&
PsdConstraint::_Internal::psd_mask(const PsdConstraint* msg) {
  return *msg->_impl_.psd_mask_;
}
PsdConstraint::PsdConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
}
PsdConstraint::PsdConstraint(const PsdConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PsdConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.psd_mask_){nullptr}
    , decltype(_impl_.reference_power_dbw_) {}

    , decltype(_impl_.resolution_bw_mhz_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.psd_mask_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask(*from._impl_.psd_mask_);
  }
  ::memcpy(&_impl_.reference_power_dbw_, &from._impl_.reference_power_dbw_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.resolution_bw_mhz_) -
    reinterpret_cast<char*>(&_impl_.reference_power_dbw_)) + sizeof(_impl_.resolution_bw_mhz_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
}

inline void PsdConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.psd_mask_){nullptr}
    , decltype(_impl_.reference_power_dbw_) { 0 }

    , decltype(_impl_.resolution_bw_mhz_) { 0 }

  };
}

PsdConstraint::~PsdConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PsdConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.psd_mask_;
}

void PsdConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PsdConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.psd_mask_ != nullptr);
    _impl_.psd_mask_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.reference_power_dbw_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.resolution_bw_mhz_) -
        reinterpret_cast<char*>(&_impl_.reference_power_dbw_)) + sizeof(_impl_.resolution_bw_mhz_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PsdConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double reference_power_dbw = 1 [json_name = "referencePowerDbw"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_reference_power_dbw(&has_bits);
          _impl_.reference_power_dbw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask psd_mask = 2 [json_name = "psdMask"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_psd_mask(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_resolution_bw_mhz(&has_bits);
          _impl_.resolution_bw_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PsdConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double reference_power_dbw = 1 [json_name = "referencePowerDbw"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_reference_power_dbw(), target);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask psd_mask = 2 [json_name = "psdMask"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::psd_mask(this),
        _Internal::psd_mask(this).GetCachedSize(), target, stream);
  }

  // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_resolution_bw_mhz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  return target;
}

::size_t PsdConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint.ScmMask psd_mask = 2 [json_name = "psdMask"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.psd_mask_);
    }

    // optional double reference_power_dbw = 1 [json_name = "referencePowerDbw"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double resolution_bw_mhz = 3 [json_name = "resolutionBwMhz"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PsdConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PsdConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PsdConstraint::GetClassData() const { return &_class_data_; }


void PsdConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PsdConstraint*>(&to_msg);
  auto& from = static_cast<const PsdConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_psd_mask()->::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask::MergeFrom(
          from._internal_psd_mask());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.reference_power_dbw_ = from._impl_.reference_power_dbw_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.resolution_bw_mhz_ = from._impl_.resolution_bw_mhz_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PsdConstraint::CopyFrom(const PsdConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PsdConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PsdConstraint::IsInitialized() const {
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.psd_mask_->IsInitialized()) return false;
  }
  return true;
}

void PsdConstraint::InternalSwap(PsdConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PsdConstraint, _impl_.resolution_bw_mhz_)
      + sizeof(PsdConstraint::_impl_.resolution_bw_mhz_)
      - PROTOBUF_FIELD_OFFSET(PsdConstraint, _impl_.psd_mask_)>(
          reinterpret_cast<char*>(&_impl_.psd_mask_),
          reinterpret_cast<char*>(&other->_impl_.psd_mask_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PsdConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[6]);
}
// ===================================================================

class PointingConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<PointingConstraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PointingConstraint, _impl_._has_bits_);
  static void set_has_min_angle_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PointingConstraint::PointingConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
}
PointingConstraint::PointingConstraint(const PointingConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
}

inline void PointingConstraint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.min_angle_deg_) { 0 }

  };
}

PointingConstraint::~PointingConstraint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointingConstraint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointingConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointingConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.min_angle_deg_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointingConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double min_angle_deg = 1 [json_name = "minAngleDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_min_angle_deg(&has_bits);
          _impl_.min_angle_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PointingConstraint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double min_angle_deg = 1 [json_name = "minAngleDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_min_angle_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  return target;
}

::size_t PointingConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional double min_angle_deg = 1 [json_name = "minAngleDeg"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointingConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointingConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointingConstraint::GetClassData() const { return &_class_data_; }


void PointingConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointingConstraint*>(&to_msg);
  auto& from = static_cast<const PointingConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_min_angle_deg(from._internal_min_angle_deg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointingConstraint::CopyFrom(const PointingConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PointingConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointingConstraint::IsInitialized() const {
  return true;
}

void PointingConstraint::InternalSwap(PointingConstraint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.min_angle_deg_, other->_impl_.min_angle_deg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PointingConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fwireless_5finterference_2eproto[7]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::InterferenceConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint_Band >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdConstraints >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ScmMask >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint_ControlPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PsdConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PointingConstraint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
