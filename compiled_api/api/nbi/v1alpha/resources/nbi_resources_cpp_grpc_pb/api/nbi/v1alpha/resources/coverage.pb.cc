// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/coverage.proto

#include "api/nbi/v1alpha/resources/coverage.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
template <typename>
PROTOBUF_CONSTEXPR TransceiverSet::TransceiverSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transceiver_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransceiverSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransceiverSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransceiverSetDefaultTypeInternal() {}
  union {
    TransceiverSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransceiverSetDefaultTypeInternal _TransceiverSet_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlatformSet::PlatformSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.platform_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlatformSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlatformSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlatformSetDefaultTypeInternal() {}
  union {
    PlatformSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlatformSetDefaultTypeInternal _PlatformSet_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StationSet::StationSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.station_set_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct StationSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StationSetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StationSetDefaultTypeInternal() {}
  union {
    StationSet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StationSetDefaultTypeInternal _StationSet_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StationSubset::StationSubset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.station_set_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.region_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct StationSubsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StationSubsetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StationSubsetDefaultTypeInternal() {}
  union {
    StationSubset _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StationSubsetDefaultTypeInternal _StationSubset_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CoordinateArray::CoordinateArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.derivation_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CoordinateArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoordinateArrayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoordinateArrayDefaultTypeInternal() {}
  union {
    CoordinateArray _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoordinateArrayDefaultTypeInternal _CoordinateArray_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SignalPowerCoverage::SignalPowerCoverage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SignalPowerCoverageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalPowerCoverageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalPowerCoverageDefaultTypeInternal() {}
  union {
    SignalPowerCoverage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalPowerCoverageDefaultTypeInternal _SignalPowerCoverage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeoJsonRegion::GeoJsonRegion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.encoded_geo_buffer_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct GeoJsonRegionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeoJsonRegionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeoJsonRegionDefaultTypeInternal() {}
  union {
    GeoJsonRegion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeoJsonRegionDefaultTypeInternal _GeoJsonRegion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SurfaceRegion::SurfaceRegion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.s2_cell_ids_)*/ {}

  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct SurfaceRegionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SurfaceRegionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SurfaceRegionDefaultTypeInternal() {}
  union {
    SurfaceRegion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SurfaceRegionDefaultTypeInternal _SurfaceRegion_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR S2CoverageGrid::S2CoverageGrid(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.s2_level_)*/ 6u

  , /*decltype(_impl_.region_description_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct S2CoverageGridDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S2CoverageGridDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~S2CoverageGridDefaultTypeInternal() {}
  union {
    S2CoverageGrid _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S2CoverageGridDefaultTypeInternal _S2CoverageGrid_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdOverS2Region::PfdOverS2Region(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.region_)*/nullptr
  , /*decltype(_impl_.received_power_flux_density_db_w_per_m2_)*/ 0
} {}
struct PfdOverS2RegionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdOverS2RegionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdOverS2RegionDefaultTypeInternal() {}
  union {
    PfdOverS2Region _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdOverS2RegionDefaultTypeInternal _PfdOverS2Region_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SurfacePfdRegions::SurfacePfdRegions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pfd_region_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SurfacePfdRegionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SurfacePfdRegionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SurfacePfdRegionsDefaultTypeInternal() {}
  union {
    SurfacePfdRegions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SurfacePfdRegionsDefaultTypeInternal _SurfacePfdRegions_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeostationaryArc::GeostationaryArc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latitude_bound_deg_)*/ 0

  , /*decltype(_impl_.resolution_deg_)*/ 0
} {}
struct GeostationaryArcDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeostationaryArcDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeostationaryArcDefaultTypeInternal() {}
  union {
    GeostationaryArc _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeostationaryArcDefaultTypeInternal _GeostationaryArc_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdOverGeoArcCell::PfdOverGeoArcCell(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.longitude_deg_)*/ 0

  , /*decltype(_impl_.latitude_deg_)*/ 0

  , /*decltype(_impl_.received_power_flux_density_db_w_per_m2_)*/ 0
} {}
struct PfdOverGeoArcCellDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdOverGeoArcCellDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdOverGeoArcCellDefaultTypeInternal() {}
  union {
    PfdOverGeoArcCell _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdOverGeoArcCellDefaultTypeInternal _PfdOverGeoArcCell_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR GeostationaryArcPfd::GeostationaryArcPfd(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cell_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GeostationaryArcPfdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeostationaryArcPfdDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeostationaryArcPfdDefaultTypeInternal() {}
  union {
    GeostationaryArcPfd _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeostationaryArcPfdDefaultTypeInternal _GeostationaryArcPfd_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdAtAntenna::PfdAtAntenna(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transceiver_model_id_)*/nullptr
  , /*decltype(_impl_.received_power_flux_density_db_w_per_m2_)*/ 0
} {}
struct PfdAtAntennaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdAtAntennaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdAtAntennaDefaultTypeInternal() {}
  union {
    PfdAtAntenna _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdAtAntennaDefaultTypeInternal _PfdAtAntenna_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PfdOverConstellation::PfdOverConstellation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.victim_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PfdOverConstellationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PfdOverConstellationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PfdOverConstellationDefaultTypeInternal() {}
  union {
    PfdOverConstellation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PfdOverConstellationDefaultTypeInternal _PfdOverConstellation_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[16];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet, _impl_.transceiver_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet, _impl_.platform_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet, _impl_.station_set_type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset, _impl_.station_set_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset, _impl_.region_id_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray, _impl_.derivation_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion, _impl_.encoded_geo_buffer_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion, _impl_.s2_cell_ids_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion, _impl_.name_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _impl_.s2_level_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _impl_.region_description_),
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region, _impl_.region_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region, _impl_.received_power_flux_density_db_w_per_m2_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions, _impl_.pfd_region_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc, _impl_.latitude_bound_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc, _impl_.resolution_deg_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell, _impl_.longitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell, _impl_.latitude_deg_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell, _impl_.received_power_flux_density_db_w_per_m2_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd, _impl_.cell_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna, _impl_.transceiver_model_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna, _impl_.received_power_flux_density_db_w_per_m2_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation, _impl_.victim_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet)},
        { 9, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet)},
        { 18, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet)},
        { 29, 39, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset)},
        { 41, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray)},
        { 53, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage)},
        { 65, 75, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion)},
        { 77, 87, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion)},
        { 89, 101, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid)},
        { 104, 114, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region)},
        { 116, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions)},
        { 125, 135, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc)},
        { 137, 148, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell)},
        { 151, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd)},
        { 160, 170, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna)},
        { 172, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TransceiverSet_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PlatformSet_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_StationSet_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_StationSubset_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_CoordinateArray_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_SignalPowerCoverage_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_GeoJsonRegion_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_SurfaceRegion_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_S2CoverageGrid_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdOverS2Region_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_SurfacePfdRegions_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_GeostationaryArc_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdOverGeoArcCell_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_GeostationaryArcPfd_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdAtAntenna_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdOverConstellation_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n(api/nbi/v1alpha/resources/coverage.pro"
    "to\022+aalyria.spacetime.api.nbi.v1alpha.re"
    "sources\032\034api/common/coordinates.proto\032%a"
    "pi/common/wireless_transceiver.proto\"k\n\016"
    "TransceiverSet\022Y\n\017transceiver_ids\030\001 \003(\0132"
    "0.aalyria.spacetime.api.common.Transceiv"
    "erModelIdR\016transceiverIds\"0\n\013PlatformSet"
    "\022!\n\014platform_ids\030\001 \003(\tR\013platformIds\"\335\001\n\n"
    "StationSet\022a\n\014transceivers\030\001 \001(\0132;.aalyr"
    "ia.spacetime.api.nbi.v1alpha.resources.T"
    "ransceiverSetH\000R\014transceivers\022X\n\tplatfor"
    "ms\030\002 \001(\01328.aalyria.spacetime.api.nbi.v1a"
    "lpha.resources.PlatformSetH\000R\tplatformsB"
    "\022\n\020station_set_type\"R\n\rStationSubset\022$\n\016"
    "station_set_id\030\001 \001(\tR\014stationSetId\022\033\n\tre"
    "gion_id\030\002 \001(\tR\010regionId\"\254\002\n\017CoordinateAr"
    "ray\022W\n\007surface\030\001 \001(\0132;.aalyria.spacetime"
    ".api.nbi.v1alpha.resources.S2CoverageGri"
    "dH\000R\007surface\022X\n\007geo_arc\030\002 \001(\0132=.aalyria."
    "spacetime.api.nbi.v1alpha.resources.Geos"
    "tationaryArcH\000R\006geoArc\022X\n\010stations\030\003 \001(\013"
    "2:.aalyria.spacetime.api.nbi.v1alpha.res"
    "ources.StationSubsetH\000R\010stationsB\014\n\nderi"
    "vation\"\301\002\n\023SignalPowerCoverage\022Z\n\007surfac"
    "e\030\001 \001(\0132>.aalyria.spacetime.api.nbi.v1al"
    "pha.resources.SurfacePfdRegionsH\000R\007surfa"
    "ce\022[\n\007geo_arc\030\002 \001(\0132@.aalyria.spacetime."
    "api.nbi.v1alpha.resources.GeostationaryA"
    "rcPfdH\000R\006geoArc\022i\n\rconstellation\030\003 \001(\0132A"
    ".aalyria.spacetime.api.nbi.v1alpha.resou"
    "rces.PfdOverConstellationH\000R\rconstellati"
    "onB\006\n\004type\"Q\n\rGeoJsonRegion\022\022\n\004name\030\001 \001("
    "\tR\004name\022,\n\022encoded_geo_buffer\030\002 \003(\014R\020enc"
    "odedGeoBuffer\"C\n\rSurfaceRegion\022\036\n\013s2_cel"
    "l_ids\030\001 \003(\003R\ts2CellIds\022\022\n\004name\030\002 \001(\tR\004na"
    "me\"\244\001\n\016S2CoverageGrid\022\?\n\006region\030\001 \001(\0132%."
    "aalyria.spacetime.api.common.S2CellsH\000R\006"
    "region\022\035\n\tregion_id\030\003 \001(\tH\000R\010regionId\022\034\n"
    "\010s2_level\030\002 \001(\r:\0016R\007s2LevelB\024\n\022region_de"
    "scription\"\243\001\n\017PfdOverS2Region\022=\n\006region\030"
    "\001 \001(\0132%.aalyria.spacetime.api.common.S2C"
    "ellsR\006region\022Q\n\'received_power_flux_dens"
    "ity_db_w_per_m2\030\002 \001(\001R receivedPowerFlux"
    "DensityDbWPerM2\"p\n\021SurfacePfdRegions\022[\n\n"
    "pfd_region\030\001 \003(\0132<.aalyria.spacetime.api"
    ".nbi.v1alpha.resources.PfdOverS2RegionR\t"
    "pfdRegion\"g\n\020GeostationaryArc\022,\n\022latitud"
    "e_bound_deg\030\001 \001(\001R\020latitudeBoundDeg\022%\n\016r"
    "esolution_deg\030\002 \001(\001R\rresolutionDeg\"\256\001\n\021P"
    "fdOverGeoArcCell\022#\n\rlongitude_deg\030\001 \001(\001R"
    "\014longitudeDeg\022!\n\014latitude_deg\030\002 \001(\001R\013lat"
    "itudeDeg\022Q\n\'received_power_flux_density_"
    "db_w_per_m2\030\003 \001(\001R receivedPowerFluxDens"
    "ityDbWPerM2\"i\n\023GeostationaryArcPfd\022R\n\004ce"
    "ll\030\001 \003(\0132>.aalyria.spacetime.api.nbi.v1a"
    "lpha.resources.PfdOverGeoArcCellR\004cell\"\313"
    "\001\n\014PfdAtAntenna\022b\n\024transceiver_model_id\030"
    "\003 \001(\01320.aalyria.spacetime.api.common.Tra"
    "nsceiverModelIdR\022transceiverModelId\022Q\n\'r"
    "eceived_power_flux_density_db_w_per_m2\030\002"
    " \001(\001R receivedPowerFluxDensityDbWPerM2J\004"
    "\010\001\020\002\"i\n\024PfdOverConstellation\022Q\n\006victim\030\001"
    " \003(\01329.aalyria.spacetime.api.nbi.v1alpha"
    ".resources.PfdAtAntennaR\006victimBb\n/com.a"
    "alyria.spacetime.api.nbi.v1alpha.resourc"
    "esZ/aalyria.com/spacetime/api/nbi/v1alph"
    "a/resources"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_deps[2] =
    {
        &::descriptor_table_api_2fcommon_2fcoordinates_2eproto,
        &::descriptor_table_api_2fcommon_2fwireless_5ftransceiver_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto = {
    false,
    false,
    2651,
    descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
    "api/nbi/v1alpha/resources/coverage.proto",
    &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_deps,
    2,
    16,
    schemas,
    file_default_instances,
    TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto::offsets,
    file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter() {
  return &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
// ===================================================================

class TransceiverSet::_Internal {
 public:
};

void TransceiverSet::clear_transceiver_ids() {
  _internal_mutable_transceiver_ids()->Clear();
}
TransceiverSet::TransceiverSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
}
TransceiverSet::TransceiverSet(const TransceiverSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransceiverSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transceiver_ids_){from._impl_.transceiver_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
}

inline void TransceiverSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.transceiver_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransceiverSet::~TransceiverSet() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransceiverSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_transceiver_ids()->~RepeatedPtrField();
}

void TransceiverSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransceiverSet::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_transceiver_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransceiverSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.common.TransceiverModelId transceiver_ids = 1 [json_name = "transceiverIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transceiver_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransceiverSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.TransceiverModelId transceiver_ids = 1 [json_name = "transceiverIds"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transceiver_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_transceiver_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  return target;
}

::size_t TransceiverSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.TransceiverModelId transceiver_ids = 1 [json_name = "transceiverIds"];
  total_size += 1UL * this->_internal_transceiver_ids_size();
  for (const auto& msg : this->_internal_transceiver_ids()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransceiverSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransceiverSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransceiverSet::GetClassData() const { return &_class_data_; }


void TransceiverSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransceiverSet*>(&to_msg);
  auto& from = static_cast<const TransceiverSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transceiver_ids()->MergeFrom(from._internal_transceiver_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransceiverSet::CopyFrom(const TransceiverSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransceiverSet::IsInitialized() const {
  return true;
}

void TransceiverSet::InternalSwap(TransceiverSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_transceiver_ids()->InternalSwap(other->_internal_mutable_transceiver_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata TransceiverSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[0]);
}
// ===================================================================

class PlatformSet::_Internal {
 public:
};

PlatformSet::PlatformSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
}
PlatformSet::PlatformSet(const PlatformSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlatformSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.platform_ids_){from._impl_.platform_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
}

inline void PlatformSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.platform_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlatformSet::~PlatformSet() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlatformSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_platform_ids()->~RepeatedPtrField();
}

void PlatformSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlatformSet::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_platform_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlatformSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string platform_ids = 1 [json_name = "platformIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_platform_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlatformSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string platform_ids = 1 [json_name = "platformIds"];
  for (int i = 0, n = this->_internal_platform_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_platform_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  return target;
}

::size_t PlatformSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string platform_ids = 1 [json_name = "platformIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_platform_ids().size());
  for (int i = 0, n = _internal_platform_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_platform_ids().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlatformSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlatformSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlatformSet::GetClassData() const { return &_class_data_; }


void PlatformSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlatformSet*>(&to_msg);
  auto& from = static_cast<const PlatformSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_platform_ids()->MergeFrom(from._internal_platform_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlatformSet::CopyFrom(const PlatformSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlatformSet::IsInitialized() const {
  return true;
}

void PlatformSet::InternalSwap(PlatformSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_platform_ids()->InternalSwap(
      other->_internal_mutable_platform_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata PlatformSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[1]);
}
// ===================================================================

class StationSet::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet& transceivers(const StationSet* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet& platforms(const StationSet* msg);
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet&
StationSet::_Internal::transceivers(const StationSet* msg) {
  return *msg->_impl_.station_set_type_.transceivers_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet&
StationSet::_Internal::platforms(const StationSet* msg) {
  return *msg->_impl_.station_set_type_.platforms_;
}
void StationSet::set_allocated_transceivers(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* transceivers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_station_set_type();
  if (transceivers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transceivers);
    if (message_arena != submessage_arena) {
      transceivers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transceivers, submessage_arena);
    }
    set_has_transceivers();
    _impl_.station_set_type_.transceivers_ = transceivers;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
}
void StationSet::set_allocated_platforms(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* platforms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_station_set_type();
  if (platforms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(platforms);
    if (message_arena != submessage_arena) {
      platforms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, platforms, submessage_arena);
    }
    set_has_platforms();
    _impl_.station_set_type_.platforms_ = platforms;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
}
StationSet::StationSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
}
StationSet::StationSet(const StationSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StationSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.station_set_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_station_set_type();
  switch (from.station_set_type_case()) {
    case kTransceivers: {
      _this->_internal_mutable_transceivers()->::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet::MergeFrom(
          from._internal_transceivers());
      break;
    }
    case kPlatforms: {
      _this->_internal_mutable_platforms()->::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet::MergeFrom(
          from._internal_platforms());
      break;
    }
    case STATION_SET_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
}

inline void StationSet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.station_set_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_station_set_type();
}

StationSet::~StationSet() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StationSet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_station_set_type()) {
    clear_station_set_type();
  }
}

void StationSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StationSet::clear_station_set_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  switch (station_set_type_case()) {
    case kTransceivers: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.station_set_type_.transceivers_;
      }
      break;
    }
    case kPlatforms: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.station_set_type_.platforms_;
      }
      break;
    }
    case STATION_SET_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = STATION_SET_TYPE_NOT_SET;
}


void StationSet::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_station_set_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StationSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet transceivers = 1 [json_name = "transceivers"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_transceivers(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet platforms = 2 [json_name = "platforms"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_platforms(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StationSet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (station_set_type_case()) {
    case kTransceivers: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::transceivers(this),
          _Internal::transceivers(this).GetCachedSize(), target, stream);
      break;
    }
    case kPlatforms: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::platforms(this),
          _Internal::platforms(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  return target;
}

::size_t StationSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (station_set_type_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet transceivers = 1 [json_name = "transceivers"];
    case kTransceivers: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.station_set_type_.transceivers_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet platforms = 2 [json_name = "platforms"];
    case kPlatforms: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.station_set_type_.platforms_);
      break;
    }
    case STATION_SET_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StationSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StationSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StationSet::GetClassData() const { return &_class_data_; }


void StationSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StationSet*>(&to_msg);
  auto& from = static_cast<const StationSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.station_set_type_case()) {
    case kTransceivers: {
      _this->_internal_mutable_transceivers()->::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet::MergeFrom(
          from._internal_transceivers());
      break;
    }
    case kPlatforms: {
      _this->_internal_mutable_platforms()->::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet::MergeFrom(
          from._internal_platforms());
      break;
    }
    case STATION_SET_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StationSet::CopyFrom(const StationSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StationSet::IsInitialized() const {
  return true;
}

void StationSet::InternalSwap(StationSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.station_set_type_, other->_impl_.station_set_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata StationSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[2]);
}
// ===================================================================

class StationSubset::_Internal {
 public:
  using HasBits = decltype(std::declval<StationSubset>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StationSubset, _impl_._has_bits_);
  static void set_has_station_set_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StationSubset::StationSubset(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
}
StationSubset::StationSubset(const StationSubset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StationSubset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.station_set_id_) {}

    , decltype(_impl_.region_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.station_set_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.station_set_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.station_set_id_.Set(from._internal_station_set_id(), _this->GetArenaForAllocation());
  }
  _impl_.region_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.region_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.region_id_.Set(from._internal_region_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
}

inline void StationSubset::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.station_set_id_) {}

    , decltype(_impl_.region_id_) {}

  };
  _impl_.station_set_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.station_set_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.region_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StationSubset::~StationSubset() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StationSubset::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.station_set_id_.Destroy();
  _impl_.region_id_.Destroy();
}

void StationSubset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StationSubset::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.station_set_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.region_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StationSubset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string station_set_id = 1 [json_name = "stationSetId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_station_set_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string region_id = 2 [json_name = "regionId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_region_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StationSubset::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string station_set_id = 1 [json_name = "stationSetId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_station_set_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string region_id = 2 [json_name = "regionId"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_region_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  return target;
}

::size_t StationSubset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string station_set_id = 1 [json_name = "stationSetId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_station_set_id());
    }

    // optional string region_id = 2 [json_name = "regionId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_region_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StationSubset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StationSubset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StationSubset::GetClassData() const { return &_class_data_; }


void StationSubset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StationSubset*>(&to_msg);
  auto& from = static_cast<const StationSubset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_station_set_id(from._internal_station_set_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_region_id(from._internal_region_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StationSubset::CopyFrom(const StationSubset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StationSubset::IsInitialized() const {
  return true;
}

void StationSubset::InternalSwap(StationSubset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.station_set_id_, lhs_arena,
                                       &other->_impl_.station_set_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.region_id_, lhs_arena,
                                       &other->_impl_.region_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata StationSubset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[3]);
}
// ===================================================================

class CoordinateArray::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid& surface(const CoordinateArray* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc& geo_arc(const CoordinateArray* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& stations(const CoordinateArray* msg);
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid&
CoordinateArray::_Internal::surface(const CoordinateArray* msg) {
  return *msg->_impl_.derivation_.surface_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc&
CoordinateArray::_Internal::geo_arc(const CoordinateArray* msg) {
  return *msg->_impl_.derivation_.geo_arc_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset&
CoordinateArray::_Internal::stations(const CoordinateArray* msg) {
  return *msg->_impl_.derivation_.stations_;
}
void CoordinateArray::set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* surface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_derivation();
  if (surface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(surface);
    if (message_arena != submessage_arena) {
      surface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, surface, submessage_arena);
    }
    set_has_surface();
    _impl_.derivation_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
}
void CoordinateArray::set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* geo_arc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_derivation();
  if (geo_arc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo_arc);
    if (message_arena != submessage_arena) {
      geo_arc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_arc, submessage_arena);
    }
    set_has_geo_arc();
    _impl_.derivation_.geo_arc_ = geo_arc;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
}
void CoordinateArray::set_allocated_stations(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* stations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_derivation();
  if (stations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stations);
    if (message_arena != submessage_arena) {
      stations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stations, submessage_arena);
    }
    set_has_stations();
    _impl_.derivation_.stations_ = stations;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
}
CoordinateArray::CoordinateArray(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
}
CoordinateArray::CoordinateArray(const CoordinateArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CoordinateArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.derivation_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_derivation();
  switch (from.derivation_case()) {
    case kSurface: {
      _this->_internal_mutable_surface()->::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid::MergeFrom(
          from._internal_surface());
      break;
    }
    case kGeoArc: {
      _this->_internal_mutable_geo_arc()->::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc::MergeFrom(
          from._internal_geo_arc());
      break;
    }
    case kStations: {
      _this->_internal_mutable_stations()->::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset::MergeFrom(
          from._internal_stations());
      break;
    }
    case DERIVATION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
}

inline void CoordinateArray::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.derivation_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_derivation();
}

CoordinateArray::~CoordinateArray() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoordinateArray::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_derivation()) {
    clear_derivation();
  }
}

void CoordinateArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CoordinateArray::clear_derivation() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  switch (derivation_case()) {
    case kSurface: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.derivation_.surface_;
      }
      break;
    }
    case kGeoArc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.derivation_.geo_arc_;
      }
      break;
    }
    case kStations: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.derivation_.stations_;
      }
      break;
    }
    case DERIVATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = DERIVATION_NOT_SET;
}


void CoordinateArray::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_derivation();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoordinateArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid surface = 1 [json_name = "surface"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_surface(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc geo_arc = 2 [json_name = "geoArc"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geo_arc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset stations = 3 [json_name = "stations"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stations(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CoordinateArray::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (derivation_case()) {
    case kSurface: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::surface(this),
          _Internal::surface(this).GetCachedSize(), target, stream);
      break;
    }
    case kGeoArc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::geo_arc(this),
          _Internal::geo_arc(this).GetCachedSize(), target, stream);
      break;
    }
    case kStations: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::stations(this),
          _Internal::stations(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  return target;
}

::size_t CoordinateArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (derivation_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid surface = 1 [json_name = "surface"];
    case kSurface: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.derivation_.surface_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc geo_arc = 2 [json_name = "geoArc"];
    case kGeoArc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.derivation_.geo_arc_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset stations = 3 [json_name = "stations"];
    case kStations: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.derivation_.stations_);
      break;
    }
    case DERIVATION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoordinateArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CoordinateArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoordinateArray::GetClassData() const { return &_class_data_; }


void CoordinateArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CoordinateArray*>(&to_msg);
  auto& from = static_cast<const CoordinateArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.derivation_case()) {
    case kSurface: {
      _this->_internal_mutable_surface()->::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid::MergeFrom(
          from._internal_surface());
      break;
    }
    case kGeoArc: {
      _this->_internal_mutable_geo_arc()->::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc::MergeFrom(
          from._internal_geo_arc());
      break;
    }
    case kStations: {
      _this->_internal_mutable_stations()->::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset::MergeFrom(
          from._internal_stations());
      break;
    }
    case DERIVATION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoordinateArray::CopyFrom(const CoordinateArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoordinateArray::IsInitialized() const {
  return true;
}

void CoordinateArray::InternalSwap(CoordinateArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.derivation_, other->_impl_.derivation_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoordinateArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[4]);
}
// ===================================================================

class SignalPowerCoverage::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions& surface(const SignalPowerCoverage* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd& geo_arc(const SignalPowerCoverage* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation& constellation(const SignalPowerCoverage* msg);
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions&
SignalPowerCoverage::_Internal::surface(const SignalPowerCoverage* msg) {
  return *msg->_impl_.type_.surface_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd&
SignalPowerCoverage::_Internal::geo_arc(const SignalPowerCoverage* msg) {
  return *msg->_impl_.type_.geo_arc_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation&
SignalPowerCoverage::_Internal::constellation(const SignalPowerCoverage* msg) {
  return *msg->_impl_.type_.constellation_;
}
void SignalPowerCoverage::set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* surface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (surface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(surface);
    if (message_arena != submessage_arena) {
      surface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, surface, submessage_arena);
    }
    set_has_surface();
    _impl_.type_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
}
void SignalPowerCoverage::set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* geo_arc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (geo_arc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geo_arc);
    if (message_arena != submessage_arena) {
      geo_arc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_arc, submessage_arena);
    }
    set_has_geo_arc();
    _impl_.type_.geo_arc_ = geo_arc;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
}
void SignalPowerCoverage::set_allocated_constellation(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* constellation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (constellation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constellation);
    if (message_arena != submessage_arena) {
      constellation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constellation, submessage_arena);
    }
    set_has_constellation();
    _impl_.type_.constellation_ = constellation;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
}
SignalPowerCoverage::SignalPowerCoverage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
}
SignalPowerCoverage::SignalPowerCoverage(const SignalPowerCoverage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignalPowerCoverage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kSurface: {
      _this->_internal_mutable_surface()->::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions::MergeFrom(
          from._internal_surface());
      break;
    }
    case kGeoArc: {
      _this->_internal_mutable_geo_arc()->::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd::MergeFrom(
          from._internal_geo_arc());
      break;
    }
    case kConstellation: {
      _this->_internal_mutable_constellation()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation::MergeFrom(
          from._internal_constellation());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
}

inline void SignalPowerCoverage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type();
}

SignalPowerCoverage::~SignalPowerCoverage() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignalPowerCoverage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void SignalPowerCoverage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignalPowerCoverage::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  switch (type_case()) {
    case kSurface: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.surface_;
      }
      break;
    }
    case kGeoArc: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.geo_arc_;
      }
      break;
    }
    case kConstellation: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.constellation_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void SignalPowerCoverage::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignalPowerCoverage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions surface = 1 [json_name = "surface"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_surface(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd geo_arc = 2 [json_name = "geoArc"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geo_arc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation constellation = 3 [json_name = "constellation"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_constellation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SignalPowerCoverage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kSurface: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::surface(this),
          _Internal::surface(this).GetCachedSize(), target, stream);
      break;
    }
    case kGeoArc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::geo_arc(this),
          _Internal::geo_arc(this).GetCachedSize(), target, stream);
      break;
    }
    case kConstellation: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::constellation(this),
          _Internal::constellation(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  return target;
}

::size_t SignalPowerCoverage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions surface = 1 [json_name = "surface"];
    case kSurface: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.surface_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd geo_arc = 2 [json_name = "geoArc"];
    case kGeoArc: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.geo_arc_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation constellation = 3 [json_name = "constellation"];
    case kConstellation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_.constellation_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignalPowerCoverage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignalPowerCoverage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignalPowerCoverage::GetClassData() const { return &_class_data_; }


void SignalPowerCoverage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignalPowerCoverage*>(&to_msg);
  auto& from = static_cast<const SignalPowerCoverage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kSurface: {
      _this->_internal_mutable_surface()->::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions::MergeFrom(
          from._internal_surface());
      break;
    }
    case kGeoArc: {
      _this->_internal_mutable_geo_arc()->::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd::MergeFrom(
          from._internal_geo_arc());
      break;
    }
    case kConstellation: {
      _this->_internal_mutable_constellation()->::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation::MergeFrom(
          from._internal_constellation());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignalPowerCoverage::CopyFrom(const SignalPowerCoverage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalPowerCoverage::IsInitialized() const {
  return true;
}

void SignalPowerCoverage::InternalSwap(SignalPowerCoverage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignalPowerCoverage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[5]);
}
// ===================================================================

class GeoJsonRegion::_Internal {
 public:
  using HasBits = decltype(std::declval<GeoJsonRegion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeoJsonRegion, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GeoJsonRegion::GeoJsonRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
}
GeoJsonRegion::GeoJsonRegion(const GeoJsonRegion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeoJsonRegion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encoded_geo_buffer_){from._impl_.encoded_geo_buffer_}
    , decltype(_impl_.name_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
}

inline void GeoJsonRegion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encoded_geo_buffer_){arena}
    , decltype(_impl_.name_) {}

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GeoJsonRegion::~GeoJsonRegion() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeoJsonRegion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_encoded_geo_buffer()->~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void GeoJsonRegion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeoJsonRegion::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_encoded_geo_buffer()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeoJsonRegion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1 [json_name = "name"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated bytes encoded_geo_buffer = 2 [json_name = "encodedGeoBuffer"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_encoded_geo_buffer();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeoJsonRegion::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1 [json_name = "name"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated bytes encoded_geo_buffer = 2 [json_name = "encodedGeoBuffer"];
  for (int i = 0, n = this->_internal_encoded_geo_buffer_size(); i < n; ++i) {
    const auto& s = this->_internal_encoded_geo_buffer(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  return target;
}

::size_t GeoJsonRegion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes encoded_geo_buffer = 2 [json_name = "encodedGeoBuffer"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_encoded_geo_buffer().size());
  for (int i = 0, n = _internal_encoded_geo_buffer().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        _internal_encoded_geo_buffer().Get(i));
  }

  // optional string name = 1 [json_name = "name"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeoJsonRegion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeoJsonRegion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeoJsonRegion::GetClassData() const { return &_class_data_; }


void GeoJsonRegion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeoJsonRegion*>(&to_msg);
  auto& from = static_cast<const GeoJsonRegion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_encoded_geo_buffer()->MergeFrom(from._internal_encoded_geo_buffer());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeoJsonRegion::CopyFrom(const GeoJsonRegion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeoJsonRegion::IsInitialized() const {
  return true;
}

void GeoJsonRegion::InternalSwap(GeoJsonRegion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_encoded_geo_buffer()->InternalSwap(
      other->_internal_mutable_encoded_geo_buffer());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata GeoJsonRegion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[6]);
}
// ===================================================================

class SurfaceRegion::_Internal {
 public:
  using HasBits = decltype(std::declval<SurfaceRegion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SurfaceRegion, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SurfaceRegion::SurfaceRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
}
SurfaceRegion::SurfaceRegion(const SurfaceRegion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SurfaceRegion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s2_cell_ids_) { from._impl_.s2_cell_ids_ }

    , decltype(_impl_.name_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
}

inline void SurfaceRegion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s2_cell_ids_) { arena }

    , decltype(_impl_.name_) {}

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SurfaceRegion::~SurfaceRegion() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SurfaceRegion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.s2_cell_ids_.~RepeatedField();
  _impl_.name_.Destroy();
}

void SurfaceRegion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SurfaceRegion::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_s2_cell_ids()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SurfaceRegion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 s2_cell_ids = 1 [json_name = "s2CellIds"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_s2_cell_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_s2_cell_ids(), ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string name = 2 [json_name = "name"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SurfaceRegion::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 s2_cell_ids = 1 [json_name = "s2CellIds"];
  for (int i = 0, n = this->_internal_s2_cell_ids_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_s2_cell_ids(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 2 [json_name = "name"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  return target;
}

::size_t SurfaceRegion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 s2_cell_ids = 1 [json_name = "s2CellIds"];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_s2_cell_ids())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_s2_cell_ids_size());
    ;
    total_size += tag_size + data_size;
  }

  // optional string name = 2 [json_name = "name"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SurfaceRegion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SurfaceRegion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SurfaceRegion::GetClassData() const { return &_class_data_; }


void SurfaceRegion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SurfaceRegion*>(&to_msg);
  auto& from = static_cast<const SurfaceRegion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.s2_cell_ids_.MergeFrom(from._impl_.s2_cell_ids_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SurfaceRegion::CopyFrom(const SurfaceRegion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SurfaceRegion::IsInitialized() const {
  return true;
}

void SurfaceRegion::InternalSwap(SurfaceRegion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.s2_cell_ids_.InternalSwap(&other->_impl_.s2_cell_ids_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SurfaceRegion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[7]);
}
// ===================================================================

class S2CoverageGrid::_Internal {
 public:
  using HasBits = decltype(std::declval<S2CoverageGrid>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(S2CoverageGrid, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::common::S2Cells& region(const S2CoverageGrid* msg);
  static void set_has_s2_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::aalyria::spacetime::api::common::S2Cells&
S2CoverageGrid::_Internal::region(const S2CoverageGrid* msg) {
  return *msg->_impl_.region_description_.region_;
}
void S2CoverageGrid::set_allocated_region(::aalyria::spacetime::api::common::S2Cells* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_region_description();
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region));
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    set_has_region();
    _impl_.region_description_.region_ = region;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
}
void S2CoverageGrid::clear_region() {
  if (region_description_case() == kRegion) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.region_description_.region_;
    }
    clear_has_region_description();
  }
}
S2CoverageGrid::S2CoverageGrid(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
}
S2CoverageGrid::S2CoverageGrid(const S2CoverageGrid& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S2CoverageGrid* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s2_level_) {}

    , decltype(_impl_.region_description_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.s2_level_ = from._impl_.s2_level_;
  clear_has_region_description();
  switch (from.region_description_case()) {
    case kRegion: {
      _this->_internal_mutable_region()->::aalyria::spacetime::api::common::S2Cells::MergeFrom(
          from._internal_region());
      break;
    }
    case kRegionId: {
      _this->_internal_set_region_id(from._internal_region_id());
      break;
    }
    case REGION_DESCRIPTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
}

inline void S2CoverageGrid::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.s2_level_) { 6u }

    , decltype(_impl_.region_description_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_region_description();
}

S2CoverageGrid::~S2CoverageGrid() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S2CoverageGrid::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_region_description()) {
    clear_region_description();
  }
}

void S2CoverageGrid::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S2CoverageGrid::clear_region_description() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  switch (region_description_case()) {
    case kRegion: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.region_description_.region_;
      }
      break;
    }
    case kRegionId: {
      _impl_.region_description_.region_id_.Destroy();
      break;
    }
    case REGION_DESCRIPTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REGION_DESCRIPTION_NOT_SET;
}


void S2CoverageGrid::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.s2_level_ = 6u;
  clear_region_description();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S2CoverageGrid::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_region(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 s2_level = 2 [default = 6, json_name = "s2Level"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_s2_level(&has_bits);
          _impl_.s2_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string region_id = 3 [json_name = "regionId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_region_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* S2CoverageGrid::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
  if (region_description_case() == kRegion) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::region(this),
        _Internal::region(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 s2_level = 2 [default = 6, json_name = "s2Level"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_s2_level(), target);
  }

  // string region_id = 3 [json_name = "regionId"];
  if (region_description_case() == kRegionId) {
    const std::string& _s = this->_internal_region_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  return target;
}

::size_t S2CoverageGrid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 s2_level = 2 [default = 6, json_name = "s2Level"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_s2_level());
  }

  switch (region_description_case()) {
    // .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
    case kRegion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.region_description_.region_);
      break;
    }
    // string region_id = 3 [json_name = "regionId"];
    case kRegionId: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_region_id());
      break;
    }
    case REGION_DESCRIPTION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S2CoverageGrid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S2CoverageGrid::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S2CoverageGrid::GetClassData() const { return &_class_data_; }


void S2CoverageGrid::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S2CoverageGrid*>(&to_msg);
  auto& from = static_cast<const S2CoverageGrid&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_s2_level(from._internal_s2_level());
  }
  switch (from.region_description_case()) {
    case kRegion: {
      _this->_internal_mutable_region()->::aalyria::spacetime::api::common::S2Cells::MergeFrom(
          from._internal_region());
      break;
    }
    case kRegionId: {
      _this->_internal_set_region_id(from._internal_region_id());
      break;
    }
    case REGION_DESCRIPTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S2CoverageGrid::CopyFrom(const S2CoverageGrid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S2CoverageGrid::IsInitialized() const {
  return true;
}

void S2CoverageGrid::InternalSwap(S2CoverageGrid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.s2_level_, other->_impl_.s2_level_);
  swap(_impl_.region_description_, other->_impl_.region_description_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata S2CoverageGrid::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[8]);
}
// ===================================================================

class PfdOverS2Region::_Internal {
 public:
  using HasBits = decltype(std::declval<PfdOverS2Region>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PfdOverS2Region, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::S2Cells& region(const PfdOverS2Region* msg);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_received_power_flux_density_db_w_per_m2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::S2Cells&
PfdOverS2Region::_Internal::region(const PfdOverS2Region* msg) {
  return *msg->_impl_.region_;
}
void PfdOverS2Region::clear_region() {
  if (_impl_.region_ != nullptr) _impl_.region_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PfdOverS2Region::PfdOverS2Region(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
}
PfdOverS2Region::PfdOverS2Region(const PfdOverS2Region& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PfdOverS2Region* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.received_power_flux_density_db_w_per_m2_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.region_ = new ::aalyria::spacetime::api::common::S2Cells(*from._impl_.region_);
  }
  _this->_impl_.received_power_flux_density_db_w_per_m2_ = from._impl_.received_power_flux_density_db_w_per_m2_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
}

inline void PfdOverS2Region::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.received_power_flux_density_db_w_per_m2_) { 0 }

  };
}

PfdOverS2Region::~PfdOverS2Region() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdOverS2Region::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.region_;
}

void PfdOverS2Region::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdOverS2Region::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.region_ != nullptr);
    _impl_.region_->Clear();
  }
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdOverS2Region::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_region(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_received_power_flux_density_db_w_per_m2(&has_bits);
          _impl_.received_power_flux_density_db_w_per_m2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdOverS2Region::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::region(this),
        _Internal::region(this).GetCachedSize(), target, stream);
  }

  // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_received_power_flux_density_db_w_per_m2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  return target;
}

::size_t PfdOverS2Region::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.region_);
    }

    // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdOverS2Region::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdOverS2Region::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdOverS2Region::GetClassData() const { return &_class_data_; }


void PfdOverS2Region::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdOverS2Region*>(&to_msg);
  auto& from = static_cast<const PfdOverS2Region&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_region()->::aalyria::spacetime::api::common::S2Cells::MergeFrom(
          from._internal_region());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.received_power_flux_density_db_w_per_m2_ = from._impl_.received_power_flux_density_db_w_per_m2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdOverS2Region::CopyFrom(const PfdOverS2Region& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdOverS2Region::IsInitialized() const {
  return true;
}

void PfdOverS2Region::InternalSwap(PfdOverS2Region* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PfdOverS2Region, _impl_.received_power_flux_density_db_w_per_m2_)
      + sizeof(PfdOverS2Region::_impl_.received_power_flux_density_db_w_per_m2_)
      - PROTOBUF_FIELD_OFFSET(PfdOverS2Region, _impl_.region_)>(
          reinterpret_cast<char*>(&_impl_.region_),
          reinterpret_cast<char*>(&other->_impl_.region_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdOverS2Region::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[9]);
}
// ===================================================================

class SurfacePfdRegions::_Internal {
 public:
};

SurfacePfdRegions::SurfacePfdRegions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
}
SurfacePfdRegions::SurfacePfdRegions(const SurfacePfdRegions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SurfacePfdRegions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pfd_region_){from._impl_.pfd_region_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
}

inline void SurfacePfdRegions::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.pfd_region_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SurfacePfdRegions::~SurfacePfdRegions() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SurfacePfdRegions::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_pfd_region()->~RepeatedPtrField();
}

void SurfacePfdRegions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SurfacePfdRegions::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_pfd_region()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SurfacePfdRegions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region pfd_region = 1 [json_name = "pfdRegion"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pfd_region(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SurfacePfdRegions::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region pfd_region = 1 [json_name = "pfdRegion"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pfd_region_size()); i < n; i++) {
    const auto& repfield = this->_internal_pfd_region(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  return target;
}

::size_t SurfacePfdRegions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region pfd_region = 1 [json_name = "pfdRegion"];
  total_size += 1UL * this->_internal_pfd_region_size();
  for (const auto& msg : this->_internal_pfd_region()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SurfacePfdRegions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SurfacePfdRegions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SurfacePfdRegions::GetClassData() const { return &_class_data_; }


void SurfacePfdRegions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SurfacePfdRegions*>(&to_msg);
  auto& from = static_cast<const SurfacePfdRegions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_pfd_region()->MergeFrom(from._internal_pfd_region());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SurfacePfdRegions::CopyFrom(const SurfacePfdRegions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SurfacePfdRegions::IsInitialized() const {
  return true;
}

void SurfacePfdRegions::InternalSwap(SurfacePfdRegions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_pfd_region()->InternalSwap(other->_internal_mutable_pfd_region());
}

::PROTOBUF_NAMESPACE_ID::Metadata SurfacePfdRegions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[10]);
}
// ===================================================================

class GeostationaryArc::_Internal {
 public:
  using HasBits = decltype(std::declval<GeostationaryArc>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GeostationaryArc, _impl_._has_bits_);
  static void set_has_latitude_bound_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resolution_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GeostationaryArc::GeostationaryArc(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
}
GeostationaryArc::GeostationaryArc(const GeostationaryArc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
}

inline void GeostationaryArc::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latitude_bound_deg_) { 0 }

    , decltype(_impl_.resolution_deg_) { 0 }

  };
}

GeostationaryArc::~GeostationaryArc() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeostationaryArc::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeostationaryArc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeostationaryArc::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.latitude_bound_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.resolution_deg_) -
        reinterpret_cast<char*>(&_impl_.latitude_bound_deg_)) + sizeof(_impl_.resolution_deg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeostationaryArc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double latitude_bound_deg = 1 [json_name = "latitudeBoundDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_latitude_bound_deg(&has_bits);
          _impl_.latitude_bound_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double resolution_deg = 2 [json_name = "resolutionDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_resolution_deg(&has_bits);
          _impl_.resolution_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeostationaryArc::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double latitude_bound_deg = 1 [json_name = "latitudeBoundDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_latitude_bound_deg(), target);
  }

  // optional double resolution_deg = 2 [json_name = "resolutionDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_resolution_deg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  return target;
}

::size_t GeostationaryArc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double latitude_bound_deg = 1 [json_name = "latitudeBoundDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double resolution_deg = 2 [json_name = "resolutionDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeostationaryArc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeostationaryArc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeostationaryArc::GetClassData() const { return &_class_data_; }


void GeostationaryArc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeostationaryArc*>(&to_msg);
  auto& from = static_cast<const GeostationaryArc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latitude_bound_deg_ = from._impl_.latitude_bound_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resolution_deg_ = from._impl_.resolution_deg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeostationaryArc::CopyFrom(const GeostationaryArc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeostationaryArc::IsInitialized() const {
  return true;
}

void GeostationaryArc::InternalSwap(GeostationaryArc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeostationaryArc, _impl_.resolution_deg_)
      + sizeof(GeostationaryArc::_impl_.resolution_deg_)
      - PROTOBUF_FIELD_OFFSET(GeostationaryArc, _impl_.latitude_bound_deg_)>(
          reinterpret_cast<char*>(&_impl_.latitude_bound_deg_),
          reinterpret_cast<char*>(&other->_impl_.latitude_bound_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeostationaryArc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[11]);
}
// ===================================================================

class PfdOverGeoArcCell::_Internal {
 public:
  using HasBits = decltype(std::declval<PfdOverGeoArcCell>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PfdOverGeoArcCell, _impl_._has_bits_);
  static void set_has_longitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude_deg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_received_power_flux_density_db_w_per_m2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PfdOverGeoArcCell::PfdOverGeoArcCell(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
}
PfdOverGeoArcCell::PfdOverGeoArcCell(const PfdOverGeoArcCell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
}

inline void PfdOverGeoArcCell::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.longitude_deg_) { 0 }

    , decltype(_impl_.latitude_deg_) { 0 }

    , decltype(_impl_.received_power_flux_density_db_w_per_m2_) { 0 }

  };
}

PfdOverGeoArcCell::~PfdOverGeoArcCell() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdOverGeoArcCell::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PfdOverGeoArcCell::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdOverGeoArcCell::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.longitude_deg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.received_power_flux_density_db_w_per_m2_) -
        reinterpret_cast<char*>(&_impl_.longitude_deg_)) + sizeof(_impl_.received_power_flux_density_db_w_per_m2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdOverGeoArcCell::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 9)) {
          _Internal::set_has_longitude_deg(&has_bits);
          _impl_.longitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude_deg(&has_bits);
          _impl_.latitude_deg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double received_power_flux_density_db_w_per_m2 = 3 [json_name = "receivedPowerFluxDensityDbWPerM2"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_received_power_flux_density_db_w_per_m2(&has_bits);
          _impl_.received_power_flux_density_db_w_per_m2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdOverGeoArcCell::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_longitude_deg(), target);
  }

  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_latitude_deg(), target);
  }

  // optional double received_power_flux_density_db_w_per_m2 = 3 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_received_power_flux_density_db_w_per_m2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  return target;
}

::size_t PfdOverGeoArcCell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional double received_power_flux_density_db_w_per_m2 = 3 [json_name = "receivedPowerFluxDensityDbWPerM2"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdOverGeoArcCell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdOverGeoArcCell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdOverGeoArcCell::GetClassData() const { return &_class_data_; }


void PfdOverGeoArcCell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdOverGeoArcCell*>(&to_msg);
  auto& from = static_cast<const PfdOverGeoArcCell&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.longitude_deg_ = from._impl_.longitude_deg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_deg_ = from._impl_.latitude_deg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.received_power_flux_density_db_w_per_m2_ = from._impl_.received_power_flux_density_db_w_per_m2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdOverGeoArcCell::CopyFrom(const PfdOverGeoArcCell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdOverGeoArcCell::IsInitialized() const {
  return true;
}

void PfdOverGeoArcCell::InternalSwap(PfdOverGeoArcCell* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PfdOverGeoArcCell, _impl_.received_power_flux_density_db_w_per_m2_)
      + sizeof(PfdOverGeoArcCell::_impl_.received_power_flux_density_db_w_per_m2_)
      - PROTOBUF_FIELD_OFFSET(PfdOverGeoArcCell, _impl_.longitude_deg_)>(
          reinterpret_cast<char*>(&_impl_.longitude_deg_),
          reinterpret_cast<char*>(&other->_impl_.longitude_deg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdOverGeoArcCell::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[12]);
}
// ===================================================================

class GeostationaryArcPfd::_Internal {
 public:
};

GeostationaryArcPfd::GeostationaryArcPfd(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
}
GeostationaryArcPfd::GeostationaryArcPfd(const GeostationaryArcPfd& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeostationaryArcPfd* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_){from._impl_.cell_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
}

inline void GeostationaryArcPfd::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GeostationaryArcPfd::~GeostationaryArcPfd() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeostationaryArcPfd::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_cell()->~RepeatedPtrField();
}

void GeostationaryArcPfd::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeostationaryArcPfd::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_cell()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeostationaryArcPfd::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell cell = 1 [json_name = "cell"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cell(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* GeostationaryArcPfd::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell cell = 1 [json_name = "cell"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  return target;
}

::size_t GeostationaryArcPfd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell cell = 1 [json_name = "cell"];
  total_size += 1UL * this->_internal_cell_size();
  for (const auto& msg : this->_internal_cell()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeostationaryArcPfd::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeostationaryArcPfd::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeostationaryArcPfd::GetClassData() const { return &_class_data_; }


void GeostationaryArcPfd::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeostationaryArcPfd*>(&to_msg);
  auto& from = static_cast<const GeostationaryArcPfd&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cell()->MergeFrom(from._internal_cell());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeostationaryArcPfd::CopyFrom(const GeostationaryArcPfd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeostationaryArcPfd::IsInitialized() const {
  return true;
}

void GeostationaryArcPfd::InternalSwap(GeostationaryArcPfd* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_cell()->InternalSwap(other->_internal_mutable_cell());
}

::PROTOBUF_NAMESPACE_ID::Metadata GeostationaryArcPfd::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[13]);
}
// ===================================================================

class PfdAtAntenna::_Internal {
 public:
  using HasBits = decltype(std::declval<PfdAtAntenna>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PfdAtAntenna, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_model_id(const PfdAtAntenna* msg);
  static void set_has_transceiver_model_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_received_power_flux_density_db_w_per_m2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::aalyria::spacetime::api::common::TransceiverModelId&
PfdAtAntenna::_Internal::transceiver_model_id(const PfdAtAntenna* msg) {
  return *msg->_impl_.transceiver_model_id_;
}
void PfdAtAntenna::clear_transceiver_model_id() {
  if (_impl_.transceiver_model_id_ != nullptr) _impl_.transceiver_model_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PfdAtAntenna::PfdAtAntenna(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
}
PfdAtAntenna::PfdAtAntenna(const PfdAtAntenna& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PfdAtAntenna* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transceiver_model_id_){nullptr}
    , decltype(_impl_.received_power_flux_density_db_w_per_m2_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.transceiver_model_id_ = new ::aalyria::spacetime::api::common::TransceiverModelId(*from._impl_.transceiver_model_id_);
  }
  _this->_impl_.received_power_flux_density_db_w_per_m2_ = from._impl_.received_power_flux_density_db_w_per_m2_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
}

inline void PfdAtAntenna::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transceiver_model_id_){nullptr}
    , decltype(_impl_.received_power_flux_density_db_w_per_m2_) { 0 }

  };
}

PfdAtAntenna::~PfdAtAntenna() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdAtAntenna::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.transceiver_model_id_;
}

void PfdAtAntenna::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdAtAntenna::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.transceiver_model_id_ != nullptr);
    _impl_.transceiver_model_id_->Clear();
  }
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdAtAntenna::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_received_power_flux_density_db_w_per_m2(&has_bits);
          _impl_.received_power_flux_density_db_w_per_m2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 3 [json_name = "transceiverModelId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_transceiver_model_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdAtAntenna::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_received_power_flux_density_db_w_per_m2(), target);
  }

  // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 3 [json_name = "transceiverModelId"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::transceiver_model_id(this),
        _Internal::transceiver_model_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  return target;
}

::size_t PfdAtAntenna::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 3 [json_name = "transceiverModelId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transceiver_model_id_);
    }

    // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdAtAntenna::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdAtAntenna::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdAtAntenna::GetClassData() const { return &_class_data_; }


void PfdAtAntenna::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdAtAntenna*>(&to_msg);
  auto& from = static_cast<const PfdAtAntenna&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_transceiver_model_id()->::aalyria::spacetime::api::common::TransceiverModelId::MergeFrom(
          from._internal_transceiver_model_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.received_power_flux_density_db_w_per_m2_ = from._impl_.received_power_flux_density_db_w_per_m2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdAtAntenna::CopyFrom(const PfdAtAntenna& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdAtAntenna::IsInitialized() const {
  return true;
}

void PfdAtAntenna::InternalSwap(PfdAtAntenna* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PfdAtAntenna, _impl_.received_power_flux_density_db_w_per_m2_)
      + sizeof(PfdAtAntenna::_impl_.received_power_flux_density_db_w_per_m2_)
      - PROTOBUF_FIELD_OFFSET(PfdAtAntenna, _impl_.transceiver_model_id_)>(
          reinterpret_cast<char*>(&_impl_.transceiver_model_id_),
          reinterpret_cast<char*>(&other->_impl_.transceiver_model_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdAtAntenna::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[14]);
}
// ===================================================================

class PfdOverConstellation::_Internal {
 public:
};

PfdOverConstellation::PfdOverConstellation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
}
PfdOverConstellation::PfdOverConstellation(const PfdOverConstellation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PfdOverConstellation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.victim_){from._impl_.victim_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
}

inline void PfdOverConstellation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.victim_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PfdOverConstellation::~PfdOverConstellation() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PfdOverConstellation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_victim()->~RepeatedPtrField();
}

void PfdOverConstellation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PfdOverConstellation::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_victim()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PfdOverConstellation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna victim = 1 [json_name = "victim"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_victim(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PfdOverConstellation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna victim = 1 [json_name = "victim"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_victim_size()); i < n; i++) {
    const auto& repfield = this->_internal_victim(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  return target;
}

::size_t PfdOverConstellation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna victim = 1 [json_name = "victim"];
  total_size += 1UL * this->_internal_victim_size();
  for (const auto& msg : this->_internal_victim()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PfdOverConstellation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PfdOverConstellation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PfdOverConstellation::GetClassData() const { return &_class_data_; }


void PfdOverConstellation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PfdOverConstellation*>(&to_msg);
  auto& from = static_cast<const PfdOverConstellation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_victim()->MergeFrom(from._internal_victim());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PfdOverConstellation::CopyFrom(const PfdOverConstellation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PfdOverConstellation::IsInitialized() const {
  return true;
}

void PfdOverConstellation::InternalSwap(PfdOverConstellation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_victim()->InternalSwap(other->_internal_mutable_victim());
}

::PROTOBUF_NAMESPACE_ID::Metadata PfdOverConstellation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto[15]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
