// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/coverage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "api/common/coordinates.pb.h"
#include "api/common/wireless_transceiver.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
class CoordinateArray;
struct CoordinateArrayDefaultTypeInternal;
extern CoordinateArrayDefaultTypeInternal _CoordinateArray_default_instance_;
class GeoJsonRegion;
struct GeoJsonRegionDefaultTypeInternal;
extern GeoJsonRegionDefaultTypeInternal _GeoJsonRegion_default_instance_;
class GeostationaryArc;
struct GeostationaryArcDefaultTypeInternal;
extern GeostationaryArcDefaultTypeInternal _GeostationaryArc_default_instance_;
class GeostationaryArcPfd;
struct GeostationaryArcPfdDefaultTypeInternal;
extern GeostationaryArcPfdDefaultTypeInternal _GeostationaryArcPfd_default_instance_;
class PfdAtAntenna;
struct PfdAtAntennaDefaultTypeInternal;
extern PfdAtAntennaDefaultTypeInternal _PfdAtAntenna_default_instance_;
class PfdOverConstellation;
struct PfdOverConstellationDefaultTypeInternal;
extern PfdOverConstellationDefaultTypeInternal _PfdOverConstellation_default_instance_;
class PfdOverGeoArcCell;
struct PfdOverGeoArcCellDefaultTypeInternal;
extern PfdOverGeoArcCellDefaultTypeInternal _PfdOverGeoArcCell_default_instance_;
class PfdOverS2Region;
struct PfdOverS2RegionDefaultTypeInternal;
extern PfdOverS2RegionDefaultTypeInternal _PfdOverS2Region_default_instance_;
class PlatformSet;
struct PlatformSetDefaultTypeInternal;
extern PlatformSetDefaultTypeInternal _PlatformSet_default_instance_;
class S2CoverageGrid;
struct S2CoverageGridDefaultTypeInternal;
extern S2CoverageGridDefaultTypeInternal _S2CoverageGrid_default_instance_;
class SignalPowerCoverage;
struct SignalPowerCoverageDefaultTypeInternal;
extern SignalPowerCoverageDefaultTypeInternal _SignalPowerCoverage_default_instance_;
class StationSet;
struct StationSetDefaultTypeInternal;
extern StationSetDefaultTypeInternal _StationSet_default_instance_;
class StationSubset;
struct StationSubsetDefaultTypeInternal;
extern StationSubsetDefaultTypeInternal _StationSubset_default_instance_;
class SurfacePfdRegions;
struct SurfacePfdRegionsDefaultTypeInternal;
extern SurfacePfdRegionsDefaultTypeInternal _SurfacePfdRegions_default_instance_;
class SurfaceRegion;
struct SurfaceRegionDefaultTypeInternal;
extern SurfaceRegionDefaultTypeInternal _SurfaceRegion_default_instance_;
class TransceiverSet;
struct TransceiverSetDefaultTypeInternal;
extern TransceiverSetDefaultTypeInternal _TransceiverSet_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::CoordinateArray>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::GeoJsonRegion>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SignalPowerCoverage>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSet>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::SurfaceRegion>(Arena*);
template <>
::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* Arena::CreateMaybeMessage<::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {

// ===================================================================


// -------------------------------------------------------------------

class TransceiverSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet) */ {
 public:
  inline TransceiverSet() : TransceiverSet(nullptr) {}
  ~TransceiverSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransceiverSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransceiverSet(const TransceiverSet& from);
  TransceiverSet(TransceiverSet&& from) noexcept
    : TransceiverSet() {
    *this = ::std::move(from);
  }

  inline TransceiverSet& operator=(const TransceiverSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransceiverSet& operator=(TransceiverSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransceiverSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransceiverSet* internal_default_instance() {
    return reinterpret_cast<const TransceiverSet*>(
               &_TransceiverSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransceiverSet& a, TransceiverSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TransceiverSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransceiverSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransceiverSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransceiverSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransceiverSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransceiverSet& from) {
    TransceiverSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransceiverSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet";
  }
  protected:
  explicit TransceiverSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransceiverIdsFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.common.TransceiverModelId transceiver_ids = 1 [json_name = "transceiverIds"];
  int transceiver_ids_size() const;
  private:
  int _internal_transceiver_ids_size() const;

  public:
  void clear_transceiver_ids() ;
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_transceiver_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransceiverModelId >*
      mutable_transceiver_ids();
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_transceiver_ids(int index) const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_add_transceiver_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransceiverModelId>& _internal_transceiver_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransceiverModelId>* _internal_mutable_transceiver_ids();
  public:
  const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_ids(int index) const;
  ::aalyria::spacetime::api::common::TransceiverModelId* add_transceiver_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransceiverModelId >&
      transceiver_ids() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransceiverModelId > transceiver_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class PlatformSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet) */ {
 public:
  inline PlatformSet() : PlatformSet(nullptr) {}
  ~PlatformSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlatformSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlatformSet(const PlatformSet& from);
  PlatformSet(PlatformSet&& from) noexcept
    : PlatformSet() {
    *this = ::std::move(from);
  }

  inline PlatformSet& operator=(const PlatformSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatformSet& operator=(PlatformSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatformSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatformSet* internal_default_instance() {
    return reinterpret_cast<const PlatformSet*>(
               &_PlatformSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlatformSet& a, PlatformSet& b) {
    a.Swap(&b);
  }
  inline void Swap(PlatformSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatformSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatformSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlatformSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlatformSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlatformSet& from) {
    PlatformSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlatformSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet";
  }
  protected:
  explicit PlatformSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformIdsFieldNumber = 1,
  };
  // repeated string platform_ids = 1 [json_name = "platformIds"];
  int platform_ids_size() const;
  private:
  int _internal_platform_ids_size() const;

  public:
  void clear_platform_ids() ;
  const std::string& platform_ids(int index) const;
  std::string* mutable_platform_ids(int index);
  void set_platform_ids(int index, const std::string& value);
  void set_platform_ids(int index, std::string&& value);
  void set_platform_ids(int index, const char* value);
  void set_platform_ids(int index, const char* value, std::size_t size);
  void set_platform_ids(int index, absl::string_view value);
  std::string* add_platform_ids();
  void add_platform_ids(const std::string& value);
  void add_platform_ids(std::string&& value);
  void add_platform_ids(const char* value);
  void add_platform_ids(const char* value, std::size_t size);
  void add_platform_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& platform_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_platform_ids();

  private:
  const std::string& _internal_platform_ids(int index) const;
  std::string* _internal_add_platform_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_platform_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_platform_ids();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> platform_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class StationSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet) */ {
 public:
  inline StationSet() : StationSet(nullptr) {}
  ~StationSet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StationSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationSet(const StationSet& from);
  StationSet(StationSet&& from) noexcept
    : StationSet() {
    *this = ::std::move(from);
  }

  inline StationSet& operator=(const StationSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationSet& operator=(StationSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationSet& default_instance() {
    return *internal_default_instance();
  }
  enum StationSetTypeCase {
    kTransceivers = 1,
    kPlatforms = 2,
    STATION_SET_TYPE_NOT_SET = 0,
  };

  static inline const StationSet* internal_default_instance() {
    return reinterpret_cast<const StationSet*>(
               &_StationSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StationSet& a, StationSet& b) {
    a.Swap(&b);
  }
  inline void Swap(StationSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationSet& from) {
    StationSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.StationSet";
  }
  protected:
  explicit StationSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransceiversFieldNumber = 1,
    kPlatformsFieldNumber = 2,
  };
  // .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet transceivers = 1 [json_name = "transceivers"];
  bool has_transceivers() const;
  private:
  bool _internal_has_transceivers() const;

  public:
  void clear_transceivers() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet& transceivers() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* release_transceivers();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* mutable_transceivers();
  void set_allocated_transceivers(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* transceivers);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet& _internal_transceivers() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* _internal_mutable_transceivers();
  public:
  void unsafe_arena_set_allocated_transceivers(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* transceivers);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* unsafe_arena_release_transceivers();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet platforms = 2 [json_name = "platforms"];
  bool has_platforms() const;
  private:
  bool _internal_has_platforms() const;

  public:
  void clear_platforms() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet& platforms() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* release_platforms();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* mutable_platforms();
  void set_allocated_platforms(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* platforms);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet& _internal_platforms() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* _internal_mutable_platforms();
  public:
  void unsafe_arena_set_allocated_platforms(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* platforms);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* unsafe_arena_release_platforms();
  void clear_station_set_type();
  StationSetTypeCase station_set_type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet)
 private:
  class _Internal;
  void set_has_transceivers();
  void set_has_platforms();

  inline bool has_station_set_type() const;
  inline void clear_has_station_set_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union StationSetTypeUnion {
      constexpr StationSetTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* transceivers_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* platforms_;
    } station_set_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class StationSubset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset) */ {
 public:
  inline StationSubset() : StationSubset(nullptr) {}
  ~StationSubset() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StationSubset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationSubset(const StationSubset& from);
  StationSubset(StationSubset&& from) noexcept
    : StationSubset() {
    *this = ::std::move(from);
  }

  inline StationSubset& operator=(const StationSubset& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationSubset& operator=(StationSubset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationSubset& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationSubset* internal_default_instance() {
    return reinterpret_cast<const StationSubset*>(
               &_StationSubset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StationSubset& a, StationSubset& b) {
    a.Swap(&b);
  }
  inline void Swap(StationSubset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationSubset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationSubset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationSubset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationSubset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationSubset& from) {
    StationSubset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationSubset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset";
  }
  protected:
  explicit StationSubset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationSetIdFieldNumber = 1,
    kRegionIdFieldNumber = 2,
  };
  // optional string station_set_id = 1 [json_name = "stationSetId"];
  bool has_station_set_id() const;
  void clear_station_set_id() ;
  const std::string& station_set_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_station_set_id(Arg_&& arg, Args_... args);
  std::string* mutable_station_set_id();
  PROTOBUF_NODISCARD std::string* release_station_set_id();
  void set_allocated_station_set_id(std::string* ptr);

  private:
  const std::string& _internal_station_set_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_set_id(
      const std::string& value);
  std::string* _internal_mutable_station_set_id();

  public:
  // optional string region_id = 2 [json_name = "regionId"];
  bool has_region_id() const;
  void clear_region_id() ;
  const std::string& region_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region_id(Arg_&& arg, Args_... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* ptr);

  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(
      const std::string& value);
  std::string* _internal_mutable_region_id();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_set_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class CoordinateArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray) */ {
 public:
  inline CoordinateArray() : CoordinateArray(nullptr) {}
  ~CoordinateArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CoordinateArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordinateArray(const CoordinateArray& from);
  CoordinateArray(CoordinateArray&& from) noexcept
    : CoordinateArray() {
    *this = ::std::move(from);
  }

  inline CoordinateArray& operator=(const CoordinateArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinateArray& operator=(CoordinateArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinateArray& default_instance() {
    return *internal_default_instance();
  }
  enum DerivationCase {
    kSurface = 1,
    kGeoArc = 2,
    kStations = 3,
    DERIVATION_NOT_SET = 0,
  };

  static inline const CoordinateArray* internal_default_instance() {
    return reinterpret_cast<const CoordinateArray*>(
               &_CoordinateArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CoordinateArray& a, CoordinateArray& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinateArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinateArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinateArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoordinateArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordinateArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoordinateArray& from) {
    CoordinateArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinateArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray";
  }
  protected:
  explicit CoordinateArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSurfaceFieldNumber = 1,
    kGeoArcFieldNumber = 2,
    kStationsFieldNumber = 3,
  };
  // .aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid surface = 1 [json_name = "surface"];
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;

  public:
  void clear_surface() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid& surface() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* release_surface();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* mutable_surface();
  void set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* surface);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid& _internal_surface() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* _internal_mutable_surface();
  public:
  void unsafe_arena_set_allocated_surface(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* surface);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* unsafe_arena_release_surface();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc geo_arc = 2 [json_name = "geoArc"];
  bool has_geo_arc() const;
  private:
  bool _internal_has_geo_arc() const;

  public:
  void clear_geo_arc() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc& geo_arc() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* release_geo_arc();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* mutable_geo_arc();
  void set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* geo_arc);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc& _internal_geo_arc() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* _internal_mutable_geo_arc();
  public:
  void unsafe_arena_set_allocated_geo_arc(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* geo_arc);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* unsafe_arena_release_geo_arc();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset stations = 3 [json_name = "stations"];
  bool has_stations() const;
  private:
  bool _internal_has_stations() const;

  public:
  void clear_stations() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& stations() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* release_stations();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* mutable_stations();
  void set_allocated_stations(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* stations);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& _internal_stations() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* _internal_mutable_stations();
  public:
  void unsafe_arena_set_allocated_stations(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* stations);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* unsafe_arena_release_stations();
  void clear_derivation();
  DerivationCase derivation_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray)
 private:
  class _Internal;
  void set_has_surface();
  void set_has_geo_arc();
  void set_has_stations();

  inline bool has_derivation() const;
  inline void clear_has_derivation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DerivationUnion {
      constexpr DerivationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* surface_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* geo_arc_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* stations_;
    } derivation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class SignalPowerCoverage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage) */ {
 public:
  inline SignalPowerCoverage() : SignalPowerCoverage(nullptr) {}
  ~SignalPowerCoverage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignalPowerCoverage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalPowerCoverage(const SignalPowerCoverage& from);
  SignalPowerCoverage(SignalPowerCoverage&& from) noexcept
    : SignalPowerCoverage() {
    *this = ::std::move(from);
  }

  inline SignalPowerCoverage& operator=(const SignalPowerCoverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalPowerCoverage& operator=(SignalPowerCoverage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalPowerCoverage& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSurface = 1,
    kGeoArc = 2,
    kConstellation = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const SignalPowerCoverage* internal_default_instance() {
    return reinterpret_cast<const SignalPowerCoverage*>(
               &_SignalPowerCoverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignalPowerCoverage& a, SignalPowerCoverage& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalPowerCoverage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalPowerCoverage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalPowerCoverage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalPowerCoverage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalPowerCoverage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalPowerCoverage& from) {
    SignalPowerCoverage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalPowerCoverage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage";
  }
  protected:
  explicit SignalPowerCoverage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSurfaceFieldNumber = 1,
    kGeoArcFieldNumber = 2,
    kConstellationFieldNumber = 3,
  };
  // .aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions surface = 1 [json_name = "surface"];
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;

  public:
  void clear_surface() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions& surface() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* release_surface();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* mutable_surface();
  void set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* surface);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions& _internal_surface() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* _internal_mutable_surface();
  public:
  void unsafe_arena_set_allocated_surface(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* surface);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* unsafe_arena_release_surface();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd geo_arc = 2 [json_name = "geoArc"];
  bool has_geo_arc() const;
  private:
  bool _internal_has_geo_arc() const;

  public:
  void clear_geo_arc() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd& geo_arc() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* release_geo_arc();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* mutable_geo_arc();
  void set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* geo_arc);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd& _internal_geo_arc() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* _internal_mutable_geo_arc();
  public:
  void unsafe_arena_set_allocated_geo_arc(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* geo_arc);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* unsafe_arena_release_geo_arc();
  // .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation constellation = 3 [json_name = "constellation"];
  bool has_constellation() const;
  private:
  bool _internal_has_constellation() const;

  public:
  void clear_constellation() ;
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation& constellation() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* release_constellation();
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* mutable_constellation();
  void set_allocated_constellation(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* constellation);
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation& _internal_constellation() const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* _internal_mutable_constellation();
  public:
  void unsafe_arena_set_allocated_constellation(
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* constellation);
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* unsafe_arena_release_constellation();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage)
 private:
  class _Internal;
  void set_has_surface();
  void set_has_geo_arc();
  void set_has_constellation();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* surface_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* geo_arc_;
      ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* constellation_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class GeoJsonRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion) */ {
 public:
  inline GeoJsonRegion() : GeoJsonRegion(nullptr) {}
  ~GeoJsonRegion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeoJsonRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeoJsonRegion(const GeoJsonRegion& from);
  GeoJsonRegion(GeoJsonRegion&& from) noexcept
    : GeoJsonRegion() {
    *this = ::std::move(from);
  }

  inline GeoJsonRegion& operator=(const GeoJsonRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoJsonRegion& operator=(GeoJsonRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeoJsonRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeoJsonRegion* internal_default_instance() {
    return reinterpret_cast<const GeoJsonRegion*>(
               &_GeoJsonRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GeoJsonRegion& a, GeoJsonRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoJsonRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoJsonRegion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeoJsonRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeoJsonRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeoJsonRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeoJsonRegion& from) {
    GeoJsonRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoJsonRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion";
  }
  protected:
  explicit GeoJsonRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedGeoBufferFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated bytes encoded_geo_buffer = 2 [json_name = "encodedGeoBuffer"];
  int encoded_geo_buffer_size() const;
  private:
  int _internal_encoded_geo_buffer_size() const;

  public:
  void clear_encoded_geo_buffer() ;
  const std::string& encoded_geo_buffer(int index) const;
  std::string* mutable_encoded_geo_buffer(int index);
  void set_encoded_geo_buffer(int index, const std::string& value);
  void set_encoded_geo_buffer(int index, std::string&& value);
  void set_encoded_geo_buffer(int index, const char* value);
  void set_encoded_geo_buffer(int index, const void* value, std::size_t size);
  void set_encoded_geo_buffer(int index, absl::string_view value);
  std::string* add_encoded_geo_buffer();
  void add_encoded_geo_buffer(const std::string& value);
  void add_encoded_geo_buffer(std::string&& value);
  void add_encoded_geo_buffer(const char* value);
  void add_encoded_geo_buffer(const void* value, std::size_t size);
  void add_encoded_geo_buffer(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& encoded_geo_buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_encoded_geo_buffer();

  private:
  const std::string& _internal_encoded_geo_buffer(int index) const;
  std::string* _internal_add_encoded_geo_buffer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_encoded_geo_buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_encoded_geo_buffer();

  public:
  // optional string name = 1 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> encoded_geo_buffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class SurfaceRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion) */ {
 public:
  inline SurfaceRegion() : SurfaceRegion(nullptr) {}
  ~SurfaceRegion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SurfaceRegion(const SurfaceRegion& from);
  SurfaceRegion(SurfaceRegion&& from) noexcept
    : SurfaceRegion() {
    *this = ::std::move(from);
  }

  inline SurfaceRegion& operator=(const SurfaceRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceRegion& operator=(SurfaceRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfaceRegion* internal_default_instance() {
    return reinterpret_cast<const SurfaceRegion*>(
               &_SurfaceRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SurfaceRegion& a, SurfaceRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfaceRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceRegion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfaceRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SurfaceRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SurfaceRegion& from) {
    SurfaceRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion";
  }
  protected:
  explicit SurfaceRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS2CellIdsFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated int64 s2_cell_ids = 1 [json_name = "s2CellIds"];
  int s2_cell_ids_size() const;
  private:
  int _internal_s2_cell_ids_size() const;

  public:
  void clear_s2_cell_ids() ;
  ::int64_t s2_cell_ids(int index) const;
  void set_s2_cell_ids(int index, ::int64_t value);
  void add_s2_cell_ids(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& s2_cell_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_s2_cell_ids();

  private:
  ::int64_t _internal_s2_cell_ids(int index) const;
  void _internal_add_s2_cell_ids(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_s2_cell_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_s2_cell_ids();

  public:
  // optional string name = 2 [json_name = "name"];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> s2_cell_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class S2CoverageGrid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid) */ {
 public:
  inline S2CoverageGrid() : S2CoverageGrid(nullptr) {}
  ~S2CoverageGrid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR S2CoverageGrid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CoverageGrid(const S2CoverageGrid& from);
  S2CoverageGrid(S2CoverageGrid&& from) noexcept
    : S2CoverageGrid() {
    *this = ::std::move(from);
  }

  inline S2CoverageGrid& operator=(const S2CoverageGrid& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CoverageGrid& operator=(S2CoverageGrid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CoverageGrid& default_instance() {
    return *internal_default_instance();
  }
  enum RegionDescriptionCase {
    kRegion = 1,
    kRegionId = 3,
    REGION_DESCRIPTION_NOT_SET = 0,
  };

  static inline const S2CoverageGrid* internal_default_instance() {
    return reinterpret_cast<const S2CoverageGrid*>(
               &_S2CoverageGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S2CoverageGrid& a, S2CoverageGrid& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CoverageGrid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CoverageGrid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CoverageGrid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CoverageGrid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CoverageGrid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CoverageGrid& from) {
    S2CoverageGrid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CoverageGrid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid";
  }
  protected:
  explicit S2CoverageGrid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS2LevelFieldNumber = 2,
    kRegionFieldNumber = 1,
    kRegionIdFieldNumber = 3,
  };
  // optional uint32 s2_level = 2 [default = 6, json_name = "s2Level"];
  bool has_s2_level() const;
  void clear_s2_level() ;
  ::uint32_t s2_level() const;
  void set_s2_level(::uint32_t value);

  private:
  ::uint32_t _internal_s2_level() const;
  void _internal_set_s2_level(::uint32_t value);

  public:
  // .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
  bool has_region() const;
  private:
  bool _internal_has_region() const;

  public:
  void clear_region() ;
  const ::aalyria::spacetime::api::common::S2Cells& region() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::S2Cells* release_region();
  ::aalyria::spacetime::api::common::S2Cells* mutable_region();
  void set_allocated_region(::aalyria::spacetime::api::common::S2Cells* region);
  private:
  const ::aalyria::spacetime::api::common::S2Cells& _internal_region() const;
  ::aalyria::spacetime::api::common::S2Cells* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::aalyria::spacetime::api::common::S2Cells* region);
  ::aalyria::spacetime::api::common::S2Cells* unsafe_arena_release_region();
  // string region_id = 3 [json_name = "regionId"];
  bool has_region_id() const;
  void clear_region_id() ;
  const std::string& region_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region_id(Arg_&& arg, Args_... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* ptr);

  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(
      const std::string& value);
  std::string* _internal_mutable_region_id();

  public:
  void clear_region_description();
  RegionDescriptionCase region_description_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid)
 private:
  class _Internal;
  void set_has_region();
  void set_has_region_id();

  inline bool has_region_description() const;
  inline void clear_has_region_description();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t s2_level_;
    union RegionDescriptionUnion {
      constexpr RegionDescriptionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::S2Cells* region_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
    } region_description_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class PfdOverS2Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region) */ {
 public:
  inline PfdOverS2Region() : PfdOverS2Region(nullptr) {}
  ~PfdOverS2Region() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdOverS2Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdOverS2Region(const PfdOverS2Region& from);
  PfdOverS2Region(PfdOverS2Region&& from) noexcept
    : PfdOverS2Region() {
    *this = ::std::move(from);
  }

  inline PfdOverS2Region& operator=(const PfdOverS2Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdOverS2Region& operator=(PfdOverS2Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdOverS2Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdOverS2Region* internal_default_instance() {
    return reinterpret_cast<const PfdOverS2Region*>(
               &_PfdOverS2Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PfdOverS2Region& a, PfdOverS2Region& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdOverS2Region* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdOverS2Region* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdOverS2Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdOverS2Region>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdOverS2Region& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdOverS2Region& from) {
    PfdOverS2Region::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdOverS2Region* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region";
  }
  protected:
  explicit PfdOverS2Region(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kReceivedPowerFluxDensityDbWPerM2FieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
  bool has_region() const;
  void clear_region() ;
  const ::aalyria::spacetime::api::common::S2Cells& region() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::S2Cells* release_region();
  ::aalyria::spacetime::api::common::S2Cells* mutable_region();
  void set_allocated_region(::aalyria::spacetime::api::common::S2Cells* region);
  private:
  const ::aalyria::spacetime::api::common::S2Cells& _internal_region() const;
  ::aalyria::spacetime::api::common::S2Cells* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::aalyria::spacetime::api::common::S2Cells* region);
  ::aalyria::spacetime::api::common::S2Cells* unsafe_arena_release_region();
  // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  bool has_received_power_flux_density_db_w_per_m2() const;
  void clear_received_power_flux_density_db_w_per_m2() ;
  double received_power_flux_density_db_w_per_m2() const;
  void set_received_power_flux_density_db_w_per_m2(double value);

  private:
  double _internal_received_power_flux_density_db_w_per_m2() const;
  void _internal_set_received_power_flux_density_db_w_per_m2(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::S2Cells* region_;
    double received_power_flux_density_db_w_per_m2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class SurfacePfdRegions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions) */ {
 public:
  inline SurfacePfdRegions() : SurfacePfdRegions(nullptr) {}
  ~SurfacePfdRegions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfacePfdRegions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SurfacePfdRegions(const SurfacePfdRegions& from);
  SurfacePfdRegions(SurfacePfdRegions&& from) noexcept
    : SurfacePfdRegions() {
    *this = ::std::move(from);
  }

  inline SurfacePfdRegions& operator=(const SurfacePfdRegions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfacePfdRegions& operator=(SurfacePfdRegions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfacePfdRegions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfacePfdRegions* internal_default_instance() {
    return reinterpret_cast<const SurfacePfdRegions*>(
               &_SurfacePfdRegions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SurfacePfdRegions& a, SurfacePfdRegions& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfacePfdRegions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfacePfdRegions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfacePfdRegions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfacePfdRegions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SurfacePfdRegions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SurfacePfdRegions& from) {
    SurfacePfdRegions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfacePfdRegions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions";
  }
  protected:
  explicit SurfacePfdRegions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPfdRegionFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region pfd_region = 1 [json_name = "pfdRegion"];
  int pfd_region_size() const;
  private:
  int _internal_pfd_region_size() const;

  public:
  void clear_pfd_region() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* mutable_pfd_region(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >*
      mutable_pfd_region();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region& _internal_pfd_region(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* _internal_add_pfd_region();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region>& _internal_pfd_region() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region>* _internal_mutable_pfd_region();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region& pfd_region(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* add_pfd_region();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >&
      pfd_region() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region > pfd_region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class GeostationaryArc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc) */ {
 public:
  inline GeostationaryArc() : GeostationaryArc(nullptr) {}
  ~GeostationaryArc() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeostationaryArc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeostationaryArc(const GeostationaryArc& from);
  GeostationaryArc(GeostationaryArc&& from) noexcept
    : GeostationaryArc() {
    *this = ::std::move(from);
  }

  inline GeostationaryArc& operator=(const GeostationaryArc& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeostationaryArc& operator=(GeostationaryArc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeostationaryArc& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeostationaryArc* internal_default_instance() {
    return reinterpret_cast<const GeostationaryArc*>(
               &_GeostationaryArc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GeostationaryArc& a, GeostationaryArc& b) {
    a.Swap(&b);
  }
  inline void Swap(GeostationaryArc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeostationaryArc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeostationaryArc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeostationaryArc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeostationaryArc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeostationaryArc& from) {
    GeostationaryArc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeostationaryArc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc";
  }
  protected:
  explicit GeostationaryArc(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeBoundDegFieldNumber = 1,
    kResolutionDegFieldNumber = 2,
  };
  // optional double latitude_bound_deg = 1 [json_name = "latitudeBoundDeg"];
  bool has_latitude_bound_deg() const;
  void clear_latitude_bound_deg() ;
  double latitude_bound_deg() const;
  void set_latitude_bound_deg(double value);

  private:
  double _internal_latitude_bound_deg() const;
  void _internal_set_latitude_bound_deg(double value);

  public:
  // optional double resolution_deg = 2 [json_name = "resolutionDeg"];
  bool has_resolution_deg() const;
  void clear_resolution_deg() ;
  double resolution_deg() const;
  void set_resolution_deg(double value);

  private:
  double _internal_resolution_deg() const;
  void _internal_set_resolution_deg(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double latitude_bound_deg_;
    double resolution_deg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class PfdOverGeoArcCell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell) */ {
 public:
  inline PfdOverGeoArcCell() : PfdOverGeoArcCell(nullptr) {}
  ~PfdOverGeoArcCell() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdOverGeoArcCell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdOverGeoArcCell(const PfdOverGeoArcCell& from);
  PfdOverGeoArcCell(PfdOverGeoArcCell&& from) noexcept
    : PfdOverGeoArcCell() {
    *this = ::std::move(from);
  }

  inline PfdOverGeoArcCell& operator=(const PfdOverGeoArcCell& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdOverGeoArcCell& operator=(PfdOverGeoArcCell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdOverGeoArcCell& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdOverGeoArcCell* internal_default_instance() {
    return reinterpret_cast<const PfdOverGeoArcCell*>(
               &_PfdOverGeoArcCell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PfdOverGeoArcCell& a, PfdOverGeoArcCell& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdOverGeoArcCell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdOverGeoArcCell* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdOverGeoArcCell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdOverGeoArcCell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdOverGeoArcCell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdOverGeoArcCell& from) {
    PfdOverGeoArcCell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdOverGeoArcCell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell";
  }
  protected:
  explicit PfdOverGeoArcCell(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeDegFieldNumber = 1,
    kLatitudeDegFieldNumber = 2,
    kReceivedPowerFluxDensityDbWPerM2FieldNumber = 3,
  };
  // optional double longitude_deg = 1 [json_name = "longitudeDeg"];
  bool has_longitude_deg() const;
  void clear_longitude_deg() ;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);

  public:
  // optional double latitude_deg = 2 [json_name = "latitudeDeg"];
  bool has_latitude_deg() const;
  void clear_latitude_deg() ;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);

  public:
  // optional double received_power_flux_density_db_w_per_m2 = 3 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  bool has_received_power_flux_density_db_w_per_m2() const;
  void clear_received_power_flux_density_db_w_per_m2() ;
  double received_power_flux_density_db_w_per_m2() const;
  void set_received_power_flux_density_db_w_per_m2(double value);

  private:
  double _internal_received_power_flux_density_db_w_per_m2() const;
  void _internal_set_received_power_flux_density_db_w_per_m2(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double longitude_deg_;
    double latitude_deg_;
    double received_power_flux_density_db_w_per_m2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class GeostationaryArcPfd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd) */ {
 public:
  inline GeostationaryArcPfd() : GeostationaryArcPfd(nullptr) {}
  ~GeostationaryArcPfd() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeostationaryArcPfd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeostationaryArcPfd(const GeostationaryArcPfd& from);
  GeostationaryArcPfd(GeostationaryArcPfd&& from) noexcept
    : GeostationaryArcPfd() {
    *this = ::std::move(from);
  }

  inline GeostationaryArcPfd& operator=(const GeostationaryArcPfd& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeostationaryArcPfd& operator=(GeostationaryArcPfd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeostationaryArcPfd& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeostationaryArcPfd* internal_default_instance() {
    return reinterpret_cast<const GeostationaryArcPfd*>(
               &_GeostationaryArcPfd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GeostationaryArcPfd& a, GeostationaryArcPfd& b) {
    a.Swap(&b);
  }
  inline void Swap(GeostationaryArcPfd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeostationaryArcPfd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeostationaryArcPfd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeostationaryArcPfd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeostationaryArcPfd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeostationaryArcPfd& from) {
    GeostationaryArcPfd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeostationaryArcPfd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd";
  }
  protected:
  explicit GeostationaryArcPfd(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell cell = 1 [json_name = "cell"];
  int cell_size() const;
  private:
  int _internal_cell_size() const;

  public:
  void clear_cell() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* mutable_cell(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >*
      mutable_cell();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell& _internal_cell(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* _internal_add_cell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell>& _internal_cell() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell>* _internal_mutable_cell();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell& cell(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* add_cell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >&
      cell() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell > cell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class PfdAtAntenna final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna) */ {
 public:
  inline PfdAtAntenna() : PfdAtAntenna(nullptr) {}
  ~PfdAtAntenna() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdAtAntenna(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdAtAntenna(const PfdAtAntenna& from);
  PfdAtAntenna(PfdAtAntenna&& from) noexcept
    : PfdAtAntenna() {
    *this = ::std::move(from);
  }

  inline PfdAtAntenna& operator=(const PfdAtAntenna& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdAtAntenna& operator=(PfdAtAntenna&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdAtAntenna& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdAtAntenna* internal_default_instance() {
    return reinterpret_cast<const PfdAtAntenna*>(
               &_PfdAtAntenna_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PfdAtAntenna& a, PfdAtAntenna& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdAtAntenna* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdAtAntenna* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdAtAntenna* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdAtAntenna>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdAtAntenna& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdAtAntenna& from) {
    PfdAtAntenna::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdAtAntenna* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna";
  }
  protected:
  explicit PfdAtAntenna(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransceiverModelIdFieldNumber = 3,
    kReceivedPowerFluxDensityDbWPerM2FieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 3 [json_name = "transceiverModelId"];
  bool has_transceiver_model_id() const;
  void clear_transceiver_model_id() ;
  const ::aalyria::spacetime::api::common::TransceiverModelId& transceiver_model_id() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::TransceiverModelId* release_transceiver_model_id();
  ::aalyria::spacetime::api::common::TransceiverModelId* mutable_transceiver_model_id();
  void set_allocated_transceiver_model_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id);
  private:
  const ::aalyria::spacetime::api::common::TransceiverModelId& _internal_transceiver_model_id() const;
  ::aalyria::spacetime::api::common::TransceiverModelId* _internal_mutable_transceiver_model_id();
  public:
  void unsafe_arena_set_allocated_transceiver_model_id(
      ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id);
  ::aalyria::spacetime::api::common::TransceiverModelId* unsafe_arena_release_transceiver_model_id();
  // optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
  bool has_received_power_flux_density_db_w_per_m2() const;
  void clear_received_power_flux_density_db_w_per_m2() ;
  double received_power_flux_density_db_w_per_m2() const;
  void set_received_power_flux_density_db_w_per_m2(double value);

  private:
  double _internal_received_power_flux_density_db_w_per_m2() const;
  void _internal_set_received_power_flux_density_db_w_per_m2(double value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id_;
    double received_power_flux_density_db_w_per_m2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};// -------------------------------------------------------------------

class PfdOverConstellation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation) */ {
 public:
  inline PfdOverConstellation() : PfdOverConstellation(nullptr) {}
  ~PfdOverConstellation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PfdOverConstellation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PfdOverConstellation(const PfdOverConstellation& from);
  PfdOverConstellation(PfdOverConstellation&& from) noexcept
    : PfdOverConstellation() {
    *this = ::std::move(from);
  }

  inline PfdOverConstellation& operator=(const PfdOverConstellation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PfdOverConstellation& operator=(PfdOverConstellation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PfdOverConstellation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PfdOverConstellation* internal_default_instance() {
    return reinterpret_cast<const PfdOverConstellation*>(
               &_PfdOverConstellation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PfdOverConstellation& a, PfdOverConstellation& b) {
    a.Swap(&b);
  }
  inline void Swap(PfdOverConstellation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PfdOverConstellation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PfdOverConstellation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PfdOverConstellation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PfdOverConstellation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PfdOverConstellation& from) {
    PfdOverConstellation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PfdOverConstellation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation";
  }
  protected:
  explicit PfdOverConstellation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVictimFieldNumber = 1,
  };
  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna victim = 1 [json_name = "victim"];
  int victim_size() const;
  private:
  int _internal_victim_size() const;

  public:
  void clear_victim() ;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* mutable_victim(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >*
      mutable_victim();
  private:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna& _internal_victim(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* _internal_add_victim();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna>& _internal_victim() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna>* _internal_mutable_victim();
  public:
  const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna& victim(int index) const;
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* add_victim();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >&
      victim() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna > victim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TransceiverSet

// repeated .aalyria.spacetime.api.common.TransceiverModelId transceiver_ids = 1 [json_name = "transceiverIds"];
inline int TransceiverSet::_internal_transceiver_ids_size() const {
  return _impl_.transceiver_ids_.size();
}
inline int TransceiverSet::transceiver_ids_size() const {
  return _internal_transceiver_ids_size();
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverSet::mutable_transceiver_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet.transceiver_ids)
  return _internal_mutable_transceiver_ids()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransceiverModelId >*
TransceiverSet::mutable_transceiver_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet.transceiver_ids)
  return _internal_mutable_transceiver_ids();
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& TransceiverSet::_internal_transceiver_ids(int index) const {
  return _internal_transceiver_ids().Get(index);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& TransceiverSet::transceiver_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet.transceiver_ids)
  return _internal_transceiver_ids(index);
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverSet::_internal_add_transceiver_ids() {
  return _internal_mutable_transceiver_ids()->Add();
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* TransceiverSet::add_transceiver_ids() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _add = _internal_add_transceiver_ids();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet.transceiver_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::TransceiverModelId >&
TransceiverSet::transceiver_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet.transceiver_ids)
  return _internal_transceiver_ids();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransceiverModelId>&
TransceiverSet::_internal_transceiver_ids() const {
  return _impl_.transceiver_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::TransceiverModelId>*
TransceiverSet::_internal_mutable_transceiver_ids() {
  return &_impl_.transceiver_ids_;
}

// -------------------------------------------------------------------

// PlatformSet

// repeated string platform_ids = 1 [json_name = "platformIds"];
inline int PlatformSet::_internal_platform_ids_size() const {
  return _impl_.platform_ids_.size();
}
inline int PlatformSet::platform_ids_size() const {
  return _internal_platform_ids_size();
}
inline void PlatformSet::clear_platform_ids() {
  _internal_mutable_platform_ids()->Clear();
}
inline std::string* PlatformSet::add_platform_ids() {
  std::string* _s = _internal_add_platform_ids();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
  return _s;
}
inline const std::string& PlatformSet::platform_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
  return _internal_platform_ids(index);
}
inline std::string* PlatformSet::mutable_platform_ids(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
  return _internal_mutable_platform_ids()->Mutable(index);
}
inline void PlatformSet::set_platform_ids(int index, const std::string& value) {
  _internal_mutable_platform_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::set_platform_ids(int index, std::string&& value) {
  _internal_mutable_platform_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::set_platform_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_platform_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::set_platform_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_platform_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::set_platform_ids(int index, absl::string_view value) {
  _internal_mutable_platform_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::add_platform_ids(const std::string& value) {
  _internal_mutable_platform_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::add_platform_ids(std::string&& value) {
  _internal_mutable_platform_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::add_platform_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_platform_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::add_platform_ids(const char* value, std::size_t size) {
  _internal_mutable_platform_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline void PlatformSet::add_platform_ids(absl::string_view value) {
  _internal_mutable_platform_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PlatformSet::platform_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
  return _internal_platform_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PlatformSet::mutable_platform_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet.platform_ids)
  return _internal_mutable_platform_ids();
}
inline const std::string& PlatformSet::_internal_platform_ids(int index) const {
  return _internal_platform_ids().Get(index);
}
inline std::string* PlatformSet::_internal_add_platform_ids() {
  return _internal_mutable_platform_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PlatformSet::_internal_platform_ids() const {
  return _impl_.platform_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PlatformSet::_internal_mutable_platform_ids() {
  return &_impl_.platform_ids_;
}

// -------------------------------------------------------------------

// StationSet

// .aalyria.spacetime.api.nbi.v1alpha.resources.TransceiverSet transceivers = 1 [json_name = "transceivers"];
inline bool StationSet::has_transceivers() const {
  return station_set_type_case() == kTransceivers;
}
inline bool StationSet::_internal_has_transceivers() const {
  return station_set_type_case() == kTransceivers;
}
inline void StationSet::set_has_transceivers() {
  _impl_._oneof_case_[0] = kTransceivers;
}
inline void StationSet::clear_transceivers() {
  if (station_set_type_case() == kTransceivers) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.station_set_type_.transceivers_;
    }
    clear_has_station_set_type();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* StationSet::release_transceivers() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
  if (station_set_type_case() == kTransceivers) {
    clear_has_station_set_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* temp = _impl_.station_set_type_.transceivers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.station_set_type_.transceivers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet& StationSet::_internal_transceivers() const {
  return station_set_type_case() == kTransceivers
      ? *_impl_.station_set_type_.transceivers_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_TransceiverSet_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet& StationSet::transceivers() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
  return _internal_transceivers();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* StationSet::unsafe_arena_release_transceivers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
  if (station_set_type_case() == kTransceivers) {
    clear_has_station_set_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* temp = _impl_.station_set_type_.transceivers_;
    _impl_.station_set_type_.transceivers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StationSet::unsafe_arena_set_allocated_transceivers(::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* transceivers) {
  clear_station_set_type();
  if (transceivers) {
    set_has_transceivers();
    _impl_.station_set_type_.transceivers_ = transceivers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* StationSet::_internal_mutable_transceivers() {
  if (station_set_type_case() != kTransceivers) {
    clear_station_set_type();
    set_has_transceivers();
    _impl_.station_set_type_.transceivers_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet >(GetArenaForAllocation());
  }
  return _impl_.station_set_type_.transceivers_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* StationSet::mutable_transceivers() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::TransceiverSet* _msg = _internal_mutable_transceivers();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.transceivers)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PlatformSet platforms = 2 [json_name = "platforms"];
inline bool StationSet::has_platforms() const {
  return station_set_type_case() == kPlatforms;
}
inline bool StationSet::_internal_has_platforms() const {
  return station_set_type_case() == kPlatforms;
}
inline void StationSet::set_has_platforms() {
  _impl_._oneof_case_[0] = kPlatforms;
}
inline void StationSet::clear_platforms() {
  if (station_set_type_case() == kPlatforms) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.station_set_type_.platforms_;
    }
    clear_has_station_set_type();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* StationSet::release_platforms() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
  if (station_set_type_case() == kPlatforms) {
    clear_has_station_set_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* temp = _impl_.station_set_type_.platforms_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.station_set_type_.platforms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet& StationSet::_internal_platforms() const {
  return station_set_type_case() == kPlatforms
      ? *_impl_.station_set_type_.platforms_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PlatformSet_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet& StationSet::platforms() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
  return _internal_platforms();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* StationSet::unsafe_arena_release_platforms() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
  if (station_set_type_case() == kPlatforms) {
    clear_has_station_set_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* temp = _impl_.station_set_type_.platforms_;
    _impl_.station_set_type_.platforms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StationSet::unsafe_arena_set_allocated_platforms(::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* platforms) {
  clear_station_set_type();
  if (platforms) {
    set_has_platforms();
    _impl_.station_set_type_.platforms_ = platforms;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* StationSet::_internal_mutable_platforms() {
  if (station_set_type_case() != kPlatforms) {
    clear_station_set_type();
    set_has_platforms();
    _impl_.station_set_type_.platforms_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet >(GetArenaForAllocation());
  }
  return _impl_.station_set_type_.platforms_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* StationSet::mutable_platforms() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PlatformSet* _msg = _internal_mutable_platforms();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.StationSet.platforms)
  return _msg;
}

inline bool StationSet::has_station_set_type() const {
  return station_set_type_case() != STATION_SET_TYPE_NOT_SET;
}
inline void StationSet::clear_has_station_set_type() {
  _impl_._oneof_case_[0] = STATION_SET_TYPE_NOT_SET;
}
inline StationSet::StationSetTypeCase StationSet::station_set_type_case() const {
  return StationSet::StationSetTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StationSubset

// optional string station_set_id = 1 [json_name = "stationSetId"];
inline bool StationSubset::has_station_set_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StationSubset::clear_station_set_id() {
  _impl_.station_set_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StationSubset::station_set_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id)
  return _internal_station_set_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StationSubset::set_station_set_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.station_set_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id)
}
inline std::string* StationSubset::mutable_station_set_id() {
  std::string* _s = _internal_mutable_station_set_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id)
  return _s;
}
inline const std::string& StationSubset::_internal_station_set_id() const {
  return _impl_.station_set_id_.Get();
}
inline void StationSubset::_internal_set_station_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.station_set_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StationSubset::_internal_mutable_station_set_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.station_set_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StationSubset::release_station_set_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.station_set_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.station_set_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StationSubset::set_allocated_station_set_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.station_set_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.station_set_id_.IsDefault()) {
          _impl_.station_set_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.station_set_id)
}

// optional string region_id = 2 [json_name = "regionId"];
inline bool StationSubset::has_region_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StationSubset::clear_region_id() {
  _impl_.region_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StationSubset::region_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id)
  return _internal_region_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StationSubset::set_region_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.region_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id)
}
inline std::string* StationSubset::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id)
  return _s;
}
inline const std::string& StationSubset::_internal_region_id() const {
  return _impl_.region_id_.Get();
}
inline void StationSubset::_internal_set_region_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StationSubset::_internal_mutable_region_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.region_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StationSubset::release_region_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.region_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StationSubset::set_allocated_region_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.region_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.region_id_.IsDefault()) {
          _impl_.region_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset.region_id)
}

// -------------------------------------------------------------------

// CoordinateArray

// .aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid surface = 1 [json_name = "surface"];
inline bool CoordinateArray::has_surface() const {
  return derivation_case() == kSurface;
}
inline bool CoordinateArray::_internal_has_surface() const {
  return derivation_case() == kSurface;
}
inline void CoordinateArray::set_has_surface() {
  _impl_._oneof_case_[0] = kSurface;
}
inline void CoordinateArray::clear_surface() {
  if (derivation_case() == kSurface) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.derivation_.surface_;
    }
    clear_has_derivation();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* CoordinateArray::release_surface() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
  if (derivation_case() == kSurface) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* temp = _impl_.derivation_.surface_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.derivation_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid& CoordinateArray::_internal_surface() const {
  return derivation_case() == kSurface
      ? *_impl_.derivation_.surface_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_S2CoverageGrid_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid& CoordinateArray::surface() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
  return _internal_surface();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* CoordinateArray::unsafe_arena_release_surface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
  if (derivation_case() == kSurface) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* temp = _impl_.derivation_.surface_;
    _impl_.derivation_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoordinateArray::unsafe_arena_set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* surface) {
  clear_derivation();
  if (surface) {
    set_has_surface();
    _impl_.derivation_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* CoordinateArray::_internal_mutable_surface() {
  if (derivation_case() != kSurface) {
    clear_derivation();
    set_has_surface();
    _impl_.derivation_.surface_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid >(GetArenaForAllocation());
  }
  return _impl_.derivation_.surface_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* CoordinateArray::mutable_surface() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::S2CoverageGrid* _msg = _internal_mutable_surface();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.surface)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc geo_arc = 2 [json_name = "geoArc"];
inline bool CoordinateArray::has_geo_arc() const {
  return derivation_case() == kGeoArc;
}
inline bool CoordinateArray::_internal_has_geo_arc() const {
  return derivation_case() == kGeoArc;
}
inline void CoordinateArray::set_has_geo_arc() {
  _impl_._oneof_case_[0] = kGeoArc;
}
inline void CoordinateArray::clear_geo_arc() {
  if (derivation_case() == kGeoArc) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.derivation_.geo_arc_;
    }
    clear_has_derivation();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* CoordinateArray::release_geo_arc() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
  if (derivation_case() == kGeoArc) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* temp = _impl_.derivation_.geo_arc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.derivation_.geo_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc& CoordinateArray::_internal_geo_arc() const {
  return derivation_case() == kGeoArc
      ? *_impl_.derivation_.geo_arc_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_GeostationaryArc_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc& CoordinateArray::geo_arc() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
  return _internal_geo_arc();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* CoordinateArray::unsafe_arena_release_geo_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
  if (derivation_case() == kGeoArc) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* temp = _impl_.derivation_.geo_arc_;
    _impl_.derivation_.geo_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoordinateArray::unsafe_arena_set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* geo_arc) {
  clear_derivation();
  if (geo_arc) {
    set_has_geo_arc();
    _impl_.derivation_.geo_arc_ = geo_arc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* CoordinateArray::_internal_mutable_geo_arc() {
  if (derivation_case() != kGeoArc) {
    clear_derivation();
    set_has_geo_arc();
    _impl_.derivation_.geo_arc_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc >(GetArenaForAllocation());
  }
  return _impl_.derivation_.geo_arc_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* CoordinateArray::mutable_geo_arc() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArc* _msg = _internal_mutable_geo_arc();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.geo_arc)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.StationSubset stations = 3 [json_name = "stations"];
inline bool CoordinateArray::has_stations() const {
  return derivation_case() == kStations;
}
inline bool CoordinateArray::_internal_has_stations() const {
  return derivation_case() == kStations;
}
inline void CoordinateArray::set_has_stations() {
  _impl_._oneof_case_[0] = kStations;
}
inline void CoordinateArray::clear_stations() {
  if (derivation_case() == kStations) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.derivation_.stations_;
    }
    clear_has_derivation();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* CoordinateArray::release_stations() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
  if (derivation_case() == kStations) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* temp = _impl_.derivation_.stations_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.derivation_.stations_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& CoordinateArray::_internal_stations() const {
  return derivation_case() == kStations
      ? *_impl_.derivation_.stations_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_StationSubset_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset& CoordinateArray::stations() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
  return _internal_stations();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* CoordinateArray::unsafe_arena_release_stations() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
  if (derivation_case() == kStations) {
    clear_has_derivation();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* temp = _impl_.derivation_.stations_;
    _impl_.derivation_.stations_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoordinateArray::unsafe_arena_set_allocated_stations(::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* stations) {
  clear_derivation();
  if (stations) {
    set_has_stations();
    _impl_.derivation_.stations_ = stations;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* CoordinateArray::_internal_mutable_stations() {
  if (derivation_case() != kStations) {
    clear_derivation();
    set_has_stations();
    _impl_.derivation_.stations_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset >(GetArenaForAllocation());
  }
  return _impl_.derivation_.stations_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* CoordinateArray::mutable_stations() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::StationSubset* _msg = _internal_mutable_stations();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.CoordinateArray.stations)
  return _msg;
}

inline bool CoordinateArray::has_derivation() const {
  return derivation_case() != DERIVATION_NOT_SET;
}
inline void CoordinateArray::clear_has_derivation() {
  _impl_._oneof_case_[0] = DERIVATION_NOT_SET;
}
inline CoordinateArray::DerivationCase CoordinateArray::derivation_case() const {
  return CoordinateArray::DerivationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalPowerCoverage

// .aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions surface = 1 [json_name = "surface"];
inline bool SignalPowerCoverage::has_surface() const {
  return type_case() == kSurface;
}
inline bool SignalPowerCoverage::_internal_has_surface() const {
  return type_case() == kSurface;
}
inline void SignalPowerCoverage::set_has_surface() {
  _impl_._oneof_case_[0] = kSurface;
}
inline void SignalPowerCoverage::clear_surface() {
  if (type_case() == kSurface) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.surface_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* SignalPowerCoverage::release_surface() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
  if (type_case() == kSurface) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* temp = _impl_.type_.surface_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions& SignalPowerCoverage::_internal_surface() const {
  return type_case() == kSurface
      ? *_impl_.type_.surface_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_SurfacePfdRegions_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions& SignalPowerCoverage::surface() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
  return _internal_surface();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* SignalPowerCoverage::unsafe_arena_release_surface() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
  if (type_case() == kSurface) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* temp = _impl_.type_.surface_;
    _impl_.type_.surface_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalPowerCoverage::unsafe_arena_set_allocated_surface(::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* surface) {
  clear_type();
  if (surface) {
    set_has_surface();
    _impl_.type_.surface_ = surface;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* SignalPowerCoverage::_internal_mutable_surface() {
  if (type_case() != kSurface) {
    clear_type();
    set_has_surface();
    _impl_.type_.surface_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions >(GetArenaForAllocation());
  }
  return _impl_.type_.surface_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* SignalPowerCoverage::mutable_surface() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::SurfacePfdRegions* _msg = _internal_mutable_surface();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.surface)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd geo_arc = 2 [json_name = "geoArc"];
inline bool SignalPowerCoverage::has_geo_arc() const {
  return type_case() == kGeoArc;
}
inline bool SignalPowerCoverage::_internal_has_geo_arc() const {
  return type_case() == kGeoArc;
}
inline void SignalPowerCoverage::set_has_geo_arc() {
  _impl_._oneof_case_[0] = kGeoArc;
}
inline void SignalPowerCoverage::clear_geo_arc() {
  if (type_case() == kGeoArc) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.geo_arc_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* SignalPowerCoverage::release_geo_arc() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
  if (type_case() == kGeoArc) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* temp = _impl_.type_.geo_arc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.geo_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd& SignalPowerCoverage::_internal_geo_arc() const {
  return type_case() == kGeoArc
      ? *_impl_.type_.geo_arc_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_GeostationaryArcPfd_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd& SignalPowerCoverage::geo_arc() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
  return _internal_geo_arc();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* SignalPowerCoverage::unsafe_arena_release_geo_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
  if (type_case() == kGeoArc) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* temp = _impl_.type_.geo_arc_;
    _impl_.type_.geo_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalPowerCoverage::unsafe_arena_set_allocated_geo_arc(::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* geo_arc) {
  clear_type();
  if (geo_arc) {
    set_has_geo_arc();
    _impl_.type_.geo_arc_ = geo_arc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* SignalPowerCoverage::_internal_mutable_geo_arc() {
  if (type_case() != kGeoArc) {
    clear_type();
    set_has_geo_arc();
    _impl_.type_.geo_arc_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd >(GetArenaForAllocation());
  }
  return _impl_.type_.geo_arc_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* SignalPowerCoverage::mutable_geo_arc() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::GeostationaryArcPfd* _msg = _internal_mutable_geo_arc();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.geo_arc)
  return _msg;
}

// .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation constellation = 3 [json_name = "constellation"];
inline bool SignalPowerCoverage::has_constellation() const {
  return type_case() == kConstellation;
}
inline bool SignalPowerCoverage::_internal_has_constellation() const {
  return type_case() == kConstellation;
}
inline void SignalPowerCoverage::set_has_constellation() {
  _impl_._oneof_case_[0] = kConstellation;
}
inline void SignalPowerCoverage::clear_constellation() {
  if (type_case() == kConstellation) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.constellation_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* SignalPowerCoverage::release_constellation() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
  if (type_case() == kConstellation) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* temp = _impl_.type_.constellation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.constellation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation& SignalPowerCoverage::_internal_constellation() const {
  return type_case() == kConstellation
      ? *_impl_.type_.constellation_
      : reinterpret_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation&>(::aalyria::spacetime::api::nbi::v1alpha::resources::_PfdOverConstellation_default_instance_);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation& SignalPowerCoverage::constellation() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
  return _internal_constellation();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* SignalPowerCoverage::unsafe_arena_release_constellation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
  if (type_case() == kConstellation) {
    clear_has_type();
    ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* temp = _impl_.type_.constellation_;
    _impl_.type_.constellation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalPowerCoverage::unsafe_arena_set_allocated_constellation(::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* constellation) {
  clear_type();
  if (constellation) {
    set_has_constellation();
    _impl_.type_.constellation_ = constellation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* SignalPowerCoverage::_internal_mutable_constellation() {
  if (type_case() != kConstellation) {
    clear_type();
    set_has_constellation();
    _impl_.type_.constellation_ = CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation >(GetArenaForAllocation());
  }
  return _impl_.type_.constellation_;
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* SignalPowerCoverage::mutable_constellation() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverConstellation* _msg = _internal_mutable_constellation();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SignalPowerCoverage.constellation)
  return _msg;
}

inline bool SignalPowerCoverage::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void SignalPowerCoverage::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline SignalPowerCoverage::TypeCase SignalPowerCoverage::type_case() const {
  return SignalPowerCoverage::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoJsonRegion

// optional string name = 1 [json_name = "name"];
inline bool GeoJsonRegion::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeoJsonRegion::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GeoJsonRegion::name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GeoJsonRegion::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name)
}
inline std::string* GeoJsonRegion::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name)
  return _s;
}
inline const std::string& GeoJsonRegion::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GeoJsonRegion::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GeoJsonRegion::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* GeoJsonRegion::release_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GeoJsonRegion::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.name)
}

// repeated bytes encoded_geo_buffer = 2 [json_name = "encodedGeoBuffer"];
inline int GeoJsonRegion::_internal_encoded_geo_buffer_size() const {
  return _impl_.encoded_geo_buffer_.size();
}
inline int GeoJsonRegion::encoded_geo_buffer_size() const {
  return _internal_encoded_geo_buffer_size();
}
inline void GeoJsonRegion::clear_encoded_geo_buffer() {
  _internal_mutable_encoded_geo_buffer()->Clear();
}
inline std::string* GeoJsonRegion::add_encoded_geo_buffer() {
  std::string* _s = _internal_add_encoded_geo_buffer();
  // @@protoc_insertion_point(field_add_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
  return _s;
}
inline const std::string& GeoJsonRegion::encoded_geo_buffer(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
  return _internal_encoded_geo_buffer(index);
}
inline std::string* GeoJsonRegion::mutable_encoded_geo_buffer(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
  return _internal_mutable_encoded_geo_buffer()->Mutable(index);
}
inline void GeoJsonRegion::set_encoded_geo_buffer(int index, const std::string& value) {
  _internal_mutable_encoded_geo_buffer()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::set_encoded_geo_buffer(int index, std::string&& value) {
  _internal_mutable_encoded_geo_buffer()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::set_encoded_geo_buffer(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_encoded_geo_buffer()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::set_encoded_geo_buffer(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_encoded_geo_buffer()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::set_encoded_geo_buffer(int index, absl::string_view value) {
  _internal_mutable_encoded_geo_buffer()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::add_encoded_geo_buffer(const std::string& value) {
  _internal_mutable_encoded_geo_buffer()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::add_encoded_geo_buffer(std::string&& value) {
  _internal_mutable_encoded_geo_buffer()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::add_encoded_geo_buffer(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_encoded_geo_buffer()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::add_encoded_geo_buffer(const void* value, std::size_t size) {
  _internal_mutable_encoded_geo_buffer()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline void GeoJsonRegion::add_encoded_geo_buffer(absl::string_view value) {
  _internal_mutable_encoded_geo_buffer()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GeoJsonRegion::encoded_geo_buffer() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
  return _internal_encoded_geo_buffer();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* GeoJsonRegion::mutable_encoded_geo_buffer() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.GeoJsonRegion.encoded_geo_buffer)
  return _internal_mutable_encoded_geo_buffer();
}
inline const std::string& GeoJsonRegion::_internal_encoded_geo_buffer(int index) const {
  return _internal_encoded_geo_buffer().Get(index);
}
inline std::string* GeoJsonRegion::_internal_add_encoded_geo_buffer() {
  return _internal_mutable_encoded_geo_buffer()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GeoJsonRegion::_internal_encoded_geo_buffer() const {
  return _impl_.encoded_geo_buffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GeoJsonRegion::_internal_mutable_encoded_geo_buffer() {
  return &_impl_.encoded_geo_buffer_;
}

// -------------------------------------------------------------------

// SurfaceRegion

// repeated int64 s2_cell_ids = 1 [json_name = "s2CellIds"];
inline int SurfaceRegion::_internal_s2_cell_ids_size() const {
  return _impl_.s2_cell_ids_.size();
}
inline int SurfaceRegion::s2_cell_ids_size() const {
  return _internal_s2_cell_ids_size();
}
inline void SurfaceRegion::clear_s2_cell_ids() {
  _internal_mutable_s2_cell_ids()->Clear();
}
inline ::int64_t SurfaceRegion::s2_cell_ids(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.s2_cell_ids)
  return _internal_s2_cell_ids(index);
}
inline void SurfaceRegion::set_s2_cell_ids(int index, ::int64_t value) {
  _internal_mutable_s2_cell_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.s2_cell_ids)
}
inline void SurfaceRegion::add_s2_cell_ids(::int64_t value) {
  _internal_add_s2_cell_ids(value);
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.s2_cell_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& SurfaceRegion::s2_cell_ids() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.s2_cell_ids)
  return _internal_s2_cell_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* SurfaceRegion::mutable_s2_cell_ids() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.s2_cell_ids)
  return _internal_mutable_s2_cell_ids();
}

inline ::int64_t SurfaceRegion::_internal_s2_cell_ids(int index) const {
  return _internal_s2_cell_ids().Get(index);
}
inline void SurfaceRegion::_internal_add_s2_cell_ids(::int64_t value) {
  _internal_mutable_s2_cell_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& SurfaceRegion::_internal_s2_cell_ids() const {
  return _impl_.s2_cell_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* SurfaceRegion::_internal_mutable_s2_cell_ids() {
  return &_impl_.s2_cell_ids_;
}

// optional string name = 2 [json_name = "name"];
inline bool SurfaceRegion::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SurfaceRegion::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SurfaceRegion::name() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SurfaceRegion::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name)
}
inline std::string* SurfaceRegion::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name)
  return _s;
}
inline const std::string& SurfaceRegion::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SurfaceRegion::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SurfaceRegion::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* SurfaceRegion::release_name() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SurfaceRegion::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.SurfaceRegion.name)
}

// -------------------------------------------------------------------

// S2CoverageGrid

// .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
inline bool S2CoverageGrid::has_region() const {
  return region_description_case() == kRegion;
}
inline bool S2CoverageGrid::_internal_has_region() const {
  return region_description_case() == kRegion;
}
inline void S2CoverageGrid::set_has_region() {
  _impl_._oneof_case_[0] = kRegion;
}
inline ::aalyria::spacetime::api::common::S2Cells* S2CoverageGrid::release_region() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
  if (region_description_case() == kRegion) {
    clear_has_region_description();
    ::aalyria::spacetime::api::common::S2Cells* temp = _impl_.region_description_.region_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.region_description_.region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::S2Cells& S2CoverageGrid::_internal_region() const {
  return region_description_case() == kRegion
      ? *_impl_.region_description_.region_
      : reinterpret_cast<::aalyria::spacetime::api::common::S2Cells&>(::aalyria::spacetime::api::common::_S2Cells_default_instance_);
}
inline const ::aalyria::spacetime::api::common::S2Cells& S2CoverageGrid::region() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
  return _internal_region();
}
inline ::aalyria::spacetime::api::common::S2Cells* S2CoverageGrid::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
  if (region_description_case() == kRegion) {
    clear_has_region_description();
    ::aalyria::spacetime::api::common::S2Cells* temp = _impl_.region_description_.region_;
    _impl_.region_description_.region_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void S2CoverageGrid::unsafe_arena_set_allocated_region(::aalyria::spacetime::api::common::S2Cells* region) {
  clear_region_description();
  if (region) {
    set_has_region();
    _impl_.region_description_.region_ = region;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
}
inline ::aalyria::spacetime::api::common::S2Cells* S2CoverageGrid::_internal_mutable_region() {
  if (region_description_case() != kRegion) {
    clear_region_description();
    set_has_region();
    _impl_.region_description_.region_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::S2Cells >(GetArenaForAllocation());
  }
  return _impl_.region_description_.region_;
}
inline ::aalyria::spacetime::api::common::S2Cells* S2CoverageGrid::mutable_region() {
  ::aalyria::spacetime::api::common::S2Cells* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region)
  return _msg;
}

// string region_id = 3 [json_name = "regionId"];
inline bool S2CoverageGrid::has_region_id() const {
  return region_description_case() == kRegionId;
}
inline void S2CoverageGrid::set_has_region_id() {
  _impl_._oneof_case_[0] = kRegionId;
}
inline void S2CoverageGrid::clear_region_id() {
  if (region_description_case() == kRegionId) {
    _impl_.region_description_.region_id_.Destroy();
    clear_has_region_description();
  }
}
inline const std::string& S2CoverageGrid::region_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id)
  return _internal_region_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void S2CoverageGrid::set_region_id(Arg_&& arg,
                                                     Args_... args) {
  if (region_description_case() != kRegionId) {
    clear_region_description();

    set_has_region_id();
    _impl_.region_description_.region_id_.InitDefault();
  }
  _impl_.region_description_.region_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id)
}
inline std::string* S2CoverageGrid::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id)
  return _s;
}
inline const std::string& S2CoverageGrid::_internal_region_id() const {
  if (region_description_case() != kRegionId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.region_description_.region_id_.Get();
}
inline void S2CoverageGrid::_internal_set_region_id(const std::string& value) {
  if (region_description_case() != kRegionId) {
    clear_region_description();

    set_has_region_id();
    _impl_.region_description_.region_id_.InitDefault();
  }


  _impl_.region_description_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* S2CoverageGrid::_internal_mutable_region_id() {
  if (region_description_case() != kRegionId) {
    clear_region_description();

    set_has_region_id();
    _impl_.region_description_.region_id_.InitDefault();
  }
  return _impl_.region_description_.region_id_.Mutable( GetArenaForAllocation());
}
inline std::string* S2CoverageGrid::release_region_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id)
  if (region_description_case() != kRegionId) {
    return nullptr;
  }
  clear_has_region_description();
  return _impl_.region_description_.region_id_.Release();
}
inline void S2CoverageGrid::set_allocated_region_id(std::string* value) {
  if (has_region_description()) {
    clear_region_description();
  }
  if (value != nullptr) {
    set_has_region_id();
    _impl_.region_description_.region_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.region_id)
}

// optional uint32 s2_level = 2 [default = 6, json_name = "s2Level"];
inline bool S2CoverageGrid::has_s2_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void S2CoverageGrid::clear_s2_level() {
  _impl_.s2_level_ = 6u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t S2CoverageGrid::s2_level() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.s2_level)
  return _internal_s2_level();
}
inline void S2CoverageGrid::set_s2_level(::uint32_t value) {
  _internal_set_s2_level(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.S2CoverageGrid.s2_level)
}
inline ::uint32_t S2CoverageGrid::_internal_s2_level() const {
  return _impl_.s2_level_;
}
inline void S2CoverageGrid::_internal_set_s2_level(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s2_level_ = value;
}

inline bool S2CoverageGrid::has_region_description() const {
  return region_description_case() != REGION_DESCRIPTION_NOT_SET;
}
inline void S2CoverageGrid::clear_has_region_description() {
  _impl_._oneof_case_[0] = REGION_DESCRIPTION_NOT_SET;
}
inline S2CoverageGrid::RegionDescriptionCase S2CoverageGrid::region_description_case() const {
  return S2CoverageGrid::RegionDescriptionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PfdOverS2Region

// optional .aalyria.spacetime.api.common.S2Cells region = 1 [json_name = "region"];
inline bool PfdOverS2Region::has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.region_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::S2Cells& PfdOverS2Region::_internal_region() const {
  const ::aalyria::spacetime::api::common::S2Cells* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::S2Cells&>(
      ::aalyria::spacetime::api::common::_S2Cells_default_instance_);
}
inline const ::aalyria::spacetime::api::common::S2Cells& PfdOverS2Region::region() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.region)
  return _internal_region();
}
inline void PfdOverS2Region::unsafe_arena_set_allocated_region(
    ::aalyria::spacetime::api::common::S2Cells* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = region;
  if (region) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.region)
}
inline ::aalyria::spacetime::api::common::S2Cells* PfdOverS2Region::release_region() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::S2Cells* temp = _impl_.region_;
  _impl_.region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::S2Cells* PfdOverS2Region::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.region)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::S2Cells* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::S2Cells* PfdOverS2Region::_internal_mutable_region() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.region_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::S2Cells>(GetArenaForAllocation());
    _impl_.region_ = p;
  }
  return _impl_.region_;
}
inline ::aalyria::spacetime::api::common::S2Cells* PfdOverS2Region::mutable_region() {
  ::aalyria::spacetime::api::common::S2Cells* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.region)
  return _msg;
}
inline void PfdOverS2Region::set_allocated_region(::aalyria::spacetime::api::common::S2Cells* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region));
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.region_ = region;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.region)
}

// optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
inline bool PfdOverS2Region::has_received_power_flux_density_db_w_per_m2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PfdOverS2Region::clear_received_power_flux_density_db_w_per_m2() {
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PfdOverS2Region::received_power_flux_density_db_w_per_m2() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.received_power_flux_density_db_w_per_m2)
  return _internal_received_power_flux_density_db_w_per_m2();
}
inline void PfdOverS2Region::set_received_power_flux_density_db_w_per_m2(double value) {
  _internal_set_received_power_flux_density_db_w_per_m2(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region.received_power_flux_density_db_w_per_m2)
}
inline double PfdOverS2Region::_internal_received_power_flux_density_db_w_per_m2() const {
  return _impl_.received_power_flux_density_db_w_per_m2_;
}
inline void PfdOverS2Region::_internal_set_received_power_flux_density_db_w_per_m2(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.received_power_flux_density_db_w_per_m2_ = value;
}

// -------------------------------------------------------------------

// SurfacePfdRegions

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverS2Region pfd_region = 1 [json_name = "pfdRegion"];
inline int SurfacePfdRegions::_internal_pfd_region_size() const {
  return _impl_.pfd_region_.size();
}
inline int SurfacePfdRegions::pfd_region_size() const {
  return _internal_pfd_region_size();
}
inline void SurfacePfdRegions::clear_pfd_region() {
  _internal_mutable_pfd_region()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* SurfacePfdRegions::mutable_pfd_region(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions.pfd_region)
  return _internal_mutable_pfd_region()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >*
SurfacePfdRegions::mutable_pfd_region() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions.pfd_region)
  return _internal_mutable_pfd_region();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region& SurfacePfdRegions::_internal_pfd_region(int index) const {
  return _internal_pfd_region().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region& SurfacePfdRegions::pfd_region(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions.pfd_region)
  return _internal_pfd_region(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* SurfacePfdRegions::_internal_add_pfd_region() {
  return _internal_mutable_pfd_region()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* SurfacePfdRegions::add_pfd_region() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region* _add = _internal_add_pfd_region();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions.pfd_region)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region >&
SurfacePfdRegions::pfd_region() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.SurfacePfdRegions.pfd_region)
  return _internal_pfd_region();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region>&
SurfacePfdRegions::_internal_pfd_region() const {
  return _impl_.pfd_region_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverS2Region>*
SurfacePfdRegions::_internal_mutable_pfd_region() {
  return &_impl_.pfd_region_;
}

// -------------------------------------------------------------------

// GeostationaryArc

// optional double latitude_bound_deg = 1 [json_name = "latitudeBoundDeg"];
inline bool GeostationaryArc::has_latitude_bound_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeostationaryArc::clear_latitude_bound_deg() {
  _impl_.latitude_bound_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double GeostationaryArc::latitude_bound_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc.latitude_bound_deg)
  return _internal_latitude_bound_deg();
}
inline void GeostationaryArc::set_latitude_bound_deg(double value) {
  _internal_set_latitude_bound_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc.latitude_bound_deg)
}
inline double GeostationaryArc::_internal_latitude_bound_deg() const {
  return _impl_.latitude_bound_deg_;
}
inline void GeostationaryArc::_internal_set_latitude_bound_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latitude_bound_deg_ = value;
}

// optional double resolution_deg = 2 [json_name = "resolutionDeg"];
inline bool GeostationaryArc::has_resolution_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GeostationaryArc::clear_resolution_deg() {
  _impl_.resolution_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double GeostationaryArc::resolution_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc.resolution_deg)
  return _internal_resolution_deg();
}
inline void GeostationaryArc::set_resolution_deg(double value) {
  _internal_set_resolution_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArc.resolution_deg)
}
inline double GeostationaryArc::_internal_resolution_deg() const {
  return _impl_.resolution_deg_;
}
inline void GeostationaryArc::_internal_set_resolution_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resolution_deg_ = value;
}

// -------------------------------------------------------------------

// PfdOverGeoArcCell

// optional double longitude_deg = 1 [json_name = "longitudeDeg"];
inline bool PfdOverGeoArcCell::has_longitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PfdOverGeoArcCell::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double PfdOverGeoArcCell::longitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.longitude_deg)
  return _internal_longitude_deg();
}
inline void PfdOverGeoArcCell::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.longitude_deg)
}
inline double PfdOverGeoArcCell::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline void PfdOverGeoArcCell::_internal_set_longitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.longitude_deg_ = value;
}

// optional double latitude_deg = 2 [json_name = "latitudeDeg"];
inline bool PfdOverGeoArcCell::has_latitude_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PfdOverGeoArcCell::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PfdOverGeoArcCell::latitude_deg() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.latitude_deg)
  return _internal_latitude_deg();
}
inline void PfdOverGeoArcCell::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.latitude_deg)
}
inline double PfdOverGeoArcCell::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline void PfdOverGeoArcCell::_internal_set_latitude_deg(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.latitude_deg_ = value;
}

// optional double received_power_flux_density_db_w_per_m2 = 3 [json_name = "receivedPowerFluxDensityDbWPerM2"];
inline bool PfdOverGeoArcCell::has_received_power_flux_density_db_w_per_m2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PfdOverGeoArcCell::clear_received_power_flux_density_db_w_per_m2() {
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double PfdOverGeoArcCell::received_power_flux_density_db_w_per_m2() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.received_power_flux_density_db_w_per_m2)
  return _internal_received_power_flux_density_db_w_per_m2();
}
inline void PfdOverGeoArcCell::set_received_power_flux_density_db_w_per_m2(double value) {
  _internal_set_received_power_flux_density_db_w_per_m2(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell.received_power_flux_density_db_w_per_m2)
}
inline double PfdOverGeoArcCell::_internal_received_power_flux_density_db_w_per_m2() const {
  return _impl_.received_power_flux_density_db_w_per_m2_;
}
inline void PfdOverGeoArcCell::_internal_set_received_power_flux_density_db_w_per_m2(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.received_power_flux_density_db_w_per_m2_ = value;
}

// -------------------------------------------------------------------

// GeostationaryArcPfd

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverGeoArcCell cell = 1 [json_name = "cell"];
inline int GeostationaryArcPfd::_internal_cell_size() const {
  return _impl_.cell_.size();
}
inline int GeostationaryArcPfd::cell_size() const {
  return _internal_cell_size();
}
inline void GeostationaryArcPfd::clear_cell() {
  _internal_mutable_cell()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* GeostationaryArcPfd::mutable_cell(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd.cell)
  return _internal_mutable_cell()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >*
GeostationaryArcPfd::mutable_cell() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd.cell)
  return _internal_mutable_cell();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell& GeostationaryArcPfd::_internal_cell(int index) const {
  return _internal_cell().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell& GeostationaryArcPfd::cell(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd.cell)
  return _internal_cell(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* GeostationaryArcPfd::_internal_add_cell() {
  return _internal_mutable_cell()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* GeostationaryArcPfd::add_cell() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell* _add = _internal_add_cell();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd.cell)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell >&
GeostationaryArcPfd::cell() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.GeostationaryArcPfd.cell)
  return _internal_cell();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell>&
GeostationaryArcPfd::_internal_cell() const {
  return _impl_.cell_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdOverGeoArcCell>*
GeostationaryArcPfd::_internal_mutable_cell() {
  return &_impl_.cell_;
}

// -------------------------------------------------------------------

// PfdAtAntenna

// optional .aalyria.spacetime.api.common.TransceiverModelId transceiver_model_id = 3 [json_name = "transceiverModelId"];
inline bool PfdAtAntenna::has_transceiver_model_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transceiver_model_id_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& PfdAtAntenna::_internal_transceiver_model_id() const {
  const ::aalyria::spacetime::api::common::TransceiverModelId* p = _impl_.transceiver_model_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::TransceiverModelId&>(
      ::aalyria::spacetime::api::common::_TransceiverModelId_default_instance_);
}
inline const ::aalyria::spacetime::api::common::TransceiverModelId& PfdAtAntenna::transceiver_model_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.transceiver_model_id)
  return _internal_transceiver_model_id();
}
inline void PfdAtAntenna::unsafe_arena_set_allocated_transceiver_model_id(
    ::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transceiver_model_id_);
  }
  _impl_.transceiver_model_id_ = transceiver_model_id;
  if (transceiver_model_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.transceiver_model_id)
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* PfdAtAntenna::release_transceiver_model_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.transceiver_model_id_;
  _impl_.transceiver_model_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* PfdAtAntenna::unsafe_arena_release_transceiver_model_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.transceiver_model_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::TransceiverModelId* temp = _impl_.transceiver_model_id_;
  _impl_.transceiver_model_id_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* PfdAtAntenna::_internal_mutable_transceiver_model_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transceiver_model_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::TransceiverModelId>(GetArenaForAllocation());
    _impl_.transceiver_model_id_ = p;
  }
  return _impl_.transceiver_model_id_;
}
inline ::aalyria::spacetime::api::common::TransceiverModelId* PfdAtAntenna::mutable_transceiver_model_id() {
  ::aalyria::spacetime::api::common::TransceiverModelId* _msg = _internal_mutable_transceiver_model_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.transceiver_model_id)
  return _msg;
}
inline void PfdAtAntenna::set_allocated_transceiver_model_id(::aalyria::spacetime::api::common::TransceiverModelId* transceiver_model_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transceiver_model_id_);
  }
  if (transceiver_model_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transceiver_model_id));
    if (message_arena != submessage_arena) {
      transceiver_model_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transceiver_model_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transceiver_model_id_ = transceiver_model_id;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.transceiver_model_id)
}

// optional double received_power_flux_density_db_w_per_m2 = 2 [json_name = "receivedPowerFluxDensityDbWPerM2"];
inline bool PfdAtAntenna::has_received_power_flux_density_db_w_per_m2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PfdAtAntenna::clear_received_power_flux_density_db_w_per_m2() {
  _impl_.received_power_flux_density_db_w_per_m2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double PfdAtAntenna::received_power_flux_density_db_w_per_m2() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.received_power_flux_density_db_w_per_m2)
  return _internal_received_power_flux_density_db_w_per_m2();
}
inline void PfdAtAntenna::set_received_power_flux_density_db_w_per_m2(double value) {
  _internal_set_received_power_flux_density_db_w_per_m2(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna.received_power_flux_density_db_w_per_m2)
}
inline double PfdAtAntenna::_internal_received_power_flux_density_db_w_per_m2() const {
  return _impl_.received_power_flux_density_db_w_per_m2_;
}
inline void PfdAtAntenna::_internal_set_received_power_flux_density_db_w_per_m2(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.received_power_flux_density_db_w_per_m2_ = value;
}

// -------------------------------------------------------------------

// PfdOverConstellation

// repeated .aalyria.spacetime.api.nbi.v1alpha.resources.PfdAtAntenna victim = 1 [json_name = "victim"];
inline int PfdOverConstellation::_internal_victim_size() const {
  return _impl_.victim_.size();
}
inline int PfdOverConstellation::victim_size() const {
  return _internal_victim_size();
}
inline void PfdOverConstellation::clear_victim() {
  _internal_mutable_victim()->Clear();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* PfdOverConstellation::mutable_victim(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation.victim)
  return _internal_mutable_victim()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >*
PfdOverConstellation::mutable_victim() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation.victim)
  return _internal_mutable_victim();
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna& PfdOverConstellation::_internal_victim(int index) const {
  return _internal_victim().Get(index);
}
inline const ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna& PfdOverConstellation::victim(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation.victim)
  return _internal_victim(index);
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* PfdOverConstellation::_internal_add_victim() {
  return _internal_mutable_victim()->Add();
}
inline ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* PfdOverConstellation::add_victim() {
  ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna* _add = _internal_add_victim();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation.victim)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna >&
PfdOverConstellation::victim() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.nbi.v1alpha.resources.PfdOverConstellation.victim)
  return _internal_victim();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna>&
PfdOverConstellation::_internal_victim() const {
  return _impl_.victim_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::nbi::v1alpha::resources::PfdAtAntenna>*
PfdOverConstellation::_internal_mutable_victim() {
  return &_impl_.victim_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fnbi_2fv1alpha_2fresources_2fcoverage_2eproto_2epb_2eh
