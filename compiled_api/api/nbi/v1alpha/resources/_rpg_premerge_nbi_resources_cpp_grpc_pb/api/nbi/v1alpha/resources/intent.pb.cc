// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/intent.proto

#include "api/nbi/v1alpha/resources/intent.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
template <typename>
PROTOBUF_CONSTEXPR Intent_ServiceRequestAndIntervals::Intent_ServiceRequestAndIntervals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interval_)*/{}
  , /*decltype(_impl_.service_request_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct Intent_ServiceRequestAndIntervalsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Intent_ServiceRequestAndIntervalsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Intent_ServiceRequestAndIntervalsDefaultTypeInternal() {}
  union {
    Intent_ServiceRequestAndIntervals _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Intent_ServiceRequestAndIntervalsDefaultTypeInternal _Intent_ServiceRequestAndIntervals_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Intent::Intent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.compiled_updates_)*/{}
  , /*decltype(_impl_.dependent_service_requests_)*/{}
  , /*decltype(_impl_.compiled_withdrawal_updates_)*/{}
  , /*decltype(_impl_.app_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.time_to_enact_)*/nullptr
  , /*decltype(_impl_.failure_)*/nullptr
  , /*decltype(_impl_.withdrawal_)*/nullptr
  , /*decltype(_impl_.time_to_withdraw_)*/nullptr
  , /*decltype(_impl_.request_timestamp_us_)*/ ::int64_t{0}

  , /*decltype(_impl_.auto_retry_)*/ false

  , /*decltype(_impl_.state_)*/ 1

  , /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct IntentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntentDefaultTypeInternal() {}
  union {
    Intent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntentDefaultTypeInternal _Intent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LinkIntent::LinkIntent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.link_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LinkIntentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinkIntentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinkIntentDefaultTypeInternal() {}
  union {
    LinkIntent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinkIntentDefaultTypeInternal _LinkIntent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RadioIntent::RadioIntent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.configurations_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RadioIntentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadioIntentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadioIntentDefaultTypeInternal() {}
  union {
    RadioIntent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadioIntentDefaultTypeInternal _RadioIntent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PathIntent::PathIntent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_segments_)*/{}
  , /*decltype(_impl_.src_element_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_element_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.classifier_)*/nullptr} {}
struct PathIntentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathIntentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathIntentDefaultTypeInternal() {}
  union {
    PathIntent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathIntentDefaultTypeInternal _PathIntent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TunnelIntent_TunnelEndpoint::TunnelIntent_TunnelEndpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.encapsulated_src_interface_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.classifier_)*/nullptr
  , /*decltype(_impl_.encapsulated_src_port_)*/ 0
} {}
struct TunnelIntent_TunnelEndpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TunnelIntent_TunnelEndpointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TunnelIntent_TunnelEndpointDefaultTypeInternal() {}
  union {
    TunnelIntent_TunnelEndpoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TunnelIntent_TunnelEndpointDefaultTypeInternal _TunnelIntent_TunnelEndpoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TunnelIntent::TunnelIntent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.method_)*/nullptr
  , /*decltype(_impl_.a_)*/nullptr
  , /*decltype(_impl_.b_)*/nullptr} {}
struct TunnelIntentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TunnelIntentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TunnelIntentDefaultTypeInternal() {}
  union {
    TunnelIntent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TunnelIntentDefaultTypeInternal _TunnelIntent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IntentFailure::IntentFailure(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.agent_ids_)*/{}
  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.precondition_failure_)*/nullptr
  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.agent_failure_code_)*/ 0
} {}
struct IntentFailureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntentFailureDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntentFailureDefaultTypeInternal() {}
  union {
    IntentFailure _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntentFailureDefaultTypeInternal _IntentFailure_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR IntentWithdrawal::IntentWithdrawal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.type_)*/ 0
} {}
struct IntentWithdrawalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntentWithdrawalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntentWithdrawalDefaultTypeInternal() {}
  union {
    IntentWithdrawal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntentWithdrawalDefaultTypeInternal _IntentWithdrawal_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals, _impl_.service_request_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals, _impl_.interval_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.app_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.time_to_enact_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.request_timestamp_us_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.compiled_updates_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.failure_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.withdrawal_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.time_to_withdraw_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.dependent_service_requests_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.compiled_withdrawal_updates_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.auto_retry_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_.value_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    7,
    5,
    ~0u,
    2,
    3,
    4,
    ~0u,
    ~0u,
    6,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent, _impl_.link_type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent, _impl_.configurations_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _impl_.src_element_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _impl_.dst_element_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _impl_.classifier_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent, _impl_.path_segments_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _impl_.classifier_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _impl_.encapsulated_src_interface_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint, _impl_.encapsulated_src_port_),
    0,
    2,
    1,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent, _impl_.a_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent, _impl_.b_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent, _impl_.method_),
    1,
    2,
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_.precondition_failure_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_.agent_ids_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure, _impl_.agent_failure_code_),
    2,
    1,
    0,
    ~0u,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal, _impl_.description_),
    1,
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals)},
        { 12, 36, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent)},
        { 51, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent)},
        { 62, -1, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent)},
        { 71, 83, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent)},
        { 87, 99, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint)},
        { 103, 114, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent)},
        { 117, 130, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure)},
        { 135, 145, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_Intent_ServiceRequestAndIntervals_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_Intent_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_LinkIntent_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_RadioIntent_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_PathIntent_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelIntent_TunnelEndpoint_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelIntent_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_IntentFailure_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_IntentWithdrawal_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n&api/nbi/v1alpha/resources/intent.proto"
    "\022+aalyria.spacetime.api.nbi.v1alpha.reso"
    "urces\032\030api/common/control.proto\032\030api/com"
    "mon/network.proto\032\025api/common/time.proto"
    "\032\027api/common/tunnel.proto\032,api/nbi/v1alp"
    "ha/resources/network_link.proto\032\037google/"
    "protobuf/timestamp.proto\032\025google/rpc/cod"
    "e.proto\032\032google/type/interval.proto\"\335\n\n\006"
    "Intent\022\031\n\006app_id\030\001 \001(\tB\002\030\001R\005appId\022>\n\rtim"
    "e_to_enact\030\003 \001(\0132\032.google.protobuf.Times"
    "tampR\013timeToEnact\022M\n\004link\030\004 \001(\01327.aalyri"
    "a.spacetime.api.nbi.v1alpha.resources.Li"
    "nkIntentH\000R\004link\022P\n\005radio\030\005 \001(\01328.aalyri"
    "a.spacetime.api.nbi.v1alpha.resources.Ra"
    "dioIntentH\000R\005radio\022O\n\005route\030\006 \001(\01327.aaly"
    "ria.spacetime.api.nbi.v1alpha.resources."
    "PathIntentH\000R\005route\022S\n\006tunnel\030\n \001(\01329.aa"
    "lyria.spacetime.api.nbi.v1alpha.resource"
    "s.TunnelIntentH\000R\006tunnel\022[\n\005state\030\007 \001(\0162"
    "8.aalyria.spacetime.api.nbi.v1alpha.reso"
    "urces.IntentState:\013INSTALL_REQR\005state\0220\n"
    "\024request_timestamp_us\030\013 \001(\003R\022requestTime"
    "stampUs\022_\n\020compiled_updates\030\010 \003(\01324.aaly"
    "ria.spacetime.api.common.ScheduledContro"
    "lUpdateR\017compiledUpdates\022T\n\007failure\030\t \001("
    "\0132:.aalyria.spacetime.api.nbi.v1alpha.re"
    "sources.IntentFailureR\007failure\022]\n\nwithdr"
    "awal\030\016 \001(\0132=.aalyria.spacetime.api.nbi.v"
    "1alpha.resources.IntentWithdrawalR\nwithd"
    "rawal\022P\n\020time_to_withdraw\030\017 \001(\0132&.aalyri"
    "a.spacetime.api.common.DateTimeR\016timeToW"
    "ithdraw\022\214\001\n\032dependent_service_requests\030\020"
    " \003(\0132N.aalyria.spacetime.api.nbi.v1alpha"
    ".resources.Intent.ServiceRequestAndInter"
    "valsR\030dependentServiceRequests\022t\n\033compil"
    "ed_withdrawal_updates\030\021 \003(\01324.aalyria.sp"
    "acetime.api.common.ScheduledControlUpdat"
    "eR\031compiledWithdrawalUpdates\022\035\n\nauto_ret"
    "ry\030\014 \001(\010R\tautoRetry\032}\n\032ServiceRequestAnd"
    "Intervals\022,\n\022service_request_id\030\001 \001(\tR\020s"
    "erviceRequestId\0221\n\010interval\030\002 \003(\0132\025.goog"
    "le.type.IntervalR\010intervalB\007\n\005valueJ\004\010\002\020"
    "\003J\010\010\022\020\200\200\200\200\002\"\205\002\n\nLinkIntent\022i\n\020directiona"
    "l_link\030\003 \001(\0132<.aalyria.spacetime.api.nbi"
    ".v1alpha.resources.DirectionalLinkH\000R\017di"
    "rectionalLink\022o\n\022bidirectional_link\030\002 \001("
    "\0132>.aalyria.spacetime.api.nbi.v1alpha.re"
    "sources.BidirectionalLinkH\000R\021bidirection"
    "alLinkB\013\n\tlink_typeJ\004\010\001\020\002J\010\010\004\020\200\200\200\200\002\"\206\001\n\013"
    "RadioIntent\022g\n\016configurations\030\002 \003(\0132\?.aa"
    "lyria.spacetime.api.nbi.v1alpha.resource"
    "s.RadioConfigurationR\016configurationsJ\004\010\001"
    "\020\002J\010\010\003\020\200\200\200\200\002\"\235\002\n\nPathIntent\022(\n\016src_eleme"
    "nt_id\030\001 \001(\tB\002\030\001R\014srcElementId\022(\n\016dst_ele"
    "ment_id\030\002 \001(\tB\002\030\001R\014dstElementId\022L\n\nclass"
    "ifier\030\n \001(\0132,.aalyria.spacetime.api.comm"
    "on.FlowClassifierR\nclassifier\022]\n\rpath_se"
    "gments\030\003 \003(\01328.aalyria.spacetime.api.nbi"
    ".v1alpha.resources.NetworkLinkR\014pathSegm"
    "entsJ\004\010\004\020\tJ\010\010\013\020\200\200\200\200\002\"\237\004\n\014TunnelIntent\022V\n"
    "\001a\030\n \001(\0132H.aalyria.spacetime.api.nbi.v1a"
    "lpha.resources.TunnelIntent.TunnelEndpoi"
    "ntR\001a\022V\n\001b\030\013 \001(\0132H.aalyria.spacetime.api"
    ".nbi.v1alpha.resources.TunnelIntent.Tunn"
    "elEndpointR\001b\022B\n\006method\030\005 \001(\0132*.aalyria."
    "spacetime.api.common.TunnelMethodR\006metho"
    "d\032\204\002\n\016TunnelEndpoint\022\027\n\007node_id\030\001 \001(\tR\006n"
    "odeId\022L\n\nclassifier\030\005 \001(\0132,.aalyria.spac"
    "etime.api.common.FlowClassifierR\nclassif"
    "ier\022A\n\035encapsulated_src_interface_id\030\006 \001"
    "(\tR\032encapsulatedSrcInterfaceId\0222\n\025encaps"
    "ulated_src_port\030\003 \001(\005R\023encapsulatedSrcPo"
    "rtJ\004\010\002\020\003J\004\010\004\020\005J\010\010\007\020\200\200\200\200\002J\004\010\001\020\005J\004\010\006\020\nJ\010\010\014"
    "\020\200\200\200\200\002\"\360\004\n\rIntentFailure\022`\n\004type\030\001 \001(\0162L"
    ".aalyria.spacetime.api.nbi.v1alpha.resou"
    "rces.IntentFailure.IntentFailureTypeR\004ty"
    "pe\022m\n\024precondition_failure\030\002 \001(\0132:.aalyr"
    "ia.spacetime.api.nbi.v1alpha.resources.I"
    "ntentFailureR\023preconditionFailure\022 \n\013des"
    "cription\030\003 \001(\tR\013description\022\033\n\tagent_ids"
    "\030\004 \003(\tR\010agentIds\022>\n\022agent_failure_code\030\005"
    " \001(\0162\020.google.rpc.CodeR\020agentFailureCode"
    "\"\204\002\n\021IntentFailureType\022\013\n\007UNKNOWN\020\000\022\027\n\023C"
    "OMPILATION_FAILURE\020\001\022\036\n\032AGENT_INSTALLATI"
    "ON_FAILURE\020\002\022\025\n\021UNREACHABLE_AGENT\020\003\022 \n\034U"
    "NEXPECTED_CDPI_STATE_CHANGE\020\004\022\027\n\023PRECOND"
    "ITION_FAILED\020\005\022\025\n\021DEADLINE_EXCEEDED\020\006\022\030\n"
    "\024PRECONDITION_EXPIRED\020\007\022\026\n\022SDN_INTERNAL_"
    "ERROR\020\t\"\004\010\010\020\010\"\010\010\n\020\377\377\377\377\007J\010\010\006\020\200\200\200\200\002\"\351\001\n\020In"
    "tentWithdrawal\022^\n\004type\030\001 \001(\0162J.aalyria.s"
    "pacetime.api.nbi.v1alpha.resources.Inten"
    "tWithdrawal.WithdrawTypeR\004type\022 \n\013descri"
    "ption\030\002 \001(\tR\013description\"I\n\014WithdrawType"
    "\022\013\n\007UNKNOWN\020\000\022\020\n\014INACCESSIBLE\020\001\022\020\n\014NOT_R"
    "EQUIRED\020\002\"\010\010\003\020\377\377\377\377\007J\010\010\003\020\200\200\200\200\002*\306\001\n\013Intent"
    "State\022\013\n\007UNKNOWN\020\000\022\017\n\013INSTALL_REQ\020\001\022\013\n\007P"
    "USHING\020\t\022\r\n\tSCHEDULED\020\n\022\016\n\nSCHEDULING\020\014\022"
    "\023\n\017MAYBE_INSTALLED\020\013\022\016\n\nINSTALLING\020\003\022\r\n\t"
    "INSTALLED\020\004\022\020\n\014WITHDRAW_REQ\020\005\022\017\n\013WITHDRA"
    "WING\020\006\022\n\n\006FAILED\020\010\"\004\010\002\020\002\"\004\010\007\020\007Bb\n/com.aa"
    "lyria.spacetime.api.nbi.v1alpha.resource"
    "sZ/aalyria.com/spacetime/api/nbi/v1alpha"
    "/resources"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_deps[8] =
    {
        &::descriptor_table_api_2fcommon_2fcontrol_2eproto,
        &::descriptor_table_api_2fcommon_2fnetwork_2eproto,
        &::descriptor_table_api_2fcommon_2ftime_2eproto,
        &::descriptor_table_api_2fcommon_2ftunnel_2eproto,
        &::descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fnetwork_5flink_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_google_2frpc_2fcode_2eproto,
        &::descriptor_table_google_2ftype_2finterval_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto = {
    false,
    false,
    4090,
    descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto,
    "api/nbi/v1alpha/resources/intent.proto",
    &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_deps,
    8,
    9,
    schemas,
    file_default_instances,
    TableStruct_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto::offsets,
    file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto,
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto,
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter() {
  return &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntentFailure_IntentFailureType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[0];
}
bool IntentFailure_IntentFailureType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IntentFailure_IntentFailureType IntentFailure::UNKNOWN;
constexpr IntentFailure_IntentFailureType IntentFailure::COMPILATION_FAILURE;
constexpr IntentFailure_IntentFailureType IntentFailure::AGENT_INSTALLATION_FAILURE;
constexpr IntentFailure_IntentFailureType IntentFailure::UNREACHABLE_AGENT;
constexpr IntentFailure_IntentFailureType IntentFailure::UNEXPECTED_CDPI_STATE_CHANGE;
constexpr IntentFailure_IntentFailureType IntentFailure::PRECONDITION_FAILED;
constexpr IntentFailure_IntentFailureType IntentFailure::DEADLINE_EXCEEDED;
constexpr IntentFailure_IntentFailureType IntentFailure::PRECONDITION_EXPIRED;
constexpr IntentFailure_IntentFailureType IntentFailure::SDN_INTERNAL_ERROR;
constexpr IntentFailure_IntentFailureType IntentFailure::IntentFailureType_MIN;
constexpr IntentFailure_IntentFailureType IntentFailure::IntentFailureType_MAX;
constexpr int IntentFailure::IntentFailureType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntentWithdrawal_WithdrawType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[1];
}
bool IntentWithdrawal_WithdrawType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IntentWithdrawal_WithdrawType IntentWithdrawal::UNKNOWN;
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal::INACCESSIBLE;
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal::NOT_REQUIRED;
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal::WithdrawType_MIN;
constexpr IntentWithdrawal_WithdrawType IntentWithdrawal::WithdrawType_MAX;
constexpr int IntentWithdrawal::WithdrawType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IntentState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[2];
}
bool IntentState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class Intent_ServiceRequestAndIntervals::_Internal {
 public:
  using HasBits = decltype(std::declval<Intent_ServiceRequestAndIntervals>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Intent_ServiceRequestAndIntervals, _impl_._has_bits_);
  static void set_has_service_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void Intent_ServiceRequestAndIntervals::clear_interval() {
  _internal_mutable_interval()->Clear();
}
Intent_ServiceRequestAndIntervals::Intent_ServiceRequestAndIntervals(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
}
Intent_ServiceRequestAndIntervals::Intent_ServiceRequestAndIntervals(const Intent_ServiceRequestAndIntervals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Intent_ServiceRequestAndIntervals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){from._impl_.interval_}
    , decltype(_impl_.service_request_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.service_request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_request_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.service_request_id_.Set(from._internal_service_request_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
}

inline void Intent_ServiceRequestAndIntervals::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){arena}
    , decltype(_impl_.service_request_id_) {}

  };
  _impl_.service_request_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_request_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Intent_ServiceRequestAndIntervals::~Intent_ServiceRequestAndIntervals() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Intent_ServiceRequestAndIntervals::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_interval()->~RepeatedPtrField();
  _impl_.service_request_id_.Destroy();
}

void Intent_ServiceRequestAndIntervals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Intent_ServiceRequestAndIntervals::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_interval()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.service_request_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Intent_ServiceRequestAndIntervals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string service_request_id = 1 [json_name = "serviceRequestId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service_request_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .google.type.Interval interval = 2 [json_name = "interval"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_interval(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Intent_ServiceRequestAndIntervals::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string service_request_id = 1 [json_name = "serviceRequestId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_service_request_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals.service_request_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_interval_size()); i < n; i++) {
    const auto& repfield = this->_internal_interval(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  return target;
}

::size_t Intent_ServiceRequestAndIntervals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  total_size += 1UL * this->_internal_interval_size();
  for (const auto& msg : this->_internal_interval()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string service_request_id = 1 [json_name = "serviceRequestId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_service_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Intent_ServiceRequestAndIntervals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Intent_ServiceRequestAndIntervals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Intent_ServiceRequestAndIntervals::GetClassData() const { return &_class_data_; }


void Intent_ServiceRequestAndIntervals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Intent_ServiceRequestAndIntervals*>(&to_msg);
  auto& from = static_cast<const Intent_ServiceRequestAndIntervals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_interval()->MergeFrom(from._internal_interval());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_service_request_id(from._internal_service_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Intent_ServiceRequestAndIntervals::CopyFrom(const Intent_ServiceRequestAndIntervals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Intent_ServiceRequestAndIntervals::IsInitialized() const {
  return true;
}

void Intent_ServiceRequestAndIntervals::InternalSwap(Intent_ServiceRequestAndIntervals* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_interval()->InternalSwap(other->_internal_mutable_interval());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_request_id_, lhs_arena,
                                       &other->_impl_.service_request_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Intent_ServiceRequestAndIntervals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[0]);
}
// ===================================================================

class Intent::_Internal {
 public:
  using HasBits = decltype(std::declval<Intent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Intent, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::Intent, _impl_._oneof_case_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_to_enact(const Intent* msg);
  static void set_has_time_to_enact(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent& link(const Intent* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent& radio(const Intent* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent& route(const Intent* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent& tunnel(const Intent* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_request_timestamp_us(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& failure(const Intent* msg);
  static void set_has_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal& withdrawal(const Intent* msg);
  static void set_has_withdrawal(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::aalyria::spacetime::api::common::DateTime& time_to_withdraw(const Intent* msg);
  static void set_has_time_to_withdraw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_auto_retry(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Intent::_Internal::time_to_enact(const Intent* msg) {
  return *msg->_impl_.time_to_enact_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent&
Intent::_Internal::link(const Intent* msg) {
  return *msg->_impl_.value_.link_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent&
Intent::_Internal::radio(const Intent* msg) {
  return *msg->_impl_.value_.radio_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent&
Intent::_Internal::route(const Intent* msg) {
  return *msg->_impl_.value_.route_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent&
Intent::_Internal::tunnel(const Intent* msg) {
  return *msg->_impl_.value_.tunnel_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure&
Intent::_Internal::failure(const Intent* msg) {
  return *msg->_impl_.failure_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal&
Intent::_Internal::withdrawal(const Intent* msg) {
  return *msg->_impl_.withdrawal_;
}
const ::aalyria::spacetime::api::common::DateTime&
Intent::_Internal::time_to_withdraw(const Intent* msg) {
  return *msg->_impl_.time_to_withdraw_;
}
void Intent::clear_time_to_enact() {
  if (_impl_.time_to_enact_ != nullptr) _impl_.time_to_enact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void Intent::set_allocated_link(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link);
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    set_has_link();
    _impl_.value_.link_ = link;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.link)
}
void Intent::set_allocated_radio(::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent* radio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (radio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(radio);
    if (message_arena != submessage_arena) {
      radio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio, submessage_arena);
    }
    set_has_radio();
    _impl_.value_.radio_ = radio;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.radio)
}
void Intent::set_allocated_route(::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(route);
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    set_has_route();
    _impl_.value_.route_ = route;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.route)
}
void Intent::set_allocated_tunnel(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent* tunnel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (tunnel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tunnel);
    if (message_arena != submessage_arena) {
      tunnel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tunnel, submessage_arena);
    }
    set_has_tunnel();
    _impl_.value_.tunnel_ = tunnel;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.Intent.tunnel)
}
void Intent::clear_compiled_updates() {
  _internal_mutable_compiled_updates()->Clear();
}
void Intent::clear_time_to_withdraw() {
  if (_impl_.time_to_withdraw_ != nullptr) _impl_.time_to_withdraw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void Intent::clear_compiled_withdrawal_updates() {
  _internal_mutable_compiled_withdrawal_updates()->Clear();
}
Intent::Intent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
}
Intent::Intent(const Intent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Intent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compiled_updates_){from._impl_.compiled_updates_}
    , decltype(_impl_.dependent_service_requests_){from._impl_.dependent_service_requests_}
    , decltype(_impl_.compiled_withdrawal_updates_){from._impl_.compiled_withdrawal_updates_}
    , decltype(_impl_.app_id_) {}

    , decltype(_impl_.time_to_enact_){nullptr}
    , decltype(_impl_.failure_){nullptr}
    , decltype(_impl_.withdrawal_){nullptr}
    , decltype(_impl_.time_to_withdraw_){nullptr}
    , decltype(_impl_.request_timestamp_us_) {}

    , decltype(_impl_.auto_retry_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.value_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.time_to_enact_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.time_to_enact_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.failure_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure(*from._impl_.failure_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.withdrawal_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal(*from._impl_.withdrawal_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.time_to_withdraw_ = new ::aalyria::spacetime::api::common::DateTime(*from._impl_.time_to_withdraw_);
  }
  ::memcpy(&_impl_.request_timestamp_us_, &from._impl_.request_timestamp_us_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.state_) -
    reinterpret_cast<char*>(&_impl_.request_timestamp_us_)) + sizeof(_impl_.state_));
  clear_has_value();
  switch (from.value_case()) {
    case kLink: {
      _this->_internal_mutable_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent::MergeFrom(
          from._internal_link());
      break;
    }
    case kRadio: {
      _this->_internal_mutable_radio()->::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent::MergeFrom(
          from._internal_radio());
      break;
    }
    case kRoute: {
      _this->_internal_mutable_route()->::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent::MergeFrom(
          from._internal_route());
      break;
    }
    case kTunnel: {
      _this->_internal_mutable_tunnel()->::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent::MergeFrom(
          from._internal_tunnel());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
}

inline void Intent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compiled_updates_){arena}
    , decltype(_impl_.dependent_service_requests_){arena}
    , decltype(_impl_.compiled_withdrawal_updates_){arena}
    , decltype(_impl_.app_id_) {}

    , decltype(_impl_.time_to_enact_){nullptr}
    , decltype(_impl_.failure_){nullptr}
    , decltype(_impl_.withdrawal_){nullptr}
    , decltype(_impl_.time_to_withdraw_){nullptr}
    , decltype(_impl_.request_timestamp_us_) { ::int64_t{0} }

    , decltype(_impl_.auto_retry_) { false }

    , decltype(_impl_.state_) { 1 }

    , decltype(_impl_.value_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_value();
}

Intent::~Intent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Intent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_compiled_updates()->~RepeatedPtrField();
  _internal_mutable_dependent_service_requests()->~RepeatedPtrField();
  _internal_mutable_compiled_withdrawal_updates()->~RepeatedPtrField();
  _impl_.app_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.time_to_enact_;
  if (this != internal_default_instance()) delete _impl_.failure_;
  if (this != internal_default_instance()) delete _impl_.withdrawal_;
  if (this != internal_default_instance()) delete _impl_.time_to_withdraw_;
  if (has_value()) {
    clear_value();
  }
}

void Intent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Intent::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  switch (value_case()) {
    case kLink: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.link_;
      }
      break;
    }
    case kRadio: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.radio_;
      }
      break;
    }
    case kRoute: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.route_;
      }
      break;
    }
    case kTunnel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.tunnel_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void Intent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_compiled_updates()->Clear();
  _internal_mutable_dependent_service_requests()->Clear();
  _internal_mutable_compiled_withdrawal_updates()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.time_to_enact_ != nullptr);
      _impl_.time_to_enact_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.failure_ != nullptr);
      _impl_.failure_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.withdrawal_ != nullptr);
      _impl_.withdrawal_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.time_to_withdraw_ != nullptr);
      _impl_.time_to_withdraw_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.request_timestamp_us_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.auto_retry_) -
        reinterpret_cast<char*>(&_impl_.request_timestamp_us_)) + sizeof(_impl_.auto_retry_));
    _impl_.state_ = 1;
  }
  clear_value();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Intent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1 [json_name = "appId", deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_to_enact(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent link = 4 [json_name = "link"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_link(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent radio = 5 [json_name = "radio"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_radio(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent route = 6 [json_name = "route"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_route(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState state = 7 [default = INSTALL_REQ, json_name = "state"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState_IsValid(static_cast<int>(val)))) {
            _internal_set_state(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_updates = 8 [json_name = "compiledUpdates"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_compiled_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure failure = 9 [json_name = "failure"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_failure(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent tunnel = 10 [json_name = "tunnel"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_tunnel(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 request_timestamp_us = 11 [json_name = "requestTimestampUs"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_request_timestamp_us(&has_bits);
          _impl_.request_timestamp_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool auto_retry = 12 [json_name = "autoRetry"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_auto_retry(&has_bits);
          _impl_.auto_retry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal withdrawal = 14 [json_name = "withdrawal"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_withdrawal(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.DateTime time_to_withdraw = 15 [json_name = "timeToWithdraw"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_to_withdraw(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals dependent_service_requests = 16 [json_name = "dependentServiceRequests"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_dependent_service_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_withdrawal_updates = 17 [json_name = "compiledWithdrawalUpdates"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_compiled_withdrawal_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Intent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1 [json_name = "appId", deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_app_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.Intent.app_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::time_to_enact(this),
        _Internal::time_to_enact(this).GetCachedSize(), target, stream);
  }

  switch (value_case()) {
    case kLink: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::link(this),
          _Internal::link(this).GetCachedSize(), target, stream);
      break;
    }
    case kRadio: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::radio(this),
          _Internal::radio(this).GetCachedSize(), target, stream);
      break;
    }
    case kRoute: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::route(this),
          _Internal::route(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState state = 7 [default = INSTALL_REQ, json_name = "state"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_state(), target);
  }

  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_updates = 8 [json_name = "compiledUpdates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compiled_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_compiled_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure failure = 9 [json_name = "failure"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::failure(this),
        _Internal::failure(this).GetCachedSize(), target, stream);
  }

  // .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent tunnel = 10 [json_name = "tunnel"];
  if (value_case() == kTunnel) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::tunnel(this),
        _Internal::tunnel(this).GetCachedSize(), target, stream);
  }

  // optional int64 request_timestamp_us = 11 [json_name = "requestTimestampUs"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        11, this->_internal_request_timestamp_us(), target);
  }

  // optional bool auto_retry = 12 [json_name = "autoRetry"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this->_internal_auto_retry(), target);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal withdrawal = 14 [json_name = "withdrawal"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::withdrawal(this),
        _Internal::withdrawal(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.DateTime time_to_withdraw = 15 [json_name = "timeToWithdraw"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::time_to_withdraw(this),
        _Internal::time_to_withdraw(this).GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals dependent_service_requests = 16 [json_name = "dependentServiceRequests"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dependent_service_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_dependent_service_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_withdrawal_updates = 17 [json_name = "compiledWithdrawalUpdates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_compiled_withdrawal_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_compiled_withdrawal_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  return target;
}

::size_t Intent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_updates = 8 [json_name = "compiledUpdates"];
  total_size += 1UL * this->_internal_compiled_updates_size();
  for (const auto& msg : this->_internal_compiled_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.Intent.ServiceRequestAndIntervals dependent_service_requests = 16 [json_name = "dependentServiceRequests"];
  total_size += 2UL * this->_internal_dependent_service_requests_size();
  for (const auto& msg : this->_internal_dependent_service_requests()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdate compiled_withdrawal_updates = 17 [json_name = "compiledWithdrawalUpdates"];
  total_size += 2UL * this->_internal_compiled_withdrawal_updates_size();
  for (const auto& msg : this->_internal_compiled_withdrawal_updates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string app_id = 1 [json_name = "appId", deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_app_id());
    }

    // optional .google.protobuf.Timestamp time_to_enact = 3 [json_name = "timeToEnact"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_to_enact_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure failure = 9 [json_name = "failure"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.failure_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal withdrawal = 14 [json_name = "withdrawal"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.withdrawal_);
    }

    // optional .aalyria.spacetime.api.common.DateTime time_to_withdraw = 15 [json_name = "timeToWithdraw"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_to_withdraw_);
    }

    // optional int64 request_timestamp_us = 11 [json_name = "requestTimestampUs"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_request_timestamp_us());
    }

    // optional bool auto_retry = 12 [json_name = "autoRetry"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentState state = 7 [default = INSTALL_REQ, json_name = "state"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

  }
  switch (value_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent link = 4 [json_name = "link"];
    case kLink: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.link_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent radio = 5 [json_name = "radio"];
    case kRadio: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.radio_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent route = 6 [json_name = "route"];
    case kRoute: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.route_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent tunnel = 10 [json_name = "tunnel"];
    case kTunnel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.tunnel_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Intent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Intent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Intent::GetClassData() const { return &_class_data_; }


void Intent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Intent*>(&to_msg);
  auto& from = static_cast<const Intent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_compiled_updates()->MergeFrom(from._internal_compiled_updates());
  _this->_internal_mutable_dependent_service_requests()->MergeFrom(from._internal_dependent_service_requests());
  _this->_internal_mutable_compiled_withdrawal_updates()->MergeFrom(from._internal_compiled_withdrawal_updates());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_time_to_enact()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_time_to_enact());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_failure()->::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure::MergeFrom(
          from._internal_failure());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_withdrawal()->::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal::MergeFrom(
          from._internal_withdrawal());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_time_to_withdraw()->::aalyria::spacetime::api::common::DateTime::MergeFrom(
          from._internal_time_to_withdraw());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_timestamp_us_ = from._impl_.request_timestamp_us_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.auto_retry_ = from._impl_.auto_retry_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.value_case()) {
    case kLink: {
      _this->_internal_mutable_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent::MergeFrom(
          from._internal_link());
      break;
    }
    case kRadio: {
      _this->_internal_mutable_radio()->::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent::MergeFrom(
          from._internal_radio());
      break;
    }
    case kRoute: {
      _this->_internal_mutable_route()->::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent::MergeFrom(
          from._internal_route());
      break;
    }
    case kTunnel: {
      _this->_internal_mutable_tunnel()->::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent::MergeFrom(
          from._internal_tunnel());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Intent::CopyFrom(const Intent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.Intent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Intent::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_compiled_updates()))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_compiled_withdrawal_updates()))
    return false;
  switch (value_case()) {
    case kLink: {
      if (value_case() == kLink) {
        if (!_impl_.value_.link_->IsInitialized()) return false;
      }
      break;
    }
    case kRadio: {
      if (value_case() == kRadio) {
        if (!_impl_.value_.radio_->IsInitialized()) return false;
      }
      break;
    }
    case kRoute: {
      break;
    }
    case kTunnel: {
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return true;
}

void Intent::InternalSwap(Intent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_compiled_updates()->InternalSwap(other->_internal_mutable_compiled_updates());
  _internal_mutable_dependent_service_requests()->InternalSwap(other->_internal_mutable_dependent_service_requests());
  _internal_mutable_compiled_withdrawal_updates()->InternalSwap(other->_internal_mutable_compiled_withdrawal_updates());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.app_id_, lhs_arena,
                                       &other->_impl_.app_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Intent, _impl_.state_)
      + sizeof(Intent::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(Intent, _impl_.time_to_enact_)>(
          reinterpret_cast<char*>(&_impl_.time_to_enact_),
          reinterpret_cast<char*>(&other->_impl_.time_to_enact_));
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Intent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[1]);
}
// ===================================================================

class LinkIntent::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent, _impl_._oneof_case_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink& directional_link(const LinkIntent* msg);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink& bidirectional_link(const LinkIntent* msg);
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink&
LinkIntent::_Internal::directional_link(const LinkIntent* msg) {
  return *msg->_impl_.link_type_.directional_link_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink&
LinkIntent::_Internal::bidirectional_link(const LinkIntent* msg) {
  return *msg->_impl_.link_type_.bidirectional_link_;
}
void LinkIntent::set_allocated_directional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink* directional_link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_link_type();
  if (directional_link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directional_link));
    if (message_arena != submessage_arena) {
      directional_link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directional_link, submessage_arena);
    }
    set_has_directional_link();
    _impl_.link_type_.directional_link_ = directional_link;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.directional_link)
}
void LinkIntent::clear_directional_link() {
  if (link_type_case() == kDirectionalLink) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.link_type_.directional_link_;
    }
    clear_has_link_type();
  }
}
void LinkIntent::set_allocated_bidirectional_link(::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink* bidirectional_link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_link_type();
  if (bidirectional_link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bidirectional_link));
    if (message_arena != submessage_arena) {
      bidirectional_link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bidirectional_link, submessage_arena);
    }
    set_has_bidirectional_link();
    _impl_.link_type_.bidirectional_link_ = bidirectional_link;
  }
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent.bidirectional_link)
}
void LinkIntent::clear_bidirectional_link() {
  if (link_type_case() == kBidirectionalLink) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.link_type_.bidirectional_link_;
    }
    clear_has_link_type();
  }
}
LinkIntent::LinkIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
}
LinkIntent::LinkIntent(const LinkIntent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinkIntent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.link_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_link_type();
  switch (from.link_type_case()) {
    case kDirectionalLink: {
      _this->_internal_mutable_directional_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink::MergeFrom(
          from._internal_directional_link());
      break;
    }
    case kBidirectionalLink: {
      _this->_internal_mutable_bidirectional_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink::MergeFrom(
          from._internal_bidirectional_link());
      break;
    }
    case LINK_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
}

inline void LinkIntent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.link_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_link_type();
}

LinkIntent::~LinkIntent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinkIntent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_link_type()) {
    clear_link_type();
  }
}

void LinkIntent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinkIntent::clear_link_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  switch (link_type_case()) {
    case kDirectionalLink: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.link_type_.directional_link_;
      }
      break;
    }
    case kBidirectionalLink: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.link_type_.bidirectional_link_;
      }
      break;
    }
    case LINK_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LINK_TYPE_NOT_SET;
}


void LinkIntent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_link_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinkIntent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink bidirectional_link = 2 [json_name = "bidirectionalLink"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bidirectional_link(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink directional_link = 3 [json_name = "directionalLink"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_directional_link(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LinkIntent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (link_type_case()) {
    case kBidirectionalLink: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::bidirectional_link(this),
          _Internal::bidirectional_link(this).GetCachedSize(), target, stream);
      break;
    }
    case kDirectionalLink: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::directional_link(this),
          _Internal::directional_link(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  return target;
}

::size_t LinkIntent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (link_type_case()) {
    // .aalyria.spacetime.api.nbi.v1alpha.resources.DirectionalLink directional_link = 3 [json_name = "directionalLink"];
    case kDirectionalLink: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.link_type_.directional_link_);
      break;
    }
    // .aalyria.spacetime.api.nbi.v1alpha.resources.BidirectionalLink bidirectional_link = 2 [json_name = "bidirectionalLink"];
    case kBidirectionalLink: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.link_type_.bidirectional_link_);
      break;
    }
    case LINK_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinkIntent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinkIntent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinkIntent::GetClassData() const { return &_class_data_; }


void LinkIntent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinkIntent*>(&to_msg);
  auto& from = static_cast<const LinkIntent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.link_type_case()) {
    case kDirectionalLink: {
      _this->_internal_mutable_directional_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::DirectionalLink::MergeFrom(
          from._internal_directional_link());
      break;
    }
    case kBidirectionalLink: {
      _this->_internal_mutable_bidirectional_link()->::aalyria::spacetime::api::nbi::v1alpha::resources::BidirectionalLink::MergeFrom(
          from._internal_bidirectional_link());
      break;
    }
    case LINK_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinkIntent::CopyFrom(const LinkIntent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.LinkIntent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkIntent::IsInitialized() const {
  switch (link_type_case()) {
    case kDirectionalLink: {
      if (link_type_case() == kDirectionalLink) {
        if (!_impl_.link_type_.directional_link_->IsInitialized()) return false;
      }
      break;
    }
    case kBidirectionalLink: {
      break;
    }
    case LINK_TYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void LinkIntent::InternalSwap(LinkIntent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.link_type_, other->_impl_.link_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinkIntent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[2]);
}
// ===================================================================

class RadioIntent::_Internal {
 public:
};

void RadioIntent::clear_configurations() {
  _internal_mutable_configurations()->Clear();
}
RadioIntent::RadioIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
}
RadioIntent::RadioIntent(const RadioIntent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RadioIntent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.configurations_){from._impl_.configurations_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
}

inline void RadioIntent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.configurations_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RadioIntent::~RadioIntent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RadioIntent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_configurations()->~RepeatedPtrField();
}

void RadioIntent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RadioIntent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_configurations()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadioIntent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration configurations = 2 [json_name = "configurations"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_configurations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RadioIntent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration configurations = 2 [json_name = "configurations"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_configurations_size()); i < n; i++) {
    const auto& repfield = this->_internal_configurations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  return target;
}

::size_t RadioIntent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.RadioConfiguration configurations = 2 [json_name = "configurations"];
  total_size += 1UL * this->_internal_configurations_size();
  for (const auto& msg : this->_internal_configurations()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadioIntent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RadioIntent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadioIntent::GetClassData() const { return &_class_data_; }


void RadioIntent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RadioIntent*>(&to_msg);
  auto& from = static_cast<const RadioIntent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_configurations()->MergeFrom(from._internal_configurations());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadioIntent::CopyFrom(const RadioIntent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.RadioIntent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadioIntent::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_configurations()))
    return false;
  return true;
}

void RadioIntent::InternalSwap(RadioIntent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_configurations()->InternalSwap(other->_internal_mutable_configurations());
}

::PROTOBUF_NAMESPACE_ID::Metadata RadioIntent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[3]);
}
// ===================================================================

class PathIntent::_Internal {
 public:
  using HasBits = decltype(std::declval<PathIntent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PathIntent, _impl_._has_bits_);
  static void set_has_src_element_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dst_element_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::FlowClassifier& classifier(const PathIntent* msg);
  static void set_has_classifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::aalyria::spacetime::api::common::FlowClassifier&
PathIntent::_Internal::classifier(const PathIntent* msg) {
  return *msg->_impl_.classifier_;
}
void PathIntent::clear_classifier() {
  if (_impl_.classifier_ != nullptr) _impl_.classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PathIntent::clear_path_segments() {
  _internal_mutable_path_segments()->Clear();
}
PathIntent::PathIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
}
PathIntent::PathIntent(const PathIntent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathIntent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_segments_){from._impl_.path_segments_}
    , decltype(_impl_.src_element_id_) {}

    , decltype(_impl_.dst_element_id_) {}

    , decltype(_impl_.classifier_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_element_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.src_element_id_.Set(from._internal_src_element_id(), _this->GetArenaForAllocation());
  }
  _impl_.dst_element_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dst_element_id_.Set(from._internal_dst_element_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.classifier_ = new ::aalyria::spacetime::api::common::FlowClassifier(*from._impl_.classifier_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
}

inline void PathIntent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_segments_){arena}
    , decltype(_impl_.src_element_id_) {}

    , decltype(_impl_.dst_element_id_) {}

    , decltype(_impl_.classifier_){nullptr}
  };
  _impl_.src_element_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_element_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_element_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PathIntent::~PathIntent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathIntent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_path_segments()->~RepeatedPtrField();
  _impl_.src_element_id_.Destroy();
  _impl_.dst_element_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.classifier_;
}

void PathIntent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathIntent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_path_segments()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.src_element_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dst_element_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.classifier_ != nullptr);
      _impl_.classifier_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathIntent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string src_element_id = 1 [json_name = "srcElementId", deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_element_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string dst_element_id = 2 [json_name = "dstElementId", deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_element_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink path_segments = 3 [json_name = "pathSegments"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_path_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 10 [json_name = "classifier"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PathIntent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string src_element_id = 1 [json_name = "srcElementId", deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_src_element_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.src_element_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string dst_element_id = 2 [json_name = "dstElementId", deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_dst_element_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent.dst_element_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink path_segments = 3 [json_name = "pathSegments"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_path_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_path_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 10 [json_name = "classifier"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  return target;
}

::size_t PathIntent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.NetworkLink path_segments = 3 [json_name = "pathSegments"];
  total_size += 1UL * this->_internal_path_segments_size();
  for (const auto& msg : this->_internal_path_segments()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string src_element_id = 1 [json_name = "srcElementId", deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_src_element_id());
    }

    // optional string dst_element_id = 2 [json_name = "dstElementId", deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_dst_element_id());
    }

    // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 10 [json_name = "classifier"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.classifier_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathIntent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathIntent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathIntent::GetClassData() const { return &_class_data_; }


void PathIntent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathIntent*>(&to_msg);
  auto& from = static_cast<const PathIntent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_path_segments()->MergeFrom(from._internal_path_segments());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_src_element_id(from._internal_src_element_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dst_element_id(from._internal_dst_element_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_classifier()->::aalyria::spacetime::api::common::FlowClassifier::MergeFrom(
          from._internal_classifier());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathIntent::CopyFrom(const PathIntent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.PathIntent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathIntent::IsInitialized() const {
  return true;
}

void PathIntent::InternalSwap(PathIntent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_path_segments()->InternalSwap(other->_internal_mutable_path_segments());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_element_id_, lhs_arena,
                                       &other->_impl_.src_element_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_element_id_, lhs_arena,
                                       &other->_impl_.dst_element_id_, rhs_arena);
  swap(_impl_.classifier_, other->_impl_.classifier_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PathIntent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[4]);
}
// ===================================================================

class TunnelIntent_TunnelEndpoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TunnelIntent_TunnelEndpoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TunnelIntent_TunnelEndpoint, _impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::FlowClassifier& classifier(const TunnelIntent_TunnelEndpoint* msg);
  static void set_has_classifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_encapsulated_src_interface_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encapsulated_src_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::common::FlowClassifier&
TunnelIntent_TunnelEndpoint::_Internal::classifier(const TunnelIntent_TunnelEndpoint* msg) {
  return *msg->_impl_.classifier_;
}
void TunnelIntent_TunnelEndpoint::clear_classifier() {
  if (_impl_.classifier_ != nullptr) _impl_.classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TunnelIntent_TunnelEndpoint::TunnelIntent_TunnelEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
}
TunnelIntent_TunnelEndpoint::TunnelIntent_TunnelEndpoint(const TunnelIntent_TunnelEndpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TunnelIntent_TunnelEndpoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.encapsulated_src_interface_id_) {}

    , decltype(_impl_.classifier_){nullptr}
    , decltype(_impl_.encapsulated_src_port_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.node_id_.Set(from._internal_node_id(), _this->GetArenaForAllocation());
  }
  _impl_.encapsulated_src_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encapsulated_src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.encapsulated_src_interface_id_.Set(from._internal_encapsulated_src_interface_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.classifier_ = new ::aalyria::spacetime::api::common::FlowClassifier(*from._impl_.classifier_);
  }
  _this->_impl_.encapsulated_src_port_ = from._impl_.encapsulated_src_port_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
}

inline void TunnelIntent_TunnelEndpoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.encapsulated_src_interface_id_) {}

    , decltype(_impl_.classifier_){nullptr}
    , decltype(_impl_.encapsulated_src_port_) { 0 }

  };
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encapsulated_src_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encapsulated_src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TunnelIntent_TunnelEndpoint::~TunnelIntent_TunnelEndpoint() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TunnelIntent_TunnelEndpoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_id_.Destroy();
  _impl_.encapsulated_src_interface_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.classifier_;
}

void TunnelIntent_TunnelEndpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TunnelIntent_TunnelEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.node_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.encapsulated_src_interface_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.classifier_ != nullptr);
      _impl_.classifier_->Clear();
    }
  }
  _impl_.encapsulated_src_port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelIntent_TunnelEndpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string node_id = 1 [json_name = "nodeId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 encapsulated_src_port = 3 [json_name = "encapsulatedSrcPort"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_encapsulated_src_port(&has_bits);
          _impl_.encapsulated_src_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 5 [json_name = "classifier"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string encapsulated_src_interface_id = 6 [json_name = "encapsulatedSrcInterfaceId"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_encapsulated_src_interface_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TunnelIntent_TunnelEndpoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string node_id = 1 [json_name = "nodeId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_node_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.node_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 encapsulated_src_port = 3 [json_name = "encapsulatedSrcPort"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_encapsulated_src_port(), target);
  }

  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 5 [json_name = "classifier"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  // optional string encapsulated_src_interface_id = 6 [json_name = "encapsulatedSrcInterfaceId"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_encapsulated_src_interface_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint.encapsulated_src_interface_id");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  return target;
}

::size_t TunnelIntent_TunnelEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string node_id = 1 [json_name = "nodeId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_node_id());
    }

    // optional string encapsulated_src_interface_id = 6 [json_name = "encapsulatedSrcInterfaceId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_encapsulated_src_interface_id());
    }

    // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 5 [json_name = "classifier"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.classifier_);
    }

    // optional int32 encapsulated_src_port = 3 [json_name = "encapsulatedSrcPort"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_encapsulated_src_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelIntent_TunnelEndpoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TunnelIntent_TunnelEndpoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelIntent_TunnelEndpoint::GetClassData() const { return &_class_data_; }


void TunnelIntent_TunnelEndpoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TunnelIntent_TunnelEndpoint*>(&to_msg);
  auto& from = static_cast<const TunnelIntent_TunnelEndpoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_node_id(from._internal_node_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_encapsulated_src_interface_id(from._internal_encapsulated_src_interface_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_classifier()->::aalyria::spacetime::api::common::FlowClassifier::MergeFrom(
          from._internal_classifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.encapsulated_src_port_ = from._impl_.encapsulated_src_port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelIntent_TunnelEndpoint::CopyFrom(const TunnelIntent_TunnelEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelIntent_TunnelEndpoint::IsInitialized() const {
  return true;
}

void TunnelIntent_TunnelEndpoint::InternalSwap(TunnelIntent_TunnelEndpoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.node_id_, lhs_arena,
                                       &other->_impl_.node_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encapsulated_src_interface_id_, lhs_arena,
                                       &other->_impl_.encapsulated_src_interface_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TunnelIntent_TunnelEndpoint, _impl_.encapsulated_src_port_)
      + sizeof(TunnelIntent_TunnelEndpoint::_impl_.encapsulated_src_port_)
      - PROTOBUF_FIELD_OFFSET(TunnelIntent_TunnelEndpoint, _impl_.classifier_)>(
          reinterpret_cast<char*>(&_impl_.classifier_),
          reinterpret_cast<char*>(&other->_impl_.classifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelIntent_TunnelEndpoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[5]);
}
// ===================================================================

class TunnelIntent::_Internal {
 public:
  using HasBits = decltype(std::declval<TunnelIntent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TunnelIntent, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& a(const TunnelIntent* msg);
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint& b(const TunnelIntent* msg);
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::common::TunnelMethod& method(const TunnelIntent* msg);
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint&
TunnelIntent::_Internal::a(const TunnelIntent* msg) {
  return *msg->_impl_.a_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint&
TunnelIntent::_Internal::b(const TunnelIntent* msg) {
  return *msg->_impl_.b_;
}
const ::aalyria::spacetime::api::common::TunnelMethod&
TunnelIntent::_Internal::method(const TunnelIntent* msg) {
  return *msg->_impl_.method_;
}
void TunnelIntent::clear_method() {
  if (_impl_.method_ != nullptr) _impl_.method_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TunnelIntent::TunnelIntent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
}
TunnelIntent::TunnelIntent(const TunnelIntent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TunnelIntent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_){nullptr}
    , decltype(_impl_.a_){nullptr}
    , decltype(_impl_.b_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.method_ = new ::aalyria::spacetime::api::common::TunnelMethod(*from._impl_.method_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.a_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint(*from._impl_.a_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.b_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint(*from._impl_.b_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
}

inline void TunnelIntent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_){nullptr}
    , decltype(_impl_.a_){nullptr}
    , decltype(_impl_.b_){nullptr}
  };
}

TunnelIntent::~TunnelIntent() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TunnelIntent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.method_;
  if (this != internal_default_instance()) delete _impl_.a_;
  if (this != internal_default_instance()) delete _impl_.b_;
}

void TunnelIntent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TunnelIntent::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.method_ != nullptr);
      _impl_.method_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.a_ != nullptr);
      _impl_.a_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.b_ != nullptr);
      _impl_.b_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelIntent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.TunnelMethod method = 5 [json_name = "method"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_method(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint a = 10 [json_name = "a"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_a(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint b = 11 [json_name = "b"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_b(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TunnelIntent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.TunnelMethod method = 5 [json_name = "method"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::method(this),
        _Internal::method(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint a = 10 [json_name = "a"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::a(this),
        _Internal::a(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint b = 11 [json_name = "b"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::b(this),
        _Internal::b(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  return target;
}

::size_t TunnelIntent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .aalyria.spacetime.api.common.TunnelMethod method = 5 [json_name = "method"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.method_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint a = 10 [json_name = "a"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.a_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent.TunnelEndpoint b = 11 [json_name = "b"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.b_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelIntent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TunnelIntent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelIntent::GetClassData() const { return &_class_data_; }


void TunnelIntent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TunnelIntent*>(&to_msg);
  auto& from = static_cast<const TunnelIntent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_method()->::aalyria::spacetime::api::common::TunnelMethod::MergeFrom(
          from._internal_method());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_a()->::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint::MergeFrom(
          from._internal_a());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_b()->::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint::MergeFrom(
          from._internal_b());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelIntent::CopyFrom(const TunnelIntent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelIntent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelIntent::IsInitialized() const {
  return true;
}

void TunnelIntent::InternalSwap(TunnelIntent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TunnelIntent, _impl_.b_)
      + sizeof(TunnelIntent::_impl_.b_)
      - PROTOBUF_FIELD_OFFSET(TunnelIntent, _impl_.method_)>(
          reinterpret_cast<char*>(&_impl_.method_),
          reinterpret_cast<char*>(&other->_impl_.method_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelIntent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[6]);
}
// ===================================================================

class IntentFailure::_Internal {
 public:
  using HasBits = decltype(std::declval<IntentFailure>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IntentFailure, _impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure& precondition_failure(const IntentFailure* msg);
  static void set_has_precondition_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_agent_failure_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure&
IntentFailure::_Internal::precondition_failure(const IntentFailure* msg) {
  return *msg->_impl_.precondition_failure_;
}
IntentFailure::IntentFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
}
IntentFailure::IntentFailure(const IntentFailure& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntentFailure* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agent_ids_){from._impl_.agent_ids_}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.precondition_failure_){nullptr}
    , decltype(_impl_.type_) {}

    , decltype(_impl_.agent_failure_code_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.precondition_failure_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure(*from._impl_.precondition_failure_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.agent_failure_code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.agent_failure_code_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
}

inline void IntentFailure::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agent_ids_){arena}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.precondition_failure_){nullptr}
    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.agent_failure_code_) { 0 }

  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IntentFailure::~IntentFailure() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntentFailure::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_agent_ids()->~RepeatedPtrField();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.precondition_failure_;
}

void IntentFailure::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntentFailure::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_agent_ids()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.precondition_failure_ != nullptr);
      _impl_.precondition_failure_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.agent_failure_code_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.agent_failure_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntentFailure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.IntentFailureType type = 1 [json_name = "type"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure_IntentFailureType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure precondition_failure = 2 [json_name = "preconditionFailure"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_precondition_failure(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string description = 3 [json_name = "description"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string agent_ids = 4 [json_name = "agentIds"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_agent_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.rpc.Code agent_failure_code = 5 [json_name = "agentFailureCode"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::google::rpc::Code_IsValid(static_cast<int>(val)))) {
            _internal_set_agent_failure_code(static_cast<::google::rpc::Code>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IntentFailure::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.IntentFailureType type = 1 [json_name = "type"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure precondition_failure = 2 [json_name = "preconditionFailure"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::precondition_failure(this),
        _Internal::precondition_failure(this).GetCachedSize(), target, stream);
  }

  // optional string description = 3 [json_name = "description"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.description");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // repeated string agent_ids = 4 [json_name = "agentIds"];
  for (int i = 0, n = this->_internal_agent_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_agent_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.agent_ids");
    target = stream->WriteString(4, s, target);
  }

  // optional .google.rpc.Code agent_failure_code = 5 [json_name = "agentFailureCode"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_agent_failure_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  return target;
}

::size_t IntentFailure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string agent_ids = 4 [json_name = "agentIds"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_agent_ids().size());
  for (int i = 0, n = _internal_agent_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_agent_ids().Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string description = 3 [json_name = "description"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_description());
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure precondition_failure = 2 [json_name = "preconditionFailure"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.precondition_failure_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure.IntentFailureType type = 1 [json_name = "type"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .google.rpc.Code agent_failure_code = 5 [json_name = "agentFailureCode"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_agent_failure_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntentFailure::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntentFailure::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntentFailure::GetClassData() const { return &_class_data_; }


void IntentFailure::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntentFailure*>(&to_msg);
  auto& from = static_cast<const IntentFailure&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_agent_ids()->MergeFrom(from._internal_agent_ids());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_precondition_failure()->::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure::MergeFrom(
          from._internal_precondition_failure());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.agent_failure_code_ = from._impl_.agent_failure_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntentFailure::CopyFrom(const IntentFailure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentFailure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntentFailure::IsInitialized() const {
  return true;
}

void IntentFailure::InternalSwap(IntentFailure* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_agent_ids()->InternalSwap(
      other->_internal_mutable_agent_ids());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntentFailure, _impl_.agent_failure_code_)
      + sizeof(IntentFailure::_impl_.agent_failure_code_)
      - PROTOBUF_FIELD_OFFSET(IntentFailure, _impl_.precondition_failure_)>(
          reinterpret_cast<char*>(&_impl_.precondition_failure_),
          reinterpret_cast<char*>(&other->_impl_.precondition_failure_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntentFailure::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[7]);
}
// ===================================================================

class IntentWithdrawal::_Internal {
 public:
  using HasBits = decltype(std::declval<IntentWithdrawal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IntentWithdrawal, _impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IntentWithdrawal::IntentWithdrawal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
}
IntentWithdrawal::IntentWithdrawal(const IntentWithdrawal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntentWithdrawal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
}

inline void IntentWithdrawal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_) {}

    , decltype(_impl_.type_) { 0 }

  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IntentWithdrawal::~IntentWithdrawal() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntentWithdrawal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.description_.Destroy();
}

void IntentWithdrawal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntentWithdrawal::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntentWithdrawal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.WithdrawType type = 1 [json_name = "type"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal_WithdrawType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string description = 2 [json_name = "description"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IntentWithdrawal::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.WithdrawType type = 1 [json_name = "type"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // optional string description = 2 [json_name = "description"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_description();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.description");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  return target;
}

::size_t IntentWithdrawal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 2 [json_name = "description"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_description());
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal.WithdrawType type = 1 [json_name = "type"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntentWithdrawal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntentWithdrawal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntentWithdrawal::GetClassData() const { return &_class_data_; }


void IntentWithdrawal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntentWithdrawal*>(&to_msg);
  auto& from = static_cast<const IntentWithdrawal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntentWithdrawal::CopyFrom(const IntentWithdrawal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.IntentWithdrawal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntentWithdrawal::IsInitialized() const {
  return true;
}

void IntentWithdrawal::InternalSwap(IntentWithdrawal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IntentWithdrawal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fintent_2eproto[8]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent_ServiceRequestAndIntervals >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::Intent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::LinkIntent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::RadioIntent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::PathIntent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent_TunnelEndpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelIntent >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentFailure >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::IntentWithdrawal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
