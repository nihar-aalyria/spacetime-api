// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/nbi/v1alpha/resources/service_request.proto

#include "api/nbi/v1alpha/resources/service_request.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
template <typename>
PROTOBUF_CONSTEXPR TunnelConfiguration::TunnelConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_interface_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_interface_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.method_)*/nullptr
  , /*decltype(_impl_.classifier_)*/nullptr} {}
struct TunnelConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TunnelConfigurationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TunnelConfigurationDefaultTypeInternal() {}
  union {
    TunnelConfiguration _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TunnelConfigurationDefaultTypeInternal _TunnelConfiguration_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ServiceRequest_FlowRequirements::ServiceRequest_FlowRequirements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_interval_)*/nullptr
  , /*decltype(_impl_.latency_maximum_)*/nullptr
  , /*decltype(_impl_.bandwidth_bps_minimum_)*/ 0

  , /*decltype(_impl_.bandwidth_bps_requested_)*/ 0

  , /*decltype(_impl_.is_disruption_tolerant_)*/ false
} {}
struct ServiceRequest_FlowRequirementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceRequest_FlowRequirementsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceRequest_FlowRequirementsDefaultTypeInternal() {}
  union {
    ServiceRequest_FlowRequirements _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceRequest_FlowRequirementsDefaultTypeInternal _ServiceRequest_FlowRequirements_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ServiceRequest_RedundancyGroup::ServiceRequest_RedundancyGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct ServiceRequest_RedundancyGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceRequest_RedundancyGroupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceRequest_RedundancyGroupDefaultTypeInternal() {}
  union {
    ServiceRequest_RedundancyGroup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceRequest_RedundancyGroupDefaultTypeInternal _ServiceRequest_RedundancyGroup_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ServiceRequest_IntentAndIntervals::ServiceRequest_IntentAndIntervals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interval_)*/{}
  , /*decltype(_impl_.intent_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct ServiceRequest_IntentAndIntervalsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceRequest_IntentAndIntervalsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceRequest_IntentAndIntervalsDefaultTypeInternal() {}
  union {
    ServiceRequest_IntentAndIntervals _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceRequest_IntentAndIntervalsDefaultTypeInternal _ServiceRequest_IntentAndIntervals_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ServiceRequest::ServiceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.requirements_)*/{}
  , /*decltype(_impl_.tunnels_)*/{}
  , /*decltype(_impl_.intent_dependencies_)*/{}
  , /*decltype(_impl_.provisioned_intervals_)*/{}
  , /*decltype(_impl_.type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.classifier_)*/nullptr
  , /*decltype(_impl_.redundancy_group_)*/nullptr
  , /*decltype(_impl_.priority_)*/ 0

  , /*decltype(_impl_.is_provisioned_now_)*/ false

  , /*decltype(_impl_.flow_type_)*/ 0

  , /*decltype(_impl_.src_type_)*/{}
  , /*decltype(_impl_.dst_type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ServiceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceRequestDefaultTypeInternal() {}
  union {
    ServiceRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DrainProvision::DrainProvision(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.reason_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.opportunistic_start_time_)*/nullptr
  , /*decltype(_impl_.deter_start_time_)*/nullptr
  , /*decltype(_impl_.force_time_)*/nullptr
  , /*decltype(_impl_.create_time_)*/nullptr
  , /*decltype(_impl_.enacting_time_)*/nullptr
  , /*decltype(_impl_.enacted_time_)*/nullptr
  , /*decltype(_impl_.deleting_time_)*/nullptr
  , /*decltype(_impl_.deleted_time_)*/nullptr
  , /*decltype(_impl_.solver_satisfaction_time_)*/nullptr
  , /*decltype(_impl_.state_)*/ 0

  , /*decltype(_impl_.method_)*/ 0

  , /*decltype(_impl_.allow_control_management_for_node_)*/ false
} {}
struct DrainProvisionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrainProvisionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrainProvisionDefaultTypeInternal() {}
  union {
    DrainProvision _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrainProvisionDefaultTypeInternal _DrainProvision_default_instance_;
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
static ::_pb::Metadata file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[6];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto = nullptr;
const ::uint32_t TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _impl_.src_interface_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _impl_.dst_interface_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _impl_.method_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration, _impl_.classifier_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_.time_interval_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_.bandwidth_bps_minimum_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_.bandwidth_bps_requested_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_.latency_maximum_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements, _impl_.is_disruption_tolerant_),
    0,
    2,
    3,
    1,
    4,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup, _impl_.id_),
    0,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals, _impl_.intent_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals, _impl_.interval_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.type_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.classifier_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.tunnels_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.priority_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.flow_type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.requirements_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.redundancy_group_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.is_provisioned_now_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.provisioned_intervals_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.intent_dependencies_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.src_type_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_.dst_type_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
    ~0u,
    3,
    5,
    ~0u,
    2,
    4,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.reason_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.opportunistic_start_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.deter_start_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.force_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.allow_control_management_for_node_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.method_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.create_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.solver_satisfaction_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.enacting_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.enacted_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.deleting_time_),
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision, _impl_.deleted_time_),
    0,
    1,
    11,
    2,
    3,
    4,
    13,
    12,
    5,
    10,
    6,
    7,
    8,
    9,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 12, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration)},
        { 16, 29, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements)},
        { 34, 43, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup)},
        { 44, 54, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals)},
        { 56, 80, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest)},
        { 94, 116, -1, sizeof(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_TunnelConfiguration_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_FlowRequirements_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_RedundancyGroup_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_IntentAndIntervals_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_ServiceRequest_default_instance_._instance,
    &::aalyria::spacetime::api::nbi::v1alpha::resources::_DrainProvision_default_instance_._instance,
};
const char descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n/api/nbi/v1alpha/resources/service_requ"
    "est.proto\022+aalyria.spacetime.api.nbi.v1a"
    "lpha.resources\032\030api/common/network.proto"
    "\032\025api/common/time.proto\032\027api/common/tunn"
    "el.proto\032\036google/protobuf/duration.proto"
    "\032\037google/protobuf/timestamp.proto\032\032googl"
    "e/type/interval.proto\"\205\002\n\023TunnelConfigur"
    "ation\022(\n\020src_interface_id\030\001 \001(\tR\016srcInte"
    "rfaceId\022(\n\020dst_interface_id\030\002 \001(\tR\016dstIn"
    "terfaceId\022B\n\006method\030\003 \001(\0132*.aalyria.spac"
    "etime.api.common.TunnelMethodR\006method\022L\n"
    "\nclassifier\030\004 \001(\0132,.aalyria.spacetime.ap"
    "i.common.FlowClassifierR\nclassifierJ\010\010\005\020"
    "\200\200\200\200\002\"\340\014\n\016ServiceRequest\022\022\n\004type\030\r \001(\tR\004"
    "type\022 \n\013src_node_id\030\002 \001(\tH\000R\tsrcNodeId\0228"
    "\n\030src_devices_in_region_id\030\010 \001(\tH\000R\024srcD"
    "evicesInRegionId\022 \n\013dst_node_id\030\020 \001(\tH\001R"
    "\tdstNodeId\0228\n\030dst_devices_in_region_id\030\022"
    " \001(\tH\001R\024dstDevicesInRegionId\022L\n\nclassifi"
    "er\030\t \001(\0132,.aalyria.spacetime.api.common."
    "FlowClassifierR\nclassifier\022Z\n\007tunnels\030\n "
    "\003(\0132@.aalyria.spacetime.api.nbi.v1alpha."
    "resources.TunnelConfigurationR\007tunnels\022\032"
    "\n\010priority\030\006 \001(\001R\010priority\022a\n\tflow_type\030"
    "\013 \001(\0162D.aalyria.spacetime.api.nbi.v1alph"
    "a.resources.ServiceRequest.FlowTypeR\010flo"
    "wType\022p\n\014requirements\030\004 \003(\0132L.aalyria.sp"
    "acetime.api.nbi.v1alpha.resources.Servic"
    "eRequest.FlowRequirementsR\014requirements\022"
    "v\n\020redundancy_group\030\014 \001(\0132K.aalyria.spac"
    "etime.api.nbi.v1alpha.resources.ServiceR"
    "equest.RedundancyGroupR\017redundancyGroup\022"
    ",\n\022is_provisioned_now\030\005 \001(\010R\020isProvision"
    "edNow\022J\n\025provisioned_intervals\030\017 \003(\0132\025.g"
    "oogle.type.IntervalR\024provisionedInterval"
    "s\022\177\n\023intent_dependencies\030\016 \003(\0132N.aalyria"
    ".spacetime.api.nbi.v1alpha.resources.Ser"
    "viceRequest.IntentAndIntervalsR\022intentDe"
    "pendencies\032\331\002\n\020FlowRequirements\022O\n\rtime_"
    "interval\030\001 \001(\0132*.aalyria.spacetime.api.c"
    "ommon.TimeIntervalR\014timeInterval\0222\n\025band"
    "width_bps_minimum\030\002 \001(\001R\023bandwidthBpsMin"
    "imum\0226\n\027bandwidth_bps_requested\030\003 \001(\001R\025b"
    "andwidthBpsRequested\022B\n\017latency_maximum\030"
    "\005 \001(\0132\031.google.protobuf.DurationR\016latenc"
    "yMaximum\0224\n\026is_disruption_tolerant\030\006 \001(\010"
    "R\024isDisruptionTolerantJ\004\010\004\020\005J\010\010\007\020\200\200\200\200\002\032!"
    "\n\017RedundancyGroup\022\016\n\002id\030\001 \001(\tR\002id\032d\n\022Int"
    "entAndIntervals\022\033\n\tintent_id\030\001 \001(\tR\010inte"
    "ntId\0221\n\010interval\030\002 \003(\0132\025.google.type.Int"
    "ervalR\010interval\"U\n\010FlowType\022\031\n\025FLOW_TYPE"
    "_UNSPECIFIED\020\000\022\032\n\026SDN_CONTROL_MANAGEMENT"
    "\020\001\022\022\n\016SDN_FORWARDING\020\002B\n\n\010src_typeB\n\n\010ds"
    "t_typeJ\004\010\001\020\002J\004\010\003\020\004J\004\010\007\020\010J\004\010\021\020\022J\010\010\023\020\200\200\200\200\002"
    "\"\337\010\n\016DrainProvision\022\027\n\007node_id\030\001 \001(\tR\006no"
    "deId\022\026\n\006reason\030\002 \001(\tR\006reason\022W\n\005state\030\003 "
    "\001(\0162A.aalyria.spacetime.api.nbi.v1alpha."
    "resources.DrainProvision.StateR\005state\022T\n"
    "\030opportunistic_start_time\030\004 \001(\0132\032.google"
    ".protobuf.TimestampR\026opportunisticStartT"
    "ime\022D\n\020deter_start_time\030\005 \001(\0132\032.google.p"
    "rotobuf.TimestampR\016deterStartTime\0229\n\nfor"
    "ce_time\030\006 \001(\0132\032.google.protobuf.Timestam"
    "pR\tforceTime\022H\n!allow_control_management"
    "_for_node\030\010 \001(\010R\035allowControlManagementF"
    "orNode\022Z\n\006method\030\007 \001(\0162B.aalyria.spaceti"
    "me.api.nbi.v1alpha.resources.DrainProvis"
    "ion.MethodR\006method\022;\n\013create_time\030\t \001(\0132"
    "\032.google.protobuf.TimestampR\ncreateTime\022"
    "T\n\030solver_satisfaction_time\030\016 \001(\0132\032.goog"
    "le.protobuf.TimestampR\026solverSatisfactio"
    "nTime\022\?\n\renacting_time\030\n \001(\0132\032.google.pr"
    "otobuf.TimestampR\014enactingTime\022=\n\014enacte"
    "d_time\030\013 \001(\0132\032.google.protobuf.Timestamp"
    "R\013enactedTime\022\?\n\rdeleting_time\030\014 \001(\0132\032.g"
    "oogle.protobuf.TimestampR\014deletingTime\022="
    "\n\014deleted_time\030\r \001(\0132\032.google.protobuf.T"
    "imestampR\013deletedTime\"r\n\005State\022\025\n\021STATE_"
    "UNSPECIFIED\020\000\022\013\n\007PENDING\020\001\022\017\n\013UNSATISFIE"
    "D\020\002\022\014\n\010ENACTING\020\003\022\013\n\007ENACTED\020\004\022\014\n\010DELETI"
    "NG\020\005\022\013\n\007DELETED\020\006\"5\n\006Method\022\026\n\022METHOD_UN"
    "SPECIFIED\020\000\022\010\n\004WAIT\020\001\022\t\n\005FORCE\020\002J\010\010\017\020\200\200\200"
    "\200\002Bb\n/com.aalyria.spacetime.api.nbi.v1al"
    "pha.resourcesZ/aalyria.com/spacetime/api"
    "/nbi/v1alpha/resources"
};
static const ::_pbi::DescriptorTable* const descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_deps[6] =
    {
        &::descriptor_table_api_2fcommon_2fnetwork_2eproto,
        &::descriptor_table_api_2fcommon_2ftime_2eproto,
        &::descriptor_table_api_2fcommon_2ftunnel_2eproto,
        &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
        &::descriptor_table_google_2ftype_2finterval_2eproto,
};
static ::absl::once_flag descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto = {
    false,
    false,
    3382,
    descriptor_table_protodef_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto,
    "api/nbi/v1alpha/resources/service_request.proto",
    &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
    descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_deps,
    6,
    6,
    schemas,
    file_default_instances,
    TableStruct_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto::offsets,
    file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto,
    file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto,
    file_level_service_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter() {
  return &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto);
namespace aalyria {
namespace spacetime {
namespace api {
namespace nbi {
namespace v1alpha {
namespace resources {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceRequest_FlowType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[0];
}
bool ServiceRequest_FlowType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ServiceRequest_FlowType ServiceRequest::FLOW_TYPE_UNSPECIFIED;
constexpr ServiceRequest_FlowType ServiceRequest::SDN_CONTROL_MANAGEMENT;
constexpr ServiceRequest_FlowType ServiceRequest::SDN_FORWARDING;
constexpr ServiceRequest_FlowType ServiceRequest::FlowType_MIN;
constexpr ServiceRequest_FlowType ServiceRequest::FlowType_MAX;
constexpr int ServiceRequest::FlowType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DrainProvision_State_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[1];
}
bool DrainProvision_State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr DrainProvision_State DrainProvision::STATE_UNSPECIFIED;
constexpr DrainProvision_State DrainProvision::PENDING;
constexpr DrainProvision_State DrainProvision::UNSATISFIED;
constexpr DrainProvision_State DrainProvision::ENACTING;
constexpr DrainProvision_State DrainProvision::ENACTED;
constexpr DrainProvision_State DrainProvision::DELETING;
constexpr DrainProvision_State DrainProvision::DELETED;
constexpr DrainProvision_State DrainProvision::State_MIN;
constexpr DrainProvision_State DrainProvision::State_MAX;
constexpr int DrainProvision::State_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DrainProvision_Method_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto);
  return file_level_enum_descriptors_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[2];
}
bool DrainProvision_Method_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr DrainProvision_Method DrainProvision::METHOD_UNSPECIFIED;
constexpr DrainProvision_Method DrainProvision::WAIT;
constexpr DrainProvision_Method DrainProvision::FORCE;
constexpr DrainProvision_Method DrainProvision::Method_MIN;
constexpr DrainProvision_Method DrainProvision::Method_MAX;
constexpr int DrainProvision::Method_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class TunnelConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<TunnelConfiguration>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TunnelConfiguration, _impl_._has_bits_);
  static void set_has_src_interface_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dst_interface_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::aalyria::spacetime::api::common::TunnelMethod& method(const TunnelConfiguration* msg);
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::aalyria::spacetime::api::common::FlowClassifier& classifier(const TunnelConfiguration* msg);
  static void set_has_classifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::aalyria::spacetime::api::common::TunnelMethod&
TunnelConfiguration::_Internal::method(const TunnelConfiguration* msg) {
  return *msg->_impl_.method_;
}
const ::aalyria::spacetime::api::common::FlowClassifier&
TunnelConfiguration::_Internal::classifier(const TunnelConfiguration* msg) {
  return *msg->_impl_.classifier_;
}
void TunnelConfiguration::clear_method() {
  if (_impl_.method_ != nullptr) _impl_.method_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TunnelConfiguration::clear_classifier() {
  if (_impl_.classifier_ != nullptr) _impl_.classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
TunnelConfiguration::TunnelConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
}
TunnelConfiguration::TunnelConfiguration(const TunnelConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TunnelConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_interface_id_) {}

    , decltype(_impl_.dst_interface_id_) {}

    , decltype(_impl_.method_){nullptr}
    , decltype(_impl_.classifier_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.src_interface_id_.Set(from._internal_src_interface_id(), _this->GetArenaForAllocation());
  }
  _impl_.dst_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dst_interface_id_.Set(from._internal_dst_interface_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.method_ = new ::aalyria::spacetime::api::common::TunnelMethod(*from._impl_.method_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.classifier_ = new ::aalyria::spacetime::api::common::FlowClassifier(*from._impl_.classifier_);
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
}

inline void TunnelConfiguration::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_interface_id_) {}

    , decltype(_impl_.dst_interface_id_) {}

    , decltype(_impl_.method_){nullptr}
    , decltype(_impl_.classifier_){nullptr}
  };
  _impl_.src_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_interface_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_interface_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TunnelConfiguration::~TunnelConfiguration() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TunnelConfiguration::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_interface_id_.Destroy();
  _impl_.dst_interface_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.method_;
  if (this != internal_default_instance()) delete _impl_.classifier_;
}

void TunnelConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TunnelConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.src_interface_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dst_interface_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.method_ != nullptr);
      _impl_.method_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.classifier_ != nullptr);
      _impl_.classifier_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TunnelConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string src_interface_id = 1 [json_name = "srcInterfaceId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_interface_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string dst_interface_id = 2 [json_name = "dstInterfaceId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_interface_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.TunnelMethod method = 3 [json_name = "method"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_method(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 4 [json_name = "classifier"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TunnelConfiguration::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string src_interface_id = 1 [json_name = "srcInterfaceId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_src_interface_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.src_interface_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string dst_interface_id = 2 [json_name = "dstInterfaceId"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_dst_interface_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration.dst_interface_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .aalyria.spacetime.api.common.TunnelMethod method = 3 [json_name = "method"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::method(this),
        _Internal::method(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 4 [json_name = "classifier"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  return target;
}

::size_t TunnelConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string src_interface_id = 1 [json_name = "srcInterfaceId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_src_interface_id());
    }

    // optional string dst_interface_id = 2 [json_name = "dstInterfaceId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_dst_interface_id());
    }

    // optional .aalyria.spacetime.api.common.TunnelMethod method = 3 [json_name = "method"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.method_);
    }

    // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 4 [json_name = "classifier"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.classifier_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TunnelConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TunnelConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TunnelConfiguration::GetClassData() const { return &_class_data_; }


void TunnelConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TunnelConfiguration*>(&to_msg);
  auto& from = static_cast<const TunnelConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_src_interface_id(from._internal_src_interface_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dst_interface_id(from._internal_dst_interface_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_method()->::aalyria::spacetime::api::common::TunnelMethod::MergeFrom(
          from._internal_method());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_classifier()->::aalyria::spacetime::api::common::FlowClassifier::MergeFrom(
          from._internal_classifier());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TunnelConfiguration::CopyFrom(const TunnelConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TunnelConfiguration::IsInitialized() const {
  return true;
}

void TunnelConfiguration::InternalSwap(TunnelConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_interface_id_, lhs_arena,
                                       &other->_impl_.src_interface_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_interface_id_, lhs_arena,
                                       &other->_impl_.dst_interface_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TunnelConfiguration, _impl_.classifier_)
      + sizeof(TunnelConfiguration::_impl_.classifier_)
      - PROTOBUF_FIELD_OFFSET(TunnelConfiguration, _impl_.method_)>(
          reinterpret_cast<char*>(&_impl_.method_),
          reinterpret_cast<char*>(&other->_impl_.method_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TunnelConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[0]);
}
// ===================================================================

class ServiceRequest_FlowRequirements::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceRequest_FlowRequirements>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ServiceRequest_FlowRequirements, _impl_._has_bits_);
  static const ::aalyria::spacetime::api::common::TimeInterval& time_interval(const ServiceRequest_FlowRequirements* msg);
  static void set_has_time_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bandwidth_bps_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bandwidth_bps_requested(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Duration& latency_maximum(const ServiceRequest_FlowRequirements* msg);
  static void set_has_latency_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_disruption_tolerant(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::aalyria::spacetime::api::common::TimeInterval&
ServiceRequest_FlowRequirements::_Internal::time_interval(const ServiceRequest_FlowRequirements* msg) {
  return *msg->_impl_.time_interval_;
}
const ::PROTOBUF_NAMESPACE_ID::Duration&
ServiceRequest_FlowRequirements::_Internal::latency_maximum(const ServiceRequest_FlowRequirements* msg) {
  return *msg->_impl_.latency_maximum_;
}
void ServiceRequest_FlowRequirements::clear_time_interval() {
  if (_impl_.time_interval_ != nullptr) _impl_.time_interval_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ServiceRequest_FlowRequirements::clear_latency_maximum() {
  if (_impl_.latency_maximum_ != nullptr) _impl_.latency_maximum_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ServiceRequest_FlowRequirements::ServiceRequest_FlowRequirements(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
}
ServiceRequest_FlowRequirements::ServiceRequest_FlowRequirements(const ServiceRequest_FlowRequirements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceRequest_FlowRequirements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_interval_){nullptr}
    , decltype(_impl_.latency_maximum_){nullptr}
    , decltype(_impl_.bandwidth_bps_minimum_) {}

    , decltype(_impl_.bandwidth_bps_requested_) {}

    , decltype(_impl_.is_disruption_tolerant_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.time_interval_ = new ::aalyria::spacetime::api::common::TimeInterval(*from._impl_.time_interval_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.latency_maximum_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from._impl_.latency_maximum_);
  }
  ::memcpy(&_impl_.bandwidth_bps_minimum_, &from._impl_.bandwidth_bps_minimum_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_disruption_tolerant_) -
    reinterpret_cast<char*>(&_impl_.bandwidth_bps_minimum_)) + sizeof(_impl_.is_disruption_tolerant_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
}

inline void ServiceRequest_FlowRequirements::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_interval_){nullptr}
    , decltype(_impl_.latency_maximum_){nullptr}
    , decltype(_impl_.bandwidth_bps_minimum_) { 0 }

    , decltype(_impl_.bandwidth_bps_requested_) { 0 }

    , decltype(_impl_.is_disruption_tolerant_) { false }

  };
}

ServiceRequest_FlowRequirements::~ServiceRequest_FlowRequirements() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceRequest_FlowRequirements::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.time_interval_;
  if (this != internal_default_instance()) delete _impl_.latency_maximum_;
}

void ServiceRequest_FlowRequirements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceRequest_FlowRequirements::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.time_interval_ != nullptr);
      _impl_.time_interval_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.latency_maximum_ != nullptr);
      _impl_.latency_maximum_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.bandwidth_bps_minimum_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_disruption_tolerant_) -
        reinterpret_cast<char*>(&_impl_.bandwidth_bps_minimum_)) + sizeof(_impl_.is_disruption_tolerant_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceRequest_FlowRequirements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .aalyria.spacetime.api.common.TimeInterval time_interval = 1 [json_name = "timeInterval"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_interval(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double bandwidth_bps_minimum = 2 [json_name = "bandwidthBpsMinimum"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_bandwidth_bps_minimum(&has_bits);
          _impl_.bandwidth_bps_minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double bandwidth_bps_requested = 3 [json_name = "bandwidthBpsRequested"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_bandwidth_bps_requested(&has_bits);
          _impl_.bandwidth_bps_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Duration latency_maximum = 5 [json_name = "latencyMaximum"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_latency_maximum(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_disruption_tolerant = 6 [json_name = "isDisruptionTolerant"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_is_disruption_tolerant(&has_bits);
          _impl_.is_disruption_tolerant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ServiceRequest_FlowRequirements::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .aalyria.spacetime.api.common.TimeInterval time_interval = 1 [json_name = "timeInterval"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::time_interval(this),
        _Internal::time_interval(this).GetCachedSize(), target, stream);
  }

  // optional double bandwidth_bps_minimum = 2 [json_name = "bandwidthBpsMinimum"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_bandwidth_bps_minimum(), target);
  }

  // optional double bandwidth_bps_requested = 3 [json_name = "bandwidthBpsRequested"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_bandwidth_bps_requested(), target);
  }

  // optional .google.protobuf.Duration latency_maximum = 5 [json_name = "latencyMaximum"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::latency_maximum(this),
        _Internal::latency_maximum(this).GetCachedSize(), target, stream);
  }

  // optional bool is_disruption_tolerant = 6 [json_name = "isDisruptionTolerant"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_is_disruption_tolerant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  return target;
}

::size_t ServiceRequest_FlowRequirements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .aalyria.spacetime.api.common.TimeInterval time_interval = 1 [json_name = "timeInterval"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_interval_);
    }

    // optional .google.protobuf.Duration latency_maximum = 5 [json_name = "latencyMaximum"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.latency_maximum_);
    }

    // optional double bandwidth_bps_minimum = 2 [json_name = "bandwidthBpsMinimum"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional double bandwidth_bps_requested = 3 [json_name = "bandwidthBpsRequested"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional bool is_disruption_tolerant = 6 [json_name = "isDisruptionTolerant"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceRequest_FlowRequirements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceRequest_FlowRequirements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceRequest_FlowRequirements::GetClassData() const { return &_class_data_; }


void ServiceRequest_FlowRequirements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceRequest_FlowRequirements*>(&to_msg);
  auto& from = static_cast<const ServiceRequest_FlowRequirements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_time_interval()->::aalyria::spacetime::api::common::TimeInterval::MergeFrom(
          from._internal_time_interval());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_latency_maximum()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(
          from._internal_latency_maximum());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bandwidth_bps_minimum_ = from._impl_.bandwidth_bps_minimum_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bandwidth_bps_requested_ = from._impl_.bandwidth_bps_requested_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_disruption_tolerant_ = from._impl_.is_disruption_tolerant_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceRequest_FlowRequirements::CopyFrom(const ServiceRequest_FlowRequirements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest_FlowRequirements::IsInitialized() const {
  return true;
}

void ServiceRequest_FlowRequirements::InternalSwap(ServiceRequest_FlowRequirements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceRequest_FlowRequirements, _impl_.is_disruption_tolerant_)
      + sizeof(ServiceRequest_FlowRequirements::_impl_.is_disruption_tolerant_)
      - PROTOBUF_FIELD_OFFSET(ServiceRequest_FlowRequirements, _impl_.time_interval_)>(
          reinterpret_cast<char*>(&_impl_.time_interval_),
          reinterpret_cast<char*>(&other->_impl_.time_interval_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceRequest_FlowRequirements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[1]);
}
// ===================================================================

class ServiceRequest_RedundancyGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceRequest_RedundancyGroup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ServiceRequest_RedundancyGroup, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ServiceRequest_RedundancyGroup::ServiceRequest_RedundancyGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
}
ServiceRequest_RedundancyGroup::ServiceRequest_RedundancyGroup(const ServiceRequest_RedundancyGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceRequest_RedundancyGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
}

inline void ServiceRequest_RedundancyGroup::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceRequest_RedundancyGroup::~ServiceRequest_RedundancyGroup() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceRequest_RedundancyGroup::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void ServiceRequest_RedundancyGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceRequest_RedundancyGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceRequest_RedundancyGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ServiceRequest_RedundancyGroup::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1 [json_name = "id"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  return target;
}

::size_t ServiceRequest_RedundancyGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string id = 1 [json_name = "id"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceRequest_RedundancyGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceRequest_RedundancyGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceRequest_RedundancyGroup::GetClassData() const { return &_class_data_; }


void ServiceRequest_RedundancyGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceRequest_RedundancyGroup*>(&to_msg);
  auto& from = static_cast<const ServiceRequest_RedundancyGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceRequest_RedundancyGroup::CopyFrom(const ServiceRequest_RedundancyGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest_RedundancyGroup::IsInitialized() const {
  return true;
}

void ServiceRequest_RedundancyGroup::InternalSwap(ServiceRequest_RedundancyGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceRequest_RedundancyGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[2]);
}
// ===================================================================

class ServiceRequest_IntentAndIntervals::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceRequest_IntentAndIntervals>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ServiceRequest_IntentAndIntervals, _impl_._has_bits_);
  static void set_has_intent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void ServiceRequest_IntentAndIntervals::clear_interval() {
  _internal_mutable_interval()->Clear();
}
ServiceRequest_IntentAndIntervals::ServiceRequest_IntentAndIntervals(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
}
ServiceRequest_IntentAndIntervals::ServiceRequest_IntentAndIntervals(const ServiceRequest_IntentAndIntervals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceRequest_IntentAndIntervals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){from._impl_.interval_}
    , decltype(_impl_.intent_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.intent_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.intent_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.intent_id_.Set(from._internal_intent_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
}

inline void ServiceRequest_IntentAndIntervals::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interval_){arena}
    , decltype(_impl_.intent_id_) {}

  };
  _impl_.intent_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.intent_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceRequest_IntentAndIntervals::~ServiceRequest_IntentAndIntervals() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceRequest_IntentAndIntervals::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_interval()->~RepeatedPtrField();
  _impl_.intent_id_.Destroy();
}

void ServiceRequest_IntentAndIntervals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceRequest_IntentAndIntervals::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_interval()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.intent_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceRequest_IntentAndIntervals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string intent_id = 1 [json_name = "intentId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_intent_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .google.type.Interval interval = 2 [json_name = "interval"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_interval(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ServiceRequest_IntentAndIntervals::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string intent_id = 1 [json_name = "intentId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_intent_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals.intent_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_interval_size()); i < n; i++) {
    const auto& repfield = this->_internal_interval(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  return target;
}

::size_t ServiceRequest_IntentAndIntervals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.type.Interval interval = 2 [json_name = "interval"];
  total_size += 1UL * this->_internal_interval_size();
  for (const auto& msg : this->_internal_interval()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string intent_id = 1 [json_name = "intentId"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_intent_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceRequest_IntentAndIntervals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceRequest_IntentAndIntervals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceRequest_IntentAndIntervals::GetClassData() const { return &_class_data_; }


void ServiceRequest_IntentAndIntervals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceRequest_IntentAndIntervals*>(&to_msg);
  auto& from = static_cast<const ServiceRequest_IntentAndIntervals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_interval()->MergeFrom(from._internal_interval());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_intent_id(from._internal_intent_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceRequest_IntentAndIntervals::CopyFrom(const ServiceRequest_IntentAndIntervals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest_IntentAndIntervals::IsInitialized() const {
  return true;
}

void ServiceRequest_IntentAndIntervals::InternalSwap(ServiceRequest_IntentAndIntervals* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_interval()->InternalSwap(other->_internal_mutable_interval());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.intent_id_, lhs_arena,
                                       &other->_impl_.intent_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceRequest_IntentAndIntervals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[3]);
}
// ===================================================================

class ServiceRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ServiceRequest, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest, _impl_._oneof_case_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::aalyria::spacetime::api::common::FlowClassifier& classifier(const ServiceRequest* msg);
  static void set_has_classifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flow_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup& redundancy_group(const ServiceRequest* msg);
  static void set_has_redundancy_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_provisioned_now(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::aalyria::spacetime::api::common::FlowClassifier&
ServiceRequest::_Internal::classifier(const ServiceRequest* msg) {
  return *msg->_impl_.classifier_;
}
const ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup&
ServiceRequest::_Internal::redundancy_group(const ServiceRequest* msg) {
  return *msg->_impl_.redundancy_group_;
}
void ServiceRequest::clear_classifier() {
  if (_impl_.classifier_ != nullptr) _impl_.classifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ServiceRequest::clear_provisioned_intervals() {
  _internal_mutable_provisioned_intervals()->Clear();
}
ServiceRequest::ServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
}
ServiceRequest::ServiceRequest(const ServiceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requirements_){from._impl_.requirements_}
    , decltype(_impl_.tunnels_){from._impl_.tunnels_}
    , decltype(_impl_.intent_dependencies_){from._impl_.intent_dependencies_}
    , decltype(_impl_.provisioned_intervals_){from._impl_.provisioned_intervals_}
    , decltype(_impl_.type_) {}

    , decltype(_impl_.classifier_){nullptr}
    , decltype(_impl_.redundancy_group_){nullptr}
    , decltype(_impl_.priority_) {}

    , decltype(_impl_.is_provisioned_now_) {}

    , decltype(_impl_.flow_type_) {}

    , decltype(_impl_.src_type_){}
    , decltype(_impl_.dst_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.type_.Set(from._internal_type(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.classifier_ = new ::aalyria::spacetime::api::common::FlowClassifier(*from._impl_.classifier_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.redundancy_group_ = new ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup(*from._impl_.redundancy_group_);
  }
  ::memcpy(&_impl_.priority_, &from._impl_.priority_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.flow_type_) -
    reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.flow_type_));
  clear_has_src_type();
  switch (from.src_type_case()) {
    case kSrcNodeId: {
      _this->_internal_set_src_node_id(from._internal_src_node_id());
      break;
    }
    case kSrcDevicesInRegionId: {
      _this->_internal_set_src_devices_in_region_id(from._internal_src_devices_in_region_id());
      break;
    }
    case SRC_TYPE_NOT_SET: {
      break;
    }
  }
  clear_has_dst_type();
  switch (from.dst_type_case()) {
    case kDstNodeId: {
      _this->_internal_set_dst_node_id(from._internal_dst_node_id());
      break;
    }
    case kDstDevicesInRegionId: {
      _this->_internal_set_dst_devices_in_region_id(from._internal_dst_devices_in_region_id());
      break;
    }
    case DST_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
}

inline void ServiceRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requirements_){arena}
    , decltype(_impl_.tunnels_){arena}
    , decltype(_impl_.intent_dependencies_){arena}
    , decltype(_impl_.provisioned_intervals_){arena}
    , decltype(_impl_.type_) {}

    , decltype(_impl_.classifier_){nullptr}
    , decltype(_impl_.redundancy_group_){nullptr}
    , decltype(_impl_.priority_) { 0 }

    , decltype(_impl_.is_provisioned_now_) { false }

    , decltype(_impl_.flow_type_) { 0 }

    , decltype(_impl_.src_type_){}
    , decltype(_impl_.dst_type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_src_type();
  clear_has_dst_type();
}

ServiceRequest::~ServiceRequest() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_requirements()->~RepeatedPtrField();
  _internal_mutable_tunnels()->~RepeatedPtrField();
  _internal_mutable_intent_dependencies()->~RepeatedPtrField();
  _internal_mutable_provisioned_intervals()->~RepeatedPtrField();
  _impl_.type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.classifier_;
  if (this != internal_default_instance()) delete _impl_.redundancy_group_;
  if (has_src_type()) {
    clear_src_type();
  }
  if (has_dst_type()) {
    clear_dst_type();
  }
}

void ServiceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceRequest::clear_src_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  switch (src_type_case()) {
    case kSrcNodeId: {
      _impl_.src_type_.src_node_id_.Destroy();
      break;
    }
    case kSrcDevicesInRegionId: {
      _impl_.src_type_.src_devices_in_region_id_.Destroy();
      break;
    }
    case SRC_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SRC_TYPE_NOT_SET;
}

void ServiceRequest::clear_dst_type() {
// @@protoc_insertion_point(one_of_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  switch (dst_type_case()) {
    case kDstNodeId: {
      _impl_.dst_type_.dst_node_id_.Destroy();
      break;
    }
    case kDstDevicesInRegionId: {
      _impl_.dst_type_.dst_devices_in_region_id_.Destroy();
      break;
    }
    case DST_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = DST_TYPE_NOT_SET;
}


void ServiceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_requirements()->Clear();
  _internal_mutable_tunnels()->Clear();
  _internal_mutable_intent_dependencies()->Clear();
  _internal_mutable_provisioned_intervals()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.classifier_ != nullptr);
      _impl_.classifier_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.redundancy_group_ != nullptr);
      _impl_.redundancy_group_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.priority_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flow_type_) -
        reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.flow_type_));
  }
  clear_src_type();
  clear_dst_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string src_node_id = 2 [json_name = "srcNodeId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_src_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements requirements = 4 [json_name = "requirements"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requirements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_provisioned_now = 5 [json_name = "isProvisionedNow"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_is_provisioned_now(&has_bits);
          _impl_.is_provisioned_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double priority = 6 [json_name = "priority"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 49)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // string src_devices_in_region_id = 8 [json_name = "srcDevicesInRegionId"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_src_devices_in_region_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 9 [json_name = "classifier"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_classifier(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration tunnels = 10 [json_name = "tunnels"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tunnels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowType flow_type = 11 [json_name = "flowType"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType_IsValid(static_cast<int>(val)))) {
            _internal_set_flow_type(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup redundancy_group = 12 [json_name = "redundancyGroup"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_redundancy_group(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string type = 13 [json_name = "type"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals intent_dependencies = 14 [json_name = "intentDependencies"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intent_dependencies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .google.type.Interval provisioned_intervals = 15 [json_name = "provisionedIntervals"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_provisioned_intervals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_node_id = 16 [json_name = "dstNodeId"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_dst_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_devices_in_region_id = 18 [json_name = "dstDevicesInRegionId"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_dst_devices_in_region_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ServiceRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string src_node_id = 2 [json_name = "srcNodeId"];
  if (src_type_case() == kSrcNodeId) {
    const std::string& _s = this->_internal_src_node_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_node_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements requirements = 4 [json_name = "requirements"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requirements_size()); i < n; i++) {
    const auto& repfield = this->_internal_requirements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_provisioned_now = 5 [json_name = "isProvisionedNow"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_is_provisioned_now(), target);
  }

  // optional double priority = 6 [json_name = "priority"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_priority(), target);
  }

  // string src_devices_in_region_id = 8 [json_name = "srcDevicesInRegionId"];
  if (src_type_case() == kSrcDevicesInRegionId) {
    const std::string& _s = this->_internal_src_devices_in_region_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.src_devices_in_region_id");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 9 [json_name = "classifier"];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::classifier(this),
        _Internal::classifier(this).GetCachedSize(), target, stream);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration tunnels = 10 [json_name = "tunnels"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tunnels_size()); i < n; i++) {
    const auto& repfield = this->_internal_tunnels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowType flow_type = 11 [json_name = "flowType"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        11, this->_internal_flow_type(), target);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup redundancy_group = 12 [json_name = "redundancyGroup"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::redundancy_group(this),
        _Internal::redundancy_group(this).GetCachedSize(), target, stream);
  }

  // optional string type = 13 [json_name = "type"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.type");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals intent_dependencies = 14 [json_name = "intentDependencies"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_intent_dependencies_size()); i < n; i++) {
    const auto& repfield = this->_internal_intent_dependencies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.type.Interval provisioned_intervals = 15 [json_name = "provisionedIntervals"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_provisioned_intervals_size()); i < n; i++) {
    const auto& repfield = this->_internal_provisioned_intervals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  switch (dst_type_case()) {
    case kDstNodeId: {
      const std::string& _s = this->_internal_dst_node_id();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_node_id");
      target = stream->WriteStringMaybeAliased(16, _s, target);
      break;
    }
    case kDstDevicesInRegionId: {
      const std::string& _s = this->_internal_dst_devices_in_region_id();
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                  "aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.dst_devices_in_region_id");
      target = stream->WriteStringMaybeAliased(18, _s, target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  return target;
}

::size_t ServiceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowRequirements requirements = 4 [json_name = "requirements"];
  total_size += 1UL * this->_internal_requirements_size();
  for (const auto& msg : this->_internal_requirements()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.TunnelConfiguration tunnels = 10 [json_name = "tunnels"];
  total_size += 1UL * this->_internal_tunnels_size();
  for (const auto& msg : this->_internal_tunnels()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.IntentAndIntervals intent_dependencies = 14 [json_name = "intentDependencies"];
  total_size += 1UL * this->_internal_intent_dependencies_size();
  for (const auto& msg : this->_internal_intent_dependencies()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.type.Interval provisioned_intervals = 15 [json_name = "provisionedIntervals"];
  total_size += 1UL * this->_internal_provisioned_intervals_size();
  for (const auto& msg : this->_internal_provisioned_intervals()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string type = 13 [json_name = "type"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_type());
    }

    // optional .aalyria.spacetime.api.common.FlowClassifier classifier = 9 [json_name = "classifier"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.classifier_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.RedundancyGroup redundancy_group = 12 [json_name = "redundancyGroup"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.redundancy_group_);
    }

    // optional double priority = 6 [json_name = "priority"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 9;
    }

    // optional bool is_provisioned_now = 5 [json_name = "isProvisionedNow"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest.FlowType flow_type = 11 [json_name = "flowType"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_flow_type());
    }

  }
  switch (src_type_case()) {
    // string src_node_id = 2 [json_name = "srcNodeId"];
    case kSrcNodeId: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_src_node_id());
      break;
    }
    // string src_devices_in_region_id = 8 [json_name = "srcDevicesInRegionId"];
    case kSrcDevicesInRegionId: {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_src_devices_in_region_id());
      break;
    }
    case SRC_TYPE_NOT_SET: {
      break;
    }
  }
  switch (dst_type_case()) {
    // string dst_node_id = 16 [json_name = "dstNodeId"];
    case kDstNodeId: {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_dst_node_id());
      break;
    }
    // string dst_devices_in_region_id = 18 [json_name = "dstDevicesInRegionId"];
    case kDstDevicesInRegionId: {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_dst_devices_in_region_id());
      break;
    }
    case DST_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceRequest::GetClassData() const { return &_class_data_; }


void ServiceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceRequest*>(&to_msg);
  auto& from = static_cast<const ServiceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_requirements()->MergeFrom(from._internal_requirements());
  _this->_internal_mutable_tunnels()->MergeFrom(from._internal_tunnels());
  _this->_internal_mutable_intent_dependencies()->MergeFrom(from._internal_intent_dependencies());
  _this->_internal_mutable_provisioned_intervals()->MergeFrom(from._internal_provisioned_intervals());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_classifier()->::aalyria::spacetime::api::common::FlowClassifier::MergeFrom(
          from._internal_classifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redundancy_group()->::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup::MergeFrom(
          from._internal_redundancy_group());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_provisioned_now_ = from._impl_.is_provisioned_now_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.flow_type_ = from._impl_.flow_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.src_type_case()) {
    case kSrcNodeId: {
      _this->_internal_set_src_node_id(from._internal_src_node_id());
      break;
    }
    case kSrcDevicesInRegionId: {
      _this->_internal_set_src_devices_in_region_id(from._internal_src_devices_in_region_id());
      break;
    }
    case SRC_TYPE_NOT_SET: {
      break;
    }
  }
  switch (from.dst_type_case()) {
    case kDstNodeId: {
      _this->_internal_set_dst_node_id(from._internal_dst_node_id());
      break;
    }
    case kDstDevicesInRegionId: {
      _this->_internal_set_dst_devices_in_region_id(from._internal_dst_devices_in_region_id());
      break;
    }
    case DST_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceRequest::CopyFrom(const ServiceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.ServiceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest::IsInitialized() const {
  return true;
}

void ServiceRequest::InternalSwap(ServiceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_requirements()->InternalSwap(other->_internal_mutable_requirements());
  _internal_mutable_tunnels()->InternalSwap(other->_internal_mutable_tunnels());
  _internal_mutable_intent_dependencies()->InternalSwap(other->_internal_mutable_intent_dependencies());
  _internal_mutable_provisioned_intervals()->InternalSwap(other->_internal_mutable_provisioned_intervals());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.type_, lhs_arena,
                                       &other->_impl_.type_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceRequest, _impl_.flow_type_)
      + sizeof(ServiceRequest::_impl_.flow_type_)
      - PROTOBUF_FIELD_OFFSET(ServiceRequest, _impl_.classifier_)>(
          reinterpret_cast<char*>(&_impl_.classifier_),
          reinterpret_cast<char*>(&other->_impl_.classifier_));
  swap(_impl_.src_type_, other->_impl_.src_type_);
  swap(_impl_.dst_type_, other->_impl_.dst_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[4]);
}
// ===================================================================

class DrainProvision::_Internal {
 public:
  using HasBits = decltype(std::declval<DrainProvision>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DrainProvision, _impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& opportunistic_start_time(const DrainProvision* msg);
  static void set_has_opportunistic_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& deter_start_time(const DrainProvision* msg);
  static void set_has_deter_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& force_time(const DrainProvision* msg);
  static void set_has_force_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_allow_control_management_for_node(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time(const DrainProvision* msg);
  static void set_has_create_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& solver_satisfaction_time(const DrainProvision* msg);
  static void set_has_solver_satisfaction_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& enacting_time(const DrainProvision* msg);
  static void set_has_enacting_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& enacted_time(const DrainProvision* msg);
  static void set_has_enacted_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleting_time(const DrainProvision* msg);
  static void set_has_deleting_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_time(const DrainProvision* msg);
  static void set_has_deleted_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::opportunistic_start_time(const DrainProvision* msg) {
  return *msg->_impl_.opportunistic_start_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::deter_start_time(const DrainProvision* msg) {
  return *msg->_impl_.deter_start_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::force_time(const DrainProvision* msg) {
  return *msg->_impl_.force_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::create_time(const DrainProvision* msg) {
  return *msg->_impl_.create_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::solver_satisfaction_time(const DrainProvision* msg) {
  return *msg->_impl_.solver_satisfaction_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::enacting_time(const DrainProvision* msg) {
  return *msg->_impl_.enacting_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::enacted_time(const DrainProvision* msg) {
  return *msg->_impl_.enacted_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::deleting_time(const DrainProvision* msg) {
  return *msg->_impl_.deleting_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DrainProvision::_Internal::deleted_time(const DrainProvision* msg) {
  return *msg->_impl_.deleted_time_;
}
void DrainProvision::clear_opportunistic_start_time() {
  if (_impl_.opportunistic_start_time_ != nullptr) _impl_.opportunistic_start_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrainProvision::clear_deter_start_time() {
  if (_impl_.deter_start_time_ != nullptr) _impl_.deter_start_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DrainProvision::clear_force_time() {
  if (_impl_.force_time_ != nullptr) _impl_.force_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void DrainProvision::clear_create_time() {
  if (_impl_.create_time_ != nullptr) _impl_.create_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void DrainProvision::clear_solver_satisfaction_time() {
  if (_impl_.solver_satisfaction_time_ != nullptr) _impl_.solver_satisfaction_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void DrainProvision::clear_enacting_time() {
  if (_impl_.enacting_time_ != nullptr) _impl_.enacting_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void DrainProvision::clear_enacted_time() {
  if (_impl_.enacted_time_ != nullptr) _impl_.enacted_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void DrainProvision::clear_deleting_time() {
  if (_impl_.deleting_time_ != nullptr) _impl_.deleting_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void DrainProvision::clear_deleted_time() {
  if (_impl_.deleted_time_ != nullptr) _impl_.deleted_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
DrainProvision::DrainProvision(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
}
DrainProvision::DrainProvision(const DrainProvision& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrainProvision* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.reason_) {}

    , decltype(_impl_.opportunistic_start_time_){nullptr}
    , decltype(_impl_.deter_start_time_){nullptr}
    , decltype(_impl_.force_time_){nullptr}
    , decltype(_impl_.create_time_){nullptr}
    , decltype(_impl_.enacting_time_){nullptr}
    , decltype(_impl_.enacted_time_){nullptr}
    , decltype(_impl_.deleting_time_){nullptr}
    , decltype(_impl_.deleted_time_){nullptr}
    , decltype(_impl_.solver_satisfaction_time_){nullptr}
    , decltype(_impl_.state_) {}

    , decltype(_impl_.method_) {}

    , decltype(_impl_.allow_control_management_for_node_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.node_id_.Set(from._internal_node_id(), _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.reason_.Set(from._internal_reason(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.opportunistic_start_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.opportunistic_start_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.deter_start_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.deter_start_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.force_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.force_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.create_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.create_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.enacting_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.enacting_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000080u) != 0) {
    _this->_impl_.enacted_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.enacted_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000100u) != 0) {
    _this->_impl_.deleting_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.deleting_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000200u) != 0) {
    _this->_impl_.deleted_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.deleted_time_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000400u) != 0) {
    _this->_impl_.solver_satisfaction_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.solver_satisfaction_time_);
  }
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.allow_control_management_for_node_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.allow_control_management_for_node_));
  // @@protoc_insertion_point(copy_constructor:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
}

inline void DrainProvision::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.reason_) {}

    , decltype(_impl_.opportunistic_start_time_){nullptr}
    , decltype(_impl_.deter_start_time_){nullptr}
    , decltype(_impl_.force_time_){nullptr}
    , decltype(_impl_.create_time_){nullptr}
    , decltype(_impl_.enacting_time_){nullptr}
    , decltype(_impl_.enacted_time_){nullptr}
    , decltype(_impl_.deleting_time_){nullptr}
    , decltype(_impl_.deleted_time_){nullptr}
    , decltype(_impl_.solver_satisfaction_time_){nullptr}
    , decltype(_impl_.state_) { 0 }

    , decltype(_impl_.method_) { 0 }

    , decltype(_impl_.allow_control_management_for_node_) { false }

  };
  _impl_.node_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DrainProvision::~DrainProvision() {
  // @@protoc_insertion_point(destructor:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrainProvision::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_id_.Destroy();
  _impl_.reason_.Destroy();
  if (this != internal_default_instance()) delete _impl_.opportunistic_start_time_;
  if (this != internal_default_instance()) delete _impl_.deter_start_time_;
  if (this != internal_default_instance()) delete _impl_.force_time_;
  if (this != internal_default_instance()) delete _impl_.create_time_;
  if (this != internal_default_instance()) delete _impl_.enacting_time_;
  if (this != internal_default_instance()) delete _impl_.enacted_time_;
  if (this != internal_default_instance()) delete _impl_.deleting_time_;
  if (this != internal_default_instance()) delete _impl_.deleted_time_;
  if (this != internal_default_instance()) delete _impl_.solver_satisfaction_time_;
}

void DrainProvision::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrainProvision::Clear() {
// @@protoc_insertion_point(message_clear_start:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.node_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.opportunistic_start_time_ != nullptr);
      _impl_.opportunistic_start_time_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.deter_start_time_ != nullptr);
      _impl_.deter_start_time_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.force_time_ != nullptr);
      _impl_.force_time_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.create_time_ != nullptr);
      _impl_.create_time_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.enacting_time_ != nullptr);
      _impl_.enacting_time_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.enacted_time_ != nullptr);
      _impl_.enacted_time_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.deleting_time_ != nullptr);
      _impl_.deleting_time_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(_impl_.deleted_time_ != nullptr);
      _impl_.deleted_time_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      ABSL_DCHECK(_impl_.solver_satisfaction_time_ != nullptr);
      _impl_.solver_satisfaction_time_->Clear();
    }
  }
  if (cached_has_bits & 0x00003800u) {
    ::memset(&_impl_.state_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.allow_control_management_for_node_) -
        reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.allow_control_management_for_node_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrainProvision::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string node_id = 1 [json_name = "nodeId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_node_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string reason = 2 [json_name = "reason"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.State state = 3 [json_name = "state"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State_IsValid(static_cast<int>(val)))) {
            _internal_set_state(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_State>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp opportunistic_start_time = 4 [json_name = "opportunisticStartTime"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_opportunistic_start_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp deter_start_time = 5 [json_name = "deterStartTime"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_deter_start_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp force_time = 6 [json_name = "forceTime"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_force_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.Method method = 7 [json_name = "method"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method_IsValid(static_cast<int>(val)))) {
            _internal_set_method(static_cast<::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision_Method>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool allow_control_management_for_node = 8 [json_name = "allowControlManagementForNode"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_allow_control_management_for_node(&has_bits);
          _impl_.allow_control_management_for_node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp create_time = 9 [json_name = "createTime"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp enacting_time = 10 [json_name = "enactingTime"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_enacting_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp enacted_time = 11 [json_name = "enactedTime"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_enacted_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp deleting_time = 12 [json_name = "deletingTime"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleting_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp deleted_time = 13 [json_name = "deletedTime"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleted_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .google.protobuf.Timestamp solver_satisfaction_time = 14 [json_name = "solverSatisfactionTime"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_solver_satisfaction_time(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DrainProvision::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string node_id = 1 [json_name = "nodeId"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_node_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.node_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string reason = 2 [json_name = "reason"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_reason();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.reason");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.State state = 3 [json_name = "state"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_state(), target);
  }

  // optional .google.protobuf.Timestamp opportunistic_start_time = 4 [json_name = "opportunisticStartTime"];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::opportunistic_start_time(this),
        _Internal::opportunistic_start_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp deter_start_time = 5 [json_name = "deterStartTime"];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::deter_start_time(this),
        _Internal::deter_start_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp force_time = 6 [json_name = "forceTime"];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::force_time(this),
        _Internal::force_time(this).GetCachedSize(), target, stream);
  }

  // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.Method method = 7 [json_name = "method"];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_method(), target);
  }

  // optional bool allow_control_management_for_node = 8 [json_name = "allowControlManagementForNode"];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_allow_control_management_for_node(), target);
  }

  // optional .google.protobuf.Timestamp create_time = 9 [json_name = "createTime"];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::create_time(this),
        _Internal::create_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp enacting_time = 10 [json_name = "enactingTime"];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::enacting_time(this),
        _Internal::enacting_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp enacted_time = 11 [json_name = "enactedTime"];
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::enacted_time(this),
        _Internal::enacted_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp deleting_time = 12 [json_name = "deletingTime"];
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::deleting_time(this),
        _Internal::deleting_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp deleted_time = 13 [json_name = "deletedTime"];
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::deleted_time(this),
        _Internal::deleted_time(this).GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Timestamp solver_satisfaction_time = 14 [json_name = "solverSatisfactionTime"];
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::solver_satisfaction_time(this),
        _Internal::solver_satisfaction_time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  return target;
}

::size_t DrainProvision::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string node_id = 1 [json_name = "nodeId"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_node_id());
    }

    // optional string reason = 2 [json_name = "reason"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_reason());
    }

    // optional .google.protobuf.Timestamp opportunistic_start_time = 4 [json_name = "opportunisticStartTime"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.opportunistic_start_time_);
    }

    // optional .google.protobuf.Timestamp deter_start_time = 5 [json_name = "deterStartTime"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deter_start_time_);
    }

    // optional .google.protobuf.Timestamp force_time = 6 [json_name = "forceTime"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.force_time_);
    }

    // optional .google.protobuf.Timestamp create_time = 9 [json_name = "createTime"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.create_time_);
    }

    // optional .google.protobuf.Timestamp enacting_time = 10 [json_name = "enactingTime"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.enacting_time_);
    }

    // optional .google.protobuf.Timestamp enacted_time = 11 [json_name = "enactedTime"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.enacted_time_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .google.protobuf.Timestamp deleting_time = 12 [json_name = "deletingTime"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deleting_time_);
    }

    // optional .google.protobuf.Timestamp deleted_time = 13 [json_name = "deletedTime"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deleted_time_);
    }

    // optional .google.protobuf.Timestamp solver_satisfaction_time = 14 [json_name = "solverSatisfactionTime"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.solver_satisfaction_time_);
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.State state = 3 [json_name = "state"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional .aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision.Method method = 7 [json_name = "method"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_method());
    }

    // optional bool allow_control_management_for_node = 8 [json_name = "allowControlManagementForNode"];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrainProvision::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrainProvision::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrainProvision::GetClassData() const { return &_class_data_; }


void DrainProvision::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrainProvision*>(&to_msg);
  auto& from = static_cast<const DrainProvision&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_node_id(from._internal_node_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_opportunistic_start_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_opportunistic_start_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_deter_start_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_deter_start_time());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_force_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_force_time());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_create_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_create_time());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_enacting_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_enacting_time());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_enacted_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_enacted_time());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_deleting_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_deleting_time());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_deleted_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_deleted_time());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_solver_satisfaction_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
          from._internal_solver_satisfaction_time());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.method_ = from._impl_.method_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.allow_control_management_for_node_ = from._impl_.allow_control_management_for_node_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrainProvision::CopyFrom(const DrainProvision& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aalyria.spacetime.api.nbi.v1alpha.resources.DrainProvision)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrainProvision::IsInitialized() const {
  return true;
}

void DrainProvision::InternalSwap(DrainProvision* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.node_id_, lhs_arena,
                                       &other->_impl_.node_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, lhs_arena,
                                       &other->_impl_.reason_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrainProvision, _impl_.allow_control_management_for_node_)
      + sizeof(DrainProvision::_impl_.allow_control_management_for_node_)
      - PROTOBUF_FIELD_OFFSET(DrainProvision, _impl_.opportunistic_start_time_)>(
          reinterpret_cast<char*>(&_impl_.opportunistic_start_time_),
          reinterpret_cast<char*>(&other->_impl_.opportunistic_start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrainProvision::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_getter, &descriptor_table_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto_once,
      file_level_metadata_api_2fnbi_2fv1alpha_2fresources_2fservice_5frequest_2eproto[5]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace resources
}  // namespace v1alpha
}  // namespace nbi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::TunnelConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_FlowRequirements >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_RedundancyGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest_IntentAndIntervals >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::ServiceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision*
Arena::CreateMaybeMessage< ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision >(Arena* arena) {
  return Arena::CreateMessageInternal< ::aalyria::spacetime::api::nbi::v1alpha::resources::DrainProvision >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
