// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/cdpi/v1alpha/cdpi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fcdpi_2fv1alpha_2fcdpi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fcdpi_2fv1alpha_2fcdpi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "api/common/control.pb.h"
#include "api/common/coordinates.pb.h"
#include "api/common/telemetry.pb.h"
#include "api/common/wireless_propagation.pb.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fcdpi_2fv1alpha_2fcdpi_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
namespace aalyria {
namespace spacetime {
namespace api {
namespace cdpi {
namespace v1alpha {
class CdpiNodeStateRequest;
struct CdpiNodeStateRequestDefaultTypeInternal;
extern CdpiNodeStateRequestDefaultTypeInternal _CdpiNodeStateRequest_default_instance_;
class CdpiRequest;
struct CdpiRequestDefaultTypeInternal;
extern CdpiRequestDefaultTypeInternal _CdpiRequest_default_instance_;
class CdpiRequestStatusRequest;
struct CdpiRequestStatusRequestDefaultTypeInternal;
extern CdpiRequestStatusRequestDefaultTypeInternal _CdpiRequestStatusRequest_default_instance_;
class CdpiRequest_Hello;
struct CdpiRequest_HelloDefaultTypeInternal;
extern CdpiRequest_HelloDefaultTypeInternal _CdpiRequest_Hello_default_instance_;
class CdpiRequest_Response;
struct CdpiRequest_ResponseDefaultTypeInternal;
extern CdpiRequest_ResponseDefaultTypeInternal _CdpiRequest_Response_default_instance_;
class CdpiResponse;
struct CdpiResponseDefaultTypeInternal;
extern CdpiResponseDefaultTypeInternal _CdpiResponse_default_instance_;
class ControlPlanePingRequest;
struct ControlPlanePingRequestDefaultTypeInternal;
extern ControlPlanePingRequestDefaultTypeInternal _ControlPlanePingRequest_default_instance_;
class ControlPlanePingResponse;
struct ControlPlanePingResponseDefaultTypeInternal;
extern ControlPlanePingResponseDefaultTypeInternal _ControlPlanePingResponse_default_instance_;
class ControlStateChangeRequest;
struct ControlStateChangeRequestDefaultTypeInternal;
extern ControlStateChangeRequestDefaultTypeInternal _ControlStateChangeRequest_default_instance_;
class ControlStateNotification;
struct ControlStateNotificationDefaultTypeInternal;
extern ControlStateNotificationDefaultTypeInternal _ControlStateNotification_default_instance_;
class SensorWeatherData;
struct SensorWeatherDataDefaultTypeInternal;
extern SensorWeatherDataDefaultTypeInternal _SensorWeatherData_default_instance_;
class TelemetryRequest;
struct TelemetryRequestDefaultTypeInternal;
extern TelemetryRequestDefaultTypeInternal _TelemetryRequest_default_instance_;
class TelemetryUpdate;
struct TelemetryUpdateDefaultTypeInternal;
extern TelemetryUpdateDefaultTypeInternal _TelemetryUpdate_default_instance_;
}  // namespace v1alpha
}  // namespace cdpi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria
PROTOBUF_NAMESPACE_OPEN
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiNodeStateRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiNodeStateRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequestStatusRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequestStatusRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::CdpiResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiResponse>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::ControlStateChangeRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::ControlStateChangeRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::ControlStateNotification* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::ControlStateNotification>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::SensorWeatherData* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::SensorWeatherData>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::TelemetryRequest* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::TelemetryRequest>(Arena*);
template <>
::aalyria::spacetime::api::cdpi::v1alpha::TelemetryUpdate* Arena::CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::TelemetryUpdate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace aalyria {
namespace spacetime {
namespace api {
namespace cdpi {
namespace v1alpha {

// ===================================================================


// -------------------------------------------------------------------

class ControlPlanePingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest) */ {
 public:
  inline ControlPlanePingRequest() : ControlPlanePingRequest(nullptr) {}
  ~ControlPlanePingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlPlanePingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlPlanePingRequest(const ControlPlanePingRequest& from);
  ControlPlanePingRequest(ControlPlanePingRequest&& from) noexcept
    : ControlPlanePingRequest() {
    *this = ::std::move(from);
  }

  inline ControlPlanePingRequest& operator=(const ControlPlanePingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPlanePingRequest& operator=(ControlPlanePingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlPlanePingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlPlanePingRequest* internal_default_instance() {
    return reinterpret_cast<const ControlPlanePingRequest*>(
               &_ControlPlanePingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ControlPlanePingRequest& a, ControlPlanePingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPlanePingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlPlanePingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlPlanePingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlPlanePingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlPlanePingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlPlanePingRequest& from) {
    ControlPlanePingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPlanePingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest";
  }
  protected:
  explicit ControlPlanePingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional int64 id = 1 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class ControlPlanePingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse) */ {
 public:
  inline ControlPlanePingResponse() : ControlPlanePingResponse(nullptr) {}
  ~ControlPlanePingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlPlanePingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlPlanePingResponse(const ControlPlanePingResponse& from);
  ControlPlanePingResponse(ControlPlanePingResponse&& from) noexcept
    : ControlPlanePingResponse() {
    *this = ::std::move(from);
  }

  inline ControlPlanePingResponse& operator=(const ControlPlanePingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPlanePingResponse& operator=(ControlPlanePingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlPlanePingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlPlanePingResponse* internal_default_instance() {
    return reinterpret_cast<const ControlPlanePingResponse*>(
               &_ControlPlanePingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ControlPlanePingResponse& a, ControlPlanePingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPlanePingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlPlanePingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlPlanePingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlPlanePingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlPlanePingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlPlanePingResponse& from) {
    ControlPlanePingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPlanePingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse";
  }
  protected:
  explicit ControlPlanePingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeOfReceiptFieldNumber = 2,
    kStatusFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // optional .google.protobuf.Timestamp time_of_receipt = 2 [json_name = "timeOfReceipt"];
  bool has_time_of_receipt() const;
  void clear_time_of_receipt() ;
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time_of_receipt() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time_of_receipt();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time_of_receipt();
  void set_allocated_time_of_receipt(::PROTOBUF_NAMESPACE_ID::Timestamp* time_of_receipt);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time_of_receipt() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time_of_receipt();
  public:
  void unsafe_arena_set_allocated_time_of_receipt(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time_of_receipt);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time_of_receipt();
  // optional .google.rpc.Status status = 3 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();
  // optional int64 id = 1 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_of_receipt_;
    ::google::rpc::Status* status_;
    ::int64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class ControlStateChangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest) */ {
 public:
  inline ControlStateChangeRequest() : ControlStateChangeRequest(nullptr) {}
  ~ControlStateChangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlStateChangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlStateChangeRequest(const ControlStateChangeRequest& from);
  ControlStateChangeRequest(ControlStateChangeRequest&& from) noexcept
    : ControlStateChangeRequest() {
    *this = ::std::move(from);
  }

  inline ControlStateChangeRequest& operator=(const ControlStateChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlStateChangeRequest& operator=(ControlStateChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlStateChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kScheduledUpdate = 1,
    kScheduledDeletion = 2,
    kControlPlanePingRequest = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const ControlStateChangeRequest* internal_default_instance() {
    return reinterpret_cast<const ControlStateChangeRequest*>(
               &_ControlStateChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ControlStateChangeRequest& a, ControlStateChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlStateChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlStateChangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlStateChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlStateChangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlStateChangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlStateChangeRequest& from) {
    ControlStateChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlStateChangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest";
  }
  protected:
  explicit ControlStateChangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduledUpdateFieldNumber = 1,
    kScheduledDeletionFieldNumber = 2,
    kControlPlanePingRequestFieldNumber = 3,
  };
  // .aalyria.spacetime.api.common.ScheduledControlUpdate scheduled_update = 1 [json_name = "scheduledUpdate"];
  bool has_scheduled_update() const;
  private:
  bool _internal_has_scheduled_update() const;

  public:
  void clear_scheduled_update() ;
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& scheduled_update() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ScheduledControlUpdate* release_scheduled_update();
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* mutable_scheduled_update();
  void set_allocated_scheduled_update(::aalyria::spacetime::api::common::ScheduledControlUpdate* scheduled_update);
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdate& _internal_scheduled_update() const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _internal_mutable_scheduled_update();
  public:
  void unsafe_arena_set_allocated_scheduled_update(
      ::aalyria::spacetime::api::common::ScheduledControlUpdate* scheduled_update);
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* unsafe_arena_release_scheduled_update();
  // .aalyria.spacetime.api.common.ScheduledControlDeletion scheduled_deletion = 2 [json_name = "scheduledDeletion"];
  bool has_scheduled_deletion() const;
  private:
  bool _internal_has_scheduled_deletion() const;

  public:
  void clear_scheduled_deletion() ;
  const ::aalyria::spacetime::api::common::ScheduledControlDeletion& scheduled_deletion() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ScheduledControlDeletion* release_scheduled_deletion();
  ::aalyria::spacetime::api::common::ScheduledControlDeletion* mutable_scheduled_deletion();
  void set_allocated_scheduled_deletion(::aalyria::spacetime::api::common::ScheduledControlDeletion* scheduled_deletion);
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlDeletion& _internal_scheduled_deletion() const;
  ::aalyria::spacetime::api::common::ScheduledControlDeletion* _internal_mutable_scheduled_deletion();
  public:
  void unsafe_arena_set_allocated_scheduled_deletion(
      ::aalyria::spacetime::api::common::ScheduledControlDeletion* scheduled_deletion);
  ::aalyria::spacetime::api::common::ScheduledControlDeletion* unsafe_arena_release_scheduled_deletion();
  // .aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest control_plane_ping_request = 3 [json_name = "controlPlanePingRequest"];
  bool has_control_plane_ping_request() const;
  private:
  bool _internal_has_control_plane_ping_request() const;

  public:
  void clear_control_plane_ping_request() ;
  const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest& control_plane_ping_request() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* release_control_plane_ping_request();
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* mutable_control_plane_ping_request();
  void set_allocated_control_plane_ping_request(::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* control_plane_ping_request);
  private:
  const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest& _internal_control_plane_ping_request() const;
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* _internal_mutable_control_plane_ping_request();
  public:
  void unsafe_arena_set_allocated_control_plane_ping_request(
      ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* control_plane_ping_request);
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* unsafe_arena_release_control_plane_ping_request();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest)
 private:
  class _Internal;
  void set_has_scheduled_update();
  void set_has_scheduled_deletion();
  void set_has_control_plane_ping_request();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::ScheduledControlUpdate* scheduled_update_;
      ::aalyria::spacetime::api::common::ScheduledControlDeletion* scheduled_deletion_;
      ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* control_plane_ping_request_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class ControlStateNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification) */ {
 public:
  inline ControlStateNotification() : ControlStateNotification(nullptr) {}
  ~ControlStateNotification() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlStateNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlStateNotification(const ControlStateNotification& from);
  ControlStateNotification(ControlStateNotification&& from) noexcept
    : ControlStateNotification() {
    *this = ::std::move(from);
  }

  inline ControlStateNotification& operator=(const ControlStateNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlStateNotification& operator=(ControlStateNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlStateNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlStateNotification* internal_default_instance() {
    return reinterpret_cast<const ControlStateNotification*>(
               &_ControlStateNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ControlStateNotification& a, ControlStateNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlStateNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlStateNotification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlStateNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlStateNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlStateNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlStateNotification& from) {
    ControlStateNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlStateNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification";
  }
  protected:
  explicit ControlStateNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusesFieldNumber = 2,
    kNodeIdFieldNumber = 1,
    kStateFieldNumber = 3,
    kControlPlanePingResponseFieldNumber = 5,
    kPriorityFieldNumber = 4,
  };
  // repeated .aalyria.spacetime.api.common.ScheduledControlUpdateStatus statuses = 2 [json_name = "statuses"];
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;

  public:
  void clear_statuses() ;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* mutable_statuses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus >*
      mutable_statuses();
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& _internal_statuses(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* _internal_add_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>& _internal_statuses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>* _internal_mutable_statuses();
  public:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& statuses(int index) const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* add_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus >&
      statuses() const;
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional .aalyria.spacetime.api.common.ControlPlaneState state = 3 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  const ::aalyria::spacetime::api::common::ControlPlaneState& state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ControlPlaneState* release_state();
  ::aalyria::spacetime::api::common::ControlPlaneState* mutable_state();
  void set_allocated_state(::aalyria::spacetime::api::common::ControlPlaneState* state);
  private:
  const ::aalyria::spacetime::api::common::ControlPlaneState& _internal_state() const;
  ::aalyria::spacetime::api::common::ControlPlaneState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::aalyria::spacetime::api::common::ControlPlaneState* state);
  ::aalyria::spacetime::api::common::ControlPlaneState* unsafe_arena_release_state();
  // optional .aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse control_plane_ping_response = 5 [json_name = "controlPlanePingResponse"];
  bool has_control_plane_ping_response() const;
  void clear_control_plane_ping_response() ;
  const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse& control_plane_ping_response() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* release_control_plane_ping_response();
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* mutable_control_plane_ping_response();
  void set_allocated_control_plane_ping_response(::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* control_plane_ping_response);
  private:
  const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse& _internal_control_plane_ping_response() const;
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* _internal_mutable_control_plane_ping_response();
  public:
  void unsafe_arena_set_allocated_control_plane_ping_response(
      ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* control_plane_ping_response);
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* unsafe_arena_release_control_plane_ping_response();
  // optional uint32 priority = 4 [default = 0, json_name = "priority"];
  bool has_priority() const;
  void clear_priority() ;
  ::uint32_t priority() const;
  void set_priority(::uint32_t value);

  private:
  ::uint32_t _internal_priority() const;
  void _internal_set_priority(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus > statuses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::aalyria::spacetime::api::common::ControlPlaneState* state_;
    ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* control_plane_ping_response_;
    ::uint32_t priority_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class TelemetryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest) */ {
 public:
  inline TelemetryRequest() : TelemetryRequest(nullptr) {}
  ~TelemetryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TelemetryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryRequest(const TelemetryRequest& from);
  TelemetryRequest(TelemetryRequest&& from) noexcept
    : TelemetryRequest() {
    *this = ::std::move(from);
  }

  inline TelemetryRequest& operator=(const TelemetryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryRequest& operator=(TelemetryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TelemetryRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kQueryStatistics = 2,
    kStatisticsPublishRateHz = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const TelemetryRequest* internal_default_instance() {
    return reinterpret_cast<const TelemetryRequest*>(
               &_TelemetryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TelemetryRequest& a, TelemetryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TelemetryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TelemetryRequest& from) {
    TelemetryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest";
  }
  protected:
  explicit TelemetryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kQueryStatisticsFieldNumber = 2,
    kStatisticsPublishRateHzFieldNumber = 3,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // .google.protobuf.Empty query_statistics = 2 [json_name = "queryStatistics"];
  bool has_query_statistics() const;
  private:
  bool _internal_has_query_statistics() const;

  public:
  void clear_query_statistics() ;
  const ::PROTOBUF_NAMESPACE_ID::Empty& query_statistics() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_query_statistics();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_query_statistics();
  void set_allocated_query_statistics(::PROTOBUF_NAMESPACE_ID::Empty* query_statistics);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_query_statistics() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_query_statistics();
  public:
  void unsafe_arena_set_allocated_query_statistics(
      ::PROTOBUF_NAMESPACE_ID::Empty* query_statistics);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_query_statistics();
  // double statistics_publish_rate_hz = 3 [json_name = "statisticsPublishRateHz"];
  bool has_statistics_publish_rate_hz() const;
  void clear_statistics_publish_rate_hz() ;
  double statistics_publish_rate_hz() const;
  void set_statistics_publish_rate_hz(double value);

  private:
  double _internal_statistics_publish_rate_hz() const;
  void _internal_set_statistics_publish_rate_hz(double value);

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest)
 private:
  class _Internal;
  void set_has_query_statistics();
  void set_has_statistics_publish_rate_hz();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Empty* query_statistics_;
      double statistics_publish_rate_hz_;
    } type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class TelemetryUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate) */ {
 public:
  inline TelemetryUpdate() : TelemetryUpdate(nullptr) {}
  ~TelemetryUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TelemetryUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryUpdate(const TelemetryUpdate& from);
  TelemetryUpdate(TelemetryUpdate&& from) noexcept
    : TelemetryUpdate() {
    *this = ::std::move(from);
  }

  inline TelemetryUpdate& operator=(const TelemetryUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryUpdate& operator=(TelemetryUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TelemetryUpdate& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kStatistics = 2,
    kEvent = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const TelemetryUpdate* internal_default_instance() {
    return reinterpret_cast<const TelemetryUpdate*>(
               &_TelemetryUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TelemetryUpdate& a, TelemetryUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TelemetryUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TelemetryUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TelemetryUpdate& from) {
    TelemetryUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate";
  }
  protected:
  explicit TelemetryUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kStatisticsFieldNumber = 2,
    kEventFieldNumber = 3,
  };
  // optional string node_id = 1 [json_name = "nodeId", deprecated = true];
  [[deprecated]]  bool has_node_id() const;
  [[deprecated]]  void clear_node_id() ;
  [[deprecated]] const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_node_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_node_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_node_id();
  [[deprecated]] void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // .aalyria.spacetime.api.common.NetworkStatsReport statistics = 2 [json_name = "statistics"];
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;

  public:
  void clear_statistics() ;
  const ::aalyria::spacetime::api::common::NetworkStatsReport& statistics() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkStatsReport* release_statistics();
  ::aalyria::spacetime::api::common::NetworkStatsReport* mutable_statistics();
  void set_allocated_statistics(::aalyria::spacetime::api::common::NetworkStatsReport* statistics);
  private:
  const ::aalyria::spacetime::api::common::NetworkStatsReport& _internal_statistics() const;
  ::aalyria::spacetime::api::common::NetworkStatsReport* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::aalyria::spacetime::api::common::NetworkStatsReport* statistics);
  ::aalyria::spacetime::api::common::NetworkStatsReport* unsafe_arena_release_statistics();
  // .aalyria.spacetime.api.common.NetworkEventReport event = 3 [json_name = "event"];
  bool has_event() const;
  private:
  bool _internal_has_event() const;

  public:
  void clear_event() ;
  const ::aalyria::spacetime::api::common::NetworkEventReport& event() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::NetworkEventReport* release_event();
  ::aalyria::spacetime::api::common::NetworkEventReport* mutable_event();
  void set_allocated_event(::aalyria::spacetime::api::common::NetworkEventReport* event);
  private:
  const ::aalyria::spacetime::api::common::NetworkEventReport& _internal_event() const;
  ::aalyria::spacetime::api::common::NetworkEventReport* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::aalyria::spacetime::api::common::NetworkEventReport* event);
  ::aalyria::spacetime::api::common::NetworkEventReport* unsafe_arena_release_event();
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate)
 private:
  class _Internal;
  void set_has_statistics();
  void set_has_event();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::aalyria::spacetime::api::common::NetworkStatsReport* statistics_;
      ::aalyria::spacetime::api::common::NetworkEventReport* event_;
    } type_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class SensorWeatherData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData) */ {
 public:
  inline SensorWeatherData() : SensorWeatherData(nullptr) {}
  ~SensorWeatherData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorWeatherData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorWeatherData(const SensorWeatherData& from);
  SensorWeatherData(SensorWeatherData&& from) noexcept
    : SensorWeatherData() {
    *this = ::std::move(from);
  }

  inline SensorWeatherData& operator=(const SensorWeatherData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorWeatherData& operator=(SensorWeatherData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorWeatherData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorWeatherData* internal_default_instance() {
    return reinterpret_cast<const SensorWeatherData*>(
               &_SensorWeatherData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SensorWeatherData& a, SensorWeatherData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorWeatherData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorWeatherData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorWeatherData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorWeatherData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorWeatherData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorWeatherData& from) {
    SensorWeatherData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorWeatherData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData";
  }
  protected:
  explicit SensorWeatherData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeatherDataFieldNumber = 3,
    kLocationFieldNumber = 4,
  };
  // optional .aalyria.spacetime.api.common.WeatherDataForecast weather_data = 3 [json_name = "weatherData"];
  bool has_weather_data() const;
  void clear_weather_data() ;
  const ::aalyria::spacetime::api::common::WeatherDataForecast& weather_data() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::WeatherDataForecast* release_weather_data();
  ::aalyria::spacetime::api::common::WeatherDataForecast* mutable_weather_data();
  void set_allocated_weather_data(::aalyria::spacetime::api::common::WeatherDataForecast* weather_data);
  private:
  const ::aalyria::spacetime::api::common::WeatherDataForecast& _internal_weather_data() const;
  ::aalyria::spacetime::api::common::WeatherDataForecast* _internal_mutable_weather_data();
  public:
  void unsafe_arena_set_allocated_weather_data(
      ::aalyria::spacetime::api::common::WeatherDataForecast* weather_data);
  ::aalyria::spacetime::api::common::WeatherDataForecast* unsafe_arena_release_weather_data();
  // optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 4 [json_name = "location"];
  bool has_location() const;
  void clear_location() ;
  const ::aalyria::spacetime::api::common::GeodeticWgs84& location() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::GeodeticWgs84* release_location();
  ::aalyria::spacetime::api::common::GeodeticWgs84* mutable_location();
  void set_allocated_location(::aalyria::spacetime::api::common::GeodeticWgs84* location);
  private:
  const ::aalyria::spacetime::api::common::GeodeticWgs84& _internal_location() const;
  ::aalyria::spacetime::api::common::GeodeticWgs84* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::aalyria::spacetime::api::common::GeodeticWgs84* location);
  ::aalyria::spacetime::api::common::GeodeticWgs84* unsafe_arena_release_location();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::common::WeatherDataForecast* weather_data_;
    ::aalyria::spacetime::api::common::GeodeticWgs84* location_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiNodeStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest) */ {
 public:
  inline CdpiNodeStateRequest() : CdpiNodeStateRequest(nullptr) {}
  ~CdpiNodeStateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiNodeStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiNodeStateRequest(const CdpiNodeStateRequest& from);
  CdpiNodeStateRequest(CdpiNodeStateRequest&& from) noexcept
    : CdpiNodeStateRequest() {
    *this = ::std::move(from);
  }

  inline CdpiNodeStateRequest& operator=(const CdpiNodeStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiNodeStateRequest& operator=(CdpiNodeStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiNodeStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiNodeStateRequest* internal_default_instance() {
    return reinterpret_cast<const CdpiNodeStateRequest*>(
               &_CdpiNodeStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CdpiNodeStateRequest& a, CdpiNodeStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiNodeStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiNodeStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiNodeStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiNodeStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiNodeStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiNodeStateRequest& from) {
    CdpiNodeStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiNodeStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest";
  }
  protected:
  explicit CdpiNodeStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kStateFieldNumber = 3,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional .aalyria.spacetime.api.common.ControlPlaneState state = 3 [json_name = "state"];
  bool has_state() const;
  void clear_state() ;
  const ::aalyria::spacetime::api::common::ControlPlaneState& state() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ControlPlaneState* release_state();
  ::aalyria::spacetime::api::common::ControlPlaneState* mutable_state();
  void set_allocated_state(::aalyria::spacetime::api::common::ControlPlaneState* state);
  private:
  const ::aalyria::spacetime::api::common::ControlPlaneState& _internal_state() const;
  ::aalyria::spacetime::api::common::ControlPlaneState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::aalyria::spacetime::api::common::ControlPlaneState* state);
  ::aalyria::spacetime::api::common::ControlPlaneState* unsafe_arena_release_state();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::aalyria::spacetime::api::common::ControlPlaneState* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiRequestStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest) */ {
 public:
  inline CdpiRequestStatusRequest() : CdpiRequestStatusRequest(nullptr) {}
  ~CdpiRequestStatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiRequestStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiRequestStatusRequest(const CdpiRequestStatusRequest& from);
  CdpiRequestStatusRequest(CdpiRequestStatusRequest&& from) noexcept
    : CdpiRequestStatusRequest() {
    *this = ::std::move(from);
  }

  inline CdpiRequestStatusRequest& operator=(const CdpiRequestStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiRequestStatusRequest& operator=(CdpiRequestStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiRequestStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiRequestStatusRequest* internal_default_instance() {
    return reinterpret_cast<const CdpiRequestStatusRequest*>(
               &_CdpiRequestStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CdpiRequestStatusRequest& a, CdpiRequestStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiRequestStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiRequestStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiRequestStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiRequestStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiRequestStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiRequestStatusRequest& from) {
    CdpiRequestStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiRequestStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest";
  }
  protected:
  explicit CdpiRequestStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional .aalyria.spacetime.api.common.ScheduledControlUpdateStatus status = 2 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& status() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* release_status();
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* mutable_status();
  void set_allocated_status(::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* status);
  private:
  const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& _internal_status() const;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* status);
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* unsafe_arena_release_status();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiRequest_Hello final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello) */ {
 public:
  inline CdpiRequest_Hello() : CdpiRequest_Hello(nullptr) {}
  ~CdpiRequest_Hello() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiRequest_Hello(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiRequest_Hello(const CdpiRequest_Hello& from);
  CdpiRequest_Hello(CdpiRequest_Hello&& from) noexcept
    : CdpiRequest_Hello() {
    *this = ::std::move(from);
  }

  inline CdpiRequest_Hello& operator=(const CdpiRequest_Hello& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiRequest_Hello& operator=(CdpiRequest_Hello&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiRequest_Hello& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiRequest_Hello* internal_default_instance() {
    return reinterpret_cast<const CdpiRequest_Hello*>(
               &_CdpiRequest_Hello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CdpiRequest_Hello& a, CdpiRequest_Hello& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiRequest_Hello* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiRequest_Hello* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiRequest_Hello* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiRequest_Hello>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiRequest_Hello& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiRequest_Hello& from) {
    CdpiRequest_Hello::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiRequest_Hello* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello";
  }
  protected:
  explicit CdpiRequest_Hello(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kChannelPriorityFieldNumber = 2,
  };
  // optional string node_id = 1 [json_name = "nodeId"];
  bool has_node_id() const;
  void clear_node_id() ;
  const std::string& node_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* ptr);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // optional uint32 channel_priority = 2 [json_name = "channelPriority"];
  bool has_channel_priority() const;
  void clear_channel_priority() ;
  ::uint32_t channel_priority() const;
  void set_channel_priority(::uint32_t value);

  private:
  ::uint32_t _internal_channel_priority() const;
  void _internal_set_channel_priority(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::uint32_t channel_priority_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiRequest_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response) */ {
 public:
  inline CdpiRequest_Response() : CdpiRequest_Response(nullptr) {}
  ~CdpiRequest_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiRequest_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiRequest_Response(const CdpiRequest_Response& from);
  CdpiRequest_Response(CdpiRequest_Response&& from) noexcept
    : CdpiRequest_Response() {
    *this = ::std::move(from);
  }

  inline CdpiRequest_Response& operator=(const CdpiRequest_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiRequest_Response& operator=(CdpiRequest_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiRequest_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiRequest_Response* internal_default_instance() {
    return reinterpret_cast<const CdpiRequest_Response*>(
               &_CdpiRequest_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CdpiRequest_Response& a, CdpiRequest_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiRequest_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiRequest_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiRequest_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiRequest_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiRequest_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiRequest_Response& from) {
    CdpiRequest_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiRequest_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response";
  }
  protected:
  explicit CdpiRequest_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kStatusFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // optional bytes payload = 3 [json_name = "payload"];
  bool has_payload() const;
  void clear_payload() ;
  const std::string& payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* ptr);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // optional .google.rpc.Status status = 2 [json_name = "status"];
  bool has_status() const;
  void clear_status() ;
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();
  // optional int64 request_id = 1 [json_name = "requestId"];
  bool has_request_id() const;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::google::rpc::Status* status_;
    ::int64_t request_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest) */ {
 public:
  inline CdpiRequest() : CdpiRequest(nullptr) {}
  ~CdpiRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiRequest(const CdpiRequest& from);
  CdpiRequest(CdpiRequest&& from) noexcept
    : CdpiRequest() {
    *this = ::std::move(from);
  }

  inline CdpiRequest& operator=(const CdpiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiRequest& operator=(CdpiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiRequest* internal_default_instance() {
    return reinterpret_cast<const CdpiRequest*>(
               &_CdpiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CdpiRequest& a, CdpiRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiRequest& from) {
    CdpiRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest";
  }
  protected:
  explicit CdpiRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CdpiRequest_Hello Hello;
  typedef CdpiRequest_Response Response;

  // accessors -------------------------------------------------------

  enum : int {
    kHelloFieldNumber = 1,
    kResponseFieldNumber = 2,
  };
  // optional .aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello hello = 1 [json_name = "hello"];
  bool has_hello() const;
  void clear_hello() ;
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello& hello() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* release_hello();
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* mutable_hello();
  void set_allocated_hello(::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* hello);
  private:
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello& _internal_hello() const;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* _internal_mutable_hello();
  public:
  void unsafe_arena_set_allocated_hello(
      ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* hello);
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* unsafe_arena_release_hello();
  // optional .aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response response = 2 [json_name = "response"];
  bool has_response() const;
  void clear_response() ;
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response& response() const;
  PROTOBUF_NODISCARD ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* release_response();
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* mutable_response();
  void set_allocated_response(::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* response);
  private:
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response& _internal_response() const;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* response);
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* unsafe_arena_release_response();
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* hello_;
    ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};// -------------------------------------------------------------------

class CdpiResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse) */ {
 public:
  inline CdpiResponse() : CdpiResponse(nullptr) {}
  ~CdpiResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CdpiResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CdpiResponse(const CdpiResponse& from);
  CdpiResponse(CdpiResponse&& from) noexcept
    : CdpiResponse() {
    *this = ::std::move(from);
  }

  inline CdpiResponse& operator=(const CdpiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdpiResponse& operator=(CdpiResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CdpiResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CdpiResponse* internal_default_instance() {
    return reinterpret_cast<const CdpiResponse*>(
               &_CdpiResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CdpiResponse& a, CdpiResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CdpiResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CdpiResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CdpiResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CdpiResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CdpiResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CdpiResponse& from) {
    CdpiResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CdpiResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse";
  }
  protected:
  explicit CdpiResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestPayloadFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // optional bytes request_payload = 2 [json_name = "requestPayload"];
  bool has_request_payload() const;
  void clear_request_payload() ;
  const std::string& request_payload() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_payload(Arg_&& arg, Args_... args);
  std::string* mutable_request_payload();
  PROTOBUF_NODISCARD std::string* release_request_payload();
  void set_allocated_request_payload(std::string* ptr);

  private:
  const std::string& _internal_request_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_payload(
      const std::string& value);
  std::string* _internal_mutable_request_payload();

  public:
  // optional int64 request_id = 1 [json_name = "requestId"];
  bool has_request_id() const;
  void clear_request_id() ;
  ::int64_t request_id() const;
  void set_request_id(::int64_t value);

  private:
  ::int64_t _internal_request_id() const;
  void _internal_set_request_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_payload_;
    ::int64_t request_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fcdpi_2fv1alpha_2fcdpi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ControlPlanePingRequest

// optional int64 id = 1 [json_name = "id"];
inline bool ControlPlanePingRequest::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ControlPlanePingRequest::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t ControlPlanePingRequest::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest.id)
  return _internal_id();
}
inline void ControlPlanePingRequest::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest.id)
}
inline ::int64_t ControlPlanePingRequest::_internal_id() const {
  return _impl_.id_;
}
inline void ControlPlanePingRequest::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// ControlPlanePingResponse

// optional int64 id = 1 [json_name = "id"];
inline bool ControlPlanePingResponse::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ControlPlanePingResponse::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t ControlPlanePingResponse::id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.id)
  return _internal_id();
}
inline void ControlPlanePingResponse::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.id)
}
inline ::int64_t ControlPlanePingResponse::_internal_id() const {
  return _impl_.id_;
}
inline void ControlPlanePingResponse::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}

// optional .google.rpc.Status status = 3 [json_name = "status"];
inline bool ControlPlanePingResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& ControlPlanePingResponse::_internal_status() const {
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ControlPlanePingResponse::status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.status)
  return _internal_status();
}
inline void ControlPlanePingResponse::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.status)
}
inline ::google::rpc::Status* ControlPlanePingResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* ControlPlanePingResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* ControlPlanePingResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* ControlPlanePingResponse::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.status)
  return _msg;
}
inline void ControlPlanePingResponse::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.status)
}

// optional .google.protobuf.Timestamp time_of_receipt = 2 [json_name = "timeOfReceipt"];
inline bool ControlPlanePingResponse::has_time_of_receipt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_of_receipt_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ControlPlanePingResponse::_internal_time_of_receipt() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_of_receipt_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ControlPlanePingResponse::time_of_receipt() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.time_of_receipt)
  return _internal_time_of_receipt();
}
inline void ControlPlanePingResponse::unsafe_arena_set_allocated_time_of_receipt(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_of_receipt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_of_receipt_);
  }
  _impl_.time_of_receipt_ = time_of_receipt;
  if (time_of_receipt) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.time_of_receipt)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ControlPlanePingResponse::release_time_of_receipt() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_of_receipt_;
  _impl_.time_of_receipt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ControlPlanePingResponse::unsafe_arena_release_time_of_receipt() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.time_of_receipt)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_of_receipt_;
  _impl_.time_of_receipt_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ControlPlanePingResponse::_internal_mutable_time_of_receipt() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.time_of_receipt_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_of_receipt_ = p;
  }
  return _impl_.time_of_receipt_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ControlPlanePingResponse::mutable_time_of_receipt() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time_of_receipt();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.time_of_receipt)
  return _msg;
}
inline void ControlPlanePingResponse::set_allocated_time_of_receipt(::PROTOBUF_NAMESPACE_ID::Timestamp* time_of_receipt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_of_receipt_);
  }
  if (time_of_receipt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_of_receipt));
    if (message_arena != submessage_arena) {
      time_of_receipt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_of_receipt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.time_of_receipt_ = time_of_receipt;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse.time_of_receipt)
}

// -------------------------------------------------------------------

// ControlStateChangeRequest

// .aalyria.spacetime.api.common.ScheduledControlUpdate scheduled_update = 1 [json_name = "scheduledUpdate"];
inline bool ControlStateChangeRequest::has_scheduled_update() const {
  return type_case() == kScheduledUpdate;
}
inline bool ControlStateChangeRequest::_internal_has_scheduled_update() const {
  return type_case() == kScheduledUpdate;
}
inline void ControlStateChangeRequest::set_has_scheduled_update() {
  _impl_._oneof_case_[0] = kScheduledUpdate;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ControlStateChangeRequest::release_scheduled_update() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_update)
  if (type_case() == kScheduledUpdate) {
    clear_has_type();
    ::aalyria::spacetime::api::common::ScheduledControlUpdate* temp = _impl_.type_.scheduled_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.scheduled_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& ControlStateChangeRequest::_internal_scheduled_update() const {
  return type_case() == kScheduledUpdate
      ? *_impl_.type_.scheduled_update_
      : reinterpret_cast<::aalyria::spacetime::api::common::ScheduledControlUpdate&>(::aalyria::spacetime::api::common::_ScheduledControlUpdate_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdate& ControlStateChangeRequest::scheduled_update() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_update)
  return _internal_scheduled_update();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ControlStateChangeRequest::unsafe_arena_release_scheduled_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_update)
  if (type_case() == kScheduledUpdate) {
    clear_has_type();
    ::aalyria::spacetime::api::common::ScheduledControlUpdate* temp = _impl_.type_.scheduled_update_;
    _impl_.type_.scheduled_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlStateChangeRequest::unsafe_arena_set_allocated_scheduled_update(::aalyria::spacetime::api::common::ScheduledControlUpdate* scheduled_update) {
  clear_type();
  if (scheduled_update) {
    set_has_scheduled_update();
    _impl_.type_.scheduled_update_ = scheduled_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_update)
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ControlStateChangeRequest::_internal_mutable_scheduled_update() {
  if (type_case() != kScheduledUpdate) {
    clear_type();
    set_has_scheduled_update();
    _impl_.type_.scheduled_update_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::ScheduledControlUpdate >(GetArenaForAllocation());
  }
  return _impl_.type_.scheduled_update_;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdate* ControlStateChangeRequest::mutable_scheduled_update() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdate* _msg = _internal_mutable_scheduled_update();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_update)
  return _msg;
}

// .aalyria.spacetime.api.common.ScheduledControlDeletion scheduled_deletion = 2 [json_name = "scheduledDeletion"];
inline bool ControlStateChangeRequest::has_scheduled_deletion() const {
  return type_case() == kScheduledDeletion;
}
inline bool ControlStateChangeRequest::_internal_has_scheduled_deletion() const {
  return type_case() == kScheduledDeletion;
}
inline void ControlStateChangeRequest::set_has_scheduled_deletion() {
  _impl_._oneof_case_[0] = kScheduledDeletion;
}
inline ::aalyria::spacetime::api::common::ScheduledControlDeletion* ControlStateChangeRequest::release_scheduled_deletion() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_deletion)
  if (type_case() == kScheduledDeletion) {
    clear_has_type();
    ::aalyria::spacetime::api::common::ScheduledControlDeletion* temp = _impl_.type_.scheduled_deletion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.scheduled_deletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::ScheduledControlDeletion& ControlStateChangeRequest::_internal_scheduled_deletion() const {
  return type_case() == kScheduledDeletion
      ? *_impl_.type_.scheduled_deletion_
      : reinterpret_cast<::aalyria::spacetime::api::common::ScheduledControlDeletion&>(::aalyria::spacetime::api::common::_ScheduledControlDeletion_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlDeletion& ControlStateChangeRequest::scheduled_deletion() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_deletion)
  return _internal_scheduled_deletion();
}
inline ::aalyria::spacetime::api::common::ScheduledControlDeletion* ControlStateChangeRequest::unsafe_arena_release_scheduled_deletion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_deletion)
  if (type_case() == kScheduledDeletion) {
    clear_has_type();
    ::aalyria::spacetime::api::common::ScheduledControlDeletion* temp = _impl_.type_.scheduled_deletion_;
    _impl_.type_.scheduled_deletion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlStateChangeRequest::unsafe_arena_set_allocated_scheduled_deletion(::aalyria::spacetime::api::common::ScheduledControlDeletion* scheduled_deletion) {
  clear_type();
  if (scheduled_deletion) {
    set_has_scheduled_deletion();
    _impl_.type_.scheduled_deletion_ = scheduled_deletion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_deletion)
}
inline ::aalyria::spacetime::api::common::ScheduledControlDeletion* ControlStateChangeRequest::_internal_mutable_scheduled_deletion() {
  if (type_case() != kScheduledDeletion) {
    clear_type();
    set_has_scheduled_deletion();
    _impl_.type_.scheduled_deletion_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::ScheduledControlDeletion >(GetArenaForAllocation());
  }
  return _impl_.type_.scheduled_deletion_;
}
inline ::aalyria::spacetime::api::common::ScheduledControlDeletion* ControlStateChangeRequest::mutable_scheduled_deletion() {
  ::aalyria::spacetime::api::common::ScheduledControlDeletion* _msg = _internal_mutable_scheduled_deletion();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.scheduled_deletion)
  return _msg;
}

// .aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingRequest control_plane_ping_request = 3 [json_name = "controlPlanePingRequest"];
inline bool ControlStateChangeRequest::has_control_plane_ping_request() const {
  return type_case() == kControlPlanePingRequest;
}
inline bool ControlStateChangeRequest::_internal_has_control_plane_ping_request() const {
  return type_case() == kControlPlanePingRequest;
}
inline void ControlStateChangeRequest::set_has_control_plane_ping_request() {
  _impl_._oneof_case_[0] = kControlPlanePingRequest;
}
inline void ControlStateChangeRequest::clear_control_plane_ping_request() {
  if (type_case() == kControlPlanePingRequest) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.control_plane_ping_request_;
    }
    clear_has_type();
  }
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* ControlStateChangeRequest::release_control_plane_ping_request() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.control_plane_ping_request)
  if (type_case() == kControlPlanePingRequest) {
    clear_has_type();
    ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* temp = _impl_.type_.control_plane_ping_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.control_plane_ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest& ControlStateChangeRequest::_internal_control_plane_ping_request() const {
  return type_case() == kControlPlanePingRequest
      ? *_impl_.type_.control_plane_ping_request_
      : reinterpret_cast<::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest&>(::aalyria::spacetime::api::cdpi::v1alpha::_ControlPlanePingRequest_default_instance_);
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest& ControlStateChangeRequest::control_plane_ping_request() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.control_plane_ping_request)
  return _internal_control_plane_ping_request();
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* ControlStateChangeRequest::unsafe_arena_release_control_plane_ping_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.control_plane_ping_request)
  if (type_case() == kControlPlanePingRequest) {
    clear_has_type();
    ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* temp = _impl_.type_.control_plane_ping_request_;
    _impl_.type_.control_plane_ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlStateChangeRequest::unsafe_arena_set_allocated_control_plane_ping_request(::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* control_plane_ping_request) {
  clear_type();
  if (control_plane_ping_request) {
    set_has_control_plane_ping_request();
    _impl_.type_.control_plane_ping_request_ = control_plane_ping_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.control_plane_ping_request)
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* ControlStateChangeRequest::_internal_mutable_control_plane_ping_request() {
  if (type_case() != kControlPlanePingRequest) {
    clear_type();
    set_has_control_plane_ping_request();
    _impl_.type_.control_plane_ping_request_ = CreateMaybeMessage< ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest >(GetArenaForAllocation());
  }
  return _impl_.type_.control_plane_ping_request_;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* ControlStateChangeRequest::mutable_control_plane_ping_request() {
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingRequest* _msg = _internal_mutable_control_plane_ping_request();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateChangeRequest.control_plane_ping_request)
  return _msg;
}

inline bool ControlStateChangeRequest::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ControlStateChangeRequest::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline ControlStateChangeRequest::TypeCase ControlStateChangeRequest::type_case() const {
  return ControlStateChangeRequest::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlStateNotification

// optional string node_id = 1 [json_name = "nodeId"];
inline bool ControlStateNotification::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ControlStateNotification::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ControlStateNotification::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControlStateNotification::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.node_id)
}
inline std::string* ControlStateNotification::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.node_id)
  return _s;
}
inline const std::string& ControlStateNotification::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void ControlStateNotification::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlStateNotification::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ControlStateNotification::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ControlStateNotification::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.node_id)
}

// repeated .aalyria.spacetime.api.common.ScheduledControlUpdateStatus statuses = 2 [json_name = "statuses"];
inline int ControlStateNotification::_internal_statuses_size() const {
  return _impl_.statuses_.size();
}
inline int ControlStateNotification::statuses_size() const {
  return _internal_statuses_size();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* ControlStateNotification::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.statuses)
  return _internal_mutable_statuses()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus >*
ControlStateNotification::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.statuses)
  return _internal_mutable_statuses();
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& ControlStateNotification::_internal_statuses(int index) const {
  return _internal_statuses().Get(index);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& ControlStateNotification::statuses(int index) const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.statuses)
  return _internal_statuses(index);
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* ControlStateNotification::_internal_add_statuses() {
  return _internal_mutable_statuses()->Add();
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* ControlStateNotification::add_statuses() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* _add = _internal_add_statuses();
  // @@protoc_insertion_point(field_add:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.statuses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus >&
ControlStateNotification::statuses() const {
  // @@protoc_insertion_point(field_list:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.statuses)
  return _internal_statuses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>&
ControlStateNotification::_internal_statuses() const {
  return _impl_.statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>*
ControlStateNotification::_internal_mutable_statuses() {
  return &_impl_.statuses_;
}

// optional .aalyria.spacetime.api.common.ControlPlaneState state = 3 [json_name = "state"];
inline bool ControlStateNotification::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::ControlPlaneState& ControlStateNotification::_internal_state() const {
  const ::aalyria::spacetime::api::common::ControlPlaneState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ControlPlaneState&>(
      ::aalyria::spacetime::api::common::_ControlPlaneState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ControlPlaneState& ControlStateNotification::state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.state)
  return _internal_state();
}
inline void ControlStateNotification::unsafe_arena_set_allocated_state(
    ::aalyria::spacetime::api::common::ControlPlaneState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.state)
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* ControlStateNotification::release_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ControlPlaneState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* ControlStateNotification::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ControlPlaneState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* ControlStateNotification::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ControlPlaneState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* ControlStateNotification::mutable_state() {
  ::aalyria::spacetime::api::common::ControlPlaneState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.state)
  return _msg;
}
inline void ControlStateNotification::set_allocated_state(::aalyria::spacetime::api::common::ControlPlaneState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.state)
}

// optional uint32 priority = 4 [default = 0, json_name = "priority"];
inline bool ControlStateNotification::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ControlStateNotification::clear_priority() {
  _impl_.priority_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ControlStateNotification::priority() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.priority)
  return _internal_priority();
}
inline void ControlStateNotification::set_priority(::uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.priority)
}
inline ::uint32_t ControlStateNotification::_internal_priority() const {
  return _impl_.priority_;
}
inline void ControlStateNotification::_internal_set_priority(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.priority_ = value;
}

// optional .aalyria.spacetime.api.cdpi.v1alpha.ControlPlanePingResponse control_plane_ping_response = 5 [json_name = "controlPlanePingResponse"];
inline bool ControlStateNotification::has_control_plane_ping_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_plane_ping_response_ != nullptr);
  return value;
}
inline void ControlStateNotification::clear_control_plane_ping_response() {
  if (_impl_.control_plane_ping_response_ != nullptr) _impl_.control_plane_ping_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse& ControlStateNotification::_internal_control_plane_ping_response() const {
  const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* p = _impl_.control_plane_ping_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse&>(
      ::aalyria::spacetime::api::cdpi::v1alpha::_ControlPlanePingResponse_default_instance_);
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse& ControlStateNotification::control_plane_ping_response() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.control_plane_ping_response)
  return _internal_control_plane_ping_response();
}
inline void ControlStateNotification::unsafe_arena_set_allocated_control_plane_ping_response(
    ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* control_plane_ping_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_plane_ping_response_);
  }
  _impl_.control_plane_ping_response_ = control_plane_ping_response;
  if (control_plane_ping_response) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.control_plane_ping_response)
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* ControlStateNotification::release_control_plane_ping_response() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* temp = _impl_.control_plane_ping_response_;
  _impl_.control_plane_ping_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* ControlStateNotification::unsafe_arena_release_control_plane_ping_response() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.control_plane_ping_response)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* temp = _impl_.control_plane_ping_response_;
  _impl_.control_plane_ping_response_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* ControlStateNotification::_internal_mutable_control_plane_ping_response() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.control_plane_ping_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse>(GetArenaForAllocation());
    _impl_.control_plane_ping_response_ = p;
  }
  return _impl_.control_plane_ping_response_;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* ControlStateNotification::mutable_control_plane_ping_response() {
  ::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* _msg = _internal_mutable_control_plane_ping_response();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.control_plane_ping_response)
  return _msg;
}
inline void ControlStateNotification::set_allocated_control_plane_ping_response(::aalyria::spacetime::api::cdpi::v1alpha::ControlPlanePingResponse* control_plane_ping_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_plane_ping_response_;
  }
  if (control_plane_ping_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control_plane_ping_response);
    if (message_arena != submessage_arena) {
      control_plane_ping_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_plane_ping_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.control_plane_ping_response_ = control_plane_ping_response;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.ControlStateNotification.control_plane_ping_response)
}

// -------------------------------------------------------------------

// TelemetryRequest

// optional string node_id = 1 [json_name = "nodeId"];
inline bool TelemetryRequest::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TelemetryRequest::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryRequest::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TelemetryRequest::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.node_id)
}
inline std::string* TelemetryRequest::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.node_id)
  return _s;
}
inline const std::string& TelemetryRequest::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void TelemetryRequest::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryRequest::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TelemetryRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TelemetryRequest::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.node_id)
}

// .google.protobuf.Empty query_statistics = 2 [json_name = "queryStatistics"];
inline bool TelemetryRequest::has_query_statistics() const {
  return type_case() == kQueryStatistics;
}
inline bool TelemetryRequest::_internal_has_query_statistics() const {
  return type_case() == kQueryStatistics;
}
inline void TelemetryRequest::set_has_query_statistics() {
  _impl_._oneof_case_[0] = kQueryStatistics;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TelemetryRequest::release_query_statistics() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.query_statistics)
  if (type_case() == kQueryStatistics) {
    clear_has_type();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.type_.query_statistics_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.query_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& TelemetryRequest::_internal_query_statistics() const {
  return type_case() == kQueryStatistics
      ? *_impl_.type_.query_statistics_
      : reinterpret_cast<::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& TelemetryRequest::query_statistics() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.query_statistics)
  return _internal_query_statistics();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TelemetryRequest::unsafe_arena_release_query_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.query_statistics)
  if (type_case() == kQueryStatistics) {
    clear_has_type();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.type_.query_statistics_;
    _impl_.type_.query_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryRequest::unsafe_arena_set_allocated_query_statistics(::PROTOBUF_NAMESPACE_ID::Empty* query_statistics) {
  clear_type();
  if (query_statistics) {
    set_has_query_statistics();
    _impl_.type_.query_statistics_ = query_statistics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.query_statistics)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TelemetryRequest::_internal_mutable_query_statistics() {
  if (type_case() != kQueryStatistics) {
    clear_type();
    set_has_query_statistics();
    _impl_.type_.query_statistics_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.type_.query_statistics_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* TelemetryRequest::mutable_query_statistics() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_query_statistics();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.query_statistics)
  return _msg;
}

// double statistics_publish_rate_hz = 3 [json_name = "statisticsPublishRateHz"];
inline bool TelemetryRequest::has_statistics_publish_rate_hz() const {
  return type_case() == kStatisticsPublishRateHz;
}
inline void TelemetryRequest::set_has_statistics_publish_rate_hz() {
  _impl_._oneof_case_[0] = kStatisticsPublishRateHz;
}
inline void TelemetryRequest::clear_statistics_publish_rate_hz() {
  if (type_case() == kStatisticsPublishRateHz) {
    _impl_.type_.statistics_publish_rate_hz_ = 0;
    clear_has_type();
  }
}
inline double TelemetryRequest::statistics_publish_rate_hz() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.statistics_publish_rate_hz)
  return _internal_statistics_publish_rate_hz();
}
inline void TelemetryRequest::set_statistics_publish_rate_hz(double value) {
  _internal_set_statistics_publish_rate_hz(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.TelemetryRequest.statistics_publish_rate_hz)
}
inline double TelemetryRequest::_internal_statistics_publish_rate_hz() const {
  if (type_case() == kStatisticsPublishRateHz) {
    return _impl_.type_.statistics_publish_rate_hz_;
  }
  return 0;
}
inline void TelemetryRequest::_internal_set_statistics_publish_rate_hz(double value) {
  if (type_case() != kStatisticsPublishRateHz) {
    clear_type();
    set_has_statistics_publish_rate_hz();
  }
  _impl_.type_.statistics_publish_rate_hz_ = value;
}

inline bool TelemetryRequest::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void TelemetryRequest::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline TelemetryRequest::TypeCase TelemetryRequest::type_case() const {
  return TelemetryRequest::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TelemetryUpdate

// optional string node_id = 1 [json_name = "nodeId", deprecated = true];
inline bool TelemetryUpdate::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TelemetryUpdate::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TelemetryUpdate::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TelemetryUpdate::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.node_id)
}
inline std::string* TelemetryUpdate::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.node_id)
  return _s;
}
inline const std::string& TelemetryUpdate::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void TelemetryUpdate::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TelemetryUpdate::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TelemetryUpdate::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TelemetryUpdate::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.node_id)
}

// .aalyria.spacetime.api.common.NetworkStatsReport statistics = 2 [json_name = "statistics"];
inline bool TelemetryUpdate::has_statistics() const {
  return type_case() == kStatistics;
}
inline bool TelemetryUpdate::_internal_has_statistics() const {
  return type_case() == kStatistics;
}
inline void TelemetryUpdate::set_has_statistics() {
  _impl_._oneof_case_[0] = kStatistics;
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* TelemetryUpdate::release_statistics() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.statistics)
  if (type_case() == kStatistics) {
    clear_has_type();
    ::aalyria::spacetime::api::common::NetworkStatsReport* temp = _impl_.type_.statistics_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::NetworkStatsReport& TelemetryUpdate::_internal_statistics() const {
  return type_case() == kStatistics
      ? *_impl_.type_.statistics_
      : reinterpret_cast<::aalyria::spacetime::api::common::NetworkStatsReport&>(::aalyria::spacetime::api::common::_NetworkStatsReport_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkStatsReport& TelemetryUpdate::statistics() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.statistics)
  return _internal_statistics();
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* TelemetryUpdate::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.statistics)
  if (type_case() == kStatistics) {
    clear_has_type();
    ::aalyria::spacetime::api::common::NetworkStatsReport* temp = _impl_.type_.statistics_;
    _impl_.type_.statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryUpdate::unsafe_arena_set_allocated_statistics(::aalyria::spacetime::api::common::NetworkStatsReport* statistics) {
  clear_type();
  if (statistics) {
    set_has_statistics();
    _impl_.type_.statistics_ = statistics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.statistics)
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* TelemetryUpdate::_internal_mutable_statistics() {
  if (type_case() != kStatistics) {
    clear_type();
    set_has_statistics();
    _impl_.type_.statistics_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkStatsReport >(GetArenaForAllocation());
  }
  return _impl_.type_.statistics_;
}
inline ::aalyria::spacetime::api::common::NetworkStatsReport* TelemetryUpdate::mutable_statistics() {
  ::aalyria::spacetime::api::common::NetworkStatsReport* _msg = _internal_mutable_statistics();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.statistics)
  return _msg;
}

// .aalyria.spacetime.api.common.NetworkEventReport event = 3 [json_name = "event"];
inline bool TelemetryUpdate::has_event() const {
  return type_case() == kEvent;
}
inline bool TelemetryUpdate::_internal_has_event() const {
  return type_case() == kEvent;
}
inline void TelemetryUpdate::set_has_event() {
  _impl_._oneof_case_[0] = kEvent;
}
inline ::aalyria::spacetime::api::common::NetworkEventReport* TelemetryUpdate::release_event() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.event)
  if (type_case() == kEvent) {
    clear_has_type();
    ::aalyria::spacetime::api::common::NetworkEventReport* temp = _impl_.type_.event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aalyria::spacetime::api::common::NetworkEventReport& TelemetryUpdate::_internal_event() const {
  return type_case() == kEvent
      ? *_impl_.type_.event_
      : reinterpret_cast<::aalyria::spacetime::api::common::NetworkEventReport&>(::aalyria::spacetime::api::common::_NetworkEventReport_default_instance_);
}
inline const ::aalyria::spacetime::api::common::NetworkEventReport& TelemetryUpdate::event() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.event)
  return _internal_event();
}
inline ::aalyria::spacetime::api::common::NetworkEventReport* TelemetryUpdate::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.event)
  if (type_case() == kEvent) {
    clear_has_type();
    ::aalyria::spacetime::api::common::NetworkEventReport* temp = _impl_.type_.event_;
    _impl_.type_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TelemetryUpdate::unsafe_arena_set_allocated_event(::aalyria::spacetime::api::common::NetworkEventReport* event) {
  clear_type();
  if (event) {
    set_has_event();
    _impl_.type_.event_ = event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.event)
}
inline ::aalyria::spacetime::api::common::NetworkEventReport* TelemetryUpdate::_internal_mutable_event() {
  if (type_case() != kEvent) {
    clear_type();
    set_has_event();
    _impl_.type_.event_ = CreateMaybeMessage< ::aalyria::spacetime::api::common::NetworkEventReport >(GetArenaForAllocation());
  }
  return _impl_.type_.event_;
}
inline ::aalyria::spacetime::api::common::NetworkEventReport* TelemetryUpdate::mutable_event() {
  ::aalyria::spacetime::api::common::NetworkEventReport* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.TelemetryUpdate.event)
  return _msg;
}

inline bool TelemetryUpdate::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void TelemetryUpdate::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline TelemetryUpdate::TypeCase TelemetryUpdate::type_case() const {
  return TelemetryUpdate::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorWeatherData

// optional .aalyria.spacetime.api.common.GeodeticWgs84 location = 4 [json_name = "location"];
inline bool SensorWeatherData::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& SensorWeatherData::_internal_location() const {
  const ::aalyria::spacetime::api::common::GeodeticWgs84* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::GeodeticWgs84&>(
      ::aalyria::spacetime::api::common::_GeodeticWgs84_default_instance_);
}
inline const ::aalyria::spacetime::api::common::GeodeticWgs84& SensorWeatherData::location() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.location)
  return _internal_location();
}
inline void SensorWeatherData::unsafe_arena_set_allocated_location(
    ::aalyria::spacetime::api::common::GeodeticWgs84* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.location)
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* SensorWeatherData::release_location() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* SensorWeatherData::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.location)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::GeodeticWgs84* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* SensorWeatherData::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::GeodeticWgs84>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::aalyria::spacetime::api::common::GeodeticWgs84* SensorWeatherData::mutable_location() {
  ::aalyria::spacetime::api::common::GeodeticWgs84* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.location)
  return _msg;
}
inline void SensorWeatherData::set_allocated_location(::aalyria::spacetime::api::common::GeodeticWgs84* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.location)
}

// optional .aalyria.spacetime.api.common.WeatherDataForecast weather_data = 3 [json_name = "weatherData"];
inline bool SensorWeatherData::has_weather_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.weather_data_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::WeatherDataForecast& SensorWeatherData::_internal_weather_data() const {
  const ::aalyria::spacetime::api::common::WeatherDataForecast* p = _impl_.weather_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::WeatherDataForecast&>(
      ::aalyria::spacetime::api::common::_WeatherDataForecast_default_instance_);
}
inline const ::aalyria::spacetime::api::common::WeatherDataForecast& SensorWeatherData::weather_data() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.weather_data)
  return _internal_weather_data();
}
inline void SensorWeatherData::unsafe_arena_set_allocated_weather_data(
    ::aalyria::spacetime::api::common::WeatherDataForecast* weather_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weather_data_);
  }
  _impl_.weather_data_ = weather_data;
  if (weather_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.weather_data)
}
inline ::aalyria::spacetime::api::common::WeatherDataForecast* SensorWeatherData::release_weather_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WeatherDataForecast* temp = _impl_.weather_data_;
  _impl_.weather_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::WeatherDataForecast* SensorWeatherData::unsafe_arena_release_weather_data() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.weather_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::common::WeatherDataForecast* temp = _impl_.weather_data_;
  _impl_.weather_data_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::WeatherDataForecast* SensorWeatherData::_internal_mutable_weather_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.weather_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::WeatherDataForecast>(GetArenaForAllocation());
    _impl_.weather_data_ = p;
  }
  return _impl_.weather_data_;
}
inline ::aalyria::spacetime::api::common::WeatherDataForecast* SensorWeatherData::mutable_weather_data() {
  ::aalyria::spacetime::api::common::WeatherDataForecast* _msg = _internal_mutable_weather_data();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.weather_data)
  return _msg;
}
inline void SensorWeatherData::set_allocated_weather_data(::aalyria::spacetime::api::common::WeatherDataForecast* weather_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weather_data_);
  }
  if (weather_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weather_data));
    if (message_arena != submessage_arena) {
      weather_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weather_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.weather_data_ = weather_data;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.SensorWeatherData.weather_data)
}

// -------------------------------------------------------------------

// CdpiNodeStateRequest

// optional string node_id = 1 [json_name = "nodeId"];
inline bool CdpiNodeStateRequest::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CdpiNodeStateRequest::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdpiNodeStateRequest::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CdpiNodeStateRequest::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.node_id)
}
inline std::string* CdpiNodeStateRequest::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.node_id)
  return _s;
}
inline const std::string& CdpiNodeStateRequest::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void CdpiNodeStateRequest::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CdpiNodeStateRequest::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CdpiNodeStateRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CdpiNodeStateRequest::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.node_id)
}

// optional .aalyria.spacetime.api.common.ControlPlaneState state = 3 [json_name = "state"];
inline bool CdpiNodeStateRequest::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::ControlPlaneState& CdpiNodeStateRequest::_internal_state() const {
  const ::aalyria::spacetime::api::common::ControlPlaneState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ControlPlaneState&>(
      ::aalyria::spacetime::api::common::_ControlPlaneState_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ControlPlaneState& CdpiNodeStateRequest::state() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.state)
  return _internal_state();
}
inline void CdpiNodeStateRequest::unsafe_arena_set_allocated_state(
    ::aalyria::spacetime::api::common::ControlPlaneState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.state)
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* CdpiNodeStateRequest::release_state() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ControlPlaneState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* CdpiNodeStateRequest::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.state)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ControlPlaneState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* CdpiNodeStateRequest::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ControlPlaneState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::aalyria::spacetime::api::common::ControlPlaneState* CdpiNodeStateRequest::mutable_state() {
  ::aalyria::spacetime::api::common::ControlPlaneState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.state)
  return _msg;
}
inline void CdpiNodeStateRequest::set_allocated_state(::aalyria::spacetime::api::common::ControlPlaneState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiNodeStateRequest.state)
}

// -------------------------------------------------------------------

// CdpiRequestStatusRequest

// optional string node_id = 1 [json_name = "nodeId"];
inline bool CdpiRequestStatusRequest::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CdpiRequestStatusRequest::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdpiRequestStatusRequest::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CdpiRequestStatusRequest::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.node_id)
}
inline std::string* CdpiRequestStatusRequest::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.node_id)
  return _s;
}
inline const std::string& CdpiRequestStatusRequest::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void CdpiRequestStatusRequest::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CdpiRequestStatusRequest::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CdpiRequestStatusRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CdpiRequestStatusRequest::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.node_id)
}

// optional .aalyria.spacetime.api.common.ScheduledControlUpdateStatus status = 2 [json_name = "status"];
inline bool CdpiRequestStatusRequest::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& CdpiRequestStatusRequest::_internal_status() const {
  const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus&>(
      ::aalyria::spacetime::api::common::_ScheduledControlUpdateStatus_default_instance_);
}
inline const ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus& CdpiRequestStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.status)
  return _internal_status();
}
inline void CdpiRequestStatusRequest::unsafe_arena_set_allocated_status(
    ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.status)
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* CdpiRequestStatusRequest::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* CdpiRequestStatusRequest::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* CdpiRequestStatusRequest::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::common::ScheduledControlUpdateStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* CdpiRequestStatusRequest::mutable_status() {
  ::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.status)
  return _msg;
}
inline void CdpiRequestStatusRequest::set_allocated_status(::aalyria::spacetime::api::common::ScheduledControlUpdateStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequestStatusRequest.status)
}

// -------------------------------------------------------------------

// CdpiRequest_Hello

// optional string node_id = 1 [json_name = "nodeId"];
inline bool CdpiRequest_Hello::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CdpiRequest_Hello::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdpiRequest_Hello::node_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CdpiRequest_Hello::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.node_id)
}
inline std::string* CdpiRequest_Hello::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.node_id)
  return _s;
}
inline const std::string& CdpiRequest_Hello::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void CdpiRequest_Hello::_internal_set_node_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CdpiRequest_Hello::_internal_mutable_node_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_id_.Mutable( GetArenaForAllocation());
}
inline std::string* CdpiRequest_Hello::release_node_id() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.node_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.node_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CdpiRequest_Hello::set_allocated_node_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.node_id)
}

// optional uint32 channel_priority = 2 [json_name = "channelPriority"];
inline bool CdpiRequest_Hello::has_channel_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CdpiRequest_Hello::clear_channel_priority() {
  _impl_.channel_priority_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t CdpiRequest_Hello::channel_priority() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.channel_priority)
  return _internal_channel_priority();
}
inline void CdpiRequest_Hello::set_channel_priority(::uint32_t value) {
  _internal_set_channel_priority(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello.channel_priority)
}
inline ::uint32_t CdpiRequest_Hello::_internal_channel_priority() const {
  return _impl_.channel_priority_;
}
inline void CdpiRequest_Hello::_internal_set_channel_priority(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_priority_ = value;
}

// -------------------------------------------------------------------

// CdpiRequest_Response

// optional int64 request_id = 1 [json_name = "requestId"];
inline bool CdpiRequest_Response::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CdpiRequest_Response::clear_request_id() {
  _impl_.request_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t CdpiRequest_Response::request_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.request_id)
  return _internal_request_id();
}
inline void CdpiRequest_Response::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.request_id)
}
inline ::int64_t CdpiRequest_Response::_internal_request_id() const {
  return _impl_.request_id_;
}
inline void CdpiRequest_Response::_internal_set_request_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// optional .google.rpc.Status status = 2 [json_name = "status"];
inline bool CdpiRequest_Response::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline const ::google::rpc::Status& CdpiRequest_Response::_internal_status() const {
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& CdpiRequest_Response::status() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.status)
  return _internal_status();
}
inline void CdpiRequest_Response::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.status)
}
inline ::google::rpc::Status* CdpiRequest_Response::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* CdpiRequest_Response::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* CdpiRequest_Response::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* CdpiRequest_Response::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.status)
  return _msg;
}
inline void CdpiRequest_Response::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.status)
}

// optional bytes payload = 3 [json_name = "payload"];
inline bool CdpiRequest_Response::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CdpiRequest_Response::clear_payload() {
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdpiRequest_Response::payload() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CdpiRequest_Response::set_payload(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.payload)
}
inline std::string* CdpiRequest_Response::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.payload)
  return _s;
}
inline const std::string& CdpiRequest_Response::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void CdpiRequest_Response::_internal_set_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* CdpiRequest_Response::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable( GetArenaForAllocation());
}
inline std::string* CdpiRequest_Response::release_payload() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.payload_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CdpiRequest_Response::set_allocated_payload(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response.payload)
}

// -------------------------------------------------------------------

// CdpiRequest

// optional .aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Hello hello = 1 [json_name = "hello"];
inline bool CdpiRequest::has_hello() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hello_ != nullptr);
  return value;
}
inline void CdpiRequest::clear_hello() {
  if (_impl_.hello_ != nullptr) _impl_.hello_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello& CdpiRequest::_internal_hello() const {
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* p = _impl_.hello_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello&>(
      ::aalyria::spacetime::api::cdpi::v1alpha::_CdpiRequest_Hello_default_instance_);
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello& CdpiRequest::hello() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.hello)
  return _internal_hello();
}
inline void CdpiRequest::unsafe_arena_set_allocated_hello(
    ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* hello) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hello_);
  }
  _impl_.hello_ = hello;
  if (hello) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.hello)
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* CdpiRequest::release_hello() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* temp = _impl_.hello_;
  _impl_.hello_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* CdpiRequest::unsafe_arena_release_hello() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.hello)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* temp = _impl_.hello_;
  _impl_.hello_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* CdpiRequest::_internal_mutable_hello() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hello_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello>(GetArenaForAllocation());
    _impl_.hello_ = p;
  }
  return _impl_.hello_;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* CdpiRequest::mutable_hello() {
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* _msg = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.hello)
  return _msg;
}
inline void CdpiRequest::set_allocated_hello(::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Hello* hello) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hello_;
  }
  if (hello) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hello);
    if (message_arena != submessage_arena) {
      hello = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hello, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hello_ = hello;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.hello)
}

// optional .aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.Response response = 2 [json_name = "response"];
inline bool CdpiRequest::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline void CdpiRequest::clear_response() {
  if (_impl_.response_ != nullptr) _impl_.response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response& CdpiRequest::_internal_response() const {
  const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response&>(
      ::aalyria::spacetime::api::cdpi::v1alpha::_CdpiRequest_Response_default_instance_);
}
inline const ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response& CdpiRequest::response() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.response)
  return _internal_response();
}
inline void CdpiRequest::unsafe_arena_set_allocated_response(
    ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.response)
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* CdpiRequest::release_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* CdpiRequest::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* CdpiRequest::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* CdpiRequest::mutable_response() {
  ::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.response)
  return _msg;
}
inline void CdpiRequest::set_allocated_response(::aalyria::spacetime::api::cdpi::v1alpha::CdpiRequest_Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiRequest.response)
}

// -------------------------------------------------------------------

// CdpiResponse

// optional int64 request_id = 1 [json_name = "requestId"];
inline bool CdpiResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CdpiResponse::clear_request_id() {
  _impl_.request_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t CdpiResponse::request_id() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_id)
  return _internal_request_id();
}
inline void CdpiResponse::set_request_id(::int64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_id)
}
inline ::int64_t CdpiResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline void CdpiResponse::_internal_set_request_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional bytes request_payload = 2 [json_name = "requestPayload"];
inline bool CdpiResponse::has_request_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CdpiResponse::clear_request_payload() {
  _impl_.request_payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdpiResponse::request_payload() const {
  // @@protoc_insertion_point(field_get:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_payload)
  return _internal_request_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CdpiResponse::set_request_payload(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_payload)
}
inline std::string* CdpiResponse::mutable_request_payload() {
  std::string* _s = _internal_mutable_request_payload();
  // @@protoc_insertion_point(field_mutable:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_payload)
  return _s;
}
inline const std::string& CdpiResponse::_internal_request_payload() const {
  return _impl_.request_payload_.Get();
}
inline void CdpiResponse::_internal_set_request_payload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.request_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* CdpiResponse::_internal_mutable_request_payload() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.request_payload_.Mutable( GetArenaForAllocation());
}
inline std::string* CdpiResponse::release_request_payload() {
  // @@protoc_insertion_point(field_release:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.request_payload_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.request_payload_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CdpiResponse::set_allocated_request_payload(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_payload_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_payload_.IsDefault()) {
          _impl_.request_payload_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aalyria.spacetime.api.cdpi.v1alpha.CdpiResponse.request_payload)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha
}  // namespace cdpi
}  // namespace api
}  // namespace spacetime
}  // namespace aalyria


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fcdpi_2fv1alpha_2fcdpi_2eproto_2epb_2eh
